// export t_kill , t_intimidate , t_persuade , t_pay , t_beat , t_killbeat ; export you , americans , arabians , nature ; export mcdef1_difficulty , mcdef2_difficulty , mcdef3_difficulty , mcdef4_difficulty , mcdef5_difficulty ; export gossudarov_mech_skill ; export cap_bases ; export your_bases ; export aiH , aiN , aiZ ; export ai_nation ; export ai_s ; export ai ; export plat_i ; export apemans ; export Diplomacy , Goss ; export BehemothSeen ; export vedci_zacali_zdrhat ; export run_sci ; export utek , utek_e ; export art_cargo1 ; export your_cars ; export your_builds ; export your_humans ; export function inicializace_main ; begin
   0: LD_INT 0
   2: PPUSH
// you := 3 ;
   3: LD_ADDR_EXP 7
   7: PUSH
   8: LD_INT 3
  10: ST_TO_ADDR
// americans := 1 ;
  11: LD_ADDR_EXP 8
  15: PUSH
  16: LD_INT 1
  18: ST_TO_ADDR
// arabians := 2 ;
  19: LD_ADDR_EXP 9
  23: PUSH
  24: LD_INT 2
  26: ST_TO_ADDR
// nature := 0 ;
  27: LD_ADDR_EXP 10
  31: PUSH
  32: LD_INT 0
  34: ST_TO_ADDR
// utek := [ [ 55 , 21 ] , [ 83 , 36 ] , [ 103 , 70 ] , [ 142 , 88 ] ] ;
  35: LD_ADDR_EXP 32
  39: PUSH
  40: LD_INT 55
  42: PUSH
  43: LD_INT 21
  45: PUSH
  46: EMPTY
  47: LIST
  48: LIST
  49: PUSH
  50: LD_INT 83
  52: PUSH
  53: LD_INT 36
  55: PUSH
  56: EMPTY
  57: LIST
  58: LIST
  59: PUSH
  60: LD_INT 103
  62: PUSH
  63: LD_INT 70
  65: PUSH
  66: EMPTY
  67: LIST
  68: LIST
  69: PUSH
  70: LD_INT 142
  72: PUSH
  73: LD_INT 88
  75: PUSH
  76: EMPTY
  77: LIST
  78: LIST
  79: PUSH
  80: EMPTY
  81: LIST
  82: LIST
  83: LIST
  84: LIST
  85: ST_TO_ADDR
// utek_e := [ 186 , 55 ] ;
  86: LD_ADDR_EXP 33
  90: PUSH
  91: LD_INT 186
  93: PUSH
  94: LD_INT 55
  96: PUSH
  97: EMPTY
  98: LIST
  99: LIST
 100: ST_TO_ADDR
// cap_bases := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// t_kill := 1 ;
 109: LD_ADDR_EXP 1
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// t_intimidate := 2 ;
 117: LD_ADDR_EXP 2
 121: PUSH
 122: LD_INT 2
 124: ST_TO_ADDR
// t_persuade := 3 ;
 125: LD_ADDR_EXP 3
 129: PUSH
 130: LD_INT 3
 132: ST_TO_ADDR
// t_pay := 4 ;
 133: LD_ADDR_EXP 4
 137: PUSH
 138: LD_INT 4
 140: ST_TO_ADDR
// t_beat := 5 ;
 141: LD_ADDR_EXP 5
 145: PUSH
 146: LD_INT 5
 148: ST_TO_ADDR
// t_killbeat := 10 ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 10
 156: ST_TO_ADDR
// Diplomacy := true ;
 157: LD_ADDR_EXP 27
 161: PUSH
 162: LD_INT 1
 164: ST_TO_ADDR
// Goss := true ;
 165: LD_ADDR_EXP 28
 169: PUSH
 170: LD_INT 1
 172: ST_TO_ADDR
// ai_s := [ 6 , 5 , 2 , 8 , 7 ] ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 6
 180: PUSH
 181: LD_INT 5
 183: PUSH
 184: LD_INT 2
 186: PUSH
 187: LD_INT 8
 189: PUSH
 190: LD_INT 7
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// ai := [ 6 , 5 , 2 , 8 , 7 ] ;
 200: LD_ADDR_EXP 24
 204: PUSH
 205: LD_INT 6
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 2
 213: PUSH
 214: LD_INT 8
 216: PUSH
 217: LD_INT 7
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: LIST
 225: LIST
 226: ST_TO_ADDR
// plat_i := 1 ;
 227: LD_ADDR_EXP 25
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// aiH := [ ] ;
 235: LD_ADDR_EXP 19
 239: PUSH
 240: EMPTY
 241: ST_TO_ADDR
// aiN := [ ai_s [ 2 ] , ai_s [ 3 ] , ai_s [ 4 ] , ai_s [ 5 ] ] ;
 242: LD_ADDR_EXP 20
 246: PUSH
 247: LD_EXP 23
 251: PUSH
 252: LD_INT 2
 254: ARRAY
 255: PUSH
 256: LD_EXP 23
 260: PUSH
 261: LD_INT 3
 263: ARRAY
 264: PUSH
 265: LD_EXP 23
 269: PUSH
 270: LD_INT 4
 272: ARRAY
 273: PUSH
 274: LD_EXP 23
 278: PUSH
 279: LD_INT 5
 281: ARRAY
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: ST_TO_ADDR
// aiZ := [ ai_s [ 1 ] ] ;
 289: LD_ADDR_EXP 21
 293: PUSH
 294: LD_EXP 23
 298: PUSH
 299: LD_INT 1
 301: ARRAY
 302: PUSH
 303: EMPTY
 304: LIST
 305: ST_TO_ADDR
// your_bases := [ ] ;
 306: LD_ADDR_EXP 18
 310: PUSH
 311: EMPTY
 312: ST_TO_ADDR
// cap_bases := 0 ;
 313: LD_ADDR_EXP 17
 317: PUSH
 318: LD_INT 0
 320: ST_TO_ADDR
// art_cargo1 := art_cargo ;
 321: LD_ADDR_EXP 34
 325: PUSH
 326: LD_INT 121
 328: ST_TO_ADDR
// ai_nation := nation_russian ;
 329: LD_ADDR_EXP 22
 333: PUSH
 334: LD_INT 3
 336: ST_TO_ADDR
// debug_strings := [ [ ] , [ ] , [ ] ] ;
 337: LD_ADDR_OWVAR 48
 341: PUSH
 342: EMPTY
 343: PUSH
 344: EMPTY
 345: PUSH
 346: EMPTY
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: ST_TO_ADDR
// end ;
 353: LD_VAR 0 1
 357: RET
// export vyhrano ; export function VyhraPlaton ; begin
 358: LD_INT 0
 360: PPUSH
// if not vyhrano then
 361: LD_EXP 38
 365: NOT
 366: IFFALSE 497
// begin vyhrano := true ;
 368: LD_ADDR_EXP 38
 372: PUSH
 373: LD_INT 1
 375: ST_TO_ADDR
// cap_bases := 5 ;
 376: LD_ADDR_EXP 17
 380: PUSH
 381: LD_INT 5
 383: ST_TO_ADDR
// Query ( QEndInfo ) ;
 384: LD_STRING QEndInfo
 386: PPUSH
 387: CALL_OW 97
// ExclusiveOn ;
 391: CALL_OW 4
// wait ( 1 ) ;
 395: LD_INT 1
 397: PPUSH
 398: CALL_OW 67
// DEnd ;
 402: CALL 8191 0 0
// ExclusiveOff ;
 406: CALL_OW 5
// SetMedals ;
 410: CALL 502 0 0
// GiveMedals ( Platon ) ;
 414: LD_STRING Platon
 416: PPUSH
 417: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ) ;
 421: LD_INT 22
 423: PUSH
 424: LD_EXP 7
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 21
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: EMPTY
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 3
 445: PUSH
 446: LD_INT 23
 448: PUSH
 449: LD_INT 0
 451: PUSH
 452: EMPTY
 453: LIST
 454: LIST
 455: PUSH
 456: EMPTY
 457: LIST
 458: LIST
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: LIST
 464: PPUSH
 465: CALL_OW 69
 469: PPUSH
 470: CALL_OW 43
// Save ;
 474: CALL 9186 0 0
// YouWin ;
 478: CALL_OW 103
// ExclusiveOn ;
 482: CALL_OW 4
// wait ( 1 ) ;
 486: LD_INT 1
 488: PPUSH
 489: CALL_OW 67
// ExclusiveOff ;
 493: CALL_OW 5
// end ; end ;
 497: LD_VAR 0 1
 501: RET
// export function SetMedals ; begin
 502: LD_INT 0
 504: PPUSH
// AddMedal ( All , cap_bases = 5 ) ;
 505: LD_STRING All
 507: PPUSH
 508: LD_EXP 17
 512: PUSH
 513: LD_INT 5
 515: EQUAL
 516: PPUSH
 517: CALL_OW 101
// AddMedal ( Diplomacy , Diplomacy ) ;
 521: LD_STRING Diplomacy
 523: PPUSH
 524: LD_EXP 27
 528: PPUSH
 529: CALL_OW 101
// AddMedal ( Goss , Goss ) ;
 533: LD_STRING Goss
 535: PPUSH
 536: LD_EXP 28
 540: PPUSH
 541: CALL_OW 101
// SA_EndMission ( 3 , 12 , cap_bases = 5 , Diplomacy > 0 , Goss > 0 ) ;
 545: LD_INT 3
 547: PPUSH
 548: LD_INT 12
 550: PPUSH
 551: LD_EXP 17
 555: PUSH
 556: LD_INT 5
 558: EQUAL
 559: PPUSH
 560: LD_EXP 27
 564: PUSH
 565: LD_INT 0
 567: GREATER
 568: PPUSH
 569: LD_EXP 28
 573: PUSH
 574: LD_INT 0
 576: GREATER
 577: PPUSH
 578: CALL 33196 0 5
// end ;
 582: LD_VAR 0 1
 586: RET
// export function LostBurlak ; begin
 587: LD_INT 0
 589: PPUSH
// YouLost ( Burlak ) ;
 590: LD_STRING Burlak
 592: PPUSH
 593: CALL_OW 104
// end ;
 597: LD_VAR 0 1
 601: RET
// export function LostArte ; begin
 602: LD_INT 0
 604: PPUSH
// YouLost ( Arte ) ;
 605: LD_STRING Arte
 607: PPUSH
 608: CALL_OW 104
// end ;
 612: LD_VAR 0 1
 616: RET
// export function set_difficulty ; begin
 617: LD_INT 0
 619: PPUSH
// mcdef1_difficulty := [ 200 , 230 , 260 ] [ difficulty ] ;
 620: LD_ADDR_EXP 11
 624: PUSH
 625: LD_INT 200
 627: PUSH
 628: LD_INT 230
 630: PUSH
 631: LD_INT 260
 633: PUSH
 634: EMPTY
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_OWVAR 67
 643: ARRAY
 644: ST_TO_ADDR
// mcdef2_difficulty := [ 150 , 180 , 200 ] [ difficulty ] ;
 645: LD_ADDR_EXP 12
 649: PUSH
 650: LD_INT 150
 652: PUSH
 653: LD_INT 180
 655: PUSH
 656: LD_INT 200
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: PUSH
 664: LD_OWVAR 67
 668: ARRAY
 669: ST_TO_ADDR
// mcdef3_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 670: LD_ADDR_EXP 13
 674: PUSH
 675: LD_INT 170
 677: PUSH
 678: LD_INT 200
 680: PUSH
 681: LD_INT 230
 683: PUSH
 684: EMPTY
 685: LIST
 686: LIST
 687: LIST
 688: PUSH
 689: LD_OWVAR 67
 693: ARRAY
 694: ST_TO_ADDR
// mcdef4_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 695: LD_ADDR_EXP 14
 699: PUSH
 700: LD_INT 170
 702: PUSH
 703: LD_INT 200
 705: PUSH
 706: LD_INT 230
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: PUSH
 714: LD_OWVAR 67
 718: ARRAY
 719: ST_TO_ADDR
// mcdef5_difficulty := [ 170 , 200 , 230 ] [ difficulty ] ;
 720: LD_ADDR_EXP 15
 724: PUSH
 725: LD_INT 170
 727: PUSH
 728: LD_INT 200
 730: PUSH
 731: LD_INT 230
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_OWVAR 67
 743: ARRAY
 744: ST_TO_ADDR
// gossudarov_mech_skill := [ 0 , 2 , 4 ] [ difficulty ] ;
 745: LD_ADDR_EXP 16
 749: PUSH
 750: LD_INT 0
 752: PUSH
 753: LD_INT 2
 755: PUSH
 756: LD_INT 4
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: PUSH
 764: LD_OWVAR 67
 768: ARRAY
 769: ST_TO_ADDR
// end ;
 770: LD_VAR 0 1
 774: RET
// export function get_your_units ; var a ; begin
 775: LD_INT 0
 777: PPUSH
 778: PPUSH
// a := FilterAllUnits ( [ [ f_side , you ] ] ) ;
 779: LD_ADDR_VAR 0 2
 783: PUSH
 784: LD_INT 22
 786: PUSH
 787: LD_EXP 7
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: EMPTY
 797: LIST
 798: PPUSH
 799: CALL_OW 69
 803: ST_TO_ADDR
// your_humans := UnitFilter ( a , [ [ f_type , unit_human ] ] ) ;
 804: LD_ADDR_EXP 37
 808: PUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: LD_INT 21
 816: PUSH
 817: LD_INT 1
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: PPUSH
 827: CALL_OW 72
 831: ST_TO_ADDR
// your_cars := UnitFilter ( a , [ [ f_type , unit_vehicle ] ] ) ;
 832: LD_ADDR_EXP 35
 836: PUSH
 837: LD_VAR 0 2
 841: PPUSH
 842: LD_INT 21
 844: PUSH
 845: LD_INT 2
 847: PUSH
 848: EMPTY
 849: LIST
 850: LIST
 851: PUSH
 852: EMPTY
 853: LIST
 854: PPUSH
 855: CALL_OW 72
 859: ST_TO_ADDR
// your_builds := UnitFilter ( a , [ [ f_type , unit_building ] ] ) ;
 860: LD_ADDR_EXP 36
 864: PUSH
 865: LD_VAR 0 2
 869: PPUSH
 870: LD_INT 21
 872: PUSH
 873: LD_INT 3
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: PUSH
 880: EMPTY
 881: LIST
 882: PPUSH
 883: CALL_OW 72
 887: ST_TO_ADDR
// end ;
 888: LD_VAR 0 1
 892: RET
// every 0 0$1 do var i ;
 893: GO 895
 895: DISABLE
 896: LD_INT 0
 898: PPUSH
// begin for i in ai do
 899: LD_ADDR_VAR 0 1
 903: PUSH
 904: LD_EXP 24
 908: PUSH
 909: FOR_IN
 910: IFFALSE 1107
// case GetAttitude ( i , you ) of att_friend :
 912: LD_VAR 0 1
 916: PPUSH
 917: LD_EXP 7
 921: PPUSH
 922: CALL_OW 81
 926: PUSH
 927: LD_INT 1
 929: DOUBLE
 930: EQUAL
 931: IFTRUE 935
 933: GO 986
 935: POP
// begin aiH := aiH union i ;
 936: LD_ADDR_EXP 19
 940: PUSH
 941: LD_EXP 19
 945: PUSH
 946: LD_VAR 0 1
 950: UNION
 951: ST_TO_ADDR
// aiZ := aiZ diff i ;
 952: LD_ADDR_EXP 21
 956: PUSH
 957: LD_EXP 21
 961: PUSH
 962: LD_VAR 0 1
 966: DIFF
 967: ST_TO_ADDR
// aiN := aiN diff i ;
 968: LD_ADDR_EXP 20
 972: PUSH
 973: LD_EXP 20
 977: PUSH
 978: LD_VAR 0 1
 982: DIFF
 983: ST_TO_ADDR
// end ; att_neutral :
 984: GO 1105
 986: LD_INT 0
 988: DOUBLE
 989: EQUAL
 990: IFTRUE 994
 992: GO 1045
 994: POP
// begin aiN := aiN union i ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_EXP 20
1004: PUSH
1005: LD_VAR 0 1
1009: UNION
1010: ST_TO_ADDR
// aiZ := aiZ diff i ;
1011: LD_ADDR_EXP 21
1015: PUSH
1016: LD_EXP 21
1020: PUSH
1021: LD_VAR 0 1
1025: DIFF
1026: ST_TO_ADDR
// aiH := aiH diff i ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_EXP 19
1036: PUSH
1037: LD_VAR 0 1
1041: DIFF
1042: ST_TO_ADDR
// end ; att_enemy :
1043: GO 1105
1045: LD_INT 2
1047: DOUBLE
1048: EQUAL
1049: IFTRUE 1053
1051: GO 1104
1053: POP
// begin aiZ := aiZ union i ;
1054: LD_ADDR_EXP 21
1058: PUSH
1059: LD_EXP 21
1063: PUSH
1064: LD_VAR 0 1
1068: UNION
1069: ST_TO_ADDR
// aiH := aiH diff i ;
1070: LD_ADDR_EXP 19
1074: PUSH
1075: LD_EXP 19
1079: PUSH
1080: LD_VAR 0 1
1084: DIFF
1085: ST_TO_ADDR
// aiN := aiN diff i ;
1086: LD_ADDR_EXP 20
1090: PUSH
1091: LD_EXP 20
1095: PUSH
1096: LD_VAR 0 1
1100: DIFF
1101: ST_TO_ADDR
// end ; end ;
1102: GO 1105
1104: POP
1105: GO 909
1107: POP
1108: POP
// enable ;
1109: ENABLE
// end ;
1110: PPOPN 1
1112: END
// every 0 0$1 do
1113: GO 1115
1115: DISABLE
// begin debug_strings := [ [ ( tick div 0 0$1 ) div 60 , ( tick div 0 0$1 ) mod 60 ] , debug_strings [ 2 ] , debug_strings [ 3 ] ] ;
1116: LD_ADDR_OWVAR 48
1120: PUSH
1121: LD_OWVAR 1
1125: PUSH
1126: LD_INT 35
1128: DIV
1129: PUSH
1130: LD_INT 60
1132: DIV
1133: PUSH
1134: LD_OWVAR 1
1138: PUSH
1139: LD_INT 35
1141: DIV
1142: PUSH
1143: LD_INT 60
1145: MOD
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: LD_OWVAR 48
1155: PUSH
1156: LD_INT 2
1158: ARRAY
1159: PUSH
1160: LD_OWVAR 48
1164: PUSH
1165: LD_INT 3
1167: ARRAY
1168: PUSH
1169: EMPTY
1170: LIST
1171: LIST
1172: LIST
1173: ST_TO_ADDR
// enable ;
1174: ENABLE
// end ;
1175: END
// starting begin SA_OnMissionStart ;
1176: CALL 33144 0 0
// inicializace_main ;
1180: CALL 0 0 0
// inicializace_ai ;
1184: CALL 22691 0 0
// inicializace_functions ;
1188: CALL 9840 0 0
// inicializace_ai_b_repair ;
1192: CALL 22265 0 0
// inicializace_ai_b_build ;
1196: CALL 16195 0 0
// inicializace_ai_defend ;
1200: CALL 11656 0 0
// inicializace_ai_c_make ;
1204: CALL 14072 0 0
// inicializace_ai_c_repair ;
1208: CALL 12604 0 0
// disable ( 10 ) ;
1212: LD_INT 10
1214: DISABLE_MARKED
// disable ( 11 ) ;
1215: LD_INT 11
1217: DISABLE_MARKED
// disable ( 12 ) ;
1218: LD_INT 12
1220: DISABLE_MARKED
// disable ( 115 ) ;
1221: LD_INT 115
1223: DISABLE_MARKED
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] , [ f_type , unit_human ] , [ f_class , class_apeman ] ] ) ;
1224: LD_ADDR_EXP 26
1228: PUSH
1229: LD_INT 23
1231: PUSH
1232: LD_INT 0
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: PUSH
1239: LD_INT 21
1241: PUSH
1242: LD_INT 1
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: PUSH
1249: LD_INT 25
1251: PUSH
1252: LD_INT 12
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: EMPTY
1260: LIST
1261: LIST
1262: LIST
1263: PPUSH
1264: CALL_OW 69
1268: ST_TO_ADDR
// set_difficulty ;
1269: CALL 617 0 0
// SetCargo ( art_cargo1 , mat_artifact , 4 * 10 ) ;
1273: LD_EXP 34
1277: PPUSH
1278: LD_INT 4
1280: PPUSH
1281: LD_INT 4
1283: PUSH
1284: LD_INT 10
1286: MUL
1287: PPUSH
1288: CALL_OW 290
// load ;
1292: CALL 8339 0 0
// inicializace_dialogues ;
1296: CALL 1321 0 0
// place_ru ;
1300: CALL 8880 0 0
// build_map ;
1304: CALL 20540 0 0
// get_groups ;
1308: CALL 22833 0 0
// get_your_units ;
1312: CALL 775 0 0
// DStart ;
1316: CALL 1496 0 0
// end ; end_of_file
1320: END
// var Gla , Bur , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ; var talking ; export function inicializace_dialogues ; begin
1321: LD_INT 0
1323: PPUSH
// Bur := Burlak ;
1324: LD_ADDR_LOC 2
1328: PUSH
1329: LD_EXP 41
1333: ST_TO_ADDR
// Gla := Gladkov ;
1334: LD_ADDR_LOC 1
1338: PUSH
1339: LD_EXP 44
1343: ST_TO_ADDR
// Glb := Gleb ;
1344: LD_ADDR_LOC 10
1348: PUSH
1349: LD_EXP 50
1353: ST_TO_ADDR
// Pla := Platonov ;
1354: LD_ADDR_LOC 3
1358: PUSH
1359: LD_EXP 42
1363: ST_TO_ADDR
// Gos := Gossudarov ;
1364: LD_ADDR_LOC 4
1368: PUSH
1369: LD_EXP 43
1373: ST_TO_ADDR
// Fad := Fadeev ;
1374: LD_ADDR_LOC 5
1378: PUSH
1379: LD_EXP 45
1383: ST_TO_ADDR
// Bor := Borodin ;
1384: LD_ADDR_LOC 6
1388: PUSH
1389: LD_EXP 46
1393: ST_TO_ADDR
// Tsr := Tsaritsyn ;
1394: LD_ADDR_LOC 7
1398: PUSH
1399: LD_EXP 47
1403: ST_TO_ADDR
// Dav := Davidov ;
1404: LD_ADDR_LOC 8
1408: PUSH
1409: LD_EXP 48
1413: ST_TO_ADDR
// Eis := Eisenstein ;
1414: LD_ADDR_LOC 9
1418: PUSH
1419: LD_EXP 49
1423: ST_TO_ADDR
// talking := [ Bur , Gla , Pla , Gos , Fad , Bor , Tsr , Dav , Eis , Glb ] ;
1424: LD_ADDR_LOC 11
1428: PUSH
1429: LD_LOC 2
1433: PUSH
1434: LD_LOC 1
1438: PUSH
1439: LD_LOC 3
1443: PUSH
1444: LD_LOC 4
1448: PUSH
1449: LD_LOC 5
1453: PUSH
1454: LD_LOC 6
1458: PUSH
1459: LD_LOC 7
1463: PUSH
1464: LD_LOC 8
1468: PUSH
1469: LD_LOC 9
1473: PUSH
1474: LD_LOC 10
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// end ;
1491: LD_VAR 0 1
1495: RET
// export function DStart ; begin
1496: LD_INT 0
1498: PPUSH
// hide_interface_automaticaly := true ;
1499: LD_ADDR_OWVAR 53
1503: PUSH
1504: LD_INT 1
1506: ST_TO_ADDR
// InGameOn ;
1507: CALL_OW 8
// CenterNowOnUnits ( IsInUnit ( Bur ) ) ;
1511: LD_LOC 2
1515: PPUSH
1516: CALL_OW 310
1520: PPUSH
1521: CALL_OW 87
// CenterNowOnUnits ( Bur ) ;
1525: LD_LOC 2
1529: PPUSH
1530: CALL_OW 87
// while IsInUnit ( bur ) do
1534: LD_LOC 2
1538: PPUSH
1539: CALL_OW 310
1543: IFFALSE 1563
// begin ComExitVehicle ( Bur ) ;
1545: LD_LOC 2
1549: PPUSH
1550: CALL_OW 121
// wait ( 0 0$0.3 ) ;
1554: LD_INT 10
1556: PPUSH
1557: CALL_OW 67
// end ;
1561: GO 1534
// Say ( Bur , DStart-Bur-1 ) ;
1563: LD_LOC 2
1567: PPUSH
1568: LD_STRING DStart-Bur-1
1570: PPUSH
1571: CALL_OW 88
// Say ( Gla , DStart-Gla-1 ) ;
1575: LD_LOC 1
1579: PPUSH
1580: LD_STRING DStart-Gla-1
1582: PPUSH
1583: CALL_OW 88
// Say ( Bur , DStart-Bur-2 ) ;
1587: LD_LOC 2
1591: PPUSH
1592: LD_STRING DStart-Bur-2
1594: PPUSH
1595: CALL_OW 88
// Say ( Gla , DStart-Gla-2 ) ;
1599: LD_LOC 1
1603: PPUSH
1604: LD_STRING DStart-Gla-2
1606: PPUSH
1607: CALL_OW 88
// Say ( Bur , DStart-Bur-3 ) ;
1611: LD_LOC 2
1615: PPUSH
1616: LD_STRING DStart-Bur-3
1618: PPUSH
1619: CALL_OW 88
// Say ( Gla , DStart-Gla-3 ) ;
1623: LD_LOC 1
1627: PPUSH
1628: LD_STRING DStart-Gla-3
1630: PPUSH
1631: CALL_OW 88
// Say ( Bur , DStart-Bur-4 ) ;
1635: LD_LOC 2
1639: PPUSH
1640: LD_STRING DStart-Bur-4
1642: PPUSH
1643: CALL_OW 88
// SetBName ( da , bluekher ) ;
1647: LD_INT 1
1649: PPUSH
1650: LD_STRING bluekher
1652: PPUSH
1653: CALL_OW 500
// SetBName ( dc , yegorov ) ;
1657: LD_INT 80
1659: PPUSH
1660: LD_STRING yegorov
1662: PPUSH
1663: CALL_OW 500
// SetBName ( dd , ryutin ) ;
1667: LD_INT 28
1669: PPUSH
1670: LD_STRING ryutin
1672: PPUSH
1673: CALL_OW 500
// SetBName ( db , budonny ) ;
1677: LD_INT 51
1679: PPUSH
1680: LD_STRING budonny
1682: PPUSH
1683: CALL_OW 500
// SetBName ( de , yakir ) ;
1687: LD_INT 37
1689: PPUSH
1690: LD_STRING yakir
1692: PPUSH
1693: CALL_OW 500
// RevealFogArea ( you , near_base ) ;
1697: LD_EXP 7
1701: PPUSH
1702: LD_INT 7
1704: PPUSH
1705: CALL_OW 332
// CenterOnUnits ( dc ) ;
1709: LD_INT 80
1711: PPUSH
1712: CALL_OW 85
// DWait ( 0 0$2 ) ;
1716: LD_INT 70
1718: PPUSH
1719: CALL_OW 68
// Say ( Gla , DStart-Gla-4 ) ;
1723: LD_LOC 1
1727: PPUSH
1728: LD_STRING DStart-Gla-4
1730: PPUSH
1731: CALL_OW 88
// CenterOnUnits ( dd ) ;
1735: LD_INT 28
1737: PPUSH
1738: CALL_OW 85
// DWait ( 0 0$2 ) ;
1742: LD_INT 70
1744: PPUSH
1745: CALL_OW 68
// Say ( Gla , DStart-Gla-4a ) ;
1749: LD_LOC 1
1753: PPUSH
1754: LD_STRING DStart-Gla-4a
1756: PPUSH
1757: CALL_OW 88
// CenterOnUnits ( de ) ;
1761: LD_INT 37
1763: PPUSH
1764: CALL_OW 85
// DWait ( 0 0$2 ) ;
1768: LD_INT 70
1770: PPUSH
1771: CALL_OW 68
// Say ( Gla , DStart-Gla-4b ) ;
1775: LD_LOC 1
1779: PPUSH
1780: LD_STRING DStart-Gla-4b
1782: PPUSH
1783: CALL_OW 88
// CenterOnUnits ( db ) ;
1787: LD_INT 51
1789: PPUSH
1790: CALL_OW 85
// DWait ( 0 0$2 ) ;
1794: LD_INT 70
1796: PPUSH
1797: CALL_OW 68
// Say ( Gla , DStart-Gla-4c ) ;
1801: LD_LOC 1
1805: PPUSH
1806: LD_STRING DStart-Gla-4c
1808: PPUSH
1809: CALL_OW 88
// CenterOnUnits ( da ) ;
1813: LD_INT 1
1815: PPUSH
1816: CALL_OW 85
// DWait ( 0 0$2 ) ;
1820: LD_INT 70
1822: PPUSH
1823: CALL_OW 68
// Say ( Gla , DStart-Gla-4d ) ;
1827: LD_LOC 1
1831: PPUSH
1832: LD_STRING DStart-Gla-4d
1834: PPUSH
1835: CALL_OW 88
// Say ( Gla , DStart-Gla-4e ) ;
1839: LD_LOC 1
1843: PPUSH
1844: LD_STRING DStart-Gla-4e
1846: PPUSH
1847: CALL_OW 88
// SaveForQuickRestart ;
1851: CALL_OW 22
// CenterNowOnUnits ( Bur ) ;
1855: LD_LOC 2
1859: PPUSH
1860: CALL_OW 87
// ChangeMissionObjectives ( MStart ) ;
1864: LD_STRING MStart
1866: PPUSH
1867: CALL_OW 337
// InGameOff ;
1871: CALL_OW 9
// end ;
1875: LD_VAR 0 1
1879: RET
// every 29 29$0 marked 111 do
1880: GO 1882
1882: DISABLE
// begin disable ( 112 ) ;
1883: LD_INT 112
1885: DISABLE_MARKED
// zdrhaji ;
1886: CALL 1915 0 0
// end ;
1890: END
// every 0 0$30 trigger kecali_o_artefaktu marked 112 do
1891: LD_EXP 40
1895: IFFALSE 1914
1897: GO 1899
1899: DISABLE
// begin disable ( 111 ) ;
1900: LD_INT 111
1902: DISABLE_MARKED
// wait ( 2 2$15 ) ;
1903: LD_INT 4725
1905: PPUSH
1906: CALL_OW 67
// zdrhaji ;
1910: CALL 1915 0 0
// end ;
1914: END
// function zdrhaji ; var ai1sci , i , mytick ; begin
1915: LD_INT 0
1917: PPUSH
1918: PPUSH
1919: PPUSH
1920: PPUSH
// vedci_zacali_zdrhat := true ;
1921: LD_ADDR_EXP 30
1925: PUSH
1926: LD_INT 1
1928: ST_TO_ADDR
// TeleportExit ( telp1 , 136 , 88 ) ;
1929: LD_INT 15
1931: PPUSH
1932: LD_INT 136
1934: PPUSH
1935: LD_INT 88
1937: PPUSH
1938: CALL_OW 243
// ai1sci := UnitFilter ( humans [ 1 ] , [ mf_sci ] ) ;
1942: LD_ADDR_VAR 0 2
1946: PUSH
1947: LD_EXP 76
1951: PUSH
1952: LD_INT 1
1954: ARRAY
1955: PPUSH
1956: LD_EXP 54
1960: PUSH
1961: EMPTY
1962: LIST
1963: PPUSH
1964: CALL_OW 72
1968: ST_TO_ADDR
// if ai1sci then
1969: LD_VAR 0 2
1973: IFFALSE 1985
// run_sci := ai1sci ;
1975: LD_ADDR_EXP 31
1979: PUSH
1980: LD_VAR 0 2
1984: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff run_sci ) ;
1985: LD_ADDR_EXP 76
1989: PUSH
1990: LD_EXP 76
1994: PPUSH
1995: LD_INT 1
1997: PPUSH
1998: LD_EXP 76
2002: PUSH
2003: LD_INT 1
2005: ARRAY
2006: PUSH
2007: LD_EXP 31
2011: DIFF
2012: PPUSH
2013: CALL_OW 1
2017: ST_TO_ADDR
// sci := sci diff run_sci ;
2018: LD_ADDR_EXP 88
2022: PUSH
2023: LD_EXP 88
2027: PUSH
2028: LD_EXP 31
2032: DIFF
2033: ST_TO_ADDR
// for i in utek do
2034: LD_ADDR_VAR 0 3
2038: PUSH
2039: LD_EXP 32
2043: PUSH
2044: FOR_IN
2045: IFFALSE 2076
// AddComMoveXY ( run_sci , i [ 1 ] , i [ 2 ] ) ;
2047: LD_EXP 31
2051: PPUSH
2052: LD_VAR 0 3
2056: PUSH
2057: LD_INT 1
2059: ARRAY
2060: PPUSH
2061: LD_VAR 0 3
2065: PUSH
2066: LD_INT 2
2068: ARRAY
2069: PPUSH
2070: CALL_OW 171
2074: GO 2044
2076: POP
2077: POP
// wait ( 0 0$10 ) ;
2078: LD_INT 350
2080: PPUSH
2081: CALL_OW 67
// DGossudarov ;
2085: CALL 2736 0 0
// mytick := tick + 1 1$30 ;
2089: LD_ADDR_VAR 0 4
2093: PUSH
2094: LD_OWVAR 1
2098: PUSH
2099: LD_INT 3150
2101: PLUS
2102: ST_TO_ADDR
// while mytick > tick and not UnitFilter ( run_sci , [ f_or , [ f_not , [ f_alive ] ] , [ f_distxy , 142 , 88 , 10 ] ] ) do
2103: LD_VAR 0 4
2107: PUSH
2108: LD_OWVAR 1
2112: GREATER
2113: PUSH
2114: LD_EXP 31
2118: PPUSH
2119: LD_INT 2
2121: PUSH
2122: LD_INT 3
2124: PUSH
2125: LD_INT 51
2127: PUSH
2128: EMPTY
2129: LIST
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 92
2137: PUSH
2138: LD_INT 142
2140: PUSH
2141: LD_INT 88
2143: PUSH
2144: LD_INT 10
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 72
2162: NOT
2163: AND
2164: IFFALSE 2175
// wait ( 0 0$1 ) ;
2166: LD_INT 35
2168: PPUSH
2169: CALL_OW 67
2173: GO 2103
// ComExitVehicle ( Gossudarov ) ;
2175: LD_EXP 43
2179: PPUSH
2180: CALL_OW 121
// while not UnitsInside ( art_cargo ) do
2184: LD_INT 121
2186: PPUSH
2187: CALL_OW 313
2191: NOT
2192: IFFALSE 2215
// begin ComEnterUnit ( Gossudarov , art_cargo ) ;
2194: LD_EXP 43
2198: PPUSH
2199: LD_INT 121
2201: PPUSH
2202: CALL_OW 120
// wait ( 0 0$1 ) ;
2206: LD_INT 35
2208: PPUSH
2209: CALL_OW 67
// end ;
2213: GO 2184
// if UnitFilter ( run_sci , [ [ f_distxy , 142 , 88 , 12 ] ] ) then
2215: LD_EXP 31
2219: PPUSH
2220: LD_INT 92
2222: PUSH
2223: LD_INT 142
2225: PUSH
2226: LD_INT 88
2228: PUSH
2229: LD_INT 12
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: PPUSH
2241: CALL_OW 72
2245: IFFALSE 2297
// while not UnitFilter ( art_cargo , [ [ f_distxy , 136 , 88 , 15 ] ] ) do
2247: LD_INT 121
2249: PPUSH
2250: LD_INT 92
2252: PUSH
2253: LD_INT 136
2255: PUSH
2256: LD_INT 88
2258: PUSH
2259: LD_INT 15
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: PPUSH
2271: CALL_OW 72
2275: NOT
2276: IFFALSE 2297
// begin ComMoveUnit ( art_cargo , telp1 ) ;
2278: LD_INT 121
2280: PPUSH
2281: LD_INT 15
2283: PPUSH
2284: CALL_OW 112
// wait ( 0 0$1 ) ;
2288: LD_INT 35
2290: PPUSH
2291: CALL_OW 67
// end ;
2295: GO 2247
// while UnitFilter ( run_sci ^ art_cargo , [ [ f_placed ] ] ) do
2297: LD_EXP 31
2301: PUSH
2302: LD_INT 121
2304: ADD
2305: PPUSH
2306: LD_INT 52
2308: PUSH
2309: EMPTY
2310: LIST
2311: PUSH
2312: EMPTY
2313: LIST
2314: PPUSH
2315: CALL_OW 72
2319: IFFALSE 2453
// begin ComMoveXY ( ( run_sci ) ^ art_cargo , utek_e [ 1 ] , utek_e [ 2 ] ) ;
2321: LD_EXP 31
2325: PUSH
2326: LD_INT 121
2328: ADD
2329: PPUSH
2330: LD_EXP 33
2334: PUSH
2335: LD_INT 1
2337: ARRAY
2338: PPUSH
2339: LD_EXP 33
2343: PUSH
2344: LD_INT 2
2346: ARRAY
2347: PPUSH
2348: CALL_OW 111
// for i in UnitFilter ( ( run_sci ) ^ art_cargo , [ [ f_distxy , utek_e [ 1 ] , utek_e [ 2 ] , 5 ] ] ) do
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_EXP 31
2361: PUSH
2362: LD_INT 121
2364: ADD
2365: PPUSH
2366: LD_INT 92
2368: PUSH
2369: LD_EXP 33
2373: PUSH
2374: LD_INT 1
2376: ARRAY
2377: PUSH
2378: LD_EXP 33
2382: PUSH
2383: LD_INT 2
2385: ARRAY
2386: PUSH
2387: LD_INT 5
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: LIST
2394: LIST
2395: PUSH
2396: EMPTY
2397: LIST
2398: PPUSH
2399: CALL_OW 72
2403: PUSH
2404: FOR_IN
2405: IFFALSE 2442
// if i = art_cargo then
2407: LD_VAR 0 3
2411: PUSH
2412: LD_INT 121
2414: EQUAL
2415: IFFALSE 2423
// LostArte else
2417: CALL 602 0 0
2421: GO 2440
// begin RemoveUnit ( i ) ;
2423: LD_VAR 0 3
2427: PPUSH
2428: CALL_OW 64
// Goss := false ;
2432: LD_ADDR_EXP 28
2436: PUSH
2437: LD_INT 0
2439: ST_TO_ADDR
// end ;
2440: GO 2404
2442: POP
2443: POP
// wait ( 0 0$1 ) ;
2444: LD_INT 35
2446: PPUSH
2447: CALL_OW 67
// end ;
2451: GO 2297
// end ;
2453: LD_VAR 0 1
2457: RET
// every 0 0$1 trigger vedci_zacali_zdrhat and UnitFilter ( run_sci ^ Gossudarov , [ [ f_alive ] , [ f_placed ] ] ) = 0 do
2458: LD_EXP 30
2462: PUSH
2463: LD_EXP 31
2467: PUSH
2468: LD_EXP 43
2472: ADD
2473: PPUSH
2474: LD_INT 51
2476: PUSH
2477: EMPTY
2478: LIST
2479: PUSH
2480: LD_INT 52
2482: PUSH
2483: EMPTY
2484: LIST
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PPUSH
2490: CALL_OW 72
2494: PUSH
2495: LD_INT 0
2497: EQUAL
2498: AND
2499: IFFALSE 2511
2501: GO 2503
2503: DISABLE
// begin ChangeMissionObjectives ( MGossSciOut ) ;
2504: LD_STRING MGossSciOut
2506: PPUSH
2507: CALL_OW 337
// end ;
2511: END
// every 0 0$1 do var h , hinfo , i ;
2512: GO 2514
2514: DISABLE
2515: LD_INT 0
2517: PPUSH
2518: PPUSH
2519: PPUSH
// begin h := FindArtifact ( 4 ) ;
2520: LD_ADDR_VAR 0 1
2524: PUSH
2525: LD_INT 4
2527: PPUSH
2528: CALL_OW 469
2532: ST_TO_ADDR
// if h then
2533: LD_VAR 0 1
2537: IFFALSE 2732
// begin hinfo := HexInfo ( h [ 1 ] , h [ 2 ] ) ;
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_VAR 0 1
2548: PUSH
2549: LD_INT 1
2551: ARRAY
2552: PPUSH
2553: LD_VAR 0 1
2557: PUSH
2558: LD_INT 2
2560: ARRAY
2561: PPUSH
2562: CALL_OW 428
2566: ST_TO_ADDR
// if hinfo > 0 then
2567: LD_VAR 0 2
2571: PUSH
2572: LD_INT 0
2574: GREATER
2575: IFFALSE 2614
// begin if GetSide ( hinfo ) = you then
2577: LD_VAR 0 2
2581: PPUSH
2582: CALL_OW 255
2586: PUSH
2587: LD_EXP 7
2591: EQUAL
2592: IFFALSE 2604
// maji_artifact := true else
2594: LD_ADDR_EXP 39
2598: PUSH
2599: LD_INT 1
2601: ST_TO_ADDR
2602: GO 2612
// maji_artifact := false ;
2604: LD_ADDR_EXP 39
2608: PUSH
2609: LD_INT 0
2611: ST_TO_ADDR
// end else
2612: GO 2732
// begin maji_artifact := false ;
2614: LD_ADDR_EXP 39
2618: PUSH
2619: LD_INT 0
2621: ST_TO_ADDR
// for i := 1 to 5 do
2622: LD_ADDR_VAR 0 3
2626: PUSH
2627: DOUBLE
2628: LD_INT 1
2630: DEC
2631: ST_TO_ADDR
2632: LD_INT 5
2634: PUSH
2635: FOR_TO
2636: IFFALSE 2730
// if ( ai_s [ i ] in your_bases ) and ( InArea ( h [ 1 ] , h [ 2 ] , near_base_area [ i ] ) or InArea ( h [ 1 ] , h [ 2 ] , nearD ) ) then
2638: LD_EXP 23
2642: PUSH
2643: LD_VAR 0 3
2647: ARRAY
2648: PUSH
2649: LD_EXP 18
2653: IN
2654: PUSH
2655: LD_VAR 0 1
2659: PUSH
2660: LD_INT 1
2662: ARRAY
2663: PPUSH
2664: LD_VAR 0 1
2668: PUSH
2669: LD_INT 2
2671: ARRAY
2672: PPUSH
2673: LD_EXP 63
2677: PUSH
2678: LD_VAR 0 3
2682: ARRAY
2683: PPUSH
2684: CALL_OW 309
2688: PUSH
2689: LD_VAR 0 1
2693: PUSH
2694: LD_INT 1
2696: ARRAY
2697: PPUSH
2698: LD_VAR 0 1
2702: PUSH
2703: LD_INT 2
2705: ARRAY
2706: PPUSH
2707: LD_INT 27
2709: PPUSH
2710: CALL_OW 309
2714: OR
2715: AND
2716: IFFALSE 2728
// begin maji_artifact := true ;
2718: LD_ADDR_EXP 39
2722: PUSH
2723: LD_INT 1
2725: ST_TO_ADDR
// break ;
2726: GO 2730
// end ;
2728: GO 2635
2730: POP
2731: POP
// end ; end ; enable ;
2732: ENABLE
// end ;
2733: PPOPN 3
2735: END
// export function DGossudarov ; var x , y ; begin
2736: LD_INT 0
2738: PPUSH
2739: PPUSH
2740: PPUSH
// x := GetX ( run_sci [ 1 ] ) ;
2741: LD_ADDR_VAR 0 2
2745: PUSH
2746: LD_EXP 31
2750: PUSH
2751: LD_INT 1
2753: ARRAY
2754: PPUSH
2755: CALL_OW 250
2759: ST_TO_ADDR
// y := GetY ( run_sci [ 1 ] ) ;
2760: LD_ADDR_VAR 0 3
2764: PUSH
2765: LD_EXP 31
2769: PUSH
2770: LD_INT 1
2772: ARRAY
2773: PPUSH
2774: CALL_OW 251
2778: ST_TO_ADDR
// PlaceSeeing ( x , y , You , 10 ) ;
2779: LD_VAR 0 2
2783: PPUSH
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_EXP 7
2793: PPUSH
2794: LD_INT 10
2796: PPUSH
2797: CALL_OW 330
// CenterNowOnXY ( x , y ) ;
2801: LD_VAR 0 2
2805: PPUSH
2806: LD_VAR 0 3
2810: PPUSH
2811: CALL_OW 86
// wait ( 0 0$1 ) ;
2815: LD_INT 35
2817: PPUSH
2818: CALL_OW 67
// DialogueOn ;
2822: CALL_OW 6
// Say ( Fad , DGossudarov-Fad-1 ) ;
2826: LD_LOC 5
2830: PPUSH
2831: LD_STRING DGossudarov-Fad-1
2833: PPUSH
2834: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-1 ) ;
2838: LD_LOC 2
2842: PPUSH
2843: LD_STRING DGossudarov-Bur-1
2845: PPUSH
2846: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-1 ) ;
2850: LD_LOC 4
2854: PPUSH
2855: LD_STRING DGossudarov-Gos-1
2857: PPUSH
2858: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-2 ) ;
2862: LD_LOC 2
2866: PPUSH
2867: LD_STRING DGossudarov-Bur-2
2869: PPUSH
2870: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-2 ) ;
2874: LD_LOC 4
2878: PPUSH
2879: LD_STRING DGossudarov-Gos-2
2881: PPUSH
2882: CALL_OW 88
// Say ( Bur , DGossudarov-Bur-3 ) ;
2886: LD_LOC 2
2890: PPUSH
2891: LD_STRING DGossudarov-Bur-3
2893: PPUSH
2894: CALL_OW 88
// Say ( Gos , DGossudarov-Gos-3 ) ;
2898: LD_LOC 4
2902: PPUSH
2903: LD_STRING DGossudarov-Gos-3
2905: PPUSH
2906: CALL_OW 88
// ChangeMissionObjectives ( MGoss ) ;
2910: LD_STRING MGoss
2912: PPUSH
2913: CALL_OW 337
// DialogueOff ;
2917: CALL_OW 7
// wait ( 0 0$5 ) ;
2921: LD_INT 175
2923: PPUSH
2924: CALL_OW 67
// RemoveSeeing ( x , y , You ) ;
2928: LD_VAR 0 2
2932: PPUSH
2933: LD_VAR 0 3
2937: PPUSH
2938: LD_EXP 7
2942: PPUSH
2943: CALL_OW 331
// end ;
2947: LD_VAR 0 1
2951: RET
// every 0 0$2 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
2952: LD_EXP 23
2956: PUSH
2957: LD_EXP 25
2961: ARRAY
2962: PPUSH
2963: LD_EXP 37
2967: PUSH
2968: LD_EXP 35
2972: ADD
2973: PPUSH
2974: CALL 10605 0 2
2978: PUSH
2979: LD_EXP 37
2983: PUSH
2984: LD_EXP 35
2988: ADD
2989: PPUSH
2990: LD_INT 95
2992: PUSH
2993: LD_EXP 63
2997: PUSH
2998: LD_EXP 25
3002: ARRAY
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: PUSH
3008: EMPTY
3009: LIST
3010: PPUSH
3011: CALL_OW 72
3015: AND
3016: IFFALSE 3025
3018: GO 3020
3020: DISABLE
// begin DA_BaseContact ;
3021: CALL 3026 0 0
// end ;
3025: END
// export function DA_BaseContact ; begin
3026: LD_INT 0
3028: PPUSH
// DialogueOn ;
3029: CALL_OW 6
// Say ( Pla , DA-BaseContact-Pla-1 ) ;
3033: LD_LOC 3
3037: PPUSH
3038: LD_STRING DA-BaseContact-Pla-1
3040: PPUSH
3041: CALL_OW 88
// Say ( Bur , DA-BaseContact-Bur-1 ) ;
3045: LD_LOC 2
3049: PPUSH
3050: LD_STRING DA-BaseContact-Bur-1
3052: PPUSH
3053: CALL_OW 88
// DialogueOff ;
3057: CALL_OW 7
// end ;
3061: LD_VAR 0 1
3065: RET
// every 0 0$20 trigger see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) do
3066: LD_EXP 23
3070: PUSH
3071: LD_EXP 25
3075: ARRAY
3076: PPUSH
3077: LD_EXP 37
3081: PUSH
3082: LD_EXP 35
3086: ADD
3087: PPUSH
3088: CALL 10605 0 2
3092: PUSH
3093: LD_EXP 37
3097: PUSH
3098: LD_EXP 35
3102: ADD
3103: PPUSH
3104: LD_INT 95
3106: PUSH
3107: LD_EXP 63
3111: PUSH
3112: LD_EXP 25
3116: ARRAY
3117: PUSH
3118: EMPTY
3119: LIST
3120: LIST
3121: PUSH
3122: EMPTY
3123: LIST
3124: PPUSH
3125: CALL_OW 72
3129: AND
3130: IFFALSE 3213
3132: GO 3134
3134: DISABLE
// begin wait ( 0 0$20 ) ;
3135: LD_INT 700
3137: PPUSH
3138: CALL_OW 67
// if see_any ( ai_s [ plat_i ] , your_humans ^ your_cars ) and UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ plat_i ] ] ] ) then
3142: LD_EXP 23
3146: PUSH
3147: LD_EXP 25
3151: ARRAY
3152: PPUSH
3153: LD_EXP 37
3157: PUSH
3158: LD_EXP 35
3162: ADD
3163: PPUSH
3164: CALL 10605 0 2
3168: PUSH
3169: LD_EXP 37
3173: PUSH
3174: LD_EXP 35
3178: ADD
3179: PPUSH
3180: LD_INT 95
3182: PUSH
3183: LD_EXP 63
3187: PUSH
3188: LD_EXP 25
3192: ARRAY
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: EMPTY
3199: LIST
3200: PPUSH
3201: CALL_OW 72
3205: AND
3206: IFFALSE 3212
// DA_BaseRefuse ;
3208: CALL 4028 0 0
// enable ;
3212: ENABLE
// end ;
3213: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 12 do
3214: LD_EXP 76
3218: PUSH
3219: LD_EXP 25
3223: ARRAY
3224: PPUSH
3225: LD_INT 3
3227: PUSH
3228: LD_EXP 54
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PPUSH
3237: CALL_OW 72
3241: PUSH
3242: LD_INT 12
3244: LESS
3245: IFFALSE 3258
3247: GO 3249
3249: DISABLE
// begin DA_BaseRefuse ;
3250: CALL 4028 0 0
// ZoufalUtok ;
3254: CALL 11909 0 0
// end ;
3258: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) < 10 do
3259: LD_EXP 76
3263: PUSH
3264: LD_EXP 25
3268: ARRAY
3269: PPUSH
3270: LD_INT 3
3272: PUSH
3273: LD_EXP 54
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PPUSH
3282: CALL_OW 72
3286: PUSH
3287: LD_INT 10
3289: LESS
3290: IFFALSE 3303
3292: GO 3294
3294: DISABLE
// begin DA_BaseRefuse ;
3295: CALL 4028 0 0
// BehemothUtok ;
3299: CALL 11718 0 0
// end ;
3303: END
// every 25 25$0 do
3304: GO 3306
3306: DISABLE
// begin BehemothUtok ;
3307: CALL 11718 0 0
// end ;
3311: END
// every 10 10$0 + 0 0$5 do
3312: GO 3314
3314: DISABLE
// begin NormalUtok ;
3315: CALL 12106 0 0
// end ;
3319: END
// every 0 0$2 trigger UnitFilter ( humans [ plat_i ] , [ f_not , mf_sci ] ) <= 7 and UnitFilter ( buildings [ plat_i ] , [ f_or , [ f_btype , b_turret ] , [ [ f_occupied ] , mf_fort ] ] ) <= 2 do var kam_zdrha , k_dispozici , mt , kam_telp , h , i , kam_zdrha_i ;
3320: LD_EXP 76
3324: PUSH
3325: LD_EXP 25
3329: ARRAY
3330: PPUSH
3331: LD_INT 3
3333: PUSH
3334: LD_EXP 54
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PPUSH
3343: CALL_OW 72
3347: PUSH
3348: LD_INT 7
3350: LESSEQUAL
3351: PUSH
3352: LD_EXP 75
3356: PUSH
3357: LD_EXP 25
3361: ARRAY
3362: PPUSH
3363: LD_INT 2
3365: PUSH
3366: LD_INT 30
3368: PUSH
3369: LD_INT 33
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: PUSH
3376: LD_INT 59
3378: PUSH
3379: EMPTY
3380: LIST
3381: PUSH
3382: LD_EXP 56
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: PPUSH
3396: CALL_OW 72
3400: PUSH
3401: LD_INT 2
3403: LESSEQUAL
3404: AND
3405: IFFALSE 4025
3407: GO 3409
3409: DISABLE
3410: LD_INT 0
3412: PPUSH
3413: PPUSH
3414: PPUSH
3415: PPUSH
3416: PPUSH
3417: PPUSH
3418: PPUSH
// begin k_dispozici := ( ai diff ( ai [ 1 ] ^ your_bases ) ) ;
3419: LD_ADDR_VAR 0 2
3423: PUSH
3424: LD_EXP 24
3428: PUSH
3429: LD_EXP 24
3433: PUSH
3434: LD_INT 1
3436: ARRAY
3437: PUSH
3438: LD_EXP 18
3442: ADD
3443: DIFF
3444: ST_TO_ADDR
// if k_dispozici then
3445: LD_VAR 0 2
3449: IFFALSE 3980
// begin kam_zdrha := ( k_dispozici ) [ Rand ( 1 , k_dispozici ) ] ;
3451: LD_ADDR_VAR 0 1
3455: PUSH
3456: LD_VAR 0 2
3460: PUSH
3461: LD_INT 1
3463: PPUSH
3464: LD_VAR 0 2
3468: PPUSH
3469: CALL_OW 12
3473: ARRAY
3474: ST_TO_ADDR
// case kam_zdrha of ai_s [ 2 ] :
3475: LD_VAR 0 1
3479: PUSH
3480: LD_EXP 23
3484: PUSH
3485: LD_INT 2
3487: ARRAY
3488: DOUBLE
3489: EQUAL
3490: IFTRUE 3494
3492: GO 3505
3494: POP
// kam_telp := b_base ; ai_s [ 3 ] :
3495: LD_ADDR_VAR 0 4
3499: PUSH
3500: LD_INT 20
3502: ST_TO_ADDR
3503: GO 3581
3505: LD_EXP 23
3509: PUSH
3510: LD_INT 3
3512: ARRAY
3513: DOUBLE
3514: EQUAL
3515: IFTRUE 3519
3517: GO 3530
3519: POP
// kam_telp := c_base ; ai_s [ 4 ] :
3520: LD_ADDR_VAR 0 4
3524: PUSH
3525: LD_INT 23
3527: ST_TO_ADDR
3528: GO 3581
3530: LD_EXP 23
3534: PUSH
3535: LD_INT 4
3537: ARRAY
3538: DOUBLE
3539: EQUAL
3540: IFTRUE 3544
3542: GO 3555
3544: POP
// kam_telp := d_base ; ai_s [ 5 ] :
3545: LD_ADDR_VAR 0 4
3549: PUSH
3550: LD_INT 22
3552: ST_TO_ADDR
3553: GO 3581
3555: LD_EXP 23
3559: PUSH
3560: LD_INT 5
3562: ARRAY
3563: DOUBLE
3564: EQUAL
3565: IFTRUE 3569
3567: GO 3580
3569: POP
// kam_telp := e_base ; end ;
3570: LD_ADDR_VAR 0 4
3574: PUSH
3575: LD_INT 21
3577: ST_TO_ADDR
3578: GO 3581
3580: POP
// repeat h := RandHexArea ( kam_telp , false ) ;
3581: LD_ADDR_VAR 0 5
3585: PUSH
3586: LD_VAR 0 4
3590: PPUSH
3591: LD_INT 0
3593: PPUSH
3594: CALL_OW 16
3598: ST_TO_ADDR
// until HexInfo ( h [ 1 ] , h [ 2 ] ) = 0 ;
3599: LD_VAR 0 5
3603: PUSH
3604: LD_INT 1
3606: ARRAY
3607: PPUSH
3608: LD_VAR 0 5
3612: PUSH
3613: LD_INT 2
3615: ARRAY
3616: PPUSH
3617: CALL_OW 428
3621: PUSH
3622: LD_INT 0
3624: EQUAL
3625: IFFALSE 3581
// if IsOk ( telp1 ) then
3627: LD_INT 15
3629: PPUSH
3630: CALL_OW 302
3634: IFFALSE 3661
// TeleportExit ( telp1 , h [ 1 ] , h [ 2 ] ) ;
3636: LD_INT 15
3638: PPUSH
3639: LD_VAR 0 5
3643: PUSH
3644: LD_INT 1
3646: ARRAY
3647: PPUSH
3648: LD_VAR 0 5
3652: PUSH
3653: LD_INT 2
3655: ARRAY
3656: PPUSH
3657: CALL_OW 243
// ComExitVehicle ( Platonov ) ;
3661: LD_EXP 42
3665: PPUSH
3666: CALL_OW 121
// AddComExitBuilding ( Platonov ) ;
3670: LD_EXP 42
3674: PPUSH
3675: CALL_OW 182
// if IsOk ( telp1 ) then
3679: LD_INT 15
3681: PPUSH
3682: CALL_OW 302
3686: IFFALSE 3702
// AddComEnterUnit ( Platonov , telp1 ) else
3688: LD_EXP 42
3692: PPUSH
3693: LD_INT 15
3695: PPUSH
3696: CALL_OW 180
3700: GO 3717
// AddComMoveXY ( Platonov , 134 , 97 ) ;
3702: LD_EXP 42
3706: PPUSH
3707: LD_INT 134
3709: PPUSH
3710: LD_INT 97
3712: PPUSH
3713: CALL_OW 171
// for i := 1 to 5 do
3717: LD_ADDR_VAR 0 6
3721: PUSH
3722: DOUBLE
3723: LD_INT 1
3725: DEC
3726: ST_TO_ADDR
3727: LD_INT 5
3729: PUSH
3730: FOR_TO
3731: IFFALSE 3763
// if ai_s [ i ] = kam_zdrha then
3733: LD_EXP 23
3737: PUSH
3738: LD_VAR 0 6
3742: ARRAY
3743: PUSH
3744: LD_VAR 0 1
3748: EQUAL
3749: IFFALSE 3761
// kam_zdrha_i := i ;
3751: LD_ADDR_VAR 0 7
3755: PUSH
3756: LD_VAR 0 6
3760: ST_TO_ADDR
3761: GO 3730
3763: POP
3764: POP
// plat_i := kam_zdrha_i ;
3765: LD_ADDR_EXP 25
3769: PUSH
3770: LD_VAR 0 7
3774: ST_TO_ADDR
// ai_s := replace ( ai_s , kam_zdrha_i , ai_s [ 1 ] ) ;
3775: LD_ADDR_EXP 23
3779: PUSH
3780: LD_EXP 23
3784: PPUSH
3785: LD_VAR 0 7
3789: PPUSH
3790: LD_EXP 23
3794: PUSH
3795: LD_INT 1
3797: ARRAY
3798: PPUSH
3799: CALL_OW 1
3803: ST_TO_ADDR
// wait ( 0 0$5 ) ;
3804: LD_INT 175
3806: PPUSH
3807: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3811: LD_EXP 42
3815: PPUSH
3816: LD_EXP 74
3820: PUSH
3821: LD_VAR 0 7
3825: ARRAY
3826: PPUSH
3827: CALL_OW 180
// DA_BaseAccept ;
3831: CALL 4078 0 0
// SurrenderBase ( t_killbeat , ai_s [ plat_i ] ) ;
3835: LD_EXP 6
3839: PPUSH
3840: LD_EXP 23
3844: PUSH
3845: LD_EXP 25
3849: ARRAY
3850: PPUSH
3851: CALL 30389 0 2
// SetAttitude ( ai_s [ plat_i ] , you , att_enemy , true ) ;
3855: LD_EXP 23
3859: PUSH
3860: LD_EXP 25
3864: ARRAY
3865: PPUSH
3866: LD_EXP 7
3870: PPUSH
3871: LD_INT 2
3873: PPUSH
3874: LD_INT 1
3876: PPUSH
3877: CALL_OW 80
// SetSideBase_custom ( GetBase ( depots [ plat_i ] ) , ai_s [ plat_i ] ) ;
3881: LD_EXP 74
3885: PUSH
3886: LD_EXP 25
3890: ARRAY
3891: PPUSH
3892: CALL_OW 274
3896: PPUSH
3897: LD_EXP 23
3901: PUSH
3902: LD_EXP 25
3906: ARRAY
3907: PPUSH
3908: CALL 32766 0 2
// SetSide ( FilterAllUnits ( [ [ f_side , kam_zdrha ] ] ) , ai_s [ plat_i ] ) ;
3912: LD_INT 22
3914: PUSH
3915: LD_VAR 0 1
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PUSH
3924: EMPTY
3925: LIST
3926: PPUSH
3927: CALL_OW 69
3931: PPUSH
3932: LD_EXP 23
3936: PUSH
3937: LD_EXP 25
3941: ARRAY
3942: PPUSH
3943: CALL_OW 235
// wait ( 1 1$0 ) ;
3947: LD_INT 2100
3949: PPUSH
3950: CALL_OW 67
// AddComEnterUnit ( Platonov , depots [ kam_zdrha_i ] ) ;
3954: LD_EXP 42
3958: PPUSH
3959: LD_EXP 74
3963: PUSH
3964: LD_VAR 0 7
3968: ARRAY
3969: PPUSH
3970: CALL_OW 180
// ZoufalUtok ;
3974: CALL 11909 0 0
// end else
3978: GO 4025
// begin while not IsDead ( Platonov ) do
3980: LD_EXP 42
3984: PPUSH
3985: CALL_OW 301
3989: NOT
3990: IFFALSE 4025
// begin ComAttackUnit ( Platonov , NearestUnitToUnit ( your_humans , Platonov ) ) ;
3992: LD_EXP 42
3996: PPUSH
3997: LD_EXP 37
4001: PPUSH
4002: LD_EXP 42
4006: PPUSH
4007: CALL_OW 74
4011: PPUSH
4012: CALL_OW 115
// wait ( 0 0$5 ) ;
4016: LD_INT 175
4018: PPUSH
4019: CALL_OW 67
// end ;
4023: GO 3980
// end ; end ;
4025: PPOPN 7
4027: END
// export function DA_BaseRefuse ; begin
4028: LD_INT 0
4030: PPUSH
// DialogueOn ;
4031: CALL_OW 6
// if not IsDead ( Pla ) then
4035: LD_LOC 3
4039: PPUSH
4040: CALL_OW 301
4044: NOT
4045: IFFALSE 4069
// if not Say ( Pla , DA-BaseReguse-Pla-1 ) then
4047: LD_LOC 3
4051: PPUSH
4052: LD_STRING DA-BaseReguse-Pla-1
4054: PPUSH
4055: CALL_OW 88
4059: NOT
4060: IFFALSE 4069
// msg ( bad ident: DA-BaseReguse-Pla-1 ) ;
4062: LD_STRING bad ident: DA-BaseReguse-Pla-1
4064: PPUSH
4065: CALL_OW 100
// DialogueOff ;
4069: CALL_OW 7
// end ;
4073: LD_VAR 0 1
4077: RET
// export function DA_BaseAccept ; begin
4078: LD_INT 0
4080: PPUSH
// DialogueOn ;
4081: CALL_OW 6
// Say ( Pla , DA-BaseAccept-Pla-1 ) ;
4085: LD_LOC 3
4089: PPUSH
4090: LD_STRING DA-BaseAccept-Pla-1
4092: PPUSH
4093: CALL_OW 88
// DialogueOff ;
4097: CALL_OW 7
// end ;
4101: LD_VAR 0 1
4105: RET
// every 0 0$2 trigger See ( you , behemoth ) do var who ;
4106: LD_EXP 7
4110: PPUSH
4111: LD_INT 125
4113: PPUSH
4114: CALL_OW 292
4118: IFFALSE 4237
4120: GO 4122
4122: DISABLE
4123: LD_INT 0
4125: PPUSH
// begin BehemothSeen := true ;
4126: LD_ADDR_EXP 29
4130: PUSH
4131: LD_INT 1
4133: ST_TO_ADDR
// if GetSide ( behemoth ) = you then
4134: LD_INT 125
4136: PPUSH
4137: CALL_OW 255
4141: PUSH
4142: LD_EXP 7
4146: EQUAL
4147: IFFALSE 4151
// exit ;
4149: GO 4237
// CenterNowOnUnits ( behemoth ) ;
4151: LD_INT 125
4153: PPUSH
4154: CALL_OW 87
// who := WhoSayAny ( your_humans diff talking , you , sex_male , 0 , 0 ) ;
4158: LD_ADDR_VAR 0 1
4162: PUSH
4163: LD_EXP 37
4167: PUSH
4168: LD_LOC 11
4172: DIFF
4173: PPUSH
4174: LD_EXP 7
4178: PPUSH
4179: LD_INT 1
4181: PPUSH
4182: LD_INT 0
4184: PPUSH
4185: LD_INT 0
4187: PPUSH
4188: CALL 10411 0 5
4192: ST_TO_ADDR
// DialogueOn ;
4193: CALL_OW 6
// Say ( who , DBehemoth-Rsol1-1 ) ;
4197: LD_VAR 0 1
4201: PPUSH
4202: LD_STRING DBehemoth-Rsol1-1
4204: PPUSH
4205: CALL_OW 88
// Say ( Pla , DBehemoth-Pla-1 ) ;
4209: LD_LOC 3
4213: PPUSH
4214: LD_STRING DBehemoth-Pla-1
4216: PPUSH
4217: CALL_OW 88
// Say ( Bur , DBehemoth-Bur-1 ) ;
4221: LD_LOC 2
4225: PPUSH
4226: LD_STRING DBehemoth-Bur-1
4228: PPUSH
4229: CALL_OW 88
// DialogueOff ;
4233: CALL_OW 7
// end ;
4237: PPOPN 1
4239: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] do
4240: LD_LOC 2
4244: PPUSH
4245: LD_INT 20
4247: PPUSH
4248: CALL_OW 308
4252: PUSH
4253: LD_EXP 23
4257: PUSH
4258: LD_INT 1
4260: ARRAY
4261: PUSH
4262: LD_EXP 23
4266: PUSH
4267: LD_INT 2
4269: ARRAY
4270: NONEQUAL
4271: AND
4272: IFFALSE 4352
4274: GO 4276
4276: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4277: LD_EXP 37
4281: PUSH
4282: LD_INT 12
4284: LESS
4285: PUSH
4286: LD_EXP 35
4290: PUSH
4291: LD_INT 20
4293: LESS
4294: AND
4295: IFFALSE 4317
// begin DB_BaseContact ;
4297: CALL 4556 0 0
// DB_BaseRefuse1st ;
4301: CALL 4584 0 0
// wait ( 0 0$30 ) ;
4305: LD_INT 1050
4307: PPUSH
4308: CALL_OW 67
// enable ( 10 ) ;
4312: LD_INT 10
4314: ENABLE_MARKED
// end else
4315: GO 4352
// begin if not ai_s [ 2 ] in your_bases then
4317: LD_EXP 23
4321: PUSH
4322: LD_INT 2
4324: ARRAY
4325: PUSH
4326: LD_EXP 18
4330: IN
4331: NOT
4332: IFFALSE 4352
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4334: LD_EXP 2
4338: PPUSH
4339: LD_EXP 23
4343: PUSH
4344: LD_INT 2
4346: ARRAY
4347: PPUSH
4348: CALL 30389 0 2
// end ; end ; end ;
4352: END
// every 0 0$2 trigger IsInArea ( Bur , b_base ) and ai_s [ 1 ] <> ai_s [ 2 ] marked 10 do
4353: LD_LOC 2
4357: PPUSH
4358: LD_INT 20
4360: PPUSH
4361: CALL_OW 308
4365: PUSH
4366: LD_EXP 23
4370: PUSH
4371: LD_INT 1
4373: ARRAY
4374: PUSH
4375: LD_EXP 23
4379: PUSH
4380: LD_INT 2
4382: ARRAY
4383: NONEQUAL
4384: AND
4385: IFFALSE 4482
4387: GO 4389
4389: DISABLE
// begin if your_humans < 12 and your_cars < 20 then
4390: LD_EXP 37
4394: PUSH
4395: LD_INT 12
4397: LESS
4398: PUSH
4399: LD_EXP 35
4403: PUSH
4404: LD_INT 20
4406: LESS
4407: AND
4408: IFFALSE 4447
// begin DB_BaseRefuse ;
4410: CALL 4612 0 0
// while IsInArea ( Bur , b_base ) do
4414: LD_LOC 2
4418: PPUSH
4419: LD_INT 20
4421: PPUSH
4422: CALL_OW 308
4426: IFFALSE 4437
// wait ( 0 0$1 ) ;
4428: LD_INT 35
4430: PPUSH
4431: CALL_OW 67
4435: GO 4414
// wait ( 0 0$20 ) ;
4437: LD_INT 700
4439: PPUSH
4440: CALL_OW 67
// enable ;
4444: ENABLE
// end else
4445: GO 4482
// begin if not ai_s [ 2 ] in your_bases then
4447: LD_EXP 23
4451: PUSH
4452: LD_INT 2
4454: ARRAY
4455: PUSH
4456: LD_EXP 18
4460: IN
4461: NOT
4462: IFFALSE 4482
// begin SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4464: LD_EXP 2
4468: PPUSH
4469: LD_EXP 23
4473: PUSH
4474: LD_INT 2
4476: ARRAY
4477: PPUSH
4478: CALL 30389 0 2
// end ; end ; end ;
4482: END
// every 0 0$2 trigger humans [ 2 ] <= 6 and ai_s [ 1 ] <> ai_s [ 2 ] do
4483: LD_EXP 76
4487: PUSH
4488: LD_INT 2
4490: ARRAY
4491: PUSH
4492: LD_INT 6
4494: LESSEQUAL
4495: PUSH
4496: LD_EXP 23
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PUSH
4505: LD_EXP 23
4509: PUSH
4510: LD_INT 2
4512: ARRAY
4513: NONEQUAL
4514: AND
4515: IFFALSE 4555
4517: GO 4519
4519: DISABLE
// begin if not ai_s [ 2 ] in your_bases then
4520: LD_EXP 23
4524: PUSH
4525: LD_INT 2
4527: ARRAY
4528: PUSH
4529: LD_EXP 18
4533: IN
4534: NOT
4535: IFFALSE 4555
// SurrenderBase ( t_killbeat , ai_s [ 2 ] ) ;
4537: LD_EXP 6
4541: PPUSH
4542: LD_EXP 23
4546: PUSH
4547: LD_INT 2
4549: ARRAY
4550: PPUSH
4551: CALL 30389 0 2
// end ;
4555: END
// export function DB_BaseContact ; begin
4556: LD_INT 0
4558: PPUSH
// DialogueOn ;
4559: CALL_OW 6
// Say ( Bor , DB-BaseContact-Bor-1 ) ;
4563: LD_LOC 6
4567: PPUSH
4568: LD_STRING DB-BaseContact-Bor-1
4570: PPUSH
4571: CALL_OW 88
// DialogueOff ;
4575: CALL_OW 7
// end ;
4579: LD_VAR 0 1
4583: RET
// export function DB_BaseRefuse1st ; begin
4584: LD_INT 0
4586: PPUSH
// DialogueOn ;
4587: CALL_OW 6
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4591: LD_LOC 6
4595: PPUSH
4596: LD_STRING DB-BaseRefuse-Bor-1
4598: PPUSH
4599: CALL_OW 88
// DialogueOff ;
4603: CALL_OW 7
// end ;
4607: LD_VAR 0 1
4611: RET
// export function DB_BaseRefuse ; begin
4612: LD_INT 0
4614: PPUSH
// Say ( Bor , DB-BaseRefuse-Bor-1 ) ;
4615: LD_LOC 6
4619: PPUSH
4620: LD_STRING DB-BaseRefuse-Bor-1
4622: PPUSH
4623: CALL_OW 88
// end ;
4627: LD_VAR 0 1
4631: RET
// export function DB_BaseAccept ( first ) ; begin
4632: LD_INT 0
4634: PPUSH
// DialogueOn ;
4635: CALL_OW 6
// Say ( Bor , DB-BaseAccept-Bor-1 ) ;
4639: LD_LOC 6
4643: PPUSH
4644: LD_STRING DB-BaseAccept-Bor-1
4646: PPUSH
4647: CALL_OW 88
// if first then
4651: LD_VAR 0 1
4655: IFFALSE 4671
// Say ( Bor , DB-BaseAccept-Bor-1a ) else
4657: LD_LOC 6
4661: PPUSH
4662: LD_STRING DB-BaseAccept-Bor-1a
4664: PPUSH
4665: CALL_OW 88
4669: GO 4683
// Say ( Bor , DB-BaseAccept-Bor-1b ) ;
4671: LD_LOC 6
4675: PPUSH
4676: LD_STRING DB-BaseAccept-Bor-1b
4678: PPUSH
4679: CALL_OW 88
// DialogueOff ;
4683: CALL_OW 7
// end ;
4687: LD_VAR 0 2
4691: RET
// var jeste_nebylo ; every 0 0$2 trigger IsInArea ( Bur , c_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
4692: LD_LOC 2
4696: PPUSH
4697: LD_INT 23
4699: PPUSH
4700: CALL_OW 308
4704: PUSH
4705: LD_EXP 23
4709: PUSH
4710: LD_INT 1
4712: ARRAY
4713: PUSH
4714: LD_EXP 23
4718: PUSH
4719: LD_INT 4
4721: ARRAY
4722: NONEQUAL
4723: AND
4724: IFFALSE 4821
4726: GO 4728
4728: DISABLE
// begin jeste_nebylo := [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
4729: LD_ADDR_LOC 12
4733: PUSH
4734: LD_INT 1
4736: PUSH
4737: LD_INT 2
4739: PUSH
4740: LD_INT 3
4742: PUSH
4743: LD_INT 4
4745: PUSH
4746: LD_INT 5
4748: PUSH
4749: LD_INT 6
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: ST_TO_ADDR
// DC_BaseContact ;
4760: CALL 5511 0 0
// if otazky then
4764: CALL 4941 0 0
4768: IFFALSE 4821
// if not ai_s [ 3 ] in your_bases then
4770: LD_EXP 23
4774: PUSH
4775: LD_INT 3
4777: ARRAY
4778: PUSH
4779: LD_EXP 18
4783: IN
4784: NOT
4785: IFFALSE 4807
// SurrenderBase ( t_persuade , ai_s [ 3 ] ) else
4787: LD_EXP 3
4791: PPUSH
4792: LD_EXP 23
4796: PUSH
4797: LD_INT 3
4799: ARRAY
4800: PPUSH
4801: CALL 30389 0 2
4805: GO 4821
// begin DQrML_Wrong ;
4807: CALL 6851 0 0
// wait ( 0 0$30 ) ;
4811: LD_INT 1050
4813: PPUSH
4814: CALL_OW 67
// enable ( 11 ) ;
4818: LD_INT 11
4820: ENABLE_MARKED
// end ; end ;
4821: END
// every 0 0$2 trigger IsInArea ( Bur , c_base ) marked 11 do
4822: LD_LOC 2
4826: PPUSH
4827: LD_INT 23
4829: PPUSH
4830: CALL_OW 308
4834: IFFALSE 4867
4836: GO 4838
4838: DISABLE
// begin if not otazky then
4839: CALL 4941 0 0
4843: NOT
4844: IFFALSE 4849
// enable else
4846: ENABLE
4847: GO 4867
// SurrenderBase ( t_intimidate , ai_s [ 2 ] ) ;
4849: LD_EXP 2
4853: PPUSH
4854: LD_EXP 23
4858: PUSH
4859: LD_INT 2
4861: ARRAY
4862: PPUSH
4863: CALL 30389 0 2
// end ;
4867: END
// every 0 0$2 trigger humans [ 3 ] <= 2 and ai_s [ 1 ] <> ai_s [ 4 ] do
4868: LD_EXP 76
4872: PUSH
4873: LD_INT 3
4875: ARRAY
4876: PUSH
4877: LD_INT 2
4879: LESSEQUAL
4880: PUSH
4881: LD_EXP 23
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PUSH
4890: LD_EXP 23
4894: PUSH
4895: LD_INT 4
4897: ARRAY
4898: NONEQUAL
4899: AND
4900: IFFALSE 4940
4902: GO 4904
4904: DISABLE
// begin if not ai_s [ 3 ] in your_bases then
4905: LD_EXP 23
4909: PUSH
4910: LD_INT 3
4912: ARRAY
4913: PUSH
4914: LD_EXP 18
4918: IN
4919: NOT
4920: IFFALSE 4940
// SurrenderBase ( t_killbeat , ai_s [ 3 ] ) ;
4922: LD_EXP 6
4926: PPUSH
4927: LD_EXP 23
4931: PUSH
4932: LD_INT 3
4934: ARRAY
4935: PPUSH
4936: CALL 30389 0 2
// end ;
4940: END
// function otazky ; var qb , qg , q ; begin
4941: LD_INT 0
4943: PPUSH
4944: PPUSH
4945: PPUSH
4946: PPUSH
// DC_BaseQuestion ;
4947: CALL 5539 0 0
// qb := 0 ;
4951: LD_ADDR_VAR 0 2
4955: PUSH
4956: LD_INT 0
4958: ST_TO_ADDR
// qg := 0 ;
4959: LD_ADDR_VAR 0 3
4963: PUSH
4964: LD_INT 0
4966: ST_TO_ADDR
// q := 0 ;
4967: LD_ADDR_VAR 0 4
4971: PUSH
4972: LD_INT 0
4974: ST_TO_ADDR
// while [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] and jeste_nebylo do
4975: LD_VAR 0 2
4979: PUSH
4980: LD_INT 2
4982: LESSEQUAL
4983: PUSH
4984: LD_VAR 0 2
4988: PUSH
4989: LD_INT 1
4991: LESSEQUAL
4992: PUSH
4993: LD_VAR 0 2
4997: PUSH
4998: LD_INT 0
5000: LESSEQUAL
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: LD_OWVAR 67
5011: ARRAY
5012: PUSH
5013: LD_LOC 12
5017: AND
5018: IFFALSE 5440
// begin q := q + 1 ;
5020: LD_ADDR_VAR 0 4
5024: PUSH
5025: LD_VAR 0 4
5029: PUSH
5030: LD_INT 1
5032: PLUS
5033: ST_TO_ADDR
// case jeste_nebylo [ Rand ( 1 , jeste_nebylo ) ] of 1 :
5034: LD_LOC 12
5038: PUSH
5039: LD_INT 1
5041: PPUSH
5042: LD_LOC 12
5046: PPUSH
5047: CALL_OW 12
5051: ARRAY
5052: PUSH
5053: LD_INT 1
5055: DOUBLE
5056: EQUAL
5057: IFTRUE 5061
5059: GO 5117
5061: POP
// begin if QML1 then
5062: CALL 5567 0 0
5066: IFFALSE 5084
// qg := qg + 1 else
5068: LD_ADDR_VAR 0 3
5072: PUSH
5073: LD_VAR 0 3
5077: PUSH
5078: LD_INT 1
5080: PLUS
5081: ST_TO_ADDR
5082: GO 5098
// qb := qb + 1 ;
5084: LD_ADDR_VAR 0 2
5088: PUSH
5089: LD_VAR 0 2
5093: PUSH
5094: LD_INT 1
5096: PLUS
5097: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 1 ] ;
5098: LD_ADDR_LOC 12
5102: PUSH
5103: LD_LOC 12
5107: PUSH
5108: LD_INT 1
5110: PUSH
5111: EMPTY
5112: LIST
5113: DIFF
5114: ST_TO_ADDR
// end ; 2 :
5115: GO 5438
5117: LD_INT 2
5119: DOUBLE
5120: EQUAL
5121: IFTRUE 5125
5123: GO 5181
5125: POP
// begin if QML2 then
5126: CALL 5771 0 0
5130: IFFALSE 5148
// qg := qg + 1 else
5132: LD_ADDR_VAR 0 3
5136: PUSH
5137: LD_VAR 0 3
5141: PUSH
5142: LD_INT 1
5144: PLUS
5145: ST_TO_ADDR
5146: GO 5162
// qb := qb + 1 ;
5148: LD_ADDR_VAR 0 2
5152: PUSH
5153: LD_VAR 0 2
5157: PUSH
5158: LD_INT 1
5160: PLUS
5161: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 2 ] ;
5162: LD_ADDR_LOC 12
5166: PUSH
5167: LD_LOC 12
5171: PUSH
5172: LD_INT 2
5174: PUSH
5175: EMPTY
5176: LIST
5177: DIFF
5178: ST_TO_ADDR
// end ; 3 :
5179: GO 5438
5181: LD_INT 3
5183: DOUBLE
5184: EQUAL
5185: IFTRUE 5189
5187: GO 5245
5189: POP
// begin if QML3 then
5190: CALL 5975 0 0
5194: IFFALSE 5212
// qg := qg + 1 else
5196: LD_ADDR_VAR 0 3
5200: PUSH
5201: LD_VAR 0 3
5205: PUSH
5206: LD_INT 1
5208: PLUS
5209: ST_TO_ADDR
5210: GO 5226
// qb := qb + 1 ;
5212: LD_ADDR_VAR 0 2
5216: PUSH
5217: LD_VAR 0 2
5221: PUSH
5222: LD_INT 1
5224: PLUS
5225: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 3 ] ;
5226: LD_ADDR_LOC 12
5230: PUSH
5231: LD_LOC 12
5235: PUSH
5236: LD_INT 3
5238: PUSH
5239: EMPTY
5240: LIST
5241: DIFF
5242: ST_TO_ADDR
// end ; 4 :
5243: GO 5438
5245: LD_INT 4
5247: DOUBLE
5248: EQUAL
5249: IFTRUE 5253
5251: GO 5309
5253: POP
// begin if QML4 then
5254: CALL 6179 0 0
5258: IFFALSE 5276
// qg := qg + 1 else
5260: LD_ADDR_VAR 0 3
5264: PUSH
5265: LD_VAR 0 3
5269: PUSH
5270: LD_INT 1
5272: PLUS
5273: ST_TO_ADDR
5274: GO 5290
// qb := qb + 1 ;
5276: LD_ADDR_VAR 0 2
5280: PUSH
5281: LD_VAR 0 2
5285: PUSH
5286: LD_INT 1
5288: PLUS
5289: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 4 ] ;
5290: LD_ADDR_LOC 12
5294: PUSH
5295: LD_LOC 12
5299: PUSH
5300: LD_INT 4
5302: PUSH
5303: EMPTY
5304: LIST
5305: DIFF
5306: ST_TO_ADDR
// end ; 5 :
5307: GO 5438
5309: LD_INT 5
5311: DOUBLE
5312: EQUAL
5313: IFTRUE 5317
5315: GO 5373
5317: POP
// begin if QML5 then
5318: CALL 6383 0 0
5322: IFFALSE 5340
// qg := qg + 1 else
5324: LD_ADDR_VAR 0 3
5328: PUSH
5329: LD_VAR 0 3
5333: PUSH
5334: LD_INT 1
5336: PLUS
5337: ST_TO_ADDR
5338: GO 5354
// qb := qb + 1 ;
5340: LD_ADDR_VAR 0 2
5344: PUSH
5345: LD_VAR 0 2
5349: PUSH
5350: LD_INT 1
5352: PLUS
5353: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 5 ] ;
5354: LD_ADDR_LOC 12
5358: PUSH
5359: LD_LOC 12
5363: PUSH
5364: LD_INT 5
5366: PUSH
5367: EMPTY
5368: LIST
5369: DIFF
5370: ST_TO_ADDR
// end ; 6 :
5371: GO 5438
5373: LD_INT 6
5375: DOUBLE
5376: EQUAL
5377: IFTRUE 5381
5379: GO 5437
5381: POP
// begin if QML6 then
5382: CALL 6587 0 0
5386: IFFALSE 5404
// qg := qg + 1 else
5388: LD_ADDR_VAR 0 3
5392: PUSH
5393: LD_VAR 0 3
5397: PUSH
5398: LD_INT 1
5400: PLUS
5401: ST_TO_ADDR
5402: GO 5418
// qb := qb + 1 ;
5404: LD_ADDR_VAR 0 2
5408: PUSH
5409: LD_VAR 0 2
5413: PUSH
5414: LD_INT 1
5416: PLUS
5417: ST_TO_ADDR
// jeste_nebylo := jeste_nebylo diff [ 6 ] ;
5418: LD_ADDR_LOC 12
5422: PUSH
5423: LD_LOC 12
5427: PUSH
5428: LD_INT 6
5430: PUSH
5431: EMPTY
5432: LIST
5433: DIFF
5434: ST_TO_ADDR
// end ; end ;
5435: GO 5438
5437: POP
// end ;
5438: GO 4975
// SA_OnTsaritsynQuizPerfectCleared ( qg ) ;
5440: LD_VAR 0 3
5444: PPUSH
5445: CALL 33159 0 1
// if [ ( qb <= 2 ) , ( qb <= 1 ) , ( qb <= 0 ) ] [ difficulty ] then
5449: LD_VAR 0 2
5453: PUSH
5454: LD_INT 2
5456: LESSEQUAL
5457: PUSH
5458: LD_VAR 0 2
5462: PUSH
5463: LD_INT 1
5465: LESSEQUAL
5466: PUSH
5467: LD_VAR 0 2
5471: PUSH
5472: LD_INT 0
5474: LESSEQUAL
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: PUSH
5481: LD_OWVAR 67
5485: ARRAY
5486: IFFALSE 5498
// result := true else
5488: LD_ADDR_VAR 0 1
5492: PUSH
5493: LD_INT 1
5495: ST_TO_ADDR
5496: GO 5506
// result := false ;
5498: LD_ADDR_VAR 0 1
5502: PUSH
5503: LD_INT 0
5505: ST_TO_ADDR
// end ;
5506: LD_VAR 0 1
5510: RET
// export function DC_BaseContact ; begin
5511: LD_INT 0
5513: PPUSH
// DialogueOn ;
5514: CALL_OW 6
// Say ( Tsr , DC-BaseContact-Tsr-1 ) ;
5518: LD_LOC 7
5522: PPUSH
5523: LD_STRING DC-BaseContact-Tsr-1
5525: PPUSH
5526: CALL_OW 88
// DialogueOff ;
5530: CALL_OW 7
// end ;
5534: LD_VAR 0 1
5538: RET
// export function DC_BaseQuestion ; begin
5539: LD_INT 0
5541: PPUSH
// DialogueOn ;
5542: CALL_OW 6
// Say ( Tsr , DC-BaseQuestion-Tsr-1 ) ;
5546: LD_LOC 7
5550: PPUSH
5551: LD_STRING DC-BaseQuestion-Tsr-1
5553: PPUSH
5554: CALL_OW 88
// DialogueOff ;
5558: CALL_OW 7
// end ;
5562: LD_VAR 0 1
5566: RET
// function QML1 ; var mozn , qr , a , bad ; begin
5567: LD_INT 0
5569: PPUSH
5570: PPUSH
5571: PPUSH
5572: PPUSH
5573: PPUSH
// bad := [ 1 , 3 ] ;
5574: LD_ADDR_VAR 0 5
5578: PUSH
5579: LD_INT 1
5581: PUSH
5582: LD_INT 3
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5589: LD_ADDR_VAR 0 2
5593: PUSH
5594: LD_INT 1
5596: PUSH
5597: LD_INT 2
5599: PUSH
5600: LD_INT 3
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: LIST
5607: ST_TO_ADDR
// if IsOk ( Gleb ) then
5608: LD_EXP 50
5612: PPUSH
5613: CALL_OW 302
5617: IFFALSE 5636
// mozn := mozn ^ [ 4 ] ;
5619: LD_ADDR_VAR 0 2
5623: PUSH
5624: LD_VAR 0 2
5628: PUSH
5629: LD_INT 4
5631: PUSH
5632: EMPTY
5633: LIST
5634: ADD
5635: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5636: LD_ADDR_VAR 0 3
5640: PUSH
5641: LD_STRING QML1
5643: PPUSH
5644: LD_VAR 0 2
5648: PPUSH
5649: CALL_OW 98
5653: ST_TO_ADDR
// if qr = 4 then
5654: LD_VAR 0 3
5658: PUSH
5659: LD_INT 4
5661: EQUAL
5662: IFFALSE 5736
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5664: LD_ADDR_VAR 0 4
5668: PUSH
5669: LD_VAR 0 5
5673: PUSH
5674: LD_INT 1
5676: PPUSH
5677: LD_INT 2
5679: PPUSH
5680: CALL_OW 12
5684: ARRAY
5685: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5686: LD_VAR 0 4
5690: PPUSH
5691: CALL 6879 0 1
// mozn := mozn diff [ a , 4 ] ;
5695: LD_ADDR_VAR 0 2
5699: PUSH
5700: LD_VAR 0 2
5704: PUSH
5705: LD_VAR 0 4
5709: PUSH
5710: LD_INT 4
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: DIFF
5717: ST_TO_ADDR
// qr := SelectiveQuery ( QML1 , mozn ) ;
5718: LD_ADDR_VAR 0 3
5722: PUSH
5723: LD_STRING QML1
5725: PPUSH
5726: LD_VAR 0 2
5730: PPUSH
5731: CALL_OW 98
5735: ST_TO_ADDR
// end ; if qr in bad then
5736: LD_VAR 0 3
5740: PUSH
5741: LD_VAR 0 5
5745: IN
5746: IFFALSE 5758
// result := false else
5748: LD_ADDR_VAR 0 1
5752: PUSH
5753: LD_INT 0
5755: ST_TO_ADDR
5756: GO 5766
// result := true ;
5758: LD_ADDR_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ST_TO_ADDR
// end ;
5766: LD_VAR 0 1
5770: RET
// function QML2 ; var mozn , qr , a , bad ; begin
5771: LD_INT 0
5773: PPUSH
5774: PPUSH
5775: PPUSH
5776: PPUSH
5777: PPUSH
// bad := [ 2 , 3 ] ;
5778: LD_ADDR_VAR 0 5
5782: PUSH
5783: LD_INT 2
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5793: LD_ADDR_VAR 0 2
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 3
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: LIST
5811: ST_TO_ADDR
// if IsOk ( Gleb ) then
5812: LD_EXP 50
5816: PPUSH
5817: CALL_OW 302
5821: IFFALSE 5840
// mozn := mozn ^ [ 4 ] ;
5823: LD_ADDR_VAR 0 2
5827: PUSH
5828: LD_VAR 0 2
5832: PUSH
5833: LD_INT 4
5835: PUSH
5836: EMPTY
5837: LIST
5838: ADD
5839: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_STRING QML2
5847: PPUSH
5848: LD_VAR 0 2
5852: PPUSH
5853: CALL_OW 98
5857: ST_TO_ADDR
// if qr = 4 then
5858: LD_VAR 0 3
5862: PUSH
5863: LD_INT 4
5865: EQUAL
5866: IFFALSE 5940
// begin a := bad [ Rand ( 1 , 2 ) ] ;
5868: LD_ADDR_VAR 0 4
5872: PUSH
5873: LD_VAR 0 5
5877: PUSH
5878: LD_INT 1
5880: PPUSH
5881: LD_INT 2
5883: PPUSH
5884: CALL_OW 12
5888: ARRAY
5889: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
5890: LD_VAR 0 4
5894: PPUSH
5895: CALL 6879 0 1
// mozn := mozn diff [ a , 4 ] ;
5899: LD_ADDR_VAR 0 2
5903: PUSH
5904: LD_VAR 0 2
5908: PUSH
5909: LD_VAR 0 4
5913: PUSH
5914: LD_INT 4
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: DIFF
5921: ST_TO_ADDR
// qr := SelectiveQuery ( QML2 , mozn ) ;
5922: LD_ADDR_VAR 0 3
5926: PUSH
5927: LD_STRING QML2
5929: PPUSH
5930: LD_VAR 0 2
5934: PPUSH
5935: CALL_OW 98
5939: ST_TO_ADDR
// end ; if qr in bad then
5940: LD_VAR 0 3
5944: PUSH
5945: LD_VAR 0 5
5949: IN
5950: IFFALSE 5962
// result := false else
5952: LD_ADDR_VAR 0 1
5956: PUSH
5957: LD_INT 0
5959: ST_TO_ADDR
5960: GO 5970
// result := true ;
5962: LD_ADDR_VAR 0 1
5966: PUSH
5967: LD_INT 1
5969: ST_TO_ADDR
// end ;
5970: LD_VAR 0 1
5974: RET
// function QML3 ; var mozn , qr , a , bad ; begin
5975: LD_INT 0
5977: PPUSH
5978: PPUSH
5979: PPUSH
5980: PPUSH
5981: PPUSH
// bad := [ 1 , 3 ] ;
5982: LD_ADDR_VAR 0 5
5986: PUSH
5987: LD_INT 1
5989: PUSH
5990: LD_INT 3
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
5997: LD_ADDR_VAR 0 2
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: LD_INT 3
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: ST_TO_ADDR
// if IsOk ( Gleb ) then
6016: LD_EXP 50
6020: PPUSH
6021: CALL_OW 302
6025: IFFALSE 6044
// mozn := mozn ^ [ 4 ] ;
6027: LD_ADDR_VAR 0 2
6031: PUSH
6032: LD_VAR 0 2
6036: PUSH
6037: LD_INT 4
6039: PUSH
6040: EMPTY
6041: LIST
6042: ADD
6043: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6044: LD_ADDR_VAR 0 3
6048: PUSH
6049: LD_STRING QML3
6051: PPUSH
6052: LD_VAR 0 2
6056: PPUSH
6057: CALL_OW 98
6061: ST_TO_ADDR
// if qr = 4 then
6062: LD_VAR 0 3
6066: PUSH
6067: LD_INT 4
6069: EQUAL
6070: IFFALSE 6144
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6072: LD_ADDR_VAR 0 4
6076: PUSH
6077: LD_VAR 0 5
6081: PUSH
6082: LD_INT 1
6084: PPUSH
6085: LD_INT 2
6087: PPUSH
6088: CALL_OW 12
6092: ARRAY
6093: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6094: LD_VAR 0 4
6098: PPUSH
6099: CALL 6879 0 1
// mozn := mozn diff [ a , 4 ] ;
6103: LD_ADDR_VAR 0 2
6107: PUSH
6108: LD_VAR 0 2
6112: PUSH
6113: LD_VAR 0 4
6117: PUSH
6118: LD_INT 4
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: DIFF
6125: ST_TO_ADDR
// qr := SelectiveQuery ( QML3 , mozn ) ;
6126: LD_ADDR_VAR 0 3
6130: PUSH
6131: LD_STRING QML3
6133: PPUSH
6134: LD_VAR 0 2
6138: PPUSH
6139: CALL_OW 98
6143: ST_TO_ADDR
// end ; if qr in bad then
6144: LD_VAR 0 3
6148: PUSH
6149: LD_VAR 0 5
6153: IN
6154: IFFALSE 6166
// result := false else
6156: LD_ADDR_VAR 0 1
6160: PUSH
6161: LD_INT 0
6163: ST_TO_ADDR
6164: GO 6174
// result := true ;
6166: LD_ADDR_VAR 0 1
6170: PUSH
6171: LD_INT 1
6173: ST_TO_ADDR
// end ;
6174: LD_VAR 0 1
6178: RET
// function QML4 ; var mozn , qr , a , bad ; begin
6179: LD_INT 0
6181: PPUSH
6182: PPUSH
6183: PPUSH
6184: PPUSH
6185: PPUSH
// bad := [ 1 , 2 ] ;
6186: LD_ADDR_VAR 0 5
6190: PUSH
6191: LD_INT 1
6193: PUSH
6194: LD_INT 2
6196: PUSH
6197: EMPTY
6198: LIST
6199: LIST
6200: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6201: LD_ADDR_VAR 0 2
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: LD_INT 2
6211: PUSH
6212: LD_INT 3
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: LIST
6219: ST_TO_ADDR
// if IsOk ( Gleb ) then
6220: LD_EXP 50
6224: PPUSH
6225: CALL_OW 302
6229: IFFALSE 6248
// mozn := mozn ^ [ 4 ] ;
6231: LD_ADDR_VAR 0 2
6235: PUSH
6236: LD_VAR 0 2
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: EMPTY
6245: LIST
6246: ADD
6247: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6248: LD_ADDR_VAR 0 3
6252: PUSH
6253: LD_STRING QML4
6255: PPUSH
6256: LD_VAR 0 2
6260: PPUSH
6261: CALL_OW 98
6265: ST_TO_ADDR
// if qr = 4 then
6266: LD_VAR 0 3
6270: PUSH
6271: LD_INT 4
6273: EQUAL
6274: IFFALSE 6348
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6276: LD_ADDR_VAR 0 4
6280: PUSH
6281: LD_VAR 0 5
6285: PUSH
6286: LD_INT 1
6288: PPUSH
6289: LD_INT 2
6291: PPUSH
6292: CALL_OW 12
6296: ARRAY
6297: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6298: LD_VAR 0 4
6302: PPUSH
6303: CALL 6879 0 1
// mozn := mozn diff [ a , 4 ] ;
6307: LD_ADDR_VAR 0 2
6311: PUSH
6312: LD_VAR 0 2
6316: PUSH
6317: LD_VAR 0 4
6321: PUSH
6322: LD_INT 4
6324: PUSH
6325: EMPTY
6326: LIST
6327: LIST
6328: DIFF
6329: ST_TO_ADDR
// qr := SelectiveQuery ( QML4 , mozn ) ;
6330: LD_ADDR_VAR 0 3
6334: PUSH
6335: LD_STRING QML4
6337: PPUSH
6338: LD_VAR 0 2
6342: PPUSH
6343: CALL_OW 98
6347: ST_TO_ADDR
// end ; if qr in bad then
6348: LD_VAR 0 3
6352: PUSH
6353: LD_VAR 0 5
6357: IN
6358: IFFALSE 6370
// result := false else
6360: LD_ADDR_VAR 0 1
6364: PUSH
6365: LD_INT 0
6367: ST_TO_ADDR
6368: GO 6378
// result := true ;
6370: LD_ADDR_VAR 0 1
6374: PUSH
6375: LD_INT 1
6377: ST_TO_ADDR
// end ;
6378: LD_VAR 0 1
6382: RET
// function QML5 ; var mozn , qr , a , bad ; begin
6383: LD_INT 0
6385: PPUSH
6386: PPUSH
6387: PPUSH
6388: PPUSH
6389: PPUSH
// bad := [ 1 , 3 ] ;
6390: LD_ADDR_VAR 0 5
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 3
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6405: LD_ADDR_VAR 0 2
6409: PUSH
6410: LD_INT 1
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 3
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: ST_TO_ADDR
// if IsOk ( Gleb ) then
6424: LD_EXP 50
6428: PPUSH
6429: CALL_OW 302
6433: IFFALSE 6452
// mozn := mozn ^ [ 4 ] ;
6435: LD_ADDR_VAR 0 2
6439: PUSH
6440: LD_VAR 0 2
6444: PUSH
6445: LD_INT 4
6447: PUSH
6448: EMPTY
6449: LIST
6450: ADD
6451: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6452: LD_ADDR_VAR 0 3
6456: PUSH
6457: LD_STRING QML5
6459: PPUSH
6460: LD_VAR 0 2
6464: PPUSH
6465: CALL_OW 98
6469: ST_TO_ADDR
// if qr = 4 then
6470: LD_VAR 0 3
6474: PUSH
6475: LD_INT 4
6477: EQUAL
6478: IFFALSE 6552
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6480: LD_ADDR_VAR 0 4
6484: PUSH
6485: LD_VAR 0 5
6489: PUSH
6490: LD_INT 1
6492: PPUSH
6493: LD_INT 2
6495: PPUSH
6496: CALL_OW 12
6500: ARRAY
6501: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6502: LD_VAR 0 4
6506: PPUSH
6507: CALL 6879 0 1
// mozn := mozn diff [ a , 4 ] ;
6511: LD_ADDR_VAR 0 2
6515: PUSH
6516: LD_VAR 0 2
6520: PUSH
6521: LD_VAR 0 4
6525: PUSH
6526: LD_INT 4
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: DIFF
6533: ST_TO_ADDR
// qr := SelectiveQuery ( QML5 , mozn ) ;
6534: LD_ADDR_VAR 0 3
6538: PUSH
6539: LD_STRING QML5
6541: PPUSH
6542: LD_VAR 0 2
6546: PPUSH
6547: CALL_OW 98
6551: ST_TO_ADDR
// end ; if qr in bad then
6552: LD_VAR 0 3
6556: PUSH
6557: LD_VAR 0 5
6561: IN
6562: IFFALSE 6574
// result := false else
6564: LD_ADDR_VAR 0 1
6568: PUSH
6569: LD_INT 0
6571: ST_TO_ADDR
6572: GO 6582
// result := true ;
6574: LD_ADDR_VAR 0 1
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// end ;
6582: LD_VAR 0 1
6586: RET
// function QML6 ; var mozn , qr , a , bad ; begin
6587: LD_INT 0
6589: PPUSH
6590: PPUSH
6591: PPUSH
6592: PPUSH
6593: PPUSH
// bad := [ 2 , 3 ] ;
6594: LD_ADDR_VAR 0 5
6598: PUSH
6599: LD_INT 2
6601: PUSH
6602: LD_INT 3
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: ST_TO_ADDR
// mozn := [ 1 , 2 , 3 ] ;
6609: LD_ADDR_VAR 0 2
6613: PUSH
6614: LD_INT 1
6616: PUSH
6617: LD_INT 2
6619: PUSH
6620: LD_INT 3
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: ST_TO_ADDR
// if IsOk ( Gleb ) then
6628: LD_EXP 50
6632: PPUSH
6633: CALL_OW 302
6637: IFFALSE 6656
// mozn := mozn ^ [ 4 ] ;
6639: LD_ADDR_VAR 0 2
6643: PUSH
6644: LD_VAR 0 2
6648: PUSH
6649: LD_INT 4
6651: PUSH
6652: EMPTY
6653: LIST
6654: ADD
6655: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6656: LD_ADDR_VAR 0 3
6660: PUSH
6661: LD_STRING QML6
6663: PPUSH
6664: LD_VAR 0 2
6668: PPUSH
6669: CALL_OW 98
6673: ST_TO_ADDR
// if qr = 4 then
6674: LD_VAR 0 3
6678: PUSH
6679: LD_INT 4
6681: EQUAL
6682: IFFALSE 6756
// begin a := bad [ Rand ( 1 , 2 ) ] ;
6684: LD_ADDR_VAR 0 4
6688: PUSH
6689: LD_VAR 0 5
6693: PUSH
6694: LD_INT 1
6696: PPUSH
6697: LD_INT 2
6699: PPUSH
6700: CALL_OW 12
6704: ARRAY
6705: ST_TO_ADDR
// DQrML_Gleb ( a ) ;
6706: LD_VAR 0 4
6710: PPUSH
6711: CALL 6879 0 1
// mozn := mozn diff [ a , 4 ] ;
6715: LD_ADDR_VAR 0 2
6719: PUSH
6720: LD_VAR 0 2
6724: PUSH
6725: LD_VAR 0 4
6729: PUSH
6730: LD_INT 4
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: DIFF
6737: ST_TO_ADDR
// qr := SelectiveQuery ( QML6 , mozn ) ;
6738: LD_ADDR_VAR 0 3
6742: PUSH
6743: LD_STRING QML6
6745: PPUSH
6746: LD_VAR 0 2
6750: PPUSH
6751: CALL_OW 98
6755: ST_TO_ADDR
// end ; if qr in bad then
6756: LD_VAR 0 3
6760: PUSH
6761: LD_VAR 0 5
6765: IN
6766: IFFALSE 6778
// result := false else
6768: LD_ADDR_VAR 0 1
6772: PUSH
6773: LD_INT 0
6775: ST_TO_ADDR
6776: GO 6786
// result := true ;
6778: LD_ADDR_VAR 0 1
6782: PUSH
6783: LD_INT 1
6785: ST_TO_ADDR
// end ;
6786: LD_VAR 0 1
6790: RET
// export function DQrML_Right ( first ) ; begin
6791: LD_INT 0
6793: PPUSH
// DialogueOn ;
6794: CALL_OW 6
// Say ( Tsr , DQrML#Right-Tsr-1 ) ;
6798: LD_LOC 7
6802: PPUSH
6803: LD_STRING DQrML#Right-Tsr-1
6805: PPUSH
6806: CALL_OW 88
// if first then
6810: LD_VAR 0 1
6814: IFFALSE 6830
// Say ( Tsr , DQrML#Right-Tsr-1a ) else
6816: LD_LOC 7
6820: PPUSH
6821: LD_STRING DQrML#Right-Tsr-1a
6823: PPUSH
6824: CALL_OW 88
6828: GO 6842
// Say ( Tsr , DQrML#Right-Tsr-1b ) ;
6830: LD_LOC 7
6834: PPUSH
6835: LD_STRING DQrML#Right-Tsr-1b
6837: PPUSH
6838: CALL_OW 88
// DialogueOff ;
6842: CALL_OW 7
// end ;
6846: LD_VAR 0 2
6850: RET
// export function DQrML_Wrong ; begin
6851: LD_INT 0
6853: PPUSH
// DialogueOn ;
6854: CALL_OW 6
// Say ( Tsr , DQrML#Wrong-Tsr-1 ) ;
6858: LD_LOC 7
6862: PPUSH
6863: LD_STRING DQrML#Wrong-Tsr-1
6865: PPUSH
6866: CALL_OW 88
// DialogueOff ;
6870: CALL_OW 7
// end ;
6874: LD_VAR 0 1
6878: RET
// function DQrML_Gleb ( num ) ; begin
6879: LD_INT 0
6881: PPUSH
// DialogueOn ;
6882: CALL_OW 6
// case num of 1 :
6886: LD_VAR 0 1
6890: PUSH
6891: LD_INT 1
6893: DOUBLE
6894: EQUAL
6895: IFTRUE 6899
6897: GO 6914
6899: POP
// Say ( Glb , DQrML#Gleb-Glb-1 ) ; 2 :
6900: LD_LOC 10
6904: PPUSH
6905: LD_STRING DQrML#Gleb-Glb-1
6907: PPUSH
6908: CALL_OW 88
6912: GO 6961
6914: LD_INT 2
6916: DOUBLE
6917: EQUAL
6918: IFTRUE 6922
6920: GO 6937
6922: POP
// Say ( Glb , DQrML#Gleb-Glb-1a ) ; 3 :
6923: LD_LOC 10
6927: PPUSH
6928: LD_STRING DQrML#Gleb-Glb-1a
6930: PPUSH
6931: CALL_OW 88
6935: GO 6961
6937: LD_INT 3
6939: DOUBLE
6940: EQUAL
6941: IFTRUE 6945
6943: GO 6960
6945: POP
// Say ( Glb , DQrML#Gleb-Glb-1b ) ; end ;
6946: LD_LOC 10
6950: PPUSH
6951: LD_STRING DQrML#Gleb-Glb-1b
6953: PPUSH
6954: CALL_OW 88
6958: GO 6961
6960: POP
// DialogueOff ;
6961: CALL_OW 7
// end ;
6965: LD_VAR 0 2
6969: RET
// export maji_artifact ; every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] do
6970: LD_LOC 2
6974: PPUSH
6975: LD_INT 22
6977: PPUSH
6978: CALL_OW 308
6982: PUSH
6983: LD_EXP 23
6987: PUSH
6988: LD_INT 1
6990: ARRAY
6991: PUSH
6992: LD_EXP 23
6996: PUSH
6997: LD_INT 4
6999: ARRAY
7000: NONEQUAL
7001: AND
7002: IFFALSE 7092
7004: GO 7006
7006: DISABLE
// begin DD_BaseContact ;
7007: CALL 7259 0 0
// if maji_artifact then
7011: LD_EXP 39
7015: IFFALSE 7054
// begin if not ai_s [ 4 ] in your_bases then
7017: LD_EXP 23
7021: PUSH
7022: LD_INT 4
7024: ARRAY
7025: PUSH
7026: LD_EXP 18
7030: IN
7031: NOT
7032: IFFALSE 7052
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7034: LD_EXP 4
7038: PPUSH
7039: LD_EXP 23
7043: PUSH
7044: LD_INT 4
7046: ARRAY
7047: PPUSH
7048: CALL 30389 0 2
// end else
7052: GO 7089
// begin DD_BaseRefuse1st ;
7054: CALL 7307 0 0
// while IsInArea ( Bur , d_base ) do
7058: LD_LOC 2
7062: PPUSH
7063: LD_INT 22
7065: PPUSH
7066: CALL_OW 308
7070: IFFALSE 7081
// wait ( 0 0$1 ) ;
7072: LD_INT 35
7074: PPUSH
7075: CALL_OW 67
7079: GO 7058
// wait ( 0 0$20 ) ;
7081: LD_INT 700
7083: PPUSH
7084: CALL_OW 67
// enable ;
7088: ENABLE
// end ; enable ( 12 ) ;
7089: LD_INT 12
7091: ENABLE_MARKED
// end ;
7092: END
// every 0 0$2 trigger IsInArea ( Bur , d_base ) and ai_s [ 1 ] <> ai_s [ 4 ] marked 12 do
7093: LD_LOC 2
7097: PPUSH
7098: LD_INT 22
7100: PPUSH
7101: CALL_OW 308
7105: PUSH
7106: LD_EXP 23
7110: PUSH
7111: LD_INT 1
7113: ARRAY
7114: PUSH
7115: LD_EXP 23
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: NONEQUAL
7124: AND
7125: IFFALSE 7185
7127: GO 7129
7129: DISABLE
// begin if maji_artifact then
7130: LD_EXP 39
7134: IFFALSE 7173
// begin if not ai_s [ 4 ] in your_bases then
7136: LD_EXP 23
7140: PUSH
7141: LD_INT 4
7143: ARRAY
7144: PUSH
7145: LD_EXP 18
7149: IN
7150: NOT
7151: IFFALSE 7171
// begin SurrenderBase ( t_pay , ai_s [ 4 ] ) end ;
7153: LD_EXP 4
7157: PPUSH
7158: LD_EXP 23
7162: PUSH
7163: LD_INT 4
7165: ARRAY
7166: PPUSH
7167: CALL 30389 0 2
// end else
7171: GO 7185
// begin DD_BaseRefuse ;
7173: CALL 7335 0 0
// wait ( 0 0$20 ) ;
7177: LD_INT 700
7179: PPUSH
7180: CALL_OW 67
// enable ;
7184: ENABLE
// end ; end ;
7185: END
// every 0 0$2 trigger humans [ 4 ] <= 4 and ai_s [ 1 ] <> ai_s [ 4 ] do
7186: LD_EXP 76
7190: PUSH
7191: LD_INT 4
7193: ARRAY
7194: PUSH
7195: LD_INT 4
7197: LESSEQUAL
7198: PUSH
7199: LD_EXP 23
7203: PUSH
7204: LD_INT 1
7206: ARRAY
7207: PUSH
7208: LD_EXP 23
7212: PUSH
7213: LD_INT 4
7215: ARRAY
7216: NONEQUAL
7217: AND
7218: IFFALSE 7258
7220: GO 7222
7222: DISABLE
// begin if not ai_s [ 4 ] in your_bases then
7223: LD_EXP 23
7227: PUSH
7228: LD_INT 4
7230: ARRAY
7231: PUSH
7232: LD_EXP 18
7236: IN
7237: NOT
7238: IFFALSE 7258
// SurrenderBase ( t_killbeat , ai_s [ 4 ] ) ;
7240: LD_EXP 6
7244: PPUSH
7245: LD_EXP 23
7249: PUSH
7250: LD_INT 4
7252: ARRAY
7253: PPUSH
7254: CALL 30389 0 2
// end ;
7258: END
// export kecali_o_artefaktu ; export function DD_BaseContact ; begin
7259: LD_INT 0
7261: PPUSH
// DialogueOn ;
7262: CALL_OW 6
// Say ( Dav , DD-BaseContact-Dav-1 ) ;
7266: LD_LOC 8
7270: PPUSH
7271: LD_STRING DD-BaseContact-Dav-1
7273: PPUSH
7274: CALL_OW 88
// Say ( Bur , DD-BaseContact-Bur-1 ) ;
7278: LD_LOC 2
7282: PPUSH
7283: LD_STRING DD-BaseContact-Bur-1
7285: PPUSH
7286: CALL_OW 88
// kecali_o_artefaktu := true ;
7290: LD_ADDR_EXP 40
7294: PUSH
7295: LD_INT 1
7297: ST_TO_ADDR
// DialogueOff ;
7298: CALL_OW 7
// end ;
7302: LD_VAR 0 1
7306: RET
// export function DD_BaseRefuse1st ; begin
7307: LD_INT 0
7309: PPUSH
// DialogueOn ;
7310: CALL_OW 6
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7314: LD_LOC 8
7318: PPUSH
7319: LD_STRING DD-BaseRefuse-Dav-1
7321: PPUSH
7322: CALL_OW 88
// DialogueOff ;
7326: CALL_OW 7
// end ;
7330: LD_VAR 0 1
7334: RET
// export function DD_BaseRefuse ; begin
7335: LD_INT 0
7337: PPUSH
// Say ( Dav , DD-BaseRefuse-Dav-1 ) ;
7338: LD_LOC 8
7342: PPUSH
7343: LD_STRING DD-BaseRefuse-Dav-1
7345: PPUSH
7346: CALL_OW 88
// end ;
7350: LD_VAR 0 1
7354: RET
// export function DD_BaseAccept ( first ) ; begin
7355: LD_INT 0
7357: PPUSH
// DialogueOn ;
7358: CALL_OW 6
// Say ( Dav , DD-BaseAccept-Dav-1 ) ;
7362: LD_LOC 8
7366: PPUSH
7367: LD_STRING DD-BaseAccept-Dav-1
7369: PPUSH
7370: CALL_OW 88
// if first then
7374: LD_VAR 0 1
7378: IFFALSE 7394
// Say ( Dav , DD-BaseAccept-Dav-1a ) else
7380: LD_LOC 8
7384: PPUSH
7385: LD_STRING DD-BaseAccept-Dav-1a
7387: PPUSH
7388: CALL_OW 88
7392: GO 7406
// Say ( Dav , DD-BaseAccept-Dav-1b ) ;
7394: LD_LOC 8
7398: PPUSH
7399: LD_STRING DD-BaseAccept-Dav-1b
7401: PPUSH
7402: CALL_OW 88
// DialogueOff ;
7406: CALL_OW 7
// end ;
7410: LD_VAR 0 2
7414: RET
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] do
7415: LD_LOC 2
7419: PPUSH
7420: LD_INT 21
7422: PPUSH
7423: CALL_OW 308
7427: PUSH
7428: LD_EXP 23
7432: PUSH
7433: LD_INT 1
7435: ARRAY
7436: PUSH
7437: LD_EXP 23
7441: PUSH
7442: LD_INT 5
7444: ARRAY
7445: NONEQUAL
7446: AND
7447: IFFALSE 7558
7449: GO 7451
7451: DISABLE
// begin DE_BaseContact ;
7452: CALL 7820 0 0
// if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7456: LD_EXP 76
7460: PUSH
7461: LD_INT 5
7463: ARRAY
7464: PPUSH
7465: LD_INT 50
7467: PUSH
7468: EMPTY
7469: LIST
7470: PUSH
7471: EMPTY
7472: LIST
7473: PPUSH
7474: CALL_OW 72
7478: PUSH
7479: LD_INT 6
7481: GREATER
7482: IFFALSE 7523
// begin DE_BaseRefuse1st ;
7484: CALL 7860 0 0
// while IsInArea ( Bur , e_base ) do
7488: LD_LOC 2
7492: PPUSH
7493: LD_INT 21
7495: PPUSH
7496: CALL_OW 308
7500: IFFALSE 7511
// wait ( 0 0$1 ) ;
7502: LD_INT 35
7504: PPUSH
7505: CALL_OW 67
7509: GO 7488
// wait ( 0 0$20 ) ;
7511: LD_INT 700
7513: PPUSH
7514: CALL_OW 67
// enable ( 115 ) ;
7518: LD_INT 115
7520: ENABLE_MARKED
// end else
7521: GO 7558
// if not ai_s [ 5 ] in your_bases then
7523: LD_EXP 23
7527: PUSH
7528: LD_INT 5
7530: ARRAY
7531: PUSH
7532: LD_EXP 18
7536: IN
7537: NOT
7538: IFFALSE 7558
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7540: LD_EXP 5
7544: PPUSH
7545: LD_EXP 23
7549: PUSH
7550: LD_INT 5
7552: ARRAY
7553: PPUSH
7554: CALL 30389 0 2
// end ;
7558: END
// every 0 0$2 trigger IsInArea ( Bur , e_base ) and ai_s [ 1 ] <> ai_s [ 5 ] marked 115 do
7559: LD_LOC 2
7563: PPUSH
7564: LD_INT 21
7566: PPUSH
7567: CALL_OW 308
7571: PUSH
7572: LD_EXP 23
7576: PUSH
7577: LD_INT 1
7579: ARRAY
7580: PUSH
7581: LD_EXP 23
7585: PUSH
7586: LD_INT 5
7588: ARRAY
7589: NONEQUAL
7590: AND
7591: IFFALSE 7659
7593: GO 7595
7595: DISABLE
// begin if UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) > 6 then
7596: LD_EXP 76
7600: PUSH
7601: LD_INT 5
7603: ARRAY
7604: PPUSH
7605: LD_INT 50
7607: PUSH
7608: EMPTY
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: PPUSH
7614: CALL_OW 72
7618: PUSH
7619: LD_INT 6
7621: GREATER
7622: IFFALSE 7658
// begin DE_BaseRefuse ;
7624: CALL 7888 0 0
// while IsInArea ( Bur , e_base ) do
7628: LD_LOC 2
7632: PPUSH
7633: LD_INT 21
7635: PPUSH
7636: CALL_OW 308
7640: IFFALSE 7651
// wait ( 0 0$1 ) ;
7642: LD_INT 35
7644: PPUSH
7645: CALL_OW 67
7649: GO 7628
// wait ( 0 0$20 ) ;
7651: LD_INT 700
7653: PPUSH
7654: CALL_OW 67
// end ; enable ;
7658: ENABLE
// end ;
7659: END
// every 0 0$2 trigger UnitFilter ( humans [ 5 ] , [ [ f_ok ] ] ) <= 6 and ai_s [ 1 ] <> ai_s [ 5 ] do
7660: LD_EXP 76
7664: PUSH
7665: LD_INT 5
7667: ARRAY
7668: PPUSH
7669: LD_INT 50
7671: PUSH
7672: EMPTY
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: PPUSH
7678: CALL_OW 72
7682: PUSH
7683: LD_INT 6
7685: LESSEQUAL
7686: PUSH
7687: LD_EXP 23
7691: PUSH
7692: LD_INT 1
7694: ARRAY
7695: PUSH
7696: LD_EXP 23
7700: PUSH
7701: LD_INT 5
7703: ARRAY
7704: NONEQUAL
7705: AND
7706: IFFALSE 7746
7708: GO 7710
7710: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7711: LD_EXP 23
7715: PUSH
7716: LD_INT 5
7718: ARRAY
7719: PUSH
7720: LD_EXP 18
7724: IN
7725: NOT
7726: IFFALSE 7746
// SurrenderBase ( t_beat , ai_s [ 5 ] ) ;
7728: LD_EXP 5
7732: PPUSH
7733: LD_EXP 23
7737: PUSH
7738: LD_INT 5
7740: ARRAY
7741: PPUSH
7742: CALL 30389 0 2
// end ;
7746: END
// every 0 0$2 trigger humans [ 5 ] <= 4 and ai_s [ 1 ] <> ai_s [ 5 ] do
7747: LD_EXP 76
7751: PUSH
7752: LD_INT 5
7754: ARRAY
7755: PUSH
7756: LD_INT 4
7758: LESSEQUAL
7759: PUSH
7760: LD_EXP 23
7764: PUSH
7765: LD_INT 1
7767: ARRAY
7768: PUSH
7769: LD_EXP 23
7773: PUSH
7774: LD_INT 5
7776: ARRAY
7777: NONEQUAL
7778: AND
7779: IFFALSE 7819
7781: GO 7783
7783: DISABLE
// begin if not ai_s [ 5 ] in your_bases then
7784: LD_EXP 23
7788: PUSH
7789: LD_INT 5
7791: ARRAY
7792: PUSH
7793: LD_EXP 18
7797: IN
7798: NOT
7799: IFFALSE 7819
// SurrenderBase ( t_killbeat , ai_s [ 5 ] ) ;
7801: LD_EXP 6
7805: PPUSH
7806: LD_EXP 23
7810: PUSH
7811: LD_INT 5
7813: ARRAY
7814: PPUSH
7815: CALL 30389 0 2
// end ;
7819: END
// export function DE_BaseContact ; begin
7820: LD_INT 0
7822: PPUSH
// DialogueOn ;
7823: CALL_OW 6
// Say ( Eis , DE-BaseContact-Eis-1 ) ;
7827: LD_LOC 9
7831: PPUSH
7832: LD_STRING DE-BaseContact-Eis-1
7834: PPUSH
7835: CALL_OW 88
// Say ( Bur , DE-BaseContact-Bur-1 ) ;
7839: LD_LOC 2
7843: PPUSH
7844: LD_STRING DE-BaseContact-Bur-1
7846: PPUSH
7847: CALL_OW 88
// DialogueOff ;
7851: CALL_OW 7
// end ;
7855: LD_VAR 0 1
7859: RET
// export function DE_BaseRefuse1st ; begin
7860: LD_INT 0
7862: PPUSH
// DialogueOn ;
7863: CALL_OW 6
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7867: LD_LOC 9
7871: PPUSH
7872: LD_STRING DE-BaseRefuse-Eis-1
7874: PPUSH
7875: CALL_OW 88
// DialogueOff ;
7879: CALL_OW 7
// end ;
7883: LD_VAR 0 1
7887: RET
// export function DE_BaseRefuse ; begin
7888: LD_INT 0
7890: PPUSH
// Say ( Eis , DE-BaseRefuse-Eis-1 ) ;
7891: LD_LOC 9
7895: PPUSH
7896: LD_STRING DE-BaseRefuse-Eis-1
7898: PPUSH
7899: CALL_OW 88
// end ;
7903: LD_VAR 0 1
7907: RET
// export function DE_BaseAccept ( first ) ; begin
7908: LD_INT 0
7910: PPUSH
// DialogueOn ;
7911: CALL_OW 6
// Say ( Eis , DE-BaseAccept-Eis-1 ) ;
7915: LD_LOC 9
7919: PPUSH
7920: LD_STRING DE-BaseAccept-Eis-1
7922: PPUSH
7923: CALL_OW 88
// if first then
7927: LD_VAR 0 1
7931: IFFALSE 7947
// Say ( Eis , DE-BaseAccept-Eis-1a ) else
7933: LD_LOC 9
7937: PPUSH
7938: LD_STRING DE-BaseAccept-Eis-1a
7940: PPUSH
7941: CALL_OW 88
7945: GO 7959
// Say ( Eis , DE-BaseAccept-Eis-1b ) ;
7947: LD_LOC 9
7951: PPUSH
7952: LD_STRING DE-BaseAccept-Eis-1b
7954: PPUSH
7955: CALL_OW 88
// DialogueOff ;
7959: CALL_OW 7
// end ;
7963: LD_VAR 0 2
7967: RET
// export function DXbaseSurrender ( side ) ; var who ; begin
7968: LD_INT 0
7970: PPUSH
7971: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , side , sex_male , 0 , 0 ) ;
7972: LD_ADDR_VAR 0 3
7976: PUSH
7977: LD_INT 21
7979: PUSH
7980: LD_INT 1
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: PUSH
7987: LD_INT 23
7989: PUSH
7990: LD_INT 3
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PPUSH
8001: CALL_OW 69
8005: PUSH
8006: LD_LOC 11
8010: DIFF
8011: PPUSH
8012: LD_VAR 0 1
8016: PPUSH
8017: LD_INT 1
8019: PPUSH
8020: LD_INT 0
8022: PPUSH
8023: LD_INT 0
8025: PPUSH
8026: CALL 10411 0 5
8030: ST_TO_ADDR
// DialogueOn ;
8031: CALL_OW 6
// Say ( who , DXbaseSurrender-Rsol1-1 ) ;
8035: LD_VAR 0 3
8039: PPUSH
8040: LD_STRING DXbaseSurrender-Rsol1-1
8042: PPUSH
8043: CALL_OW 88
// DialogueOff ;
8047: CALL_OW 7
// end ;
8051: LD_VAR 0 2
8055: RET
// export function DRocket ; var who ; begin
8056: LD_INT 0
8058: PPUSH
8059: PPUSH
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , class_scientistic , 0 ) ;
8060: LD_ADDR_VAR 0 2
8064: PUSH
8065: LD_INT 21
8067: PUSH
8068: LD_INT 1
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 23
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: PUSH
8094: LD_LOC 11
8098: DIFF
8099: PPUSH
8100: LD_EXP 7
8104: PPUSH
8105: LD_INT 1
8107: PPUSH
8108: LD_INT 4
8110: PPUSH
8111: LD_INT 0
8113: PPUSH
8114: CALL 10411 0 5
8118: ST_TO_ADDR
// TalkOn ;
8119: CALL 10670 0 0
// Say ( who , DRocket-RSci1-1 ) ;
8123: LD_VAR 0 2
8127: PPUSH
8128: LD_STRING DRocket-RSci1-1
8130: PPUSH
8131: CALL_OW 88
// TalkOff ;
8135: CALL 10686 0 0
// end ;
8139: LD_VAR 0 1
8143: RET
// every 0 0$1 trigger cap_bases >= 4 do
8144: LD_EXP 17
8148: PUSH
8149: LD_INT 4
8151: GREATEREQUAL
8152: IFFALSE 8168
8154: GO 8156
8156: DISABLE
// begin QEnd ;
8157: CALL 8169 0 0
// ChangeMissionObjectives ( MDestroy ) ;
8161: LD_STRING MDestroy
8163: PPUSH
8164: CALL_OW 337
// end ;
8168: END
// export function QEnd ; var qr ; begin
8169: LD_INT 0
8171: PPUSH
8172: PPUSH
// qr := Query ( QKill ) ;
8173: LD_ADDR_VAR 0 2
8177: PUSH
8178: LD_STRING QKill
8180: PPUSH
8181: CALL_OW 97
8185: ST_TO_ADDR
// end ;
8186: LD_VAR 0 1
8190: RET
// export function DEnd ; var who ; begin
8191: LD_INT 0
8193: PPUSH
8194: PPUSH
// who := Gla ;
8195: LD_ADDR_VAR 0 2
8199: PUSH
8200: LD_LOC 1
8204: ST_TO_ADDR
// if not IsOk ( Gla ) then
8205: LD_LOC 1
8209: PPUSH
8210: CALL_OW 302
8214: NOT
8215: IFFALSE 8276
// who := WhoSayAny ( FilterAllUnits ( [ [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) diff talking , you , sex_male , 0 , 0 ) ;
8217: LD_ADDR_VAR 0 2
8221: PUSH
8222: LD_INT 21
8224: PUSH
8225: LD_INT 1
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 23
8234: PUSH
8235: LD_INT 3
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: PUSH
8242: EMPTY
8243: LIST
8244: LIST
8245: PPUSH
8246: CALL_OW 69
8250: PUSH
8251: LD_LOC 11
8255: DIFF
8256: PPUSH
8257: LD_EXP 7
8261: PPUSH
8262: LD_INT 1
8264: PPUSH
8265: LD_INT 0
8267: PPUSH
8268: LD_INT 0
8270: PPUSH
8271: CALL 10411 0 5
8275: ST_TO_ADDR
// DialogueOn ;
8276: CALL_OW 6
// Say ( Bur , DEnd-Bur-1 ) ;
8280: LD_LOC 2
8284: PPUSH
8285: LD_STRING DEnd-Bur-1
8287: PPUSH
8288: CALL_OW 88
// if Say ( who , DEnd-Gla-1 ) then
8292: LD_VAR 0 2
8296: PPUSH
8297: LD_STRING DEnd-Gla-1
8299: PPUSH
8300: CALL_OW 88
8304: IFFALSE 8318
// Say ( Bur , DEnd-Bur-2 ) ;
8306: LD_LOC 2
8310: PPUSH
8311: LD_STRING DEnd-Bur-2
8313: PPUSH
8314: CALL_OW 88
// Say ( Bur , DEnd-Bur-2a ) ;
8318: LD_LOC 2
8322: PPUSH
8323: LD_STRING DEnd-Bur-2a
8325: PPUSH
8326: CALL_OW 88
// DialogueOff ;
8330: CALL_OW 7
// end ; end_of_file
8334: LD_VAR 0 1
8338: RET
// export Burlak , Platonov , Gossudarov , Gladkov , Fadeev , Borodin , Tsaritsyn , Davidov , Eisenstein , Gleb ; var masha_def , masha ; var used ; export function Load ; var i ; begin
8339: LD_INT 0
8341: PPUSH
8342: PPUSH
// Masha := LoadVariable ( Masha , [ ] ) ;
8343: LD_ADDR_LOC 14
8347: PUSH
8348: LD_STRING Masha
8350: PPUSH
8351: EMPTY
8352: PPUSH
8353: CALL_OW 30
8357: ST_TO_ADDR
// InitUc ;
8358: CALL_OW 18
// InitHc ;
8362: CALL_OW 19
// uc_nation := nation_russian ;
8366: LD_ADDR_OWVAR 21
8370: PUSH
8371: LD_INT 3
8373: ST_TO_ADDR
// uc_side := ai_s [ 1 ] ;
8374: LD_ADDR_OWVAR 20
8378: PUSH
8379: LD_EXP 23
8383: PUSH
8384: LD_INT 1
8386: ARRAY
8387: ST_TO_ADDR
// Platonov := MyCreateCharacter ( Platonov , class_soldier , true ) ;
8388: LD_ADDR_EXP 42
8392: PUSH
8393: LD_STRING Platonov
8395: PPUSH
8396: LD_INT 1
8398: PPUSH
8399: LD_INT 1
8401: PPUSH
8402: CALL 9003 0 3
8406: ST_TO_ADDR
// Gossudarov := MyCreateCharacter ( Gossudarov , class_scientistic , false ) ;
8407: LD_ADDR_EXP 43
8411: PUSH
8412: LD_STRING Gossudarov
8414: PPUSH
8415: LD_INT 4
8417: PPUSH
8418: LD_INT 0
8420: PPUSH
8421: CALL 9003 0 3
8425: ST_TO_ADDR
// SetSkill ( Gossudarov , skill_mechanical , gossudarov_mech_skill ) ;
8426: LD_EXP 43
8430: PPUSH
8431: LD_INT 3
8433: PPUSH
8434: LD_EXP 16
8438: PPUSH
8439: CALL_OW 237
// uc_side := ai_s [ 2 ] ;
8443: LD_ADDR_OWVAR 20
8447: PUSH
8448: LD_EXP 23
8452: PUSH
8453: LD_INT 2
8455: ARRAY
8456: ST_TO_ADDR
// Borodin := MyCreateCharacter ( Borodin , 0 , true ) ;
8457: LD_ADDR_EXP 46
8461: PUSH
8462: LD_STRING Borodin
8464: PPUSH
8465: LD_INT 0
8467: PPUSH
8468: LD_INT 1
8470: PPUSH
8471: CALL 9003 0 3
8475: ST_TO_ADDR
// uc_side := ai_s [ 3 ] ;
8476: LD_ADDR_OWVAR 20
8480: PUSH
8481: LD_EXP 23
8485: PUSH
8486: LD_INT 3
8488: ARRAY
8489: ST_TO_ADDR
// Tsaritsyn := MyCreateCharacter ( Tsaritsyn , 0 , true ) ;
8490: LD_ADDR_EXP 47
8494: PUSH
8495: LD_STRING Tsaritsyn
8497: PPUSH
8498: LD_INT 0
8500: PPUSH
8501: LD_INT 1
8503: PPUSH
8504: CALL 9003 0 3
8508: ST_TO_ADDR
// uc_side := ai_s [ 4 ] ;
8509: LD_ADDR_OWVAR 20
8513: PUSH
8514: LD_EXP 23
8518: PUSH
8519: LD_INT 4
8521: ARRAY
8522: ST_TO_ADDR
// Davidov := MyCreateCharacter ( Davidov , class_scientistic , true ) ;
8523: LD_ADDR_EXP 48
8527: PUSH
8528: LD_STRING Davidov
8530: PPUSH
8531: LD_INT 4
8533: PPUSH
8534: LD_INT 1
8536: PPUSH
8537: CALL 9003 0 3
8541: ST_TO_ADDR
// uc_side := ai_s [ 5 ] ;
8542: LD_ADDR_OWVAR 20
8546: PUSH
8547: LD_EXP 23
8551: PUSH
8552: LD_INT 5
8554: ARRAY
8555: ST_TO_ADDR
// Eisenstein := MyCreateCharacter ( Eisenstein , 0 , true ) ;
8556: LD_ADDR_EXP 49
8560: PUSH
8561: LD_STRING Eisenstein
8563: PPUSH
8564: LD_INT 0
8566: PPUSH
8567: LD_INT 1
8569: PPUSH
8570: CALL 9003 0 3
8574: ST_TO_ADDR
// uc_side := you ;
8575: LD_ADDR_OWVAR 20
8579: PUSH
8580: LD_EXP 7
8584: ST_TO_ADDR
// Burlak := MyCreateCharacter ( Burlak , class_mechanic , false ) ;
8585: LD_ADDR_EXP 41
8589: PUSH
8590: LD_STRING Burlak
8592: PPUSH
8593: LD_INT 3
8595: PPUSH
8596: LD_INT 0
8598: PPUSH
8599: CALL 9003 0 3
8603: ST_TO_ADDR
// Gladkov := MyCreateCharacter ( Gladkov , 0 , true ) ;
8604: LD_ADDR_EXP 44
8608: PUSH
8609: LD_STRING Gladkov
8611: PPUSH
8612: LD_INT 0
8614: PPUSH
8615: LD_INT 1
8617: PPUSH
8618: CALL 9003 0 3
8622: ST_TO_ADDR
// Fadeev := MyCreateCharacter ( Fadeev , 0 , true ) ;
8623: LD_ADDR_EXP 45
8627: PUSH
8628: LD_STRING Fadeev
8630: PPUSH
8631: LD_INT 0
8633: PPUSH
8634: LD_INT 1
8636: PPUSH
8637: CALL 9003 0 3
8641: ST_TO_ADDR
// Gleb := MyCreateCharacter ( Gleb , class_soldier , false ) ;
8642: LD_ADDR_EXP 50
8646: PUSH
8647: LD_STRING Gleb
8649: PPUSH
8650: LD_INT 1
8652: PPUSH
8653: LD_INT 0
8655: PPUSH
8656: CALL 9003 0 3
8660: ST_TO_ADDR
// masha_def := LoadVariable ( Masha , [ ] ) ;
8661: LD_ADDR_LOC 13
8665: PUSH
8666: LD_STRING Masha
8668: PPUSH
8669: EMPTY
8670: PPUSH
8671: CALL_OW 30
8675: ST_TO_ADDR
// if masha_def then
8676: LD_LOC 13
8680: IFFALSE 8752
// begin InitVc ;
8682: CALL_OW 20
// vc_chassis := masha_def [ 1 ] ;
8686: LD_ADDR_OWVAR 37
8690: PUSH
8691: LD_LOC 13
8695: PUSH
8696: LD_INT 1
8698: ARRAY
8699: ST_TO_ADDR
// vc_engine := masha_def [ 2 ] ;
8700: LD_ADDR_OWVAR 39
8704: PUSH
8705: LD_LOC 13
8709: PUSH
8710: LD_INT 2
8712: ARRAY
8713: ST_TO_ADDR
// vc_control := masha_def [ 3 ] ;
8714: LD_ADDR_OWVAR 38
8718: PUSH
8719: LD_LOC 13
8723: PUSH
8724: LD_INT 3
8726: ARRAY
8727: ST_TO_ADDR
// vc_weapon := masha_def [ 4 ] ;
8728: LD_ADDR_OWVAR 40
8732: PUSH
8733: LD_LOC 13
8737: PUSH
8738: LD_INT 4
8740: ARRAY
8741: ST_TO_ADDR
// masha := CreateVehicle ;
8742: LD_ADDR_LOC 14
8746: PUSH
8747: CALL_OW 45
8751: ST_TO_ADDR
// end ; used := [ ] ;
8752: LD_ADDR_LOC 15
8756: PUSH
8757: EMPTY
8758: ST_TO_ADDR
// used := [ Gleb ] diff 0 ;
8759: LD_ADDR_LOC 15
8763: PUSH
8764: LD_EXP 50
8768: PUSH
8769: EMPTY
8770: LIST
8771: PUSH
8772: LD_INT 0
8774: DIFF
8775: ST_TO_ADDR
// used := used ^ [ Fadeev , Gladkov ] ;
8776: LD_ADDR_LOC 15
8780: PUSH
8781: LD_LOC 15
8785: PUSH
8786: LD_EXP 45
8790: PUSH
8791: LD_EXP 44
8795: PUSH
8796: EMPTY
8797: LIST
8798: LIST
8799: ADD
8800: ST_TO_ADDR
// for i := used + 1 to 3 do
8801: LD_ADDR_VAR 0 2
8805: PUSH
8806: DOUBLE
8807: LD_LOC 15
8811: PUSH
8812: LD_INT 1
8814: PLUS
8815: DEC
8816: ST_TO_ADDR
8817: LD_INT 3
8819: PUSH
8820: FOR_TO
8821: IFFALSE 8854
// begin PrepareSoldier ( sex_male , 6 ) ;
8823: LD_INT 1
8825: PPUSH
8826: LD_INT 6
8828: PPUSH
8829: CALL_OW 381
// used := used ^ [ CreateHuman ] ;
8833: LD_ADDR_LOC 15
8837: PUSH
8838: LD_LOC 15
8842: PUSH
8843: CALL_OW 44
8847: PUSH
8848: EMPTY
8849: LIST
8850: ADD
8851: ST_TO_ADDR
// end ;
8852: GO 8820
8854: POP
8855: POP
// used := used ^ [ Burlak ] ;
8856: LD_ADDR_LOC 15
8860: PUSH
8861: LD_LOC 15
8865: PUSH
8866: LD_EXP 41
8870: PUSH
8871: EMPTY
8872: LIST
8873: ADD
8874: ST_TO_ADDR
// end ;
8875: LD_VAR 0 1
8879: RET
// export function place_ru ; var i ; begin
8880: LD_INT 0
8882: PPUSH
8883: PPUSH
// for i in used diff burlak do
8884: LD_ADDR_VAR 0 2
8888: PUSH
8889: LD_LOC 15
8893: PUSH
8894: LD_EXP 41
8898: DIFF
8899: PUSH
8900: FOR_IN
8901: IFFALSE 8920
// PlaceUnitArea ( i , ru_place , false ) ;
8903: LD_VAR 0 2
8907: PPUSH
8908: LD_INT 6
8910: PPUSH
8911: LD_INT 0
8913: PPUSH
8914: CALL_OW 49
8918: GO 8900
8920: POP
8921: POP
// if masha then
8922: LD_LOC 14
8926: IFFALSE 8983
// begin SetMark ( masha , 1 ) ;
8928: LD_LOC 14
8932: PPUSH
8933: LD_INT 1
8935: PPUSH
8936: CALL_OW 242
// PlaceHumanInUnit ( Burlak , masha ) ;
8940: LD_EXP 41
8944: PPUSH
8945: LD_LOC 14
8949: PPUSH
8950: CALL_OW 52
// PlaceUnitArea ( masha , ru_place , false ) ;
8954: LD_LOC 14
8958: PPUSH
8959: LD_INT 6
8961: PPUSH
8962: LD_INT 0
8964: PPUSH
8965: CALL_OW 49
// SetMark ( masha , 1 ) ;
8969: LD_LOC 14
8973: PPUSH
8974: LD_INT 1
8976: PPUSH
8977: CALL_OW 242
// end else
8981: GO 8998
// PlaceUnitArea ( Burlak , ru_place , false ) ;
8983: LD_EXP 41
8987: PPUSH
8988: LD_INT 6
8990: PPUSH
8991: LD_INT 0
8993: PPUSH
8994: CALL_OW 49
// end ;
8998: LD_VAR 0 1
9002: RET
// function MyCreateCharacter ( name , unclass , new ) ; begin
9003: LD_INT 0
9005: PPUSH
// if ( new and NewCharacter ( name ) ) or TestCharacters ( name ) then
9006: LD_VAR 0 3
9010: PUSH
9011: LD_VAR 0 1
9015: PPUSH
9016: CALL_OW 25
9020: AND
9021: PUSH
9022: LD_VAR 0 1
9026: PPUSH
9027: CALL_OW 28
9031: OR
9032: IFFALSE 9115
// begin if new then
9034: LD_VAR 0 3
9038: IFFALSE 9057
// result := NewCharacter ( name ) else
9040: LD_ADDR_VAR 0 4
9044: PUSH
9045: LD_VAR 0 1
9049: PPUSH
9050: CALL_OW 25
9054: ST_TO_ADDR
9055: GO 9093
// begin if CheckCharacterSet ( name ) then
9057: LD_VAR 0 1
9061: PPUSH
9062: CALL_OW 29
9066: IFFALSE 9085
// result := CreateCharacter ( name ) else
9068: LD_ADDR_VAR 0 4
9072: PUSH
9073: LD_VAR 0 1
9077: PPUSH
9078: CALL_OW 34
9082: ST_TO_ADDR
9083: GO 9093
// result := 0 ;
9085: LD_ADDR_VAR 0 4
9089: PUSH
9090: LD_INT 0
9092: ST_TO_ADDR
// end ; if unclass then
9093: LD_VAR 0 2
9097: IFFALSE 9113
// SetClass ( result , unclass ) ;
9099: LD_VAR 0 4
9103: PPUSH
9104: LD_VAR 0 2
9108: PPUSH
9109: CALL_OW 336
// end else
9113: GO 9181
// begin Msg ( Chybi  & name & ! ) ;
9115: LD_STRING Chybi 
9117: PUSH
9118: LD_VAR 0 1
9122: STR
9123: PUSH
9124: LD_STRING !
9126: STR
9127: PPUSH
9128: CALL_OW 100
// hc_name := name ;
9132: LD_ADDR_OWVAR 26
9136: PUSH
9137: LD_VAR 0 1
9141: ST_TO_ADDR
// PrepareHuman ( sex_male , 0 , 3 ) ;
9142: LD_INT 1
9144: PPUSH
9145: LD_INT 0
9147: PPUSH
9148: LD_INT 3
9150: PPUSH
9151: CALL_OW 380
// if unclass then
9155: LD_VAR 0 2
9159: IFFALSE 9171
// hc_class := unclass ;
9161: LD_ADDR_OWVAR 28
9165: PUSH
9166: LD_VAR 0 2
9170: ST_TO_ADDR
// result := CreateHuman ;
9171: LD_ADDR_VAR 0 4
9175: PUSH
9176: CALL_OW 44
9180: ST_TO_ADDR
// end ; end ;
9181: LD_VAR 0 4
9185: RET
// export function Save ; var tmp , Bluekher , t ; begin
9186: LD_INT 0
9188: PPUSH
9189: PPUSH
9190: PPUSH
9191: PPUSH
// SaveCharacters ( Burlak , Burlak ) ;
9192: LD_EXP 41
9196: PPUSH
9197: LD_STRING Burlak
9199: PPUSH
9200: CALL_OW 38
// SaveCharacters ( Gladkov , Gladkov ) ;
9204: LD_EXP 44
9208: PPUSH
9209: LD_STRING Gladkov
9211: PPUSH
9212: CALL_OW 38
// SaveCharacters ( Fadeev , Fadeev ) ;
9216: LD_EXP 45
9220: PPUSH
9221: LD_STRING Fadeev
9223: PPUSH
9224: CALL_OW 38
// DeleteCharacters ( Platonov ) ;
9228: LD_STRING Platonov
9230: PPUSH
9231: CALL_OW 40
// SaveVariable ( not IsLive ( Platonov ) , PlatonovKilled ) ;
9235: LD_EXP 42
9239: PPUSH
9240: CALL_OW 300
9244: NOT
9245: PPUSH
9246: LD_STRING PlatonovKilled
9248: PPUSH
9249: CALL_OW 39
// SaveVariable ( BehemothSeen , BehemothSeen ) ;
9253: LD_EXP 29
9257: PPUSH
9258: LD_STRING BehemothSeen
9260: PPUSH
9261: CALL_OW 39
// if IsDead ( masha ) then
9265: LD_LOC 14
9269: PPUSH
9270: CALL_OW 301
9274: IFFALSE 9283
// DeleteVariable ( Masha ) ;
9276: LD_STRING Masha
9278: PPUSH
9279: CALL_OW 41
// SaveCharacters ( Borodin , Borodin ) ;
9283: LD_EXP 46
9287: PPUSH
9288: LD_STRING Borodin
9290: PPUSH
9291: CALL_OW 38
// SaveCharacters ( Tsaritsyn , Tsaritsyn ) ;
9295: LD_EXP 47
9299: PPUSH
9300: LD_STRING Tsaritsyn
9302: PPUSH
9303: CALL_OW 38
// SaveCharacters ( Davidov , Davidov ) ;
9307: LD_EXP 48
9311: PPUSH
9312: LD_STRING Davidov
9314: PPUSH
9315: CALL_OW 38
// SaveCharacters ( Eisenstein , Eisenstein ) ;
9319: LD_EXP 49
9323: PPUSH
9324: LD_STRING Eisenstein
9326: PPUSH
9327: CALL_OW 38
// if Gleb then
9331: LD_EXP 50
9335: IFFALSE 9349
// SaveCharacters ( Gleb , Gleb ) ;
9337: LD_EXP 50
9341: PPUSH
9342: LD_STRING Gleb
9344: PPUSH
9345: CALL_OW 38
// DeleteCharacters ( Gossudarov ) ;
9349: LD_STRING Gossudarov
9351: PPUSH
9352: CALL_OW 40
// tmp := FilterUnitsInArea ( Bluekher_area , [ [ f_type , unit_building ] ] ) ;
9356: LD_ADDR_VAR 0 2
9360: PUSH
9361: LD_INT 18
9363: PPUSH
9364: LD_INT 21
9366: PUSH
9367: LD_INT 3
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PUSH
9374: EMPTY
9375: LIST
9376: PPUSH
9377: CALL_OW 70
9381: ST_TO_ADDR
// Bluekher := [ ] ;
9382: LD_ADDR_VAR 0 3
9386: PUSH
9387: EMPTY
9388: ST_TO_ADDR
// for t in tmp do
9389: LD_ADDR_VAR 0 4
9393: PUSH
9394: LD_VAR 0 2
9398: PUSH
9399: FOR_IN
9400: IFFALSE 9787
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
9402: LD_VAR 0 4
9406: PPUSH
9407: CALL_OW 266
9411: PUSH
9412: LD_INT 9
9414: DOUBLE
9415: EQUAL
9416: IFTRUE 9456
9418: LD_INT 10
9420: DOUBLE
9421: EQUAL
9422: IFTRUE 9456
9424: LD_INT 13
9426: DOUBLE
9427: EQUAL
9428: IFTRUE 9456
9430: LD_INT 12
9432: DOUBLE
9433: EQUAL
9434: IFTRUE 9456
9436: LD_INT 15
9438: DOUBLE
9439: EQUAL
9440: IFTRUE 9456
9442: LD_INT 11
9444: DOUBLE
9445: EQUAL
9446: IFTRUE 9456
9448: LD_INT 14
9450: DOUBLE
9451: EQUAL
9452: IFTRUE 9456
9454: GO 9459
9456: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
9457: GO 9785
9459: LD_INT 6
9461: DOUBLE
9462: EQUAL
9463: IFTRUE 9479
9465: LD_INT 7
9467: DOUBLE
9468: EQUAL
9469: IFTRUE 9479
9471: LD_INT 8
9473: DOUBLE
9474: EQUAL
9475: IFTRUE 9479
9477: GO 9592
9479: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , getlabkind ( t , 1 ) , getlabkind ( t , 2 ) ] ] ; b_bunker , b_turret :
9480: LD_ADDR_VAR 0 3
9484: PUSH
9485: LD_VAR 0 3
9489: PUSH
9490: LD_VAR 0 4
9494: PPUSH
9495: CALL_OW 250
9499: PUSH
9500: LD_VAR 0 4
9504: PPUSH
9505: CALL_OW 251
9509: PUSH
9510: LD_VAR 0 4
9514: PPUSH
9515: CALL_OW 254
9519: PUSH
9520: LD_VAR 0 4
9524: PPUSH
9525: CALL_OW 266
9529: PUSH
9530: LD_VAR 0 4
9534: PPUSH
9535: CALL_OW 267
9539: PUSH
9540: LD_VAR 0 4
9544: PPUSH
9545: CALL_OW 248
9549: PUSH
9550: LD_VAR 0 4
9554: PPUSH
9555: LD_INT 1
9557: PPUSH
9558: CALL_OW 268
9562: PUSH
9563: LD_VAR 0 4
9567: PPUSH
9568: LD_INT 2
9570: PPUSH
9571: CALL_OW 268
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: EMPTY
9587: LIST
9588: ADD
9589: ST_TO_ADDR
9590: GO 9785
9592: LD_INT 32
9594: DOUBLE
9595: EQUAL
9596: IFTRUE 9606
9598: LD_INT 33
9600: DOUBLE
9601: EQUAL
9602: IFTRUE 9606
9604: GO 9702
9606: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) , GetWeapon ( t ) ] ] ; else
9607: LD_ADDR_VAR 0 3
9611: PUSH
9612: LD_VAR 0 3
9616: PUSH
9617: LD_VAR 0 4
9621: PPUSH
9622: CALL_OW 250
9626: PUSH
9627: LD_VAR 0 4
9631: PPUSH
9632: CALL_OW 251
9636: PUSH
9637: LD_VAR 0 4
9641: PPUSH
9642: CALL_OW 254
9646: PUSH
9647: LD_VAR 0 4
9651: PPUSH
9652: CALL_OW 266
9656: PUSH
9657: LD_VAR 0 4
9661: PPUSH
9662: CALL_OW 267
9666: PUSH
9667: LD_VAR 0 4
9671: PPUSH
9672: CALL_OW 248
9676: PUSH
9677: LD_VAR 0 4
9681: PPUSH
9682: CALL_OW 264
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: PUSH
9696: EMPTY
9697: LIST
9698: ADD
9699: ST_TO_ADDR
9700: GO 9785
9702: POP
// Bluekher := Bluekher ^ [ [ getx ( t ) , gety ( t ) , getdir ( t ) , getbtype ( t ) , getblevel ( t ) , GetNation ( t ) ] ] ; end ;
9703: LD_ADDR_VAR 0 3
9707: PUSH
9708: LD_VAR 0 3
9712: PUSH
9713: LD_VAR 0 4
9717: PPUSH
9718: CALL_OW 250
9722: PUSH
9723: LD_VAR 0 4
9727: PPUSH
9728: CALL_OW 251
9732: PUSH
9733: LD_VAR 0 4
9737: PPUSH
9738: CALL_OW 254
9742: PUSH
9743: LD_VAR 0 4
9747: PPUSH
9748: CALL_OW 266
9752: PUSH
9753: LD_VAR 0 4
9757: PPUSH
9758: CALL_OW 267
9762: PUSH
9763: LD_VAR 0 4
9767: PPUSH
9768: CALL_OW 248
9772: PUSH
9773: EMPTY
9774: LIST
9775: LIST
9776: LIST
9777: LIST
9778: LIST
9779: LIST
9780: PUSH
9781: EMPTY
9782: LIST
9783: ADD
9784: ST_TO_ADDR
// end ;
9785: GO 9399
9787: POP
9788: POP
// SaveVariable ( Bluekher , Bluekher ) ;
9789: LD_VAR 0 3
9793: PPUSH
9794: LD_STRING Bluekher
9796: PPUSH
9797: CALL_OW 39
// if CheckCharacterSet ( survivors3 ) then
9801: LD_STRING survivors3
9803: PPUSH
9804: CALL_OW 29
9808: IFFALSE 9835
// begin tmp = CreateCharacterSet ( survivors3 ) ;
9810: LD_ADDR_VAR 0 2
9814: PUSH
9815: LD_STRING survivors3
9817: PPUSH
9818: CALL_OW 31
9822: ST_TO_ADDR
// SaveCharacters ( tmp , survivors4 ) ;
9823: LD_VAR 0 2
9827: PPUSH
9828: LD_STRING survivors4
9830: PPUSH
9831: CALL_OW 38
// end ; end ; end_of_file
9835: LD_VAR 0 1
9839: RET
// export mf_sol ; export mf_eng ; export mf_mec ; export mf_sci ; export mf_lab ; export mf_fort ; export mf_bunk ; export mf_dep ; export mf_fact ; export mf_comp ; export mf_manu ; export function inicializace_functions ; begin
9840: LD_INT 0
9842: PPUSH
// mf_sol := [ f_class , class_soldier ] ;
9843: LD_ADDR_EXP 51
9847: PUSH
9848: LD_INT 25
9850: PUSH
9851: LD_INT 1
9853: PUSH
9854: EMPTY
9855: LIST
9856: LIST
9857: ST_TO_ADDR
// mf_eng := [ f_class , class_engineer ] ;
9858: LD_ADDR_EXP 52
9862: PUSH
9863: LD_INT 25
9865: PUSH
9866: LD_INT 2
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: ST_TO_ADDR
// mf_mec := [ f_class , class_mechanic ] ;
9873: LD_ADDR_EXP 53
9877: PUSH
9878: LD_INT 25
9880: PUSH
9881: LD_INT 3
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: ST_TO_ADDR
// mf_sci := [ f_class , class_scientistic ] ;
9888: LD_ADDR_EXP 54
9892: PUSH
9893: LD_INT 25
9895: PUSH
9896: LD_INT 4
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: ST_TO_ADDR
// mf_lab := [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ;
9903: LD_ADDR_EXP 55
9907: PUSH
9908: LD_INT 2
9910: PUSH
9911: LD_INT 30
9913: PUSH
9914: LD_INT 6
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: PUSH
9921: LD_INT 30
9923: PUSH
9924: LD_INT 7
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PUSH
9931: LD_INT 30
9933: PUSH
9934: LD_INT 8
9936: PUSH
9937: EMPTY
9938: LIST
9939: LIST
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: LIST
9946: ST_TO_ADDR
// mf_fort := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ;
9947: LD_ADDR_EXP 56
9951: PUSH
9952: LD_INT 2
9954: PUSH
9955: LD_INT 30
9957: PUSH
9958: LD_INT 32
9960: PUSH
9961: EMPTY
9962: LIST
9963: LIST
9964: PUSH
9965: LD_INT 30
9967: PUSH
9968: LD_INT 31
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: PUSH
9975: LD_INT 30
9977: PUSH
9978: LD_INT 4
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PUSH
9985: LD_INT 30
9987: PUSH
9988: LD_INT 5
9990: PUSH
9991: EMPTY
9992: LIST
9993: LIST
9994: PUSH
9995: EMPTY
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: LIST
10001: ST_TO_ADDR
// mf_bunk := [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ;
10002: LD_ADDR_EXP 57
10006: PUSH
10007: LD_INT 2
10009: PUSH
10010: LD_INT 30
10012: PUSH
10013: LD_INT 32
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PUSH
10020: LD_INT 30
10022: PUSH
10023: LD_INT 31
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: PUSH
10030: EMPTY
10031: LIST
10032: LIST
10033: LIST
10034: ST_TO_ADDR
// mf_dep := [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ;
10035: LD_ADDR_EXP 58
10039: PUSH
10040: LD_INT 2
10042: PUSH
10043: LD_INT 30
10045: PUSH
10046: LD_INT 0
10048: PUSH
10049: EMPTY
10050: LIST
10051: LIST
10052: PUSH
10053: LD_INT 30
10055: PUSH
10056: LD_INT 1
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: PUSH
10063: EMPTY
10064: LIST
10065: LIST
10066: LIST
10067: ST_TO_ADDR
// mf_fact := [ f_or , [ f_btype , b_factory ] , [ f_btype , b_workshop ] ] ;
10068: LD_ADDR_EXP 59
10072: PUSH
10073: LD_INT 2
10075: PUSH
10076: LD_INT 30
10078: PUSH
10079: LD_INT 3
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: PUSH
10086: LD_INT 30
10088: PUSH
10089: LD_INT 2
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: ST_TO_ADDR
// mf_comp := [ f_control , control_computer ] ;
10101: LD_ADDR_EXP 60
10105: PUSH
10106: LD_INT 33
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: ST_TO_ADDR
// mf_manu := [ f_control , control_manual ] ;
10116: LD_ADDR_EXP 61
10120: PUSH
10121: LD_INT 33
10123: PUSH
10124: LD_INT 1
10126: PUSH
10127: EMPTY
10128: LIST
10129: LIST
10130: ST_TO_ADDR
// end ;
10131: LD_VAR 0 1
10135: RET
// export function get_x_best ( lidi , num , skill , mclass , idle ) ; var i , skills ; begin
10136: LD_INT 0
10138: PPUSH
10139: PPUSH
10140: PPUSH
// if mclass then
10141: LD_VAR 0 4
10145: IFFALSE 10177
// lidi := UnitFilter ( lidi , [ [ f_class , mclass ] ] ) ;
10147: LD_ADDR_VAR 0 1
10151: PUSH
10152: LD_VAR 0 1
10156: PPUSH
10157: LD_INT 25
10159: PUSH
10160: LD_VAR 0 4
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: PUSH
10169: EMPTY
10170: LIST
10171: PPUSH
10172: CALL_OW 72
10176: ST_TO_ADDR
// skills := [ ] ;
10177: LD_ADDR_VAR 0 8
10181: PUSH
10182: EMPTY
10183: ST_TO_ADDR
// for i in lidi do
10184: LD_ADDR_VAR 0 7
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: FOR_IN
10195: IFFALSE 10228
// skills := skills ^ [ GetSkill ( i , skill ) ] ;
10197: LD_ADDR_VAR 0 8
10201: PUSH
10202: LD_VAR 0 8
10206: PUSH
10207: LD_VAR 0 7
10211: PPUSH
10212: LD_VAR 0 3
10216: PPUSH
10217: CALL_OW 259
10221: PUSH
10222: EMPTY
10223: LIST
10224: ADD
10225: ST_TO_ADDR
10226: GO 10194
10228: POP
10229: POP
// lidi := SortListByListDesc ( lidi , skills ) ;
10230: LD_ADDR_VAR 0 1
10234: PUSH
10235: LD_VAR 0 1
10239: PPUSH
10240: LD_VAR 0 8
10244: PPUSH
10245: CALL_OW 77
10249: ST_TO_ADDR
// if num > lidi then
10250: LD_VAR 0 2
10254: PUSH
10255: LD_VAR 0 1
10259: GREATER
10260: IFFALSE 10276
// num := lidi + 0 ;
10262: LD_ADDR_VAR 0 2
10266: PUSH
10267: LD_VAR 0 1
10271: PUSH
10272: LD_INT 0
10274: PLUS
10275: ST_TO_ADDR
// i := 1 ;
10276: LD_ADDR_VAR 0 7
10280: PUSH
10281: LD_INT 1
10283: ST_TO_ADDR
// result := [ ] ;
10284: LD_ADDR_VAR 0 6
10288: PUSH
10289: EMPTY
10290: ST_TO_ADDR
// while i <= lidi and result < num do
10291: LD_VAR 0 7
10295: PUSH
10296: LD_VAR 0 1
10300: LESSEQUAL
10301: PUSH
10302: LD_VAR 0 6
10306: PUSH
10307: LD_VAR 0 2
10311: LESS
10312: AND
10313: IFFALSE 10406
// begin if idle then
10315: LD_VAR 0 5
10319: IFFALSE 10365
// begin if IsIdle ( lidi [ i ] ) then
10321: LD_VAR 0 1
10325: PUSH
10326: LD_VAR 0 7
10330: ARRAY
10331: PPUSH
10332: CALL_OW 316
10336: IFFALSE 10363
// result := result ^ [ lidi [ i ] ] ;
10338: LD_ADDR_VAR 0 6
10342: PUSH
10343: LD_VAR 0 6
10347: PUSH
10348: LD_VAR 0 1
10352: PUSH
10353: LD_VAR 0 7
10357: ARRAY
10358: PUSH
10359: EMPTY
10360: LIST
10361: ADD
10362: ST_TO_ADDR
// end else
10363: GO 10390
// result := result ^ [ lidi [ i ] ] ;
10365: LD_ADDR_VAR 0 6
10369: PUSH
10370: LD_VAR 0 6
10374: PUSH
10375: LD_VAR 0 1
10379: PUSH
10380: LD_VAR 0 7
10384: ARRAY
10385: PUSH
10386: EMPTY
10387: LIST
10388: ADD
10389: ST_TO_ADDR
// i := i + 1 ;
10390: LD_ADDR_VAR 0 7
10394: PUSH
10395: LD_VAR 0 7
10399: PUSH
10400: LD_INT 1
10402: PLUS
10403: ST_TO_ADDR
// end ;
10404: GO 10291
// end ;
10406: LD_VAR 0 6
10410: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
10411: LD_INT 0
10413: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
10414: LD_ADDR_VAR 0 1
10418: PUSH
10419: LD_VAR 0 1
10423: PPUSH
10424: LD_INT 21
10426: PUSH
10427: LD_INT 1
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 22
10436: PUSH
10437: LD_VAR 0 2
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: LD_INT 23
10451: PUSH
10452: LD_INT 0
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PPUSH
10465: CALL_OW 72
10469: ST_TO_ADDR
// if sex <> 0 then
10470: LD_VAR 0 3
10474: PUSH
10475: LD_INT 0
10477: NONEQUAL
10478: IFFALSE 10507
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
10480: LD_ADDR_VAR 0 1
10484: PUSH
10485: LD_VAR 0 1
10489: PPUSH
10490: LD_INT 26
10492: PUSH
10493: LD_VAR 0 3
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: PPUSH
10502: CALL_OW 72
10506: ST_TO_ADDR
// if Hclass <> 0 then
10507: LD_VAR 0 4
10511: PUSH
10512: LD_INT 0
10514: NONEQUAL
10515: IFFALSE 10544
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
10517: LD_ADDR_VAR 0 1
10521: PUSH
10522: LD_VAR 0 1
10526: PPUSH
10527: LD_INT 25
10529: PUSH
10530: LD_VAR 0 4
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: PPUSH
10539: CALL_OW 72
10543: ST_TO_ADDR
// if index <= 0 then
10544: LD_VAR 0 5
10548: PUSH
10549: LD_INT 0
10551: LESSEQUAL
10552: IFFALSE 10562
// index := 1 ;
10554: LD_ADDR_VAR 0 5
10558: PUSH
10559: LD_INT 1
10561: ST_TO_ADDR
// if lidi >= index then
10562: LD_VAR 0 1
10566: PUSH
10567: LD_VAR 0 5
10571: GREATEREQUAL
10572: IFFALSE 10592
// result := lidi [ index ] else
10574: LD_ADDR_VAR 0 6
10578: PUSH
10579: LD_VAR 0 1
10583: PUSH
10584: LD_VAR 0 5
10588: ARRAY
10589: ST_TO_ADDR
10590: GO 10600
// result := 0 ;
10592: LD_ADDR_VAR 0 6
10596: PUSH
10597: LD_INT 0
10599: ST_TO_ADDR
// end ;
10600: LD_VAR 0 6
10604: RET
// export function see_any ( strana , sez ) ; var i ; begin
10605: LD_INT 0
10607: PPUSH
10608: PPUSH
// result := [ ] ;
10609: LD_ADDR_VAR 0 3
10613: PUSH
10614: EMPTY
10615: ST_TO_ADDR
// for i in sez do
10616: LD_ADDR_VAR 0 4
10620: PUSH
10621: LD_VAR 0 2
10625: PUSH
10626: FOR_IN
10627: IFFALSE 10663
// if See ( strana , i ) then
10629: LD_VAR 0 1
10633: PPUSH
10634: LD_VAR 0 4
10638: PPUSH
10639: CALL_OW 292
10643: IFFALSE 10661
// begin result := result ^ i ;
10645: LD_ADDR_VAR 0 3
10649: PUSH
10650: LD_VAR 0 3
10654: PUSH
10655: LD_VAR 0 4
10659: ADD
10660: ST_TO_ADDR
// end ;
10661: GO 10626
10663: POP
10664: POP
// ; end ;
10665: LD_VAR 0 3
10669: RET
// export function TalkOn ; begin
10670: LD_INT 0
10672: PPUSH
// stop_talking := true ;
10673: LD_ADDR_OWVAR 56
10677: PUSH
10678: LD_INT 1
10680: ST_TO_ADDR
// end ;
10681: LD_VAR 0 1
10685: RET
// export function TalkOff ; begin
10686: LD_INT 0
10688: PPUSH
// stop_talking := false ;
10689: LD_ADDR_OWVAR 56
10693: PUSH
10694: LD_INT 0
10696: ST_TO_ADDR
// end ;
10697: LD_VAR 0 1
10701: RET
// export function FilterHumansInArea ( area , filter ) ; var inbase , i ; begin
10702: LD_INT 0
10704: PPUSH
10705: PPUSH
10706: PPUSH
// result := [ ] ;
10707: LD_ADDR_VAR 0 3
10711: PUSH
10712: EMPTY
10713: ST_TO_ADDR
// inbase := FilterUnitsInArea ( area , [ f_side , you ] ) ;
10714: LD_ADDR_VAR 0 4
10718: PUSH
10719: LD_VAR 0 1
10723: PPUSH
10724: LD_INT 22
10726: PUSH
10727: LD_EXP 7
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: PPUSH
10736: CALL_OW 70
10740: ST_TO_ADDR
// for i in inbase do
10741: LD_ADDR_VAR 0 5
10745: PUSH
10746: LD_VAR 0 4
10750: PUSH
10751: FOR_IN
10752: IFFALSE 10825
// begin if GetType ( i ) = unit_building or GetType ( i ) = unit_vehicle then
10754: LD_VAR 0 5
10758: PPUSH
10759: CALL_OW 247
10763: PUSH
10764: LD_INT 3
10766: EQUAL
10767: PUSH
10768: LD_VAR 0 5
10772: PPUSH
10773: CALL_OW 247
10777: PUSH
10778: LD_INT 2
10780: EQUAL
10781: OR
10782: IFFALSE 10807
// begin result := result ^ UnitsInside ( i ) ;
10784: LD_ADDR_VAR 0 3
10788: PUSH
10789: LD_VAR 0 3
10793: PUSH
10794: LD_VAR 0 5
10798: PPUSH
10799: CALL_OW 313
10803: ADD
10804: ST_TO_ADDR
// end else
10805: GO 10823
// begin result := result ^ i ;
10807: LD_ADDR_VAR 0 3
10811: PUSH
10812: LD_VAR 0 3
10816: PUSH
10817: LD_VAR 0 5
10821: ADD
10822: ST_TO_ADDR
// end ; end ;
10823: GO 10751
10825: POP
10826: POP
// result := UnitFilter ( result , filter ) ;
10827: LD_ADDR_VAR 0 3
10831: PUSH
10832: LD_VAR 0 3
10836: PPUSH
10837: LD_VAR 0 2
10841: PPUSH
10842: CALL_OW 72
10846: ST_TO_ADDR
// end ;
10847: LD_VAR 0 3
10851: RET
// export function inside_units ( uns ) ; var i ; begin
10852: LD_INT 0
10854: PPUSH
10855: PPUSH
// result := [ ] ;
10856: LD_ADDR_VAR 0 2
10860: PUSH
10861: EMPTY
10862: ST_TO_ADDR
// for i in uns do
10863: LD_ADDR_VAR 0 3
10867: PUSH
10868: LD_VAR 0 1
10872: PUSH
10873: FOR_IN
10874: IFFALSE 10899
// result := result ^ UnitsInside ( i ) ;
10876: LD_ADDR_VAR 0 2
10880: PUSH
10881: LD_VAR 0 2
10885: PUSH
10886: LD_VAR 0 3
10890: PPUSH
10891: CALL_OW 313
10895: ADD
10896: ST_TO_ADDR
10897: GO 10873
10899: POP
10900: POP
// end ;
10901: LD_VAR 0 2
10905: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
10906: LD_INT 0
10908: PPUSH
10909: PPUSH
10910: PPUSH
10911: PPUSH
10912: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
10913: LD_ADDR_VAR 0 1
10917: PUSH
10918: LD_VAR 0 1
10922: PPUSH
10923: LD_INT 51
10925: PUSH
10926: EMPTY
10927: LIST
10928: PPUSH
10929: CALL_OW 72
10933: PUSH
10934: EMPTY
10935: UNION
10936: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
10937: LD_ADDR_VAR 0 2
10941: PUSH
10942: LD_VAR 0 2
10946: PPUSH
10947: LD_INT 51
10949: PUSH
10950: EMPTY
10951: LIST
10952: PPUSH
10953: CALL_OW 72
10957: PUSH
10958: EMPTY
10959: UNION
10960: ST_TO_ADDR
// for i in cars do
10961: LD_ADDR_VAR 0 7
10965: PUSH
10966: LD_VAR 0 1
10970: PUSH
10971: FOR_IN
10972: IFFALSE 11007
// if not IsDrivenBy ( i ) then
10974: LD_VAR 0 7
10978: PPUSH
10979: CALL_OW 311
10983: NOT
10984: IFFALSE 11005
// empty := empty ^ [ i ] ;
10986: LD_ADDR_VAR 0 5
10990: PUSH
10991: LD_VAR 0 5
10995: PUSH
10996: LD_VAR 0 7
11000: PUSH
11001: EMPTY
11002: LIST
11003: ADD
11004: ST_TO_ADDR
11005: GO 10971
11007: POP
11008: POP
// if take_out then
11009: LD_VAR 0 3
11013: IFFALSE 11071
// begin for i in drivers do
11015: LD_ADDR_VAR 0 7
11019: PUSH
11020: LD_VAR 0 2
11024: PUSH
11025: FOR_IN
11026: IFFALSE 11067
// if not ( IsInUnit ( i ) in cars ) then
11028: LD_VAR 0 7
11032: PPUSH
11033: CALL_OW 310
11037: PUSH
11038: LD_VAR 0 1
11042: IN
11043: NOT
11044: IFFALSE 11065
// free := free ^ [ i ] ;
11046: LD_ADDR_VAR 0 6
11050: PUSH
11051: LD_VAR 0 6
11055: PUSH
11056: LD_VAR 0 7
11060: PUSH
11061: EMPTY
11062: LIST
11063: ADD
11064: ST_TO_ADDR
11065: GO 11025
11067: POP
11068: POP
// end else
11069: GO 11119
// begin for i in drivers do
11071: LD_ADDR_VAR 0 7
11075: PUSH
11076: LD_VAR 0 2
11080: PUSH
11081: FOR_IN
11082: IFFALSE 11117
// if not IsInUnit ( i ) then
11084: LD_VAR 0 7
11088: PPUSH
11089: CALL_OW 310
11093: NOT
11094: IFFALSE 11115
// free := free ^ [ i ] ;
11096: LD_ADDR_VAR 0 6
11100: PUSH
11101: LD_VAR 0 6
11105: PUSH
11106: LD_VAR 0 7
11110: PUSH
11111: EMPTY
11112: LIST
11113: ADD
11114: ST_TO_ADDR
11115: GO 11081
11117: POP
11118: POP
// end ; result := cars diff empty ;
11119: LD_ADDR_VAR 0 4
11123: PUSH
11124: LD_VAR 0 1
11128: PUSH
11129: LD_VAR 0 5
11133: DIFF
11134: ST_TO_ADDR
// if empty <= free then
11135: LD_VAR 0 5
11139: PUSH
11140: LD_VAR 0 6
11144: LESSEQUAL
11145: IFFALSE 11159
// konec := empty else
11147: LD_ADDR_VAR 0 8
11151: PUSH
11152: LD_VAR 0 5
11156: ST_TO_ADDR
11157: GO 11169
// konec := free ;
11159: LD_ADDR_VAR 0 8
11163: PUSH
11164: LD_VAR 0 6
11168: ST_TO_ADDR
// for i := 1 to konec do
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: DOUBLE
11175: LD_INT 1
11177: DEC
11178: ST_TO_ADDR
11179: LD_VAR 0 8
11183: PUSH
11184: FOR_TO
11185: IFFALSE 11240
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
11187: LD_VAR 0 6
11191: PUSH
11192: LD_VAR 0 7
11196: ARRAY
11197: PPUSH
11198: LD_VAR 0 5
11202: PUSH
11203: LD_VAR 0 7
11207: ARRAY
11208: PPUSH
11209: CALL_OW 120
// result := result ^ [ empty [ i ] ] ;
11213: LD_ADDR_VAR 0 4
11217: PUSH
11218: LD_VAR 0 4
11222: PUSH
11223: LD_VAR 0 5
11227: PUSH
11228: LD_VAR 0 7
11232: ARRAY
11233: PUSH
11234: EMPTY
11235: LIST
11236: ADD
11237: ST_TO_ADDR
// end ;
11238: GO 11184
11240: POP
11241: POP
// end ;
11242: LD_VAR 0 4
11246: RET
// export function find_remotes ( cars , mechs , remotes ) ; var cas , i ; begin
11247: LD_INT 0
11249: PPUSH
11250: PPUSH
11251: PPUSH
// while remotes > mechs do
11252: LD_VAR 0 3
11256: PUSH
11257: LD_VAR 0 2
11261: GREATER
11262: IFFALSE 11278
// delete ( remotes , 1 ) ;
11264: LD_VAR 0 3
11268: PPUSH
11269: LD_INT 1
11271: PPUSH
11272: CALL_OW 3
11276: GO 11252
// for i := 1 to remotes do
11278: LD_ADDR_VAR 0 6
11282: PUSH
11283: DOUBLE
11284: LD_INT 1
11286: DEC
11287: ST_TO_ADDR
11288: LD_VAR 0 3
11292: PUSH
11293: FOR_TO
11294: IFFALSE 11324
// ComEnterUnit ( mechs [ i ] , remotes [ i ] ) ;
11296: LD_VAR 0 2
11300: PUSH
11301: LD_VAR 0 6
11305: ARRAY
11306: PPUSH
11307: LD_VAR 0 3
11311: PUSH
11312: LD_VAR 0 6
11316: ARRAY
11317: PPUSH
11318: CALL_OW 120
11322: GO 11293
11324: POP
11325: POP
// end ;
11326: LD_VAR 0 4
11330: RET
// export function wait_for_remotes ( cars , remotes , cas ) ; var c , unlinked , i ; begin
11331: LD_INT 0
11333: PPUSH
11334: PPUSH
11335: PPUSH
11336: PPUSH
// c := tick + cas ;
11337: LD_ADDR_VAR 0 5
11341: PUSH
11342: LD_OWVAR 1
11346: PUSH
11347: LD_VAR 0 3
11351: PLUS
11352: ST_TO_ADDR
// while tick < c and ( not ( inside_units ( remotes ) + 0 ) = remotes ) do
11353: LD_OWVAR 1
11357: PUSH
11358: LD_VAR 0 5
11362: LESS
11363: PUSH
11364: LD_VAR 0 2
11368: PPUSH
11369: CALL 10852 0 1
11373: PUSH
11374: LD_INT 0
11376: PLUS
11377: PUSH
11378: LD_VAR 0 2
11382: EQUAL
11383: NOT
11384: AND
11385: IFFALSE 11396
// wait ( 0 0$1 ) ;
11387: LD_INT 35
11389: PPUSH
11390: CALL_OW 67
11394: GO 11353
// unlinked := cars ;
11396: LD_ADDR_VAR 0 6
11400: PUSH
11401: LD_VAR 0 1
11405: ST_TO_ADDR
// for i in remotes do
11406: LD_ADDR_VAR 0 7
11410: PUSH
11411: LD_VAR 0 2
11415: PUSH
11416: FOR_IN
11417: IFFALSE 11466
// begin ComLinkTo ( unlinked , UnitsInside ( i ) ) ;
11419: LD_VAR 0 6
11423: PPUSH
11424: LD_VAR 0 7
11428: PPUSH
11429: CALL_OW 313
11433: PPUSH
11434: CALL_OW 135
// unlinked := unlinked diff UnitsLinked ( UnitsInside ( i ) ) ;
11438: LD_ADDR_VAR 0 6
11442: PUSH
11443: LD_VAR 0 6
11447: PUSH
11448: LD_VAR 0 7
11452: PPUSH
11453: CALL_OW 313
11457: PPUSH
11458: CALL_OW 432
11462: DIFF
11463: ST_TO_ADDR
// end ;
11464: GO 11416
11466: POP
11467: POP
// end ;
11468: LD_VAR 0 4
11472: RET
// export function wait_for_drivers ( cars , cas ) ; var i , vsichni_ready , k , pockat ; begin
11473: LD_INT 0
11475: PPUSH
11476: PPUSH
11477: PPUSH
11478: PPUSH
11479: PPUSH
// k := 0 ;
11480: LD_ADDR_VAR 0 6
11484: PUSH
11485: LD_INT 0
11487: ST_TO_ADDR
// pockat := tick + cas ;
11488: LD_ADDR_VAR 0 7
11492: PUSH
11493: LD_OWVAR 1
11497: PUSH
11498: LD_VAR 0 2
11502: PLUS
11503: ST_TO_ADDR
// while not vsichni_ready and tick < pockat do
11504: LD_VAR 0 5
11508: NOT
11509: PUSH
11510: LD_OWVAR 1
11514: PUSH
11515: LD_VAR 0 7
11519: LESS
11520: AND
11521: IFFALSE 11591
// begin vsichni_ready := true ;
11523: LD_ADDR_VAR 0 5
11527: PUSH
11528: LD_INT 1
11530: ST_TO_ADDR
// k := k + 1 ;
11531: LD_ADDR_VAR 0 6
11535: PUSH
11536: LD_VAR 0 6
11540: PUSH
11541: LD_INT 1
11543: PLUS
11544: ST_TO_ADDR
// for i in cars do
11545: LD_ADDR_VAR 0 4
11549: PUSH
11550: LD_VAR 0 1
11554: PUSH
11555: FOR_IN
11556: IFFALSE 11580
// if not IsDrivenBy ( i ) then
11558: LD_VAR 0 4
11562: PPUSH
11563: CALL_OW 311
11567: NOT
11568: IFFALSE 11578
// vsichni_ready := false ;
11570: LD_ADDR_VAR 0 5
11574: PUSH
11575: LD_INT 0
11577: ST_TO_ADDR
11578: GO 11555
11580: POP
11581: POP
// wait ( 0 0$1.0 ) ;
11582: LD_INT 35
11584: PPUSH
11585: CALL_OW 67
// end ;
11589: GO 11504
// end ;
11591: LD_VAR 0 3
11595: RET
// export function rev ( list ) ; var i ; begin
11596: LD_INT 0
11598: PPUSH
11599: PPUSH
// for i := list + 0 to 1 do
11600: LD_ADDR_VAR 0 3
11604: PUSH
11605: DOUBLE
11606: LD_VAR 0 1
11610: PUSH
11611: LD_INT 0
11613: PLUS
11614: DEC
11615: ST_TO_ADDR
11616: LD_INT 1
11618: PUSH
11619: FOR_TO
11620: IFFALSE 11649
// result := result ^ [ list [ i ] ] ;
11622: LD_ADDR_VAR 0 2
11626: PUSH
11627: LD_VAR 0 2
11631: PUSH
11632: LD_VAR 0 1
11636: PUSH
11637: LD_VAR 0 3
11641: ARRAY
11642: PUSH
11643: EMPTY
11644: LIST
11645: ADD
11646: ST_TO_ADDR
11647: GO 11619
11649: POP
11650: POP
// end ; end_of_file
11651: LD_VAR 0 2
11655: RET
// export under_attack ; export near_base_area ; export function inicializace_ai_defend ; begin
11656: LD_INT 0
11658: PPUSH
// under_attack := [ false , false , false , false , false ] ;
11659: LD_ADDR_EXP 62
11663: PUSH
11664: LD_INT 0
11666: PUSH
11667: LD_INT 0
11669: PUSH
11670: LD_INT 0
11672: PUSH
11673: LD_INT 0
11675: PUSH
11676: LD_INT 0
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: ST_TO_ADDR
// near_base_area := [ nearA , nearB , nearC , nearD , nearE ] ;
11686: LD_ADDR_EXP 63
11690: PUSH
11691: LD_INT 24
11693: PUSH
11694: LD_INT 25
11696: PUSH
11697: LD_INT 26
11699: PUSH
11700: LD_INT 27
11702: PUSH
11703: LD_INT 28
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: ST_TO_ADDR
// end ;
11713: LD_VAR 0 1
11717: RET
// export BehMcRegId , BehMcAttId ; export function BehemothUtok ; begin
11718: LD_INT 0
11720: PPUSH
// if GetSide ( behemoth ) = you then
11721: LD_INT 125
11723: PPUSH
11724: CALL_OW 255
11728: PUSH
11729: LD_EXP 7
11733: EQUAL
11734: IFFALSE 11738
// exit ;
11736: GO 11904
// BehMcRegId := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11738: LD_ADDR_EXP 64
11742: PUSH
11743: LD_EXP 23
11747: PUSH
11748: LD_INT 1
11750: ARRAY
11751: PPUSH
11752: LD_INT 1
11754: PUSH
11755: LD_INT 140
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 4
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: EMPTY
11771: LIST
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: PUSH
11777: LD_INT 10
11779: PUSH
11780: LD_EXP 41
11784: PUSH
11785: EMPTY
11786: LIST
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: PUSH
11792: LD_INT 3
11794: PUSH
11795: LD_EXP 63
11799: PUSH
11800: LD_EXP 25
11804: ARRAY
11805: PUSH
11806: EMPTY
11807: LIST
11808: LIST
11809: PUSH
11810: LD_INT 7
11812: PUSH
11813: LD_INT 8
11815: NEG
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: PPUSH
11825: CALL_OW 399
11829: ST_TO_ADDR
// BehMcAttId := McAttack ( 12 , BehMcRegId , [ behemoth ] , [ [ mc_retreat_area_vehicles , nearA ] , [ mc_retreat_area_people , nearA ] , [ mc_retreat_lives_vehicles , 600 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
11830: LD_ADDR_EXP 65
11834: PUSH
11835: LD_INT 12
11837: PPUSH
11838: LD_EXP 64
11842: PPUSH
11843: LD_INT 125
11845: PUSH
11846: EMPTY
11847: LIST
11848: PPUSH
11849: LD_INT 8
11851: PUSH
11852: LD_INT 24
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: LD_INT 7
11861: PUSH
11862: LD_INT 24
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PUSH
11869: LD_INT 6
11871: PUSH
11872: LD_INT 600
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 5
11881: PUSH
11882: LD_INT 800
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: LD_INT 10
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: LIST
11896: LIST
11897: LIST
11898: PPUSH
11899: CALL_OW 402
11903: ST_TO_ADDR
// end ;
11904: LD_VAR 0 1
11908: RET
// export ZouMcRegId , ZouMcAttId ; export function ZoufalUtok ; begin
11909: LD_INT 0
11911: PPUSH
// ZouMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ Burlak ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
11912: LD_ADDR_EXP 66
11916: PUSH
11917: LD_EXP 23
11921: PUSH
11922: LD_EXP 25
11926: ARRAY
11927: PPUSH
11928: LD_INT 1
11930: PUSH
11931: LD_INT 140
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_INT 4
11940: PUSH
11941: LD_EXP 42
11945: PUSH
11946: EMPTY
11947: LIST
11948: PUSH
11949: EMPTY
11950: LIST
11951: LIST
11952: PUSH
11953: LD_INT 10
11955: PUSH
11956: LD_EXP 41
11960: PUSH
11961: EMPTY
11962: LIST
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 3
11970: PUSH
11971: LD_EXP 63
11975: PUSH
11976: LD_EXP 25
11980: ARRAY
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 7
11988: PUSH
11989: LD_INT 8
11991: NEG
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: PPUSH
12001: CALL_OW 399
12005: ST_TO_ADDR
// ZouMcAttId := McAttack ( 12 , ZouMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
12006: LD_ADDR_EXP 67
12010: PUSH
12011: LD_INT 12
12013: PPUSH
12014: LD_EXP 66
12018: PPUSH
12019: LD_EXP 77
12023: PUSH
12024: LD_EXP 25
12028: ARRAY
12029: PPUSH
12030: LD_INT 8
12032: PUSH
12033: LD_EXP 63
12037: PUSH
12038: LD_EXP 25
12042: ARRAY
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 7
12050: PUSH
12051: LD_EXP 63
12055: PUSH
12056: LD_EXP 25
12060: ARRAY
12061: PUSH
12062: EMPTY
12063: LIST
12064: LIST
12065: PUSH
12066: LD_INT 6
12068: PUSH
12069: LD_INT 100
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: PUSH
12076: LD_INT 5
12078: PUSH
12079: LD_INT 800
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PUSH
12086: LD_INT 10
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: PPUSH
12096: CALL_OW 402
12100: ST_TO_ADDR
// end ;
12101: LD_VAR 0 1
12105: RET
// export NorMcRegId , NorMcAttId ; export function NormalUtok ; begin
12106: LD_INT 0
12108: PPUSH
// NorMcRegId := McRegistry ( ai_s [ plat_i ] , [ [ mc_reg_refresh_time , 0 0$4 ] , [ mc_reg_units_to_protect , [ Platonov ] ] , [ mc_reg_units_to_guard , [ your_humans ] ] , [ mc_reg_area_to_protect , near_base_area [ plat_i ] ] , mc_reg_ignore_fog , - mc_reg_only_important ] ) ;
12109: LD_ADDR_EXP 68
12113: PUSH
12114: LD_EXP 23
12118: PUSH
12119: LD_EXP 25
12123: ARRAY
12124: PPUSH
12125: LD_INT 1
12127: PUSH
12128: LD_INT 140
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_INT 4
12137: PUSH
12138: LD_EXP 42
12142: PUSH
12143: EMPTY
12144: LIST
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: PUSH
12150: LD_INT 10
12152: PUSH
12153: LD_EXP 37
12157: PUSH
12158: EMPTY
12159: LIST
12160: PUSH
12161: EMPTY
12162: LIST
12163: LIST
12164: PUSH
12165: LD_INT 3
12167: PUSH
12168: LD_EXP 63
12172: PUSH
12173: LD_EXP 25
12177: ARRAY
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PUSH
12183: LD_INT 7
12185: PUSH
12186: LD_INT 8
12188: NEG
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: LIST
12196: LIST
12197: PPUSH
12198: CALL_OW 399
12202: ST_TO_ADDR
// NorMcAttId := McAttack ( 12 , NorMcRegId , vehicles [ plat_i ] , [ [ mc_retreat_area_vehicles , near_base_area [ plat_i ] ] , [ mc_retreat_area_people , near_base_area [ plat_i ] ] , [ mc_retreat_lives_vehicles , 100 ] , [ mc_retreat_lives_people , 800 ] , mc_no_stop ] ) ;
12203: LD_ADDR_EXP 69
12207: PUSH
12208: LD_INT 12
12210: PPUSH
12211: LD_EXP 68
12215: PPUSH
12216: LD_EXP 77
12220: PUSH
12221: LD_EXP 25
12225: ARRAY
12226: PPUSH
12227: LD_INT 8
12229: PUSH
12230: LD_EXP 63
12234: PUSH
12235: LD_EXP 25
12239: ARRAY
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 7
12247: PUSH
12248: LD_EXP 63
12252: PUSH
12253: LD_EXP 25
12257: ARRAY
12258: PUSH
12259: EMPTY
12260: LIST
12261: LIST
12262: PUSH
12263: LD_INT 6
12265: PUSH
12266: LD_INT 100
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 5
12275: PUSH
12276: LD_INT 800
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: PUSH
12283: LD_INT 10
12285: PUSH
12286: EMPTY
12287: LIST
12288: LIST
12289: LIST
12290: LIST
12291: LIST
12292: PPUSH
12293: CALL_OW 402
12297: ST_TO_ADDR
// end ;
12298: LD_VAR 0 1
12302: RET
// function utok_na_vetrelce ( vetrelci , index_strany ) ; var nearest , units ; begin
12303: LD_INT 0
12305: PPUSH
12306: PPUSH
12307: PPUSH
// if vetrelci and ( ai_s [ index_strany ] in aiZ ) then
12308: LD_VAR 0 1
12312: PUSH
12313: LD_EXP 23
12317: PUSH
12318: LD_VAR 0 2
12322: ARRAY
12323: PUSH
12324: LD_EXP 21
12328: IN
12329: AND
12330: IFFALSE 12433
// begin nearest := NearestUnitToUnit ( vetrelci , depots [ index_strany ] ) ;
12332: LD_ADDR_VAR 0 4
12336: PUSH
12337: LD_VAR 0 1
12341: PPUSH
12342: LD_EXP 74
12346: PUSH
12347: LD_VAR 0 2
12351: ARRAY
12352: PPUSH
12353: CALL_OW 74
12357: ST_TO_ADDR
// if nearest then
12358: LD_VAR 0 4
12362: IFFALSE 12433
// begin units := attack_units isect vehicles [ index_strany ] ;
12364: LD_ADDR_VAR 0 5
12368: PUSH
12369: LD_EXP 78
12373: PUSH
12374: LD_EXP 77
12378: PUSH
12379: LD_VAR 0 2
12383: ARRAY
12384: ISECT
12385: ST_TO_ADDR
// ComRemember ( units ) ;
12386: LD_VAR 0 5
12390: PPUSH
12391: CALL_OW 143
// AddComAgressiveMove ( units , GetX ( nearest ) , GetY ( nearest ) ) ;
12395: LD_VAR 0 5
12399: PPUSH
12400: LD_VAR 0 4
12404: PPUSH
12405: CALL_OW 250
12409: PPUSH
12410: LD_VAR 0 4
12414: PPUSH
12415: CALL_OW 251
12419: PPUSH
12420: CALL_OW 174
// AddComReturn ( units ) ;
12424: LD_VAR 0 5
12428: PPUSH
12429: CALL_OW 204
// end ; end ; end ;
12433: LD_VAR 0 3
12437: RET
// every 0 0$10 do var i , a ;
12438: GO 12440
12440: DISABLE
12441: LD_INT 0
12443: PPUSH
12444: PPUSH
// begin for i := 1 to 5 do
12445: LD_ADDR_VAR 0 1
12449: PUSH
12450: DOUBLE
12451: LD_INT 1
12453: DEC
12454: ST_TO_ADDR
12455: LD_INT 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12598
// begin a := UnitFilter ( your_humans ^ your_cars , [ [ f_inarea , near_base_area [ i ] ] ] ) ;
12461: LD_ADDR_VAR 0 2
12465: PUSH
12466: LD_EXP 37
12470: PUSH
12471: LD_EXP 35
12475: ADD
12476: PPUSH
12477: LD_INT 95
12479: PUSH
12480: LD_EXP 63
12484: PUSH
12485: LD_VAR 0 1
12489: ARRAY
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: PUSH
12495: EMPTY
12496: LIST
12497: PPUSH
12498: CALL_OW 72
12502: ST_TO_ADDR
// if a and ai_s [ i ] in aiZ then
12503: LD_VAR 0 2
12507: PUSH
12508: LD_EXP 23
12512: PUSH
12513: LD_VAR 0 1
12517: ARRAY
12518: PUSH
12519: LD_EXP 21
12523: IN
12524: AND
12525: IFFALSE 12566
// begin under_attack := replace ( under_attack , i , true ) ;
12527: LD_ADDR_EXP 62
12531: PUSH
12532: LD_EXP 62
12536: PPUSH
12537: LD_VAR 0 1
12541: PPUSH
12542: LD_INT 1
12544: PPUSH
12545: CALL_OW 1
12549: ST_TO_ADDR
// utok_na_vetrelce ( a , i ) ;
12550: LD_VAR 0 2
12554: PPUSH
12555: LD_VAR 0 1
12559: PPUSH
12560: CALL 12303 0 2
// end else
12564: GO 12589
// under_attack := replace ( under_attack , i , false ) ;
12566: LD_ADDR_EXP 62
12570: PUSH
12571: LD_EXP 62
12575: PPUSH
12576: LD_VAR 0 1
12580: PPUSH
12581: LD_INT 0
12583: PPUSH
12584: CALL_OW 1
12588: ST_TO_ADDR
// wait ( 0 0$2 ) ;
12589: LD_INT 70
12591: PPUSH
12592: CALL_OW 67
// end ;
12596: GO 12458
12598: POP
12599: POP
// enable ;
12600: ENABLE
// end ; end_of_file
12601: PPOPN 2
12603: END
// var repair_site ; export rc ; export bc ; export function inicializace_ai_c_repair ; begin
12604: LD_INT 0
12606: PPUSH
// repair_site := [ [ 30 , 29 ] , [ 89 , 17 ] , [ 72 , 125 ] , [ 215 , 140 ] , [ 184 , 85 ] ] ;
12607: LD_ADDR_LOC 16
12611: PUSH
12612: LD_INT 30
12614: PUSH
12615: LD_INT 29
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 89
12624: PUSH
12625: LD_INT 17
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 72
12634: PUSH
12635: LD_INT 125
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 215
12644: PUSH
12645: LD_INT 140
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: LD_INT 184
12654: PUSH
12655: LD_INT 85
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: LIST
12666: LIST
12667: LIST
12668: ST_TO_ADDR
// bc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12669: LD_ADDR_EXP 71
12673: PUSH
12674: EMPTY
12675: PUSH
12676: EMPTY
12677: PUSH
12678: EMPTY
12679: PUSH
12680: EMPTY
12681: PUSH
12682: EMPTY
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: LIST
12688: LIST
12689: LIST
12690: ST_TO_ADDR
// rc := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
12691: LD_ADDR_EXP 70
12695: PUSH
12696: EMPTY
12697: PUSH
12698: EMPTY
12699: PUSH
12700: EMPTY
12701: PUSH
12702: EMPTY
12703: PUSH
12704: EMPTY
12705: PUSH
12706: EMPTY
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: ST_TO_ADDR
// end ;
12713: LD_VAR 0 1
12717: RET
// every 0 0$5.0 + 0 0$0.5 do var i ;
12718: GO 12720
12720: DISABLE
12721: LD_INT 0
12723: PPUSH
// begin for i := 1 to 5 do
12724: LD_ADDR_VAR 0 1
12728: PUSH
12729: DOUBLE
12730: LD_INT 1
12732: DEC
12733: ST_TO_ADDR
12734: LD_INT 5
12736: PUSH
12737: FOR_TO
12738: IFFALSE 12793
// if ai_s [ i ] in ai then
12740: LD_EXP 23
12744: PUSH
12745: LD_VAR 0 1
12749: ARRAY
12750: PUSH
12751: LD_EXP 24
12755: IN
12756: IFFALSE 12791
// begin dop_pal ( vehicles [ i ] , depots [ i ] ) ;
12758: LD_EXP 77
12762: PUSH
12763: LD_VAR 0 1
12767: ARRAY
12768: PPUSH
12769: LD_EXP 74
12773: PUSH
12774: LD_VAR 0 1
12778: ARRAY
12779: PPUSH
12780: CALL 12799 0 2
// wait ( 0 0$1 ) ;
12784: LD_INT 35
12786: PPUSH
12787: CALL_OW 67
// end ;
12791: GO 12737
12793: POP
12794: POP
// enable ;
12795: ENABLE
// end ;
12796: PPOPN 1
12798: END
// function dop_pal ( tc , tdep ) ; var set_fuel , fuel ; begin
12799: LD_INT 0
12801: PPUSH
12802: PPUSH
12803: PPUSH
// for set_fuel in UnitFilter ( tc , [ [ f_dist , tdep , 40 ] ] ) do
12804: LD_ADDR_VAR 0 4
12808: PUSH
12809: LD_VAR 0 1
12813: PPUSH
12814: LD_INT 91
12816: PUSH
12817: LD_VAR 0 2
12821: PUSH
12822: LD_INT 40
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: PPUSH
12833: CALL_OW 72
12837: PUSH
12838: FOR_IN
12839: IFFALSE 12886
// begin fuel := GetFuel ( set_fuel ) ;
12841: LD_ADDR_VAR 0 5
12845: PUSH
12846: LD_VAR 0 4
12850: PPUSH
12851: CALL_OW 261
12855: ST_TO_ADDR
// if fuel <= 80 then
12856: LD_VAR 0 5
12860: PUSH
12861: LD_INT 80
12863: LESSEQUAL
12864: IFFALSE 12884
// SetFuel ( set_fuel , fuel + 20 ) ;
12866: LD_VAR 0 4
12870: PPUSH
12871: LD_VAR 0 5
12875: PUSH
12876: LD_INT 20
12878: PLUS
12879: PPUSH
12880: CALL_OW 240
// end ;
12884: GO 12838
12886: POP
12887: POP
// end ;
12888: LD_VAR 0 3
12892: RET
// every 0 0$5 + 0 0$0.3 do var zivoty , i , rem_t , add_t , k ;
12893: GO 12895
12895: DISABLE
12896: LD_INT 0
12898: PPUSH
12899: PPUSH
12900: PPUSH
12901: PPUSH
12902: PPUSH
// begin for k := 1 to 5 do
12903: LD_ADDR_VAR 0 5
12907: PUSH
12908: DOUBLE
12909: LD_INT 1
12911: DEC
12912: ST_TO_ADDR
12913: LD_INT 5
12915: PUSH
12916: FOR_TO
12917: IFFALSE 13235
// if ai_s [ k ] in ai then
12919: LD_EXP 23
12923: PUSH
12924: LD_VAR 0 5
12928: ARRAY
12929: PUSH
12930: LD_EXP 24
12934: IN
12935: IFFALSE 13211
// begin rem_t := [ ] ;
12937: LD_ADDR_VAR 0 3
12941: PUSH
12942: EMPTY
12943: ST_TO_ADDR
// add_t := [ ] ;
12944: LD_ADDR_VAR 0 4
12948: PUSH
12949: EMPTY
12950: ST_TO_ADDR
// for i in UnitFilter ( vehicles [ k ] , [ [ f_not , [ f_side , you ] ] ] ) do
12951: LD_ADDR_VAR 0 2
12955: PUSH
12956: LD_EXP 77
12960: PUSH
12961: LD_VAR 0 5
12965: ARRAY
12966: PPUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 22
12972: PUSH
12973: LD_EXP 7
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: EMPTY
12987: LIST
12988: PPUSH
12989: CALL_OW 72
12993: PUSH
12994: FOR_IN
12995: IFFALSE 13063
// begin if GetLives ( i ) < 500 then
12997: LD_VAR 0 2
13001: PPUSH
13002: CALL_OW 256
13006: PUSH
13007: LD_INT 500
13009: LESS
13010: IFFALSE 13030
// begin rem_t := rem_t ^ i ;
13012: LD_ADDR_VAR 0 3
13016: PUSH
13017: LD_VAR 0 3
13021: PUSH
13022: LD_VAR 0 2
13026: ADD
13027: ST_TO_ADDR
// end else
13028: GO 13061
// if GetLives ( i ) >= 950 then
13030: LD_VAR 0 2
13034: PPUSH
13035: CALL_OW 256
13039: PUSH
13040: LD_INT 950
13042: GREATEREQUAL
13043: IFFALSE 13061
// begin add_t := add_t ^ i ;
13045: LD_ADDR_VAR 0 4
13049: PUSH
13050: LD_VAR 0 4
13054: PUSH
13055: LD_VAR 0 2
13059: ADD
13060: ST_TO_ADDR
// end ; end ;
13061: GO 12994
13063: POP
13064: POP
// bc := replace ( bc , k , bc [ k ] union rem_t ) ;
13065: LD_ADDR_EXP 71
13069: PUSH
13070: LD_EXP 71
13074: PPUSH
13075: LD_VAR 0 5
13079: PPUSH
13080: LD_EXP 71
13084: PUSH
13085: LD_VAR 0 5
13089: ARRAY
13090: PUSH
13091: LD_VAR 0 3
13095: UNION
13096: PPUSH
13097: CALL_OW 1
13101: ST_TO_ADDR
// bc := replace ( bc , k , bc [ k ] diff add_t ) ;
13102: LD_ADDR_EXP 71
13106: PUSH
13107: LD_EXP 71
13111: PPUSH
13112: LD_VAR 0 5
13116: PPUSH
13117: LD_EXP 71
13121: PUSH
13122: LD_VAR 0 5
13126: ARRAY
13127: PUSH
13128: LD_VAR 0 4
13132: DIFF
13133: PPUSH
13134: CALL_OW 1
13138: ST_TO_ADDR
// remove_from_vehicles ( rem_t ) ;
13139: LD_VAR 0 3
13143: PPUSH
13144: CALL 28295 0 1
// add_to_vehicles ( add_t ) ;
13148: LD_VAR 0 4
13152: PPUSH
13153: CALL 26964 0 1
// ComMoveXY ( bc [ k ] , repair_site [ k ] [ 1 ] , repair_site [ k ] [ 2 ] ) ;
13157: LD_EXP 71
13161: PUSH
13162: LD_VAR 0 5
13166: ARRAY
13167: PPUSH
13168: LD_LOC 16
13172: PUSH
13173: LD_VAR 0 5
13177: ARRAY
13178: PUSH
13179: LD_INT 1
13181: ARRAY
13182: PPUSH
13183: LD_LOC 16
13187: PUSH
13188: LD_VAR 0 5
13192: ARRAY
13193: PUSH
13194: LD_INT 2
13196: ARRAY
13197: PPUSH
13198: CALL_OW 111
// wait ( 0 0$0.9 ) ;
13202: LD_INT 32
13204: PPUSH
13205: CALL_OW 67
// end else
13209: GO 13233
// bc := replace ( bc , k , [ ] ) ;
13211: LD_ADDR_EXP 71
13215: PUSH
13216: LD_EXP 71
13220: PPUSH
13221: LD_VAR 0 5
13225: PPUSH
13226: EMPTY
13227: PPUSH
13228: CALL_OW 1
13232: ST_TO_ADDR
13233: GO 12916
13235: POP
13236: POP
// enable ;
13237: ENABLE
// end ;
13238: PPOPN 5
13240: END
// every 0 0$5 + 0 0$0.1 do var zivoty , i , rc_t , k ;
13241: GO 13243
13243: DISABLE
13244: LD_INT 0
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
// begin for k := 1 to 5 do
13250: LD_ADDR_VAR 0 4
13254: PUSH
13255: DOUBLE
13256: LD_INT 1
13258: DEC
13259: ST_TO_ADDR
13260: LD_INT 5
13262: PUSH
13263: FOR_TO
13264: IFFALSE 13431
// if ai_s [ k ] in ai then
13266: LD_EXP 23
13270: PUSH
13271: LD_VAR 0 4
13275: ARRAY
13276: PUSH
13277: LD_EXP 24
13281: IN
13282: IFFALSE 13407
// begin rc_t := [ ] ;
13284: LD_ADDR_VAR 0 3
13288: PUSH
13289: EMPTY
13290: ST_TO_ADDR
// for i in bc [ k ] do
13291: LD_ADDR_VAR 0 2
13295: PUSH
13296: LD_EXP 71
13300: PUSH
13301: LD_VAR 0 4
13305: ARRAY
13306: PUSH
13307: FOR_IN
13308: IFFALSE 13364
// begin if GetLives ( i ) < 950 then
13310: LD_VAR 0 2
13314: PPUSH
13315: CALL_OW 256
13319: PUSH
13320: LD_INT 950
13322: LESS
13323: IFFALSE 13362
// begin rc_t := rc_t ^ i ;
13325: LD_ADDR_VAR 0 3
13329: PUSH
13330: LD_VAR 0 3
13334: PUSH
13335: LD_VAR 0 2
13339: ADD
13340: ST_TO_ADDR
// zivoty := zivoty ^ GetLives ( i ) ;
13341: LD_ADDR_VAR 0 1
13345: PUSH
13346: LD_VAR 0 1
13350: PUSH
13351: LD_VAR 0 2
13355: PPUSH
13356: CALL_OW 256
13360: ADD
13361: ST_TO_ADDR
// end ; end ;
13362: GO 13307
13364: POP
13365: POP
// SortListByListAsc ( rc_t , zivoty ) ;
13366: LD_VAR 0 3
13370: PPUSH
13371: LD_VAR 0 1
13375: PPUSH
13376: CALL_OW 76
// rc := replace ( rc , k , rc_t ) ;
13380: LD_ADDR_EXP 70
13384: PUSH
13385: LD_EXP 70
13389: PPUSH
13390: LD_VAR 0 4
13394: PPUSH
13395: LD_VAR 0 3
13399: PPUSH
13400: CALL_OW 1
13404: ST_TO_ADDR
// end else
13405: GO 13429
// rc := replace ( rc , k , [ ] ) ;
13407: LD_ADDR_EXP 70
13411: PUSH
13412: LD_EXP 70
13416: PPUSH
13417: LD_VAR 0 4
13421: PPUSH
13422: EMPTY
13423: PPUSH
13424: CALL_OW 1
13428: ST_TO_ADDR
13429: GO 13263
13431: POP
13432: POP
// enable ;
13433: ENABLE
// end ;
13434: PPOPN 4
13436: END
// every 0 0$5 + 0 0$0.9 do var i ;
13437: GO 13439
13439: DISABLE
13440: LD_INT 0
13442: PPUSH
// begin for i := 1 to 5 do
13443: LD_ADDR_VAR 0 1
13447: PUSH
13448: DOUBLE
13449: LD_INT 1
13451: DEC
13452: ST_TO_ADDR
13453: LD_INT 5
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13512
// if ai_s [ i ] in ai then
13459: LD_EXP 23
13463: PUSH
13464: LD_VAR 0 1
13468: ARRAY
13469: PUSH
13470: LD_EXP 24
13474: IN
13475: IFFALSE 13510
// begin rep ( ai_s [ i ] , rc [ i ] ) ;
13477: LD_EXP 23
13481: PUSH
13482: LD_VAR 0 1
13486: ARRAY
13487: PPUSH
13488: LD_EXP 70
13492: PUSH
13493: LD_VAR 0 1
13497: ARRAY
13498: PPUSH
13499: CALL 13518 0 2
// wait ( 0 0$0.8 ) ;
13503: LD_INT 28
13505: PPUSH
13506: CALL_OW 67
// end ;
13510: GO 13456
13512: POP
13513: POP
// enable ;
13514: ENABLE
// end ;
13515: PPOPN 1
13517: END
// function rep ( side , rep_cars ) ; var a ; begin
13518: LD_INT 0
13520: PPUSH
13521: PPUSH
// if ( side in ai ) and rep_cars then
13522: LD_VAR 0 1
13526: PUSH
13527: LD_EXP 24
13531: IN
13532: PUSH
13533: LD_VAR 0 2
13537: AND
13538: IFFALSE 14067
// begin if rep_cars [ 1 ] < 400 then
13540: LD_VAR 0 2
13544: PUSH
13545: LD_INT 1
13547: ARRAY
13548: PUSH
13549: LD_INT 400
13551: LESS
13552: IFFALSE 13651
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13554: LD_ADDR_VAR 0 4
13558: PUSH
13559: LD_EXP 86
13563: PPUSH
13564: LD_INT 22
13566: PUSH
13567: LD_VAR 0 1
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 91
13578: PUSH
13579: LD_VAR 0 2
13583: PUSH
13584: LD_INT 1
13586: ARRAY
13587: PUSH
13588: LD_INT 20
13590: PUSH
13591: EMPTY
13592: LIST
13593: LIST
13594: LIST
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: PPUSH
13600: CALL_OW 72
13604: PPUSH
13605: LD_INT 2
13607: PPUSH
13608: LD_INT 3
13610: PPUSH
13611: LD_INT 0
13613: PPUSH
13614: LD_INT 0
13616: PPUSH
13617: CALL 10136 0 5
13621: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13622: LD_VAR 0 4
13626: PPUSH
13627: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13631: LD_VAR 0 4
13635: PPUSH
13636: LD_VAR 0 2
13640: PUSH
13641: LD_INT 1
13643: ARRAY
13644: PPUSH
13645: CALL_OW 189
// end else
13649: GO 14067
// if rep_cars [ 1 ] < 700 or rep_cars >= 2 then
13651: LD_VAR 0 2
13655: PUSH
13656: LD_INT 1
13658: ARRAY
13659: PUSH
13660: LD_INT 700
13662: LESS
13663: PUSH
13664: LD_VAR 0 2
13668: PUSH
13669: LD_INT 2
13671: GREATEREQUAL
13672: OR
13673: IFFALSE 13867
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , false ) ;
13675: LD_ADDR_VAR 0 4
13679: PUSH
13680: LD_EXP 86
13684: PPUSH
13685: LD_INT 22
13687: PUSH
13688: LD_VAR 0 1
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PUSH
13697: LD_INT 91
13699: PUSH
13700: LD_VAR 0 2
13704: PUSH
13705: LD_INT 1
13707: ARRAY
13708: PUSH
13709: LD_INT 20
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: LIST
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PPUSH
13721: CALL_OW 72
13725: PPUSH
13726: LD_INT 1
13728: PPUSH
13729: LD_INT 3
13731: PPUSH
13732: LD_INT 0
13734: PPUSH
13735: LD_INT 0
13737: PPUSH
13738: CALL 10136 0 5
13742: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13743: LD_VAR 0 4
13747: PPUSH
13748: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13752: LD_VAR 0 4
13756: PPUSH
13757: LD_VAR 0 2
13761: PUSH
13762: LD_INT 1
13764: ARRAY
13765: PPUSH
13766: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 1 , skill_mechanical , 0 , true ) ;
13770: LD_ADDR_VAR 0 4
13774: PUSH
13775: LD_EXP 86
13779: PPUSH
13780: LD_INT 22
13782: PUSH
13783: LD_VAR 0 1
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 91
13794: PUSH
13795: LD_VAR 0 2
13799: PUSH
13800: LD_INT 2
13802: ARRAY
13803: PUSH
13804: LD_INT 20
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 72
13820: PPUSH
13821: LD_INT 1
13823: PPUSH
13824: LD_INT 3
13826: PPUSH
13827: LD_INT 0
13829: PPUSH
13830: LD_INT 1
13832: PPUSH
13833: CALL 10136 0 5
13837: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13838: LD_VAR 0 4
13842: PPUSH
13843: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
13847: LD_VAR 0 4
13851: PPUSH
13852: LD_VAR 0 2
13856: PUSH
13857: LD_INT 2
13859: ARRAY
13860: PPUSH
13861: CALL_OW 189
// end else
13865: GO 14067
// if rep_cars >= 3 then
13867: LD_VAR 0 2
13871: PUSH
13872: LD_INT 3
13874: GREATEREQUAL
13875: IFFALSE 14067
// begin a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 1 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , false ) ;
13877: LD_ADDR_VAR 0 4
13881: PUSH
13882: LD_EXP 86
13886: PPUSH
13887: LD_INT 22
13889: PUSH
13890: LD_VAR 0 1
13894: PUSH
13895: EMPTY
13896: LIST
13897: LIST
13898: PUSH
13899: LD_INT 91
13901: PUSH
13902: LD_VAR 0 2
13906: PUSH
13907: LD_INT 1
13909: ARRAY
13910: PUSH
13911: LD_INT 20
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: PUSH
13919: EMPTY
13920: LIST
13921: LIST
13922: PPUSH
13923: CALL_OW 72
13927: PPUSH
13928: LD_INT 2
13930: PPUSH
13931: LD_INT 3
13933: PPUSH
13934: LD_INT 0
13936: PPUSH
13937: LD_INT 0
13939: PPUSH
13940: CALL 10136 0 5
13944: ST_TO_ADDR
// ComExitBuilding ( a ) ;
13945: LD_VAR 0 4
13949: PPUSH
13950: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 1 ] ) ;
13954: LD_VAR 0 4
13958: PPUSH
13959: LD_VAR 0 2
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PPUSH
13968: CALL_OW 189
// a := get_x_best ( UnitFilter ( mec , [ [ f_side , side ] , [ f_dist , rep_cars [ 2 ] , 20 ] ] ) , 2 , skill_mechanical , 0 , true ) ;
13972: LD_ADDR_VAR 0 4
13976: PUSH
13977: LD_EXP 86
13981: PPUSH
13982: LD_INT 22
13984: PUSH
13985: LD_VAR 0 1
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: PUSH
13994: LD_INT 91
13996: PUSH
13997: LD_VAR 0 2
14001: PUSH
14002: LD_INT 2
14004: ARRAY
14005: PUSH
14006: LD_INT 20
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: PUSH
14014: EMPTY
14015: LIST
14016: LIST
14017: PPUSH
14018: CALL_OW 72
14022: PPUSH
14023: LD_INT 2
14025: PPUSH
14026: LD_INT 3
14028: PPUSH
14029: LD_INT 0
14031: PPUSH
14032: LD_INT 1
14034: PPUSH
14035: CALL 10136 0 5
14039: ST_TO_ADDR
// ComExitBuilding ( a ) ;
14040: LD_VAR 0 4
14044: PPUSH
14045: CALL_OW 122
// AddComRepairVehicle ( a , rep_cars [ 2 ] ) ;
14049: LD_VAR 0 4
14053: PPUSH
14054: LD_VAR 0 2
14058: PUSH
14059: LD_INT 2
14061: ARRAY
14062: PPUSH
14063: CALL_OW 189
// end ; end ; end ; end_of_file
14067: LD_VAR 0 3
14071: RET
// var d1 , d2 , d3 , d5 , d6 , d7 ; export function inicializace_ai_c_make ; begin
14072: LD_INT 0
14074: PPUSH
// d1 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gatling_gun ] ;
14075: LD_ADDR_LOC 17
14079: PUSH
14080: LD_INT 23
14082: PUSH
14083: LD_INT 1
14085: PUSH
14086: LD_INT 1
14088: PUSH
14089: LD_INT 43
14091: PUSH
14092: EMPTY
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: ST_TO_ADDR
// d2 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_rocket_launcher ] ;
14098: LD_ADDR_LOC 18
14102: PUSH
14103: LD_INT 23
14105: PUSH
14106: LD_INT 1
14108: PUSH
14109: LD_INT 1
14111: PUSH
14112: LD_INT 45
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: ST_TO_ADDR
// d3 := [ ru_heavy_wheeled , engine_combustion , control_manual , ru_heavy_gun ] ;
14121: LD_ADDR_LOC 19
14125: PUSH
14126: LD_INT 23
14128: PUSH
14129: LD_INT 1
14131: PUSH
14132: LD_INT 1
14134: PUSH
14135: LD_INT 46
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: ST_TO_ADDR
// d5 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_gatling_gun ] ;
14144: LD_ADDR_LOC 20
14148: PUSH
14149: LD_INT 23
14151: PUSH
14152: LD_INT 3
14154: PUSH
14155: LD_INT 3
14157: PUSH
14158: LD_INT 43
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: ST_TO_ADDR
// d6 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_rocket_launcher ] ;
14167: LD_ADDR_LOC 21
14171: PUSH
14172: LD_INT 23
14174: PUSH
14175: LD_INT 3
14177: PUSH
14178: LD_INT 3
14180: PUSH
14181: LD_INT 45
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: ST_TO_ADDR
// d7 := [ ru_heavy_wheeled , engine_siberite , control_computer , ru_heavy_gun ] ;
14190: LD_ADDR_LOC 22
14194: PUSH
14195: LD_INT 23
14197: PUSH
14198: LD_INT 3
14200: PUSH
14201: LD_INT 3
14203: PUSH
14204: LD_INT 46
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: ST_TO_ADDR
// end ;
14213: LD_VAR 0 1
14217: RET
// every 0 0$3 do var i , a ;
14218: GO 14220
14220: DISABLE
14221: LD_INT 0
14223: PPUSH
14224: PPUSH
// begin for i := 1 to 5 do
14225: LD_ADDR_VAR 0 1
14229: PUSH
14230: DOUBLE
14231: LD_INT 1
14233: DEC
14234: ST_TO_ADDR
14235: LD_INT 5
14237: PUSH
14238: FOR_TO
14239: IFFALSE 14463
// begin if ai_s [ i ] in ai then
14241: LD_EXP 23
14245: PUSH
14246: LD_VAR 0 1
14250: ARRAY
14251: PUSH
14252: LD_EXP 24
14256: IN
14257: IFFALSE 14461
// begin if depots [ i ] then
14259: LD_EXP 74
14263: PUSH
14264: LD_VAR 0 1
14268: ARRAY
14269: IFFALSE 14461
// begin if GetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans ) < 150 then
14271: LD_EXP 74
14275: PUSH
14276: LD_VAR 0 1
14280: ARRAY
14281: PUSH
14282: LD_INT 1
14284: ARRAY
14285: PPUSH
14286: CALL_OW 274
14290: PPUSH
14291: LD_INT 1
14293: PPUSH
14294: CALL_OW 275
14298: PUSH
14299: LD_INT 150
14301: LESS
14302: IFFALSE 14346
// SetResourceType ( GetBase ( depots [ i ] [ 1 ] ) , mat_cans , 150 + Rand ( 50 , 100 ) ) ;
14304: LD_EXP 74
14308: PUSH
14309: LD_VAR 0 1
14313: ARRAY
14314: PUSH
14315: LD_INT 1
14317: ARRAY
14318: PPUSH
14319: CALL_OW 274
14323: PPUSH
14324: LD_INT 1
14326: PPUSH
14327: LD_INT 150
14329: PUSH
14330: LD_INT 50
14332: PPUSH
14333: LD_INT 100
14335: PPUSH
14336: CALL_OW 12
14340: PLUS
14341: PPUSH
14342: CALL_OW 277
// a := GetListOfCratesInArea ( near_base_area [ i ] ) ;
14346: LD_ADDR_VAR 0 2
14350: PUSH
14351: LD_EXP 63
14355: PUSH
14356: LD_VAR 0 1
14360: ARRAY
14361: PPUSH
14362: CALL_OW 435
14366: ST_TO_ADDR
// if a > 6 then
14367: LD_VAR 0 2
14371: PUSH
14372: LD_INT 6
14374: GREATER
14375: IFFALSE 14461
// for i in a do
14377: LD_ADDR_VAR 0 1
14381: PUSH
14382: LD_VAR 0 2
14386: PUSH
14387: FOR_IN
14388: IFFALSE 14459
// if not SeeXY ( you , i [ 1 ] , i [ 2 ] ) then
14390: LD_EXP 7
14394: PPUSH
14395: LD_VAR 0 1
14399: PUSH
14400: LD_INT 1
14402: ARRAY
14403: PPUSH
14404: LD_VAR 0 1
14408: PUSH
14409: LD_INT 2
14411: ARRAY
14412: PPUSH
14413: CALL_OW 293
14417: NOT
14418: IFFALSE 14457
// begin MoveAreaXY ( hexik , i [ 1 ] , i [ 2 ] ) ;
14420: LD_INT 32
14422: PPUSH
14423: LD_VAR 0 1
14427: PUSH
14428: LD_INT 1
14430: ARRAY
14431: PPUSH
14432: LD_VAR 0 1
14436: PUSH
14437: LD_INT 2
14439: ARRAY
14440: PPUSH
14441: CALL_OW 425
// EraseResourceArea ( hexik , mat_cans ) ;
14445: LD_INT 32
14447: PPUSH
14448: LD_INT 1
14450: PPUSH
14451: CALL_OW 286
// break ;
14455: GO 14459
// end ;
14457: GO 14387
14459: POP
14460: POP
// end ; end ; end ;
14461: GO 14238
14463: POP
14464: POP
// end ;
14465: PPOPN 2
14467: END
// function MyCanBeConstructed ( tfact , d ) ; begin
14468: LD_INT 0
14470: PPUSH
// result := CanBeConstructed ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_VAR 0 1
14480: PPUSH
14481: LD_VAR 0 2
14485: PUSH
14486: LD_INT 1
14488: ARRAY
14489: PPUSH
14490: LD_VAR 0 2
14494: PUSH
14495: LD_INT 2
14497: ARRAY
14498: PPUSH
14499: LD_VAR 0 2
14503: PUSH
14504: LD_INT 3
14506: ARRAY
14507: PPUSH
14508: LD_VAR 0 2
14512: PUSH
14513: LD_INT 4
14515: ARRAY
14516: PPUSH
14517: CALL_OW 448
14521: ST_TO_ADDR
// end ;
14522: LD_VAR 0 3
14526: RET
// function MyComConstruct ( tfact , d ) ; begin
14527: LD_INT 0
14529: PPUSH
// result := ComConstruct ( tfact , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ;
14530: LD_ADDR_VAR 0 3
14534: PUSH
14535: LD_VAR 0 1
14539: PPUSH
14540: LD_VAR 0 2
14544: PUSH
14545: LD_INT 1
14547: ARRAY
14548: PPUSH
14549: LD_VAR 0 2
14553: PUSH
14554: LD_INT 2
14556: ARRAY
14557: PPUSH
14558: LD_VAR 0 2
14562: PUSH
14563: LD_INT 3
14565: ARRAY
14566: PPUSH
14567: LD_VAR 0 2
14571: PUSH
14572: LD_INT 4
14574: ARRAY
14575: PPUSH
14576: CALL_OW 125
14580: ST_TO_ADDR
// end ;
14581: LD_VAR 0 3
14585: RET
// every 0 0$10 + 0 0$1.1 trigger IsOk ( factories [ 1 ] ) and IsIdle ( factories [ 1 ] ) do var a , tfact , def , att ;
14586: LD_EXP 73
14590: PUSH
14591: LD_INT 1
14593: ARRAY
14594: PPUSH
14595: CALL_OW 302
14599: PUSH
14600: LD_EXP 73
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: PPUSH
14609: CALL_OW 316
14613: AND
14614: IFFALSE 14933
14616: GO 14618
14618: DISABLE
14619: LD_INT 0
14621: PPUSH
14622: PPUSH
14623: PPUSH
14624: PPUSH
// begin tfact := factories [ 1 ] ;
14625: LD_ADDR_VAR 0 2
14629: PUSH
14630: LD_EXP 73
14634: PUSH
14635: LD_INT 1
14637: ARRAY
14638: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 1 ] , [ mf_manu ] ) ;
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_EXP 77
14648: PUSH
14649: LD_INT 1
14651: ARRAY
14652: PPUSH
14653: LD_EXP 61
14657: PUSH
14658: EMPTY
14659: LIST
14660: PPUSH
14661: CALL_OW 72
14665: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 1 ] , [ mf_comp ] ) ;
14666: LD_ADDR_VAR 0 4
14670: PUSH
14671: LD_EXP 77
14675: PUSH
14676: LD_INT 1
14678: ARRAY
14679: PPUSH
14680: LD_EXP 60
14684: PUSH
14685: EMPTY
14686: LIST
14687: PPUSH
14688: CALL_OW 72
14692: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
14693: LD_INT 1
14695: PUSH
14696: LD_VAR 0 3
14700: PUSH
14701: LD_INT 2
14703: LESS
14704: PUSH
14705: LD_VAR 0 2
14709: PPUSH
14710: LD_LOC 18
14714: PPUSH
14715: CALL 14468 0 2
14719: AND
14720: DOUBLE
14721: EQUAL
14722: IFTRUE 14726
14724: GO 14743
14726: POP
// begin MyComConstruct ( tfact , d2 ) ;
14727: LD_VAR 0 2
14731: PPUSH
14732: LD_LOC 18
14736: PPUSH
14737: CALL 14527 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
14741: GO 14932
14743: LD_VAR 0 3
14747: PUSH
14748: LD_INT 3
14750: LESS
14751: PUSH
14752: LD_VAR 0 2
14756: PPUSH
14757: LD_LOC 19
14761: PPUSH
14762: CALL 14468 0 2
14766: AND
14767: DOUBLE
14768: EQUAL
14769: IFTRUE 14773
14771: GO 14790
14773: POP
// begin MyComConstruct ( tfact , d3 ) ;
14774: LD_VAR 0 2
14778: PPUSH
14779: LD_LOC 19
14783: PPUSH
14784: CALL 14527 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
14788: GO 14932
14790: LD_VAR 0 4
14794: PUSH
14795: LD_INT 2
14797: LESS
14798: PUSH
14799: LD_VAR 0 2
14803: PPUSH
14804: LD_LOC 21
14808: PPUSH
14809: CALL 14468 0 2
14813: AND
14814: DOUBLE
14815: EQUAL
14816: IFTRUE 14820
14818: GO 14837
14820: POP
// begin MyComConstruct ( tfact , d6 ) ;
14821: LD_VAR 0 2
14825: PPUSH
14826: LD_LOC 21
14830: PPUSH
14831: CALL 14527 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
14835: GO 14932
14837: LD_VAR 0 4
14841: PUSH
14842: LD_INT 3
14844: LESS
14845: PUSH
14846: LD_VAR 0 2
14850: PPUSH
14851: LD_LOC 20
14855: PPUSH
14856: CALL 14468 0 2
14860: AND
14861: DOUBLE
14862: EQUAL
14863: IFTRUE 14867
14865: GO 14884
14867: POP
// begin MyComConstruct ( tfact , d5 ) ;
14868: LD_VAR 0 2
14872: PPUSH
14873: LD_LOC 20
14877: PPUSH
14878: CALL 14527 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
14882: GO 14932
14884: LD_VAR 0 4
14888: PUSH
14889: LD_INT 5
14891: LESS
14892: PUSH
14893: LD_VAR 0 2
14897: PPUSH
14898: LD_LOC 22
14902: PPUSH
14903: CALL 14468 0 2
14907: AND
14908: DOUBLE
14909: EQUAL
14910: IFTRUE 14914
14912: GO 14931
14914: POP
// begin MyComConstruct ( tfact , d7 ) ;
14915: LD_VAR 0 2
14919: PPUSH
14920: LD_LOC 22
14924: PPUSH
14925: CALL 14527 0 2
// end ; end ;
14929: GO 14932
14931: POP
// enable ;
14932: ENABLE
// end ;
14933: PPOPN 4
14935: END
// every 0 0$10 + 0 0$2.3 trigger IsOk ( factories [ 2 ] ) and IsIdle ( factories [ 2 ] ) do var a , tfact , def , att ;
14936: LD_EXP 73
14940: PUSH
14941: LD_INT 2
14943: ARRAY
14944: PPUSH
14945: CALL_OW 302
14949: PUSH
14950: LD_EXP 73
14954: PUSH
14955: LD_INT 2
14957: ARRAY
14958: PPUSH
14959: CALL_OW 316
14963: AND
14964: IFFALSE 15283
14966: GO 14968
14968: DISABLE
14969: LD_INT 0
14971: PPUSH
14972: PPUSH
14973: PPUSH
14974: PPUSH
// begin tfact := factories [ 2 ] ;
14975: LD_ADDR_VAR 0 2
14979: PUSH
14980: LD_EXP 73
14984: PUSH
14985: LD_INT 2
14987: ARRAY
14988: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 2 ] , [ mf_manu ] ) ;
14989: LD_ADDR_VAR 0 3
14993: PUSH
14994: LD_EXP 77
14998: PUSH
14999: LD_INT 2
15001: ARRAY
15002: PPUSH
15003: LD_EXP 61
15007: PUSH
15008: EMPTY
15009: LIST
15010: PPUSH
15011: CALL_OW 72
15015: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 2 ] , [ mf_comp ] ) ;
15016: LD_ADDR_VAR 0 4
15020: PUSH
15021: LD_EXP 77
15025: PUSH
15026: LD_INT 2
15028: ARRAY
15029: PPUSH
15030: LD_EXP 60
15034: PUSH
15035: EMPTY
15036: LIST
15037: PPUSH
15038: CALL_OW 72
15042: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15043: LD_INT 1
15045: PUSH
15046: LD_VAR 0 3
15050: PUSH
15051: LD_INT 2
15053: LESS
15054: PUSH
15055: LD_VAR 0 2
15059: PPUSH
15060: LD_LOC 18
15064: PPUSH
15065: CALL 14468 0 2
15069: AND
15070: DOUBLE
15071: EQUAL
15072: IFTRUE 15076
15074: GO 15093
15076: POP
// begin MyComConstruct ( tfact , d2 ) ;
15077: LD_VAR 0 2
15081: PPUSH
15082: LD_LOC 18
15086: PPUSH
15087: CALL 14527 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15091: GO 15282
15093: LD_VAR 0 3
15097: PUSH
15098: LD_INT 3
15100: LESS
15101: PUSH
15102: LD_VAR 0 2
15106: PPUSH
15107: LD_LOC 19
15111: PPUSH
15112: CALL 14468 0 2
15116: AND
15117: DOUBLE
15118: EQUAL
15119: IFTRUE 15123
15121: GO 15140
15123: POP
// begin MyComConstruct ( tfact , d3 ) ;
15124: LD_VAR 0 2
15128: PPUSH
15129: LD_LOC 19
15133: PPUSH
15134: CALL 14527 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15138: GO 15282
15140: LD_VAR 0 4
15144: PUSH
15145: LD_INT 2
15147: LESS
15148: PUSH
15149: LD_VAR 0 2
15153: PPUSH
15154: LD_LOC 21
15158: PPUSH
15159: CALL 14468 0 2
15163: AND
15164: DOUBLE
15165: EQUAL
15166: IFTRUE 15170
15168: GO 15187
15170: POP
// begin MyComConstruct ( tfact , d6 ) ;
15171: LD_VAR 0 2
15175: PPUSH
15176: LD_LOC 21
15180: PPUSH
15181: CALL 14527 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
15185: GO 15282
15187: LD_VAR 0 4
15191: PUSH
15192: LD_INT 3
15194: LESS
15195: PUSH
15196: LD_VAR 0 2
15200: PPUSH
15201: LD_LOC 20
15205: PPUSH
15206: CALL 14468 0 2
15210: AND
15211: DOUBLE
15212: EQUAL
15213: IFTRUE 15217
15215: GO 15234
15217: POP
// begin MyComConstruct ( tfact , d5 ) ;
15218: LD_VAR 0 2
15222: PPUSH
15223: LD_LOC 20
15227: PPUSH
15228: CALL 14527 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15232: GO 15282
15234: LD_VAR 0 4
15238: PUSH
15239: LD_INT 5
15241: LESS
15242: PUSH
15243: LD_VAR 0 2
15247: PPUSH
15248: LD_LOC 22
15252: PPUSH
15253: CALL 14468 0 2
15257: AND
15258: DOUBLE
15259: EQUAL
15260: IFTRUE 15264
15262: GO 15281
15264: POP
// begin MyComConstruct ( tfact , d7 ) ;
15265: LD_VAR 0 2
15269: PPUSH
15270: LD_LOC 22
15274: PPUSH
15275: CALL 14527 0 2
// end ; end ;
15279: GO 15282
15281: POP
// enable ;
15282: ENABLE
// end ;
15283: PPOPN 4
15285: END
// every 0 0$10 + 0 0$3.4 trigger IsOk ( factories [ 3 ] ) and IsIdle ( factories [ 3 ] ) do var a , tfact , def , att ;
15286: LD_EXP 73
15290: PUSH
15291: LD_INT 3
15293: ARRAY
15294: PPUSH
15295: CALL_OW 302
15299: PUSH
15300: LD_EXP 73
15304: PUSH
15305: LD_INT 3
15307: ARRAY
15308: PPUSH
15309: CALL_OW 316
15313: AND
15314: IFFALSE 15539
15316: GO 15318
15318: DISABLE
15319: LD_INT 0
15321: PPUSH
15322: PPUSH
15323: PPUSH
15324: PPUSH
// begin tfact := factories [ 3 ] ;
15325: LD_ADDR_VAR 0 2
15329: PUSH
15330: LD_EXP 73
15334: PUSH
15335: LD_INT 3
15337: ARRAY
15338: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 3 ] , [ mf_manu ] ) ;
15339: LD_ADDR_VAR 0 3
15343: PUSH
15344: LD_EXP 77
15348: PUSH
15349: LD_INT 3
15351: ARRAY
15352: PPUSH
15353: LD_EXP 61
15357: PUSH
15358: EMPTY
15359: LIST
15360: PPUSH
15361: CALL_OW 72
15365: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 3 ] , [ mf_comp ] ) ;
15366: LD_ADDR_VAR 0 4
15370: PUSH
15371: LD_EXP 77
15375: PUSH
15376: LD_INT 3
15378: ARRAY
15379: PPUSH
15380: LD_EXP 60
15384: PUSH
15385: EMPTY
15386: LIST
15387: PPUSH
15388: CALL_OW 72
15392: ST_TO_ADDR
// case true of def < 1 and MyCanBeConstructed ( tfact , d2 ) :
15393: LD_INT 1
15395: PUSH
15396: LD_VAR 0 3
15400: PUSH
15401: LD_INT 1
15403: LESS
15404: PUSH
15405: LD_VAR 0 2
15409: PPUSH
15410: LD_LOC 18
15414: PPUSH
15415: CALL 14468 0 2
15419: AND
15420: DOUBLE
15421: EQUAL
15422: IFTRUE 15426
15424: GO 15443
15426: POP
// begin MyComConstruct ( tfact , d2 ) ;
15427: LD_VAR 0 2
15431: PPUSH
15432: LD_LOC 18
15436: PPUSH
15437: CALL 14527 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15441: GO 15538
15443: LD_VAR 0 4
15447: PUSH
15448: LD_INT 2
15450: LESS
15451: PUSH
15452: LD_VAR 0 2
15456: PPUSH
15457: LD_LOC 21
15461: PPUSH
15462: CALL 14468 0 2
15466: AND
15467: DOUBLE
15468: EQUAL
15469: IFTRUE 15473
15471: GO 15490
15473: POP
// begin MyComConstruct ( tfact , d6 ) ;
15474: LD_VAR 0 2
15478: PPUSH
15479: LD_LOC 21
15483: PPUSH
15484: CALL 14527 0 2
// end ; att < 4 and MyCanBeConstructed ( tfact , d7 ) :
15488: GO 15538
15490: LD_VAR 0 4
15494: PUSH
15495: LD_INT 4
15497: LESS
15498: PUSH
15499: LD_VAR 0 2
15503: PPUSH
15504: LD_LOC 22
15508: PPUSH
15509: CALL 14468 0 2
15513: AND
15514: DOUBLE
15515: EQUAL
15516: IFTRUE 15520
15518: GO 15537
15520: POP
// begin MyComConstruct ( tfact , d7 ) ;
15521: LD_VAR 0 2
15525: PPUSH
15526: LD_LOC 22
15530: PPUSH
15531: CALL 14527 0 2
// end ; end ;
15535: GO 15538
15537: POP
// enable ;
15538: ENABLE
// end ;
15539: PPOPN 4
15541: END
// every 0 0$10 + 0 0$4.5 trigger IsOk ( factories [ 4 ] ) and IsIdle ( factories [ 4 ] ) do var a , tfact , def , att ;
15542: LD_EXP 73
15546: PUSH
15547: LD_INT 4
15549: ARRAY
15550: PPUSH
15551: CALL_OW 302
15555: PUSH
15556: LD_EXP 73
15560: PUSH
15561: LD_INT 4
15563: ARRAY
15564: PPUSH
15565: CALL_OW 316
15569: AND
15570: IFFALSE 15842
15572: GO 15574
15574: DISABLE
15575: LD_INT 0
15577: PPUSH
15578: PPUSH
15579: PPUSH
15580: PPUSH
// begin tfact := factories [ 4 ] ;
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_EXP 73
15590: PUSH
15591: LD_INT 4
15593: ARRAY
15594: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 4 ] , [ mf_manu ] ) ;
15595: LD_ADDR_VAR 0 3
15599: PUSH
15600: LD_EXP 77
15604: PUSH
15605: LD_INT 4
15607: ARRAY
15608: PPUSH
15609: LD_EXP 61
15613: PUSH
15614: EMPTY
15615: LIST
15616: PPUSH
15617: CALL_OW 72
15621: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 4 ] , [ mf_comp ] ) ;
15622: LD_ADDR_VAR 0 4
15626: PUSH
15627: LD_EXP 77
15631: PUSH
15632: LD_INT 4
15634: ARRAY
15635: PPUSH
15636: LD_EXP 60
15640: PUSH
15641: EMPTY
15642: LIST
15643: PPUSH
15644: CALL_OW 72
15648: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15649: LD_INT 1
15651: PUSH
15652: LD_VAR 0 3
15656: PUSH
15657: LD_INT 2
15659: LESS
15660: PUSH
15661: LD_VAR 0 2
15665: PPUSH
15666: LD_LOC 18
15670: PPUSH
15671: CALL 14468 0 2
15675: AND
15676: DOUBLE
15677: EQUAL
15678: IFTRUE 15682
15680: GO 15699
15682: POP
// begin MyComConstruct ( tfact , d2 ) ;
15683: LD_VAR 0 2
15687: PPUSH
15688: LD_LOC 18
15692: PPUSH
15693: CALL 14527 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
15697: GO 15841
15699: LD_VAR 0 3
15703: PUSH
15704: LD_INT 3
15706: LESS
15707: PUSH
15708: LD_VAR 0 2
15712: PPUSH
15713: LD_LOC 19
15717: PPUSH
15718: CALL 14468 0 2
15722: AND
15723: DOUBLE
15724: EQUAL
15725: IFTRUE 15729
15727: GO 15746
15729: POP
// begin MyComConstruct ( tfact , d3 ) ;
15730: LD_VAR 0 2
15734: PPUSH
15735: LD_LOC 19
15739: PPUSH
15740: CALL 14527 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
15744: GO 15841
15746: LD_VAR 0 4
15750: PUSH
15751: LD_INT 2
15753: LESS
15754: PUSH
15755: LD_VAR 0 2
15759: PPUSH
15760: LD_LOC 21
15764: PPUSH
15765: CALL 14468 0 2
15769: AND
15770: DOUBLE
15771: EQUAL
15772: IFTRUE 15776
15774: GO 15793
15776: POP
// begin MyComConstruct ( tfact , d6 ) ;
15777: LD_VAR 0 2
15781: PPUSH
15782: LD_LOC 21
15786: PPUSH
15787: CALL 14527 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
15791: GO 15841
15793: LD_VAR 0 4
15797: PUSH
15798: LD_INT 5
15800: LESS
15801: PUSH
15802: LD_VAR 0 2
15806: PPUSH
15807: LD_LOC 22
15811: PPUSH
15812: CALL 14468 0 2
15816: AND
15817: DOUBLE
15818: EQUAL
15819: IFTRUE 15823
15821: GO 15840
15823: POP
// begin MyComConstruct ( tfact , d7 ) ;
15824: LD_VAR 0 2
15828: PPUSH
15829: LD_LOC 22
15833: PPUSH
15834: CALL 14527 0 2
// end ; end ;
15838: GO 15841
15840: POP
// enable ;
15841: ENABLE
// end ;
15842: PPOPN 4
15844: END
// every 0 0$10 + 0 0$5.6 trigger IsOk ( factories [ 5 ] ) and IsIdle ( factories [ 5 ] ) do var a , tfact , def , att ;
15845: LD_EXP 73
15849: PUSH
15850: LD_INT 5
15852: ARRAY
15853: PPUSH
15854: CALL_OW 302
15858: PUSH
15859: LD_EXP 73
15863: PUSH
15864: LD_INT 5
15866: ARRAY
15867: PPUSH
15868: CALL_OW 316
15872: AND
15873: IFFALSE 16192
15875: GO 15877
15877: DISABLE
15878: LD_INT 0
15880: PPUSH
15881: PPUSH
15882: PPUSH
15883: PPUSH
// begin tfact := factories [ 5 ] ;
15884: LD_ADDR_VAR 0 2
15888: PUSH
15889: LD_EXP 73
15893: PUSH
15894: LD_INT 5
15896: ARRAY
15897: ST_TO_ADDR
// def := UnitFilter ( vehicles [ 5 ] , [ mf_manu ] ) ;
15898: LD_ADDR_VAR 0 3
15902: PUSH
15903: LD_EXP 77
15907: PUSH
15908: LD_INT 5
15910: ARRAY
15911: PPUSH
15912: LD_EXP 61
15916: PUSH
15917: EMPTY
15918: LIST
15919: PPUSH
15920: CALL_OW 72
15924: ST_TO_ADDR
// att := UnitFilter ( vehicles [ 5 ] , [ mf_comp ] ) ;
15925: LD_ADDR_VAR 0 4
15929: PUSH
15930: LD_EXP 77
15934: PUSH
15935: LD_INT 5
15937: ARRAY
15938: PPUSH
15939: LD_EXP 60
15943: PUSH
15944: EMPTY
15945: LIST
15946: PPUSH
15947: CALL_OW 72
15951: ST_TO_ADDR
// case true of def < 2 and MyCanBeConstructed ( tfact , d2 ) :
15952: LD_INT 1
15954: PUSH
15955: LD_VAR 0 3
15959: PUSH
15960: LD_INT 2
15962: LESS
15963: PUSH
15964: LD_VAR 0 2
15968: PPUSH
15969: LD_LOC 18
15973: PPUSH
15974: CALL 14468 0 2
15978: AND
15979: DOUBLE
15980: EQUAL
15981: IFTRUE 15985
15983: GO 16002
15985: POP
// begin MyComConstruct ( tfact , d2 ) ;
15986: LD_VAR 0 2
15990: PPUSH
15991: LD_LOC 18
15995: PPUSH
15996: CALL 14527 0 2
// end ; def < 3 and MyCanBeConstructed ( tfact , d3 ) :
16000: GO 16191
16002: LD_VAR 0 3
16006: PUSH
16007: LD_INT 3
16009: LESS
16010: PUSH
16011: LD_VAR 0 2
16015: PPUSH
16016: LD_LOC 19
16020: PPUSH
16021: CALL 14468 0 2
16025: AND
16026: DOUBLE
16027: EQUAL
16028: IFTRUE 16032
16030: GO 16049
16032: POP
// begin MyComConstruct ( tfact , d3 ) ;
16033: LD_VAR 0 2
16037: PPUSH
16038: LD_LOC 19
16042: PPUSH
16043: CALL 14527 0 2
// end ; att < 2 and MyCanBeConstructed ( tfact , d6 ) :
16047: GO 16191
16049: LD_VAR 0 4
16053: PUSH
16054: LD_INT 2
16056: LESS
16057: PUSH
16058: LD_VAR 0 2
16062: PPUSH
16063: LD_LOC 21
16067: PPUSH
16068: CALL 14468 0 2
16072: AND
16073: DOUBLE
16074: EQUAL
16075: IFTRUE 16079
16077: GO 16096
16079: POP
// begin MyComConstruct ( tfact , d6 ) ;
16080: LD_VAR 0 2
16084: PPUSH
16085: LD_LOC 21
16089: PPUSH
16090: CALL 14527 0 2
// end ; att < 3 and MyCanBeConstructed ( tfact , d5 ) :
16094: GO 16191
16096: LD_VAR 0 4
16100: PUSH
16101: LD_INT 3
16103: LESS
16104: PUSH
16105: LD_VAR 0 2
16109: PPUSH
16110: LD_LOC 20
16114: PPUSH
16115: CALL 14468 0 2
16119: AND
16120: DOUBLE
16121: EQUAL
16122: IFTRUE 16126
16124: GO 16143
16126: POP
// begin MyComConstruct ( tfact , d5 ) ;
16127: LD_VAR 0 2
16131: PPUSH
16132: LD_LOC 20
16136: PPUSH
16137: CALL 14527 0 2
// end ; att < 5 and MyCanBeConstructed ( tfact , d7 ) :
16141: GO 16191
16143: LD_VAR 0 4
16147: PUSH
16148: LD_INT 5
16150: LESS
16151: PUSH
16152: LD_VAR 0 2
16156: PPUSH
16157: LD_LOC 22
16161: PPUSH
16162: CALL 14468 0 2
16166: AND
16167: DOUBLE
16168: EQUAL
16169: IFTRUE 16173
16171: GO 16190
16173: POP
// begin MyComConstruct ( tfact , d7 ) ;
16174: LD_VAR 0 2
16178: PPUSH
16179: LD_LOC 22
16183: PPUSH
16184: CALL 14527 0 2
// end ; end ;
16188: GO 16191
16190: POP
// enable ;
16191: ENABLE
// end ; end_of_file
16192: PPOPN 4
16194: END
// var builds ; var aici ; var in_depots ; var abase ; export hlavouni ; var upgradeable ; var trough_upgrade ; export function inicializace_ai_b_build ; begin
16195: LD_INT 0
16197: PPUSH
// upgradeable := [ b_depot , b_workshop , b_armoury , b_lab , b_lab_half , b_lab ] ;
16198: LD_ADDR_LOC 27
16202: PUSH
16203: LD_INT 0
16205: PUSH
16206: LD_INT 2
16208: PUSH
16209: LD_INT 4
16211: PUSH
16212: LD_INT 6
16214: PUSH
16215: LD_INT 7
16217: PUSH
16218: LD_INT 6
16220: PUSH
16221: EMPTY
16222: LIST
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: ST_TO_ADDR
// trough_upgrade := [ b_warehouse , b_factory , b_barracks , b_lab_half , b_lab_full , b_lab_full ] ;
16229: LD_ADDR_LOC 28
16233: PUSH
16234: LD_INT 1
16236: PUSH
16237: LD_INT 3
16239: PUSH
16240: LD_INT 5
16242: PUSH
16243: LD_INT 7
16245: PUSH
16246: LD_INT 8
16248: PUSH
16249: LD_INT 8
16251: PUSH
16252: EMPTY
16253: LIST
16254: LIST
16255: LIST
16256: LIST
16257: LIST
16258: LIST
16259: ST_TO_ADDR
// abase := [ abase1 , abase2 , abase3 , abase4 , abase5 ] ;
16260: LD_ADDR_LOC 26
16264: PUSH
16265: LD_INT 5
16267: PUSH
16268: LD_INT 4
16270: PUSH
16271: LD_INT 3
16273: PUSH
16274: LD_INT 2
16276: PUSH
16277: LD_INT 1
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: LIST
16284: LIST
16285: LIST
16286: ST_TO_ADDR
// aici := [ [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 8 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 6 ] , [ 3 , class_scientistic , 6 ] , [ 8 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] , [ [ 1 , class_engineer , 8 ] , [ 3 , class_scientistic , 8 ] , [ 8 , class_soldier , 8 ] , [ 3 , class_mechanic , 8 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 4 ] , [ 3 , class_scientistic , 4 ] , [ 5 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 3 , class_scientistic , 5 ] , [ 5 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 0 , class_scientistic , 4 ] , [ 2 , class_soldier , 4 ] , [ 1 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 5 ] , [ 0 , class_scientistic , 5 ] , [ 2 , class_soldier , 5 ] , [ 1 , class_mechanic , 5 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 4 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 4 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 4 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] , [ [ [ 1 , class_engineer , 4 ] , [ 1 , class_scientistic , 4 ] , [ 3 , class_soldier , 4 ] , [ 3 , class_mechanic , 4 ] ] , [ [ 1 , class_engineer , 5 ] , [ 1 , class_scientistic , 5 ] , [ 3 , class_soldier , 5 ] , [ 3 , class_mechanic , 5 ] ] , [ [ 1 , class_engineer , 6 ] , [ 1 , class_scientistic , 6 ] , [ 3 , class_soldier , 6 ] , [ 3 , class_mechanic , 6 ] ] ] [ difficulty ] ] ;
16287: LD_ADDR_LOC 24
16291: PUSH
16292: LD_INT 1
16294: PUSH
16295: LD_INT 2
16297: PUSH
16298: LD_INT 4
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: LIST
16305: PUSH
16306: LD_INT 3
16308: PUSH
16309: LD_INT 4
16311: PUSH
16312: LD_INT 4
16314: PUSH
16315: EMPTY
16316: LIST
16317: LIST
16318: LIST
16319: PUSH
16320: LD_INT 8
16322: PUSH
16323: LD_INT 1
16325: PUSH
16326: LD_INT 4
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: LIST
16333: PUSH
16334: LD_INT 3
16336: PUSH
16337: LD_INT 3
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: LIST
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: LIST
16352: LIST
16353: PUSH
16354: LD_INT 1
16356: PUSH
16357: LD_INT 2
16359: PUSH
16360: LD_INT 6
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: PUSH
16368: LD_INT 3
16370: PUSH
16371: LD_INT 4
16373: PUSH
16374: LD_INT 6
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 8
16384: PUSH
16385: LD_INT 1
16387: PUSH
16388: LD_INT 6
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 3
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: LD_INT 6
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: LIST
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: LIST
16414: LIST
16415: PUSH
16416: LD_INT 1
16418: PUSH
16419: LD_INT 2
16421: PUSH
16422: LD_INT 8
16424: PUSH
16425: EMPTY
16426: LIST
16427: LIST
16428: LIST
16429: PUSH
16430: LD_INT 3
16432: PUSH
16433: LD_INT 4
16435: PUSH
16436: LD_INT 8
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: LIST
16443: PUSH
16444: LD_INT 8
16446: PUSH
16447: LD_INT 1
16449: PUSH
16450: LD_INT 8
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: LIST
16457: PUSH
16458: LD_INT 3
16460: PUSH
16461: LD_INT 3
16463: PUSH
16464: LD_INT 8
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: LIST
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: LIST
16476: LIST
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: LIST
16482: PUSH
16483: LD_OWVAR 67
16487: ARRAY
16488: PUSH
16489: LD_INT 1
16491: PUSH
16492: LD_INT 2
16494: PUSH
16495: LD_INT 4
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: LIST
16502: PUSH
16503: LD_INT 3
16505: PUSH
16506: LD_INT 4
16508: PUSH
16509: LD_INT 4
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: LIST
16516: PUSH
16517: LD_INT 5
16519: PUSH
16520: LD_INT 1
16522: PUSH
16523: LD_INT 4
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: LIST
16530: PUSH
16531: LD_INT 3
16533: PUSH
16534: LD_INT 3
16536: PUSH
16537: LD_INT 4
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: LIST
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: LIST
16549: LIST
16550: PUSH
16551: LD_INT 1
16553: PUSH
16554: LD_INT 2
16556: PUSH
16557: LD_INT 4
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PUSH
16565: LD_INT 3
16567: PUSH
16568: LD_INT 4
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: LIST
16578: PUSH
16579: LD_INT 5
16581: PUSH
16582: LD_INT 1
16584: PUSH
16585: LD_INT 4
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: PUSH
16593: LD_INT 3
16595: PUSH
16596: LD_INT 3
16598: PUSH
16599: LD_INT 4
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: PUSH
16607: EMPTY
16608: LIST
16609: LIST
16610: LIST
16611: LIST
16612: PUSH
16613: LD_INT 1
16615: PUSH
16616: LD_INT 2
16618: PUSH
16619: LD_INT 5
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: LIST
16626: PUSH
16627: LD_INT 3
16629: PUSH
16630: LD_INT 4
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: LIST
16640: PUSH
16641: LD_INT 5
16643: PUSH
16644: LD_INT 1
16646: PUSH
16647: LD_INT 5
16649: PUSH
16650: EMPTY
16651: LIST
16652: LIST
16653: LIST
16654: PUSH
16655: LD_INT 3
16657: PUSH
16658: LD_INT 3
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: LIST
16668: PUSH
16669: EMPTY
16670: LIST
16671: LIST
16672: LIST
16673: LIST
16674: PUSH
16675: EMPTY
16676: LIST
16677: LIST
16678: LIST
16679: PUSH
16680: LD_OWVAR 67
16684: ARRAY
16685: PUSH
16686: LD_INT 1
16688: PUSH
16689: LD_INT 2
16691: PUSH
16692: LD_INT 4
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: LIST
16699: PUSH
16700: LD_INT 0
16702: PUSH
16703: LD_INT 4
16705: PUSH
16706: LD_INT 4
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: PUSH
16714: LD_INT 2
16716: PUSH
16717: LD_INT 1
16719: PUSH
16720: LD_INT 4
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: LIST
16727: PUSH
16728: LD_INT 1
16730: PUSH
16731: LD_INT 3
16733: PUSH
16734: LD_INT 4
16736: PUSH
16737: EMPTY
16738: LIST
16739: LIST
16740: LIST
16741: PUSH
16742: EMPTY
16743: LIST
16744: LIST
16745: LIST
16746: LIST
16747: PUSH
16748: LD_INT 1
16750: PUSH
16751: LD_INT 2
16753: PUSH
16754: LD_INT 5
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: LIST
16761: PUSH
16762: LD_INT 0
16764: PUSH
16765: LD_INT 4
16767: PUSH
16768: LD_INT 5
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: LIST
16775: PUSH
16776: LD_INT 2
16778: PUSH
16779: LD_INT 1
16781: PUSH
16782: LD_INT 5
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: LIST
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: LD_INT 3
16795: PUSH
16796: LD_INT 5
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: LIST
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: LIST
16808: LIST
16809: PUSH
16810: LD_INT 1
16812: PUSH
16813: LD_INT 2
16815: PUSH
16816: LD_INT 5
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: PUSH
16824: LD_INT 0
16826: PUSH
16827: LD_INT 4
16829: PUSH
16830: LD_INT 5
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: LIST
16837: PUSH
16838: LD_INT 2
16840: PUSH
16841: LD_INT 1
16843: PUSH
16844: LD_INT 5
16846: PUSH
16847: EMPTY
16848: LIST
16849: LIST
16850: LIST
16851: PUSH
16852: LD_INT 1
16854: PUSH
16855: LD_INT 3
16857: PUSH
16858: LD_INT 5
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: LIST
16865: PUSH
16866: EMPTY
16867: LIST
16868: LIST
16869: LIST
16870: LIST
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: PUSH
16877: LD_OWVAR 67
16881: ARRAY
16882: PUSH
16883: LD_INT 1
16885: PUSH
16886: LD_INT 2
16888: PUSH
16889: LD_INT 4
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: LIST
16896: PUSH
16897: LD_INT 4
16899: PUSH
16900: LD_INT 4
16902: PUSH
16903: LD_INT 4
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: PUSH
16911: LD_INT 3
16913: PUSH
16914: LD_INT 1
16916: PUSH
16917: LD_INT 4
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: PUSH
16925: LD_INT 3
16927: PUSH
16928: LD_INT 3
16930: PUSH
16931: LD_INT 4
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: LIST
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: PUSH
16945: LD_INT 1
16947: PUSH
16948: LD_INT 2
16950: PUSH
16951: LD_INT 5
16953: PUSH
16954: EMPTY
16955: LIST
16956: LIST
16957: LIST
16958: PUSH
16959: LD_INT 4
16961: PUSH
16962: LD_INT 4
16964: PUSH
16965: LD_INT 5
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: PUSH
16973: LD_INT 3
16975: PUSH
16976: LD_INT 1
16978: PUSH
16979: LD_INT 5
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 3
16989: PUSH
16990: LD_INT 3
16992: PUSH
16993: LD_INT 5
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: PUSH
17007: LD_INT 1
17009: PUSH
17010: LD_INT 2
17012: PUSH
17013: LD_INT 6
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: LIST
17020: PUSH
17021: LD_INT 4
17023: PUSH
17024: LD_INT 4
17026: PUSH
17027: LD_INT 6
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 3
17037: PUSH
17038: LD_INT 1
17040: PUSH
17041: LD_INT 6
17043: PUSH
17044: EMPTY
17045: LIST
17046: LIST
17047: LIST
17048: PUSH
17049: LD_INT 3
17051: PUSH
17052: LD_INT 3
17054: PUSH
17055: LD_INT 6
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: LIST
17062: PUSH
17063: EMPTY
17064: LIST
17065: LIST
17066: LIST
17067: LIST
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: LIST
17073: PUSH
17074: LD_OWVAR 67
17078: ARRAY
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 4
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: LIST
17093: PUSH
17094: LD_INT 1
17096: PUSH
17097: LD_INT 4
17099: PUSH
17100: LD_INT 4
17102: PUSH
17103: EMPTY
17104: LIST
17105: LIST
17106: LIST
17107: PUSH
17108: LD_INT 3
17110: PUSH
17111: LD_INT 1
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: LIST
17121: PUSH
17122: LD_INT 3
17124: PUSH
17125: LD_INT 3
17127: PUSH
17128: LD_INT 4
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: LIST
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: PUSH
17142: LD_INT 1
17144: PUSH
17145: LD_INT 2
17147: PUSH
17148: LD_INT 5
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: LIST
17155: PUSH
17156: LD_INT 1
17158: PUSH
17159: LD_INT 4
17161: PUSH
17162: LD_INT 5
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 3
17172: PUSH
17173: LD_INT 1
17175: PUSH
17176: LD_INT 5
17178: PUSH
17179: EMPTY
17180: LIST
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 3
17186: PUSH
17187: LD_INT 3
17189: PUSH
17190: LD_INT 5
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: LIST
17197: PUSH
17198: EMPTY
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 1
17206: PUSH
17207: LD_INT 2
17209: PUSH
17210: LD_INT 6
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: LIST
17217: PUSH
17218: LD_INT 1
17220: PUSH
17221: LD_INT 4
17223: PUSH
17224: LD_INT 6
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: PUSH
17232: LD_INT 3
17234: PUSH
17235: LD_INT 1
17237: PUSH
17238: LD_INT 6
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: LIST
17245: PUSH
17246: LD_INT 3
17248: PUSH
17249: LD_INT 3
17251: PUSH
17252: LD_INT 6
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: LIST
17264: LIST
17265: PUSH
17266: EMPTY
17267: LIST
17268: LIST
17269: LIST
17270: PUSH
17271: LD_OWVAR 67
17275: ARRAY
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: LIST
17281: LIST
17282: LIST
17283: ST_TO_ADDR
// builds := [ [ [ b_warehouse , 24 , 9 , 3 , [ ] ] , [ b_barracks , 39 , 26 , 5 , [ ] ] , [ b_siberite_power , 9 , 11 , 2 , [ ] ] , [ b_turret , 45 , 20 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 44 , 25 , 2 , [ ru_heavy_gun ] ] , [ b_turret , 26 , 40 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 37 , 39 , 2 , [ ru_heavy_gun ] ] , [ b_bunker , 42 , 21 , 2 , [ ru_gatling_gun ] ] , [ b_bunker , 38 , 36 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 53 , 15 , 2 , [ ru_rocket_launcher ] ] , [ b_lab_full , 10 , 7 , 2 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_full , 34 , 10 , 3 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_factory , 20 , 21 , 2 , [ ] ] , [ b_ext_gun , 24 , 21 , 4 , [ ] ] , [ b_ext_rocket , 20 , 18 , 3 , [ ] ] , [ b_ext_siberium , 20 , 25 , 0 , [ ] ] , [ b_ext_computer , 17 , 21 , 1 , [ ] ] , [ b_ext_track , 16 , 17 , 2 , [ ] ] , [ b_siberite_mine , 20 , 34 , 0 , [ ] ] , [ b_siberite_power , 15 , 5 , 2 , [ ] ] , [ b_oil_mine , 14 , 23 , 2 , [ ] ] , [ b_teleport , 32 , 20 , 3 , [ ] ] ] , [ [ b_factory , 98 , 26 , 5 , [ ] ] , [ b_barracks , 80 , 13 , 0 , [ ] ] , [ b_siberite_power , 97 , 3 , 1 , [ ] ] , [ b_turret , 105 , 35 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 111 , 22 , 2 , [ ru_gatling_gun ] ] , [ b_turret , 115 , 27 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 65 , 3 , 3 , [ ru_rocket_launcher ] , 20 20$0 ] , [ b_turret , 68 , 3 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 71 , 4 , 3 , [ ru_heavy_gun ] ] , [ b_siberite_power , 101 , 4 , 5 , [ ] ] , [ b_turret , 108 , 35 , 2 , [ ru_heavy_gun ] ] , [ b_ext_track , 101 , 26 , 4 , [ ] ] , [ b_ext_gun , 98 , 22 , 3 , [ ] ] , [ b_ext_siberium , 94 , 26 , 1 , [ ] ] , [ b_ext_rocket , 98 , 29 , 0 , [ ] ] , [ b_ext_noncombat , 102 , 30 , 5 , [ ] ] , [ b_warehouse , 86 , 6 , 3 , [ ] ] , [ b_siberite_mine , 102 , 9 , 4 , [ ] ] , [ b_oil_mine , 77 , 3 , 4 , [ ] ] , [ b_lab_full , 100 , 17 , 4 , [ b_lab_siberium , b_lab_weapon ] ] , [ b_lab_half , 94 , 6 , 3 , [ b_lab_computer , b_lab_basic ] ] ] , [ [ b_warehouse , 90 , 141 , 0 , [ ] ] , [ b_barracks , 98 , 133 , 4 , [ ] ] , [ b_siberite_power , 72 , 133 , 2 , [ ] ] , [ b_bunker , 95 , 128 , 0 , [ ru_rocket_launcher ] ] , [ b_bunker , 80 , 122 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 95 , 128 , 0 , [ ru_rocket_launcher ] , 15 15$0 ] , [ b_turret , 80 , 122 , 2 , [ ru_rocket_launcher ] , 17 17$0 ] , [ b_turret , 112 , 154 , 1 , [ ru_rocket_launcher ] , 16 16$0 ] , [ b_turret , 78 , 124 , 2 , [ ru_heavy_gun ] , 20 20$0 ] , [ b_turret , 99 , 130 , 1 , [ ru_heavy_gun ] , 22 22$0 ] , [ b_turret , 112 , 151 , 1 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_factory , 81 , 135 , 5 , [ ] ] , [ b_ext_siberium , 84 , 135 , 4 , [ ] ] , [ b_ext_gun , 85 , 139 , 5 , [ ] ] , [ b_ext_track , 77 , 135 , 1 , [ ] ] , [ b_ext_rocket , 81 , 138 , 0 , [ ] , 14 14$0 ] , [ b_siberite_mine , 71 , 137 , 0 , [ ] ] , [ b_oil_mine , 69 , 133 , 5 , [ ] ] , [ b_lab_half , 102 , 153 , 0 , [ b_lab_computer , b_lab_basic ] , 35 35$0 ] , [ b_lab_full , 97 , 145 , 2 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 74 , 137 , 2 , [ ] ] , [ b_ext_computer , 81 , 131 , 3 , [ ] ] ] , [ [ b_warehouse , 217 , 129 , 3 , [ ] ] , [ b_siberite_power , 233 , 154 , 4 , [ ] ] , [ b_turret , 205 , 123 , 0 , [ ru_gatling_gun ] , 25 25$0 ] , [ b_turret , 200 , 142 , 4 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 135 , 4 , [ ru_heavy_gun ] , 28 28$0 ] , [ b_turret , 201 , 127 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 199 , 138 , 4 , [ ru_rocket_launcher ] ] , [ b_turret , 202 , 124 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 209 , 154 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 218 , 123 , 5 , [ ru_rocket_launcher ] ] , [ b_lab_full , 227 , 145 , 2 , [ b_lab_computer , b_lab_spacetime ] ] , [ b_lab_full , 221 , 153 , 4 , [ b_lab_weapon , b_lab_siberium ] ] , [ b_siberite_power , 231 , 155 , 4 , [ ] ] , [ b_oil_mine , 224 , 134 , 4 , [ ] ] , [ b_siberite_mine , 224 , 150 , 2 , [ ] ] , [ b_factory , 207 , 141 , 1 , [ ] ] , [ b_ext_computer , 211 , 145 , 5 , [ ] ] , [ b_ext_siberium , 207 , 144 , 0 , [ ] ] , [ b_ext_rocket , 203 , 141 , 1 , [ ] ] , [ b_ext_track , 204 , 138 , 2 , [ ] ] , [ b_ext_gun , 207 , 137 , 3 , [ ] ] , [ b_armoury , 210 , 128 , 2 , [ ] , 35 35$0 ] , [ b_armoury , 210 , 128 , 2 , [ ] ] ] , [ [ b_warehouse , 184 , 73 , 3 , [ ] ] , [ b_barracks , 188 , 94 , 5 , [ ] ] , [ b_turret , 171 , 92 , 3 , [ ru_rocket_launcher ] ] , [ b_turret , 177 , 98 , 3 , [ ru_heavy_gun ] ] , [ b_turret , 169 , 69 , 5 , [ ru_heavy_gun ] ] , [ b_turret , 170 , 66 , 5 , [ ru_rocket_launcher ] ] , [ b_turret , 184 , 62 , 5 , [ ru_gatling_gun ] ] , [ b_turret , 203 , 102 , 2 , [ ru_rocket_launcher ] , 30 30$0 ] , [ b_turret , 195 , 103 , 2 , [ ru_rocket_launcher ] ] , [ b_turret , 200 , 103 , 2 , [ ru_heavy_gun ] ] , [ b_siberite_power , 198 , 90 , 3 , [ ] ] , [ b_siberite_mine , 179 , 70 , 1 , [ ] ] , [ b_factory , 190 , 84 , 4 , [ ] ] , [ b_ext_gun , 190 , 88 , 0 , [ ] ] , [ b_ext_rocket , 193 , 87 , 5 , [ ] ] , [ b_ext_siberium , 194 , 84 , 4 , [ ] ] , [ b_ext_computer , 190 , 81 , 3 , [ ] ] , [ b_lab_full , 176 , 92 , 0 , [ b_lab_siberium , b_lab_basic ] ] , [ b_lab_full , 176 , 82 , 3 , [ b_lab_computer , b_lab_weapon ] ] , [ b_siberite_power , 196 , 92 , 5 , [ ] ] , [ b_siberite_power , 198 , 86 , 1 , [ ] ] , [ b_siberite_mine , 192 , 93 , 0 , [ ] ] ] ] ;
17284: LD_ADDR_LOC 23
17288: PUSH
17289: LD_INT 1
17291: PUSH
17292: LD_INT 24
17294: PUSH
17295: LD_INT 9
17297: PUSH
17298: LD_INT 3
17300: PUSH
17301: EMPTY
17302: PUSH
17303: EMPTY
17304: LIST
17305: LIST
17306: LIST
17307: LIST
17308: LIST
17309: PUSH
17310: LD_INT 5
17312: PUSH
17313: LD_INT 39
17315: PUSH
17316: LD_INT 26
17318: PUSH
17319: LD_INT 5
17321: PUSH
17322: EMPTY
17323: PUSH
17324: EMPTY
17325: LIST
17326: LIST
17327: LIST
17328: LIST
17329: LIST
17330: PUSH
17331: LD_INT 28
17333: PUSH
17334: LD_INT 9
17336: PUSH
17337: LD_INT 11
17339: PUSH
17340: LD_INT 2
17342: PUSH
17343: EMPTY
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: LIST
17349: LIST
17350: LIST
17351: PUSH
17352: LD_INT 33
17354: PUSH
17355: LD_INT 45
17357: PUSH
17358: LD_INT 20
17360: PUSH
17361: LD_INT 2
17363: PUSH
17364: LD_INT 45
17366: PUSH
17367: EMPTY
17368: LIST
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: LIST
17374: LIST
17375: LIST
17376: PUSH
17377: LD_INT 33
17379: PUSH
17380: LD_INT 44
17382: PUSH
17383: LD_INT 25
17385: PUSH
17386: LD_INT 2
17388: PUSH
17389: LD_INT 46
17391: PUSH
17392: EMPTY
17393: LIST
17394: PUSH
17395: EMPTY
17396: LIST
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: PUSH
17402: LD_INT 33
17404: PUSH
17405: LD_INT 26
17407: PUSH
17408: LD_INT 40
17410: PUSH
17411: LD_INT 3
17413: PUSH
17414: LD_INT 45
17416: PUSH
17417: EMPTY
17418: LIST
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: LIST
17426: PUSH
17427: LD_INT 33
17429: PUSH
17430: LD_INT 37
17432: PUSH
17433: LD_INT 39
17435: PUSH
17436: LD_INT 2
17438: PUSH
17439: LD_INT 46
17441: PUSH
17442: EMPTY
17443: LIST
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: PUSH
17452: LD_INT 32
17454: PUSH
17455: LD_INT 42
17457: PUSH
17458: LD_INT 21
17460: PUSH
17461: LD_INT 2
17463: PUSH
17464: LD_INT 43
17466: PUSH
17467: EMPTY
17468: LIST
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: LIST
17474: LIST
17475: LIST
17476: PUSH
17477: LD_INT 32
17479: PUSH
17480: LD_INT 38
17482: PUSH
17483: LD_INT 36
17485: PUSH
17486: LD_INT 2
17488: PUSH
17489: LD_INT 43
17491: PUSH
17492: EMPTY
17493: LIST
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: PUSH
17502: LD_INT 33
17504: PUSH
17505: LD_INT 53
17507: PUSH
17508: LD_INT 15
17510: PUSH
17511: LD_INT 2
17513: PUSH
17514: LD_INT 45
17516: PUSH
17517: EMPTY
17518: LIST
17519: PUSH
17520: EMPTY
17521: LIST
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: PUSH
17527: LD_INT 8
17529: PUSH
17530: LD_INT 10
17532: PUSH
17533: LD_INT 7
17535: PUSH
17536: LD_INT 2
17538: PUSH
17539: LD_INT 11
17541: PUSH
17542: LD_INT 10
17544: PUSH
17545: EMPTY
17546: LIST
17547: LIST
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: LIST
17553: LIST
17554: LIST
17555: PUSH
17556: LD_INT 8
17558: PUSH
17559: LD_INT 34
17561: PUSH
17562: LD_INT 10
17564: PUSH
17565: LD_INT 3
17567: PUSH
17568: LD_INT 12
17570: PUSH
17571: LD_INT 14
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: PUSH
17585: LD_INT 3
17587: PUSH
17588: LD_INT 20
17590: PUSH
17591: LD_INT 21
17593: PUSH
17594: LD_INT 2
17596: PUSH
17597: EMPTY
17598: PUSH
17599: EMPTY
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: PUSH
17606: LD_INT 17
17608: PUSH
17609: LD_INT 24
17611: PUSH
17612: LD_INT 21
17614: PUSH
17615: LD_INT 4
17617: PUSH
17618: EMPTY
17619: PUSH
17620: EMPTY
17621: LIST
17622: LIST
17623: LIST
17624: LIST
17625: LIST
17626: PUSH
17627: LD_INT 18
17629: PUSH
17630: LD_INT 20
17632: PUSH
17633: LD_INT 18
17635: PUSH
17636: LD_INT 3
17638: PUSH
17639: EMPTY
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: LIST
17645: LIST
17646: LIST
17647: PUSH
17648: LD_INT 21
17650: PUSH
17651: LD_INT 20
17653: PUSH
17654: LD_INT 25
17656: PUSH
17657: LD_INT 0
17659: PUSH
17660: EMPTY
17661: PUSH
17662: EMPTY
17663: LIST
17664: LIST
17665: LIST
17666: LIST
17667: LIST
17668: PUSH
17669: LD_INT 24
17671: PUSH
17672: LD_INT 17
17674: PUSH
17675: LD_INT 21
17677: PUSH
17678: LD_INT 1
17680: PUSH
17681: EMPTY
17682: PUSH
17683: EMPTY
17684: LIST
17685: LIST
17686: LIST
17687: LIST
17688: LIST
17689: PUSH
17690: LD_INT 16
17692: PUSH
17693: LD_INT 16
17695: PUSH
17696: LD_INT 17
17698: PUSH
17699: LD_INT 2
17701: PUSH
17702: EMPTY
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: LIST
17708: LIST
17709: LIST
17710: PUSH
17711: LD_INT 30
17713: PUSH
17714: LD_INT 20
17716: PUSH
17717: LD_INT 34
17719: PUSH
17720: LD_INT 0
17722: PUSH
17723: EMPTY
17724: PUSH
17725: EMPTY
17726: LIST
17727: LIST
17728: LIST
17729: LIST
17730: LIST
17731: PUSH
17732: LD_INT 28
17734: PUSH
17735: LD_INT 15
17737: PUSH
17738: LD_INT 5
17740: PUSH
17741: LD_INT 2
17743: PUSH
17744: EMPTY
17745: PUSH
17746: EMPTY
17747: LIST
17748: LIST
17749: LIST
17750: LIST
17751: LIST
17752: PUSH
17753: LD_INT 29
17755: PUSH
17756: LD_INT 14
17758: PUSH
17759: LD_INT 23
17761: PUSH
17762: LD_INT 2
17764: PUSH
17765: EMPTY
17766: PUSH
17767: EMPTY
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: PUSH
17774: LD_INT 34
17776: PUSH
17777: LD_INT 32
17779: PUSH
17780: LD_INT 20
17782: PUSH
17783: LD_INT 3
17785: PUSH
17786: EMPTY
17787: PUSH
17788: EMPTY
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 3
17821: PUSH
17822: LD_INT 98
17824: PUSH
17825: LD_INT 26
17827: PUSH
17828: LD_INT 5
17830: PUSH
17831: EMPTY
17832: PUSH
17833: EMPTY
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: LIST
17839: PUSH
17840: LD_INT 5
17842: PUSH
17843: LD_INT 80
17845: PUSH
17846: LD_INT 13
17848: PUSH
17849: LD_INT 0
17851: PUSH
17852: EMPTY
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: LIST
17858: LIST
17859: LIST
17860: PUSH
17861: LD_INT 28
17863: PUSH
17864: LD_INT 97
17866: PUSH
17867: LD_INT 3
17869: PUSH
17870: LD_INT 1
17872: PUSH
17873: EMPTY
17874: PUSH
17875: EMPTY
17876: LIST
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: PUSH
17882: LD_INT 33
17884: PUSH
17885: LD_INT 105
17887: PUSH
17888: LD_INT 35
17890: PUSH
17891: LD_INT 3
17893: PUSH
17894: LD_INT 45
17896: PUSH
17897: EMPTY
17898: LIST
17899: PUSH
17900: EMPTY
17901: LIST
17902: LIST
17903: LIST
17904: LIST
17905: LIST
17906: PUSH
17907: LD_INT 33
17909: PUSH
17910: LD_INT 111
17912: PUSH
17913: LD_INT 22
17915: PUSH
17916: LD_INT 2
17918: PUSH
17919: LD_INT 43
17921: PUSH
17922: EMPTY
17923: LIST
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: LIST
17929: LIST
17930: LIST
17931: PUSH
17932: LD_INT 33
17934: PUSH
17935: LD_INT 115
17937: PUSH
17938: LD_INT 27
17940: PUSH
17941: LD_INT 2
17943: PUSH
17944: LD_INT 45
17946: PUSH
17947: EMPTY
17948: LIST
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: PUSH
17957: LD_INT 33
17959: PUSH
17960: LD_INT 65
17962: PUSH
17963: LD_INT 3
17965: PUSH
17966: LD_INT 3
17968: PUSH
17969: LD_INT 45
17971: PUSH
17972: EMPTY
17973: LIST
17974: PUSH
17975: LD_INT 42000
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: LIST
17982: LIST
17983: LIST
17984: LIST
17985: PUSH
17986: LD_INT 33
17988: PUSH
17989: LD_INT 68
17991: PUSH
17992: LD_INT 3
17994: PUSH
17995: LD_INT 3
17997: PUSH
17998: LD_INT 45
18000: PUSH
18001: EMPTY
18002: LIST
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 33
18013: PUSH
18014: LD_INT 71
18016: PUSH
18017: LD_INT 4
18019: PUSH
18020: LD_INT 3
18022: PUSH
18023: LD_INT 46
18025: PUSH
18026: EMPTY
18027: LIST
18028: PUSH
18029: EMPTY
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: PUSH
18036: LD_INT 28
18038: PUSH
18039: LD_INT 101
18041: PUSH
18042: LD_INT 4
18044: PUSH
18045: LD_INT 5
18047: PUSH
18048: EMPTY
18049: PUSH
18050: EMPTY
18051: LIST
18052: LIST
18053: LIST
18054: LIST
18055: LIST
18056: PUSH
18057: LD_INT 33
18059: PUSH
18060: LD_INT 108
18062: PUSH
18063: LD_INT 35
18065: PUSH
18066: LD_INT 2
18068: PUSH
18069: LD_INT 46
18071: PUSH
18072: EMPTY
18073: LIST
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: LIST
18079: LIST
18080: LIST
18081: PUSH
18082: LD_INT 16
18084: PUSH
18085: LD_INT 101
18087: PUSH
18088: LD_INT 26
18090: PUSH
18091: LD_INT 4
18093: PUSH
18094: EMPTY
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 17
18105: PUSH
18106: LD_INT 98
18108: PUSH
18109: LD_INT 22
18111: PUSH
18112: LD_INT 3
18114: PUSH
18115: EMPTY
18116: PUSH
18117: EMPTY
18118: LIST
18119: LIST
18120: LIST
18121: LIST
18122: LIST
18123: PUSH
18124: LD_INT 21
18126: PUSH
18127: LD_INT 94
18129: PUSH
18130: LD_INT 26
18132: PUSH
18133: LD_INT 1
18135: PUSH
18136: EMPTY
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: LIST
18142: LIST
18143: LIST
18144: PUSH
18145: LD_INT 18
18147: PUSH
18148: LD_INT 98
18150: PUSH
18151: LD_INT 29
18153: PUSH
18154: LD_INT 0
18156: PUSH
18157: EMPTY
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: LIST
18163: LIST
18164: LIST
18165: PUSH
18166: LD_INT 19
18168: PUSH
18169: LD_INT 102
18171: PUSH
18172: LD_INT 30
18174: PUSH
18175: LD_INT 5
18177: PUSH
18178: EMPTY
18179: PUSH
18180: EMPTY
18181: LIST
18182: LIST
18183: LIST
18184: LIST
18185: LIST
18186: PUSH
18187: LD_INT 1
18189: PUSH
18190: LD_INT 86
18192: PUSH
18193: LD_INT 6
18195: PUSH
18196: LD_INT 3
18198: PUSH
18199: EMPTY
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: LIST
18205: LIST
18206: LIST
18207: PUSH
18208: LD_INT 30
18210: PUSH
18211: LD_INT 102
18213: PUSH
18214: LD_INT 9
18216: PUSH
18217: LD_INT 4
18219: PUSH
18220: EMPTY
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: PUSH
18229: LD_INT 29
18231: PUSH
18232: LD_INT 77
18234: PUSH
18235: LD_INT 3
18237: PUSH
18238: LD_INT 4
18240: PUSH
18241: EMPTY
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: PUSH
18250: LD_INT 8
18252: PUSH
18253: LD_INT 100
18255: PUSH
18256: LD_INT 17
18258: PUSH
18259: LD_INT 4
18261: PUSH
18262: LD_INT 11
18264: PUSH
18265: LD_INT 10
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: PUSH
18279: LD_INT 7
18281: PUSH
18282: LD_INT 94
18284: PUSH
18285: LD_INT 6
18287: PUSH
18288: LD_INT 3
18290: PUSH
18291: LD_INT 12
18293: PUSH
18294: LD_INT 9
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: LIST
18305: LIST
18306: LIST
18307: PUSH
18308: EMPTY
18309: LIST
18310: LIST
18311: LIST
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: LIST
18318: LIST
18319: LIST
18320: LIST
18321: LIST
18322: LIST
18323: LIST
18324: LIST
18325: LIST
18326: LIST
18327: LIST
18328: LIST
18329: LIST
18330: PUSH
18331: LD_INT 1
18333: PUSH
18334: LD_INT 90
18336: PUSH
18337: LD_INT 141
18339: PUSH
18340: LD_INT 0
18342: PUSH
18343: EMPTY
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: LIST
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 5
18354: PUSH
18355: LD_INT 98
18357: PUSH
18358: LD_INT 133
18360: PUSH
18361: LD_INT 4
18363: PUSH
18364: EMPTY
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: LIST
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 28
18375: PUSH
18376: LD_INT 72
18378: PUSH
18379: LD_INT 133
18381: PUSH
18382: LD_INT 2
18384: PUSH
18385: EMPTY
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: PUSH
18394: LD_INT 32
18396: PUSH
18397: LD_INT 95
18399: PUSH
18400: LD_INT 128
18402: PUSH
18403: LD_INT 0
18405: PUSH
18406: LD_INT 45
18408: PUSH
18409: EMPTY
18410: LIST
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: PUSH
18419: LD_INT 32
18421: PUSH
18422: LD_INT 80
18424: PUSH
18425: LD_INT 122
18427: PUSH
18428: LD_INT 2
18430: PUSH
18431: LD_INT 45
18433: PUSH
18434: EMPTY
18435: LIST
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: PUSH
18444: LD_INT 33
18446: PUSH
18447: LD_INT 95
18449: PUSH
18450: LD_INT 128
18452: PUSH
18453: LD_INT 0
18455: PUSH
18456: LD_INT 45
18458: PUSH
18459: EMPTY
18460: LIST
18461: PUSH
18462: LD_INT 31500
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: PUSH
18473: LD_INT 33
18475: PUSH
18476: LD_INT 80
18478: PUSH
18479: LD_INT 122
18481: PUSH
18482: LD_INT 2
18484: PUSH
18485: LD_INT 45
18487: PUSH
18488: EMPTY
18489: LIST
18490: PUSH
18491: LD_INT 35700
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: PUSH
18502: LD_INT 33
18504: PUSH
18505: LD_INT 112
18507: PUSH
18508: LD_INT 154
18510: PUSH
18511: LD_INT 1
18513: PUSH
18514: LD_INT 45
18516: PUSH
18517: EMPTY
18518: LIST
18519: PUSH
18520: LD_INT 33600
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: PUSH
18531: LD_INT 33
18533: PUSH
18534: LD_INT 78
18536: PUSH
18537: LD_INT 124
18539: PUSH
18540: LD_INT 2
18542: PUSH
18543: LD_INT 46
18545: PUSH
18546: EMPTY
18547: LIST
18548: PUSH
18549: LD_INT 42000
18551: PUSH
18552: EMPTY
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: LIST
18559: PUSH
18560: LD_INT 33
18562: PUSH
18563: LD_INT 99
18565: PUSH
18566: LD_INT 130
18568: PUSH
18569: LD_INT 1
18571: PUSH
18572: LD_INT 46
18574: PUSH
18575: EMPTY
18576: LIST
18577: PUSH
18578: LD_INT 46200
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: PUSH
18589: LD_INT 33
18591: PUSH
18592: LD_INT 112
18594: PUSH
18595: LD_INT 151
18597: PUSH
18598: LD_INT 1
18600: PUSH
18601: LD_INT 43
18603: PUSH
18604: EMPTY
18605: LIST
18606: PUSH
18607: LD_INT 52500
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: LIST
18614: LIST
18615: LIST
18616: LIST
18617: PUSH
18618: LD_INT 3
18620: PUSH
18621: LD_INT 81
18623: PUSH
18624: LD_INT 135
18626: PUSH
18627: LD_INT 5
18629: PUSH
18630: EMPTY
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: LIST
18636: LIST
18637: LIST
18638: PUSH
18639: LD_INT 21
18641: PUSH
18642: LD_INT 84
18644: PUSH
18645: LD_INT 135
18647: PUSH
18648: LD_INT 4
18650: PUSH
18651: EMPTY
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: LIST
18659: PUSH
18660: LD_INT 17
18662: PUSH
18663: LD_INT 85
18665: PUSH
18666: LD_INT 139
18668: PUSH
18669: LD_INT 5
18671: PUSH
18672: EMPTY
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: LIST
18678: LIST
18679: LIST
18680: PUSH
18681: LD_INT 16
18683: PUSH
18684: LD_INT 77
18686: PUSH
18687: LD_INT 135
18689: PUSH
18690: LD_INT 1
18692: PUSH
18693: EMPTY
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: LIST
18699: LIST
18700: LIST
18701: PUSH
18702: LD_INT 18
18704: PUSH
18705: LD_INT 81
18707: PUSH
18708: LD_INT 138
18710: PUSH
18711: LD_INT 0
18713: PUSH
18714: EMPTY
18715: PUSH
18716: LD_INT 29400
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: PUSH
18727: LD_INT 30
18729: PUSH
18730: LD_INT 71
18732: PUSH
18733: LD_INT 137
18735: PUSH
18736: LD_INT 0
18738: PUSH
18739: EMPTY
18740: PUSH
18741: EMPTY
18742: LIST
18743: LIST
18744: LIST
18745: LIST
18746: LIST
18747: PUSH
18748: LD_INT 29
18750: PUSH
18751: LD_INT 69
18753: PUSH
18754: LD_INT 133
18756: PUSH
18757: LD_INT 5
18759: PUSH
18760: EMPTY
18761: PUSH
18762: EMPTY
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: PUSH
18769: LD_INT 7
18771: PUSH
18772: LD_INT 102
18774: PUSH
18775: LD_INT 153
18777: PUSH
18778: LD_INT 0
18780: PUSH
18781: LD_INT 12
18783: PUSH
18784: LD_INT 9
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: LD_INT 73500
18793: PUSH
18794: EMPTY
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 8
18804: PUSH
18805: LD_INT 97
18807: PUSH
18808: LD_INT 145
18810: PUSH
18811: LD_INT 2
18813: PUSH
18814: LD_INT 10
18816: PUSH
18817: LD_INT 11
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PUSH
18824: EMPTY
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: PUSH
18831: LD_INT 28
18833: PUSH
18834: LD_INT 74
18836: PUSH
18837: LD_INT 137
18839: PUSH
18840: LD_INT 2
18842: PUSH
18843: EMPTY
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 24
18854: PUSH
18855: LD_INT 81
18857: PUSH
18858: LD_INT 131
18860: PUSH
18861: LD_INT 3
18863: PUSH
18864: EMPTY
18865: PUSH
18866: EMPTY
18867: LIST
18868: LIST
18869: LIST
18870: LIST
18871: LIST
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: LIST
18880: LIST
18881: LIST
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: LIST
18895: LIST
18896: PUSH
18897: LD_INT 1
18899: PUSH
18900: LD_INT 217
18902: PUSH
18903: LD_INT 129
18905: PUSH
18906: LD_INT 3
18908: PUSH
18909: EMPTY
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: LIST
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 28
18920: PUSH
18921: LD_INT 233
18923: PUSH
18924: LD_INT 154
18926: PUSH
18927: LD_INT 4
18929: PUSH
18930: EMPTY
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: LIST
18936: LIST
18937: LIST
18938: PUSH
18939: LD_INT 33
18941: PUSH
18942: LD_INT 205
18944: PUSH
18945: LD_INT 123
18947: PUSH
18948: LD_INT 0
18950: PUSH
18951: LD_INT 43
18953: PUSH
18954: EMPTY
18955: LIST
18956: PUSH
18957: LD_INT 52500
18959: PUSH
18960: EMPTY
18961: LIST
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: LIST
18967: PUSH
18968: LD_INT 33
18970: PUSH
18971: LD_INT 200
18973: PUSH
18974: LD_INT 142
18976: PUSH
18977: LD_INT 4
18979: PUSH
18980: LD_INT 46
18982: PUSH
18983: EMPTY
18984: LIST
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: LIST
18990: LIST
18991: LIST
18992: PUSH
18993: LD_INT 33
18995: PUSH
18996: LD_INT 199
18998: PUSH
18999: LD_INT 135
19001: PUSH
19002: LD_INT 4
19004: PUSH
19005: LD_INT 46
19007: PUSH
19008: EMPTY
19009: LIST
19010: PUSH
19011: LD_INT 58800
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: LIST
19018: LIST
19019: LIST
19020: LIST
19021: PUSH
19022: LD_INT 33
19024: PUSH
19025: LD_INT 201
19027: PUSH
19028: LD_INT 127
19030: PUSH
19031: LD_INT 5
19033: PUSH
19034: LD_INT 46
19036: PUSH
19037: EMPTY
19038: LIST
19039: PUSH
19040: EMPTY
19041: LIST
19042: LIST
19043: LIST
19044: LIST
19045: LIST
19046: PUSH
19047: LD_INT 33
19049: PUSH
19050: LD_INT 199
19052: PUSH
19053: LD_INT 138
19055: PUSH
19056: LD_INT 4
19058: PUSH
19059: LD_INT 45
19061: PUSH
19062: EMPTY
19063: LIST
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: LIST
19069: LIST
19070: LIST
19071: PUSH
19072: LD_INT 33
19074: PUSH
19075: LD_INT 202
19077: PUSH
19078: LD_INT 124
19080: PUSH
19081: LD_INT 5
19083: PUSH
19084: LD_INT 45
19086: PUSH
19087: EMPTY
19088: LIST
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: LIST
19094: LIST
19095: LIST
19096: PUSH
19097: LD_INT 33
19099: PUSH
19100: LD_INT 209
19102: PUSH
19103: LD_INT 154
19105: PUSH
19106: LD_INT 3
19108: PUSH
19109: LD_INT 45
19111: PUSH
19112: EMPTY
19113: LIST
19114: PUSH
19115: EMPTY
19116: LIST
19117: LIST
19118: LIST
19119: LIST
19120: LIST
19121: PUSH
19122: LD_INT 33
19124: PUSH
19125: LD_INT 218
19127: PUSH
19128: LD_INT 123
19130: PUSH
19131: LD_INT 5
19133: PUSH
19134: LD_INT 45
19136: PUSH
19137: EMPTY
19138: LIST
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: LIST
19144: LIST
19145: LIST
19146: PUSH
19147: LD_INT 8
19149: PUSH
19150: LD_INT 227
19152: PUSH
19153: LD_INT 145
19155: PUSH
19156: LD_INT 2
19158: PUSH
19159: LD_INT 12
19161: PUSH
19162: LD_INT 14
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: PUSH
19169: EMPTY
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: PUSH
19176: LD_INT 8
19178: PUSH
19179: LD_INT 221
19181: PUSH
19182: LD_INT 153
19184: PUSH
19185: LD_INT 4
19187: PUSH
19188: LD_INT 10
19190: PUSH
19191: LD_INT 11
19193: PUSH
19194: EMPTY
19195: LIST
19196: LIST
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: PUSH
19205: LD_INT 28
19207: PUSH
19208: LD_INT 231
19210: PUSH
19211: LD_INT 155
19213: PUSH
19214: LD_INT 4
19216: PUSH
19217: EMPTY
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: LIST
19223: LIST
19224: LIST
19225: PUSH
19226: LD_INT 29
19228: PUSH
19229: LD_INT 224
19231: PUSH
19232: LD_INT 134
19234: PUSH
19235: LD_INT 4
19237: PUSH
19238: EMPTY
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: LIST
19244: LIST
19245: LIST
19246: PUSH
19247: LD_INT 30
19249: PUSH
19250: LD_INT 224
19252: PUSH
19253: LD_INT 150
19255: PUSH
19256: LD_INT 2
19258: PUSH
19259: EMPTY
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: LD_INT 3
19270: PUSH
19271: LD_INT 207
19273: PUSH
19274: LD_INT 141
19276: PUSH
19277: LD_INT 1
19279: PUSH
19280: EMPTY
19281: PUSH
19282: EMPTY
19283: LIST
19284: LIST
19285: LIST
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 24
19291: PUSH
19292: LD_INT 211
19294: PUSH
19295: LD_INT 145
19297: PUSH
19298: LD_INT 5
19300: PUSH
19301: EMPTY
19302: PUSH
19303: EMPTY
19304: LIST
19305: LIST
19306: LIST
19307: LIST
19308: LIST
19309: PUSH
19310: LD_INT 21
19312: PUSH
19313: LD_INT 207
19315: PUSH
19316: LD_INT 144
19318: PUSH
19319: LD_INT 0
19321: PUSH
19322: EMPTY
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: LIST
19328: LIST
19329: LIST
19330: PUSH
19331: LD_INT 18
19333: PUSH
19334: LD_INT 203
19336: PUSH
19337: LD_INT 141
19339: PUSH
19340: LD_INT 1
19342: PUSH
19343: EMPTY
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: LIST
19351: PUSH
19352: LD_INT 16
19354: PUSH
19355: LD_INT 204
19357: PUSH
19358: LD_INT 138
19360: PUSH
19361: LD_INT 2
19363: PUSH
19364: EMPTY
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: PUSH
19373: LD_INT 17
19375: PUSH
19376: LD_INT 207
19378: PUSH
19379: LD_INT 137
19381: PUSH
19382: LD_INT 3
19384: PUSH
19385: EMPTY
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: LIST
19393: PUSH
19394: LD_INT 4
19396: PUSH
19397: LD_INT 210
19399: PUSH
19400: LD_INT 128
19402: PUSH
19403: LD_INT 2
19405: PUSH
19406: EMPTY
19407: PUSH
19408: LD_INT 73500
19410: PUSH
19411: EMPTY
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: PUSH
19419: LD_INT 4
19421: PUSH
19422: LD_INT 210
19424: PUSH
19425: LD_INT 128
19427: PUSH
19428: LD_INT 2
19430: PUSH
19431: EMPTY
19432: PUSH
19433: EMPTY
19434: LIST
19435: LIST
19436: LIST
19437: LIST
19438: LIST
19439: PUSH
19440: EMPTY
19441: LIST
19442: LIST
19443: LIST
19444: LIST
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: LIST
19450: LIST
19451: LIST
19452: LIST
19453: LIST
19454: LIST
19455: LIST
19456: LIST
19457: LIST
19458: LIST
19459: LIST
19460: LIST
19461: LIST
19462: LIST
19463: LIST
19464: PUSH
19465: LD_INT 1
19467: PUSH
19468: LD_INT 184
19470: PUSH
19471: LD_INT 73
19473: PUSH
19474: LD_INT 3
19476: PUSH
19477: EMPTY
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: LIST
19485: PUSH
19486: LD_INT 5
19488: PUSH
19489: LD_INT 188
19491: PUSH
19492: LD_INT 94
19494: PUSH
19495: LD_INT 5
19497: PUSH
19498: EMPTY
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: PUSH
19507: LD_INT 33
19509: PUSH
19510: LD_INT 171
19512: PUSH
19513: LD_INT 92
19515: PUSH
19516: LD_INT 3
19518: PUSH
19519: LD_INT 45
19521: PUSH
19522: EMPTY
19523: LIST
19524: PUSH
19525: EMPTY
19526: LIST
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: PUSH
19532: LD_INT 33
19534: PUSH
19535: LD_INT 177
19537: PUSH
19538: LD_INT 98
19540: PUSH
19541: LD_INT 3
19543: PUSH
19544: LD_INT 46
19546: PUSH
19547: EMPTY
19548: LIST
19549: PUSH
19550: EMPTY
19551: LIST
19552: LIST
19553: LIST
19554: LIST
19555: LIST
19556: PUSH
19557: LD_INT 33
19559: PUSH
19560: LD_INT 169
19562: PUSH
19563: LD_INT 69
19565: PUSH
19566: LD_INT 5
19568: PUSH
19569: LD_INT 46
19571: PUSH
19572: EMPTY
19573: LIST
19574: PUSH
19575: EMPTY
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 33
19584: PUSH
19585: LD_INT 170
19587: PUSH
19588: LD_INT 66
19590: PUSH
19591: LD_INT 5
19593: PUSH
19594: LD_INT 45
19596: PUSH
19597: EMPTY
19598: LIST
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: LIST
19606: PUSH
19607: LD_INT 33
19609: PUSH
19610: LD_INT 184
19612: PUSH
19613: LD_INT 62
19615: PUSH
19616: LD_INT 5
19618: PUSH
19619: LD_INT 43
19621: PUSH
19622: EMPTY
19623: LIST
19624: PUSH
19625: EMPTY
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: PUSH
19632: LD_INT 33
19634: PUSH
19635: LD_INT 203
19637: PUSH
19638: LD_INT 102
19640: PUSH
19641: LD_INT 2
19643: PUSH
19644: LD_INT 45
19646: PUSH
19647: EMPTY
19648: LIST
19649: PUSH
19650: LD_INT 63000
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: LIST
19660: PUSH
19661: LD_INT 33
19663: PUSH
19664: LD_INT 195
19666: PUSH
19667: LD_INT 103
19669: PUSH
19670: LD_INT 2
19672: PUSH
19673: LD_INT 45
19675: PUSH
19676: EMPTY
19677: LIST
19678: PUSH
19679: EMPTY
19680: LIST
19681: LIST
19682: LIST
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 33
19688: PUSH
19689: LD_INT 200
19691: PUSH
19692: LD_INT 103
19694: PUSH
19695: LD_INT 2
19697: PUSH
19698: LD_INT 46
19700: PUSH
19701: EMPTY
19702: LIST
19703: PUSH
19704: EMPTY
19705: LIST
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: PUSH
19711: LD_INT 28
19713: PUSH
19714: LD_INT 198
19716: PUSH
19717: LD_INT 90
19719: PUSH
19720: LD_INT 3
19722: PUSH
19723: EMPTY
19724: PUSH
19725: EMPTY
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: PUSH
19732: LD_INT 30
19734: PUSH
19735: LD_INT 179
19737: PUSH
19738: LD_INT 70
19740: PUSH
19741: LD_INT 1
19743: PUSH
19744: EMPTY
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: LIST
19750: LIST
19751: LIST
19752: PUSH
19753: LD_INT 3
19755: PUSH
19756: LD_INT 190
19758: PUSH
19759: LD_INT 84
19761: PUSH
19762: LD_INT 4
19764: PUSH
19765: EMPTY
19766: PUSH
19767: EMPTY
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: LIST
19773: PUSH
19774: LD_INT 17
19776: PUSH
19777: LD_INT 190
19779: PUSH
19780: LD_INT 88
19782: PUSH
19783: LD_INT 0
19785: PUSH
19786: EMPTY
19787: PUSH
19788: EMPTY
19789: LIST
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: PUSH
19795: LD_INT 18
19797: PUSH
19798: LD_INT 193
19800: PUSH
19801: LD_INT 87
19803: PUSH
19804: LD_INT 5
19806: PUSH
19807: EMPTY
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: LIST
19815: PUSH
19816: LD_INT 21
19818: PUSH
19819: LD_INT 194
19821: PUSH
19822: LD_INT 84
19824: PUSH
19825: LD_INT 4
19827: PUSH
19828: EMPTY
19829: PUSH
19830: EMPTY
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: PUSH
19837: LD_INT 24
19839: PUSH
19840: LD_INT 190
19842: PUSH
19843: LD_INT 81
19845: PUSH
19846: LD_INT 3
19848: PUSH
19849: EMPTY
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: LIST
19857: PUSH
19858: LD_INT 8
19860: PUSH
19861: LD_INT 176
19863: PUSH
19864: LD_INT 92
19866: PUSH
19867: LD_INT 0
19869: PUSH
19870: LD_INT 11
19872: PUSH
19873: LD_INT 9
19875: PUSH
19876: EMPTY
19877: LIST
19878: LIST
19879: PUSH
19880: EMPTY
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: LIST
19886: PUSH
19887: LD_INT 8
19889: PUSH
19890: LD_INT 176
19892: PUSH
19893: LD_INT 82
19895: PUSH
19896: LD_INT 3
19898: PUSH
19899: LD_INT 12
19901: PUSH
19902: LD_INT 10
19904: PUSH
19905: EMPTY
19906: LIST
19907: LIST
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: LIST
19913: LIST
19914: LIST
19915: PUSH
19916: LD_INT 28
19918: PUSH
19919: LD_INT 196
19921: PUSH
19922: LD_INT 92
19924: PUSH
19925: LD_INT 5
19927: PUSH
19928: EMPTY
19929: PUSH
19930: EMPTY
19931: LIST
19932: LIST
19933: LIST
19934: LIST
19935: LIST
19936: PUSH
19937: LD_INT 28
19939: PUSH
19940: LD_INT 198
19942: PUSH
19943: LD_INT 86
19945: PUSH
19946: LD_INT 1
19948: PUSH
19949: EMPTY
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: LIST
19957: PUSH
19958: LD_INT 30
19960: PUSH
19961: LD_INT 192
19963: PUSH
19964: LD_INT 93
19966: PUSH
19967: LD_INT 0
19969: PUSH
19970: EMPTY
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: PUSH
19979: EMPTY
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: LIST
19991: LIST
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: LIST
19998: LIST
19999: LIST
20000: LIST
20001: LIST
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: LIST
20008: LIST
20009: ST_TO_ADDR
// in_depots := [ [ 820 , 720 , 421 ] , [ 770 , 620 , 320 ] , [ 680 , 900 , 310 ] , [ 730 , 920 , 240 ] , [ 510 , 810 , 300 ] ] ;
20010: LD_ADDR_LOC 25
20014: PUSH
20015: LD_INT 820
20017: PUSH
20018: LD_INT 720
20020: PUSH
20021: LD_INT 421
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: LIST
20028: PUSH
20029: LD_INT 770
20031: PUSH
20032: LD_INT 620
20034: PUSH
20035: LD_INT 320
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: LIST
20042: PUSH
20043: LD_INT 680
20045: PUSH
20046: LD_INT 900
20048: PUSH
20049: LD_INT 310
20051: PUSH
20052: EMPTY
20053: LIST
20054: LIST
20055: LIST
20056: PUSH
20057: LD_INT 730
20059: PUSH
20060: LD_INT 920
20062: PUSH
20063: LD_INT 240
20065: PUSH
20066: EMPTY
20067: LIST
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 510
20073: PUSH
20074: LD_INT 810
20076: PUSH
20077: LD_INT 300
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: LIST
20084: PUSH
20085: EMPTY
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: ST_TO_ADDR
// end ;
20092: LD_VAR 0 1
20096: RET
// function UpgradeableTo ( b , up ) ; var i ; begin
20097: LD_INT 0
20099: PPUSH
20100: PPUSH
// result := 0 ;
20101: LD_ADDR_VAR 0 3
20105: PUSH
20106: LD_INT 0
20108: ST_TO_ADDR
// for i := 1 to upgradeable do
20109: LD_ADDR_VAR 0 4
20113: PUSH
20114: DOUBLE
20115: LD_INT 1
20117: DEC
20118: ST_TO_ADDR
20119: LD_LOC 27
20123: PUSH
20124: FOR_TO
20125: IFFALSE 20177
// if b = upgradeable [ i ] and up = trough_upgrade [ i ] then
20127: LD_VAR 0 1
20131: PUSH
20132: LD_LOC 27
20136: PUSH
20137: LD_VAR 0 4
20141: ARRAY
20142: EQUAL
20143: PUSH
20144: LD_VAR 0 2
20148: PUSH
20149: LD_LOC 28
20153: PUSH
20154: LD_VAR 0 4
20158: ARRAY
20159: EQUAL
20160: AND
20161: IFFALSE 20175
// begin result := up ;
20163: LD_ADDR_VAR 0 3
20167: PUSH
20168: LD_VAR 0 2
20172: ST_TO_ADDR
// break ;
20173: GO 20177
// end ;
20175: GO 20124
20177: POP
20178: POP
// end ;
20179: LD_VAR 0 3
20183: RET
// function IsUpgraded ( b ) ; begin
20184: LD_INT 0
20186: PPUSH
// result := 0 ;
20187: LD_ADDR_VAR 0 2
20191: PUSH
20192: LD_INT 0
20194: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20195: LD_VAR 0 1
20199: PUSH
20200: LD_LOC 28
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: DOUBLE
20209: EQUAL
20210: IFTRUE 20214
20212: GO 20231
20214: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20215: LD_ADDR_VAR 0 2
20219: PUSH
20220: LD_LOC 27
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: ST_TO_ADDR
20229: GO 20356
20231: LD_LOC 28
20235: PUSH
20236: LD_INT 2
20238: ARRAY
20239: DOUBLE
20240: EQUAL
20241: IFTRUE 20245
20243: GO 20262
20245: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20246: LD_ADDR_VAR 0 2
20250: PUSH
20251: LD_LOC 27
20255: PUSH
20256: LD_INT 2
20258: ARRAY
20259: ST_TO_ADDR
20260: GO 20356
20262: LD_LOC 28
20266: PUSH
20267: LD_INT 3
20269: ARRAY
20270: DOUBLE
20271: EQUAL
20272: IFTRUE 20276
20274: GO 20293
20276: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20277: LD_ADDR_VAR 0 2
20281: PUSH
20282: LD_LOC 27
20286: PUSH
20287: LD_INT 3
20289: ARRAY
20290: ST_TO_ADDR
20291: GO 20356
20293: LD_LOC 28
20297: PUSH
20298: LD_INT 4
20300: ARRAY
20301: DOUBLE
20302: EQUAL
20303: IFTRUE 20307
20305: GO 20324
20307: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 5 ] :
20308: LD_ADDR_VAR 0 2
20312: PUSH
20313: LD_LOC 27
20317: PUSH
20318: LD_INT 4
20320: ARRAY
20321: ST_TO_ADDR
20322: GO 20356
20324: LD_LOC 28
20328: PUSH
20329: LD_INT 5
20331: ARRAY
20332: DOUBLE
20333: EQUAL
20334: IFTRUE 20338
20336: GO 20355
20338: POP
// result := upgradeable [ 5 ] ; end ;
20339: LD_ADDR_VAR 0 2
20343: PUSH
20344: LD_LOC 27
20348: PUSH
20349: LD_INT 5
20351: ARRAY
20352: ST_TO_ADDR
20353: GO 20356
20355: POP
// end ;
20356: LD_VAR 0 2
20360: RET
// function BasicFrom ( b ) ; begin
20361: LD_INT 0
20363: PPUSH
// result := b ;
20364: LD_ADDR_VAR 0 2
20368: PUSH
20369: LD_VAR 0 1
20373: ST_TO_ADDR
// case b of trough_upgrade [ 1 ] :
20374: LD_VAR 0 1
20378: PUSH
20379: LD_LOC 28
20383: PUSH
20384: LD_INT 1
20386: ARRAY
20387: DOUBLE
20388: EQUAL
20389: IFTRUE 20393
20391: GO 20410
20393: POP
// result := upgradeable [ 1 ] ; trough_upgrade [ 2 ] :
20394: LD_ADDR_VAR 0 2
20398: PUSH
20399: LD_LOC 27
20403: PUSH
20404: LD_INT 1
20406: ARRAY
20407: ST_TO_ADDR
20408: GO 20535
20410: LD_LOC 28
20414: PUSH
20415: LD_INT 2
20417: ARRAY
20418: DOUBLE
20419: EQUAL
20420: IFTRUE 20424
20422: GO 20441
20424: POP
// result := upgradeable [ 2 ] ; trough_upgrade [ 3 ] :
20425: LD_ADDR_VAR 0 2
20429: PUSH
20430: LD_LOC 27
20434: PUSH
20435: LD_INT 2
20437: ARRAY
20438: ST_TO_ADDR
20439: GO 20535
20441: LD_LOC 28
20445: PUSH
20446: LD_INT 3
20448: ARRAY
20449: DOUBLE
20450: EQUAL
20451: IFTRUE 20455
20453: GO 20472
20455: POP
// result := upgradeable [ 3 ] ; trough_upgrade [ 4 ] :
20456: LD_ADDR_VAR 0 2
20460: PUSH
20461: LD_LOC 27
20465: PUSH
20466: LD_INT 3
20468: ARRAY
20469: ST_TO_ADDR
20470: GO 20535
20472: LD_LOC 28
20476: PUSH
20477: LD_INT 4
20479: ARRAY
20480: DOUBLE
20481: EQUAL
20482: IFTRUE 20486
20484: GO 20503
20486: POP
// result := upgradeable [ 4 ] ; trough_upgrade [ 6 ] :
20487: LD_ADDR_VAR 0 2
20491: PUSH
20492: LD_LOC 27
20496: PUSH
20497: LD_INT 4
20499: ARRAY
20500: ST_TO_ADDR
20501: GO 20535
20503: LD_LOC 28
20507: PUSH
20508: LD_INT 6
20510: ARRAY
20511: DOUBLE
20512: EQUAL
20513: IFTRUE 20517
20515: GO 20534
20517: POP
// result := upgradeable [ 6 ] ; end ;
20518: LD_ADDR_VAR 0 2
20522: PUSH
20523: LD_LOC 27
20527: PUSH
20528: LD_INT 6
20530: ARRAY
20531: ST_TO_ADDR
20532: GO 20535
20534: POP
// end ;
20535: LD_VAR 0 2
20539: RET
// export function build_map ; var i , j ; begin
20540: LD_INT 0
20542: PPUSH
20543: PPUSH
20544: PPUSH
// for i := 1 to 5 do
20545: LD_ADDR_VAR 0 2
20549: PUSH
20550: DOUBLE
20551: LD_INT 1
20553: DEC
20554: ST_TO_ADDR
20555: LD_INT 5
20557: PUSH
20558: FOR_TO
20559: IFFALSE 20626
// buildings := replace ( buildings , i , place_base ( builds [ i ] , in_depots [ i ] , ai_s [ i ] , ai_nation ) ) ;
20561: LD_ADDR_EXP 75
20565: PUSH
20566: LD_EXP 75
20570: PPUSH
20571: LD_VAR 0 2
20575: PPUSH
20576: LD_LOC 23
20580: PUSH
20581: LD_VAR 0 2
20585: ARRAY
20586: PPUSH
20587: LD_LOC 25
20591: PUSH
20592: LD_VAR 0 2
20596: ARRAY
20597: PPUSH
20598: LD_EXP 23
20602: PUSH
20603: LD_VAR 0 2
20607: ARRAY
20608: PPUSH
20609: LD_EXP 22
20613: PPUSH
20614: CALL 20866 0 4
20618: PPUSH
20619: CALL_OW 1
20623: ST_TO_ADDR
20624: GO 20558
20626: POP
20627: POP
// hlavouni := [ Platonov , Gossudarov , Borodin , Tsaritsyn , Davidov , Eisenstein ] ;
20628: LD_ADDR_EXP 72
20632: PUSH
20633: LD_EXP 42
20637: PUSH
20638: LD_EXP 43
20642: PUSH
20643: LD_EXP 46
20647: PUSH
20648: LD_EXP 47
20652: PUSH
20653: LD_EXP 48
20657: PUSH
20658: LD_EXP 49
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: ST_TO_ADDR
// PlaceHumanInUnit ( Platonov , da ) ;
20671: LD_EXP 42
20675: PPUSH
20676: LD_INT 1
20678: PPUSH
20679: CALL_OW 52
// PlaceHumanInUnit ( Gossudarov , art_cargo ) ;
20683: LD_EXP 43
20687: PPUSH
20688: LD_INT 121
20690: PPUSH
20691: CALL_OW 52
// PlaceHumanInUnit ( Borodin , db ) ;
20695: LD_EXP 46
20699: PPUSH
20700: LD_INT 51
20702: PPUSH
20703: CALL_OW 52
// PlaceHumanInUnit ( Tsaritsyn , dc ) ;
20707: LD_EXP 47
20711: PPUSH
20712: LD_INT 80
20714: PPUSH
20715: CALL_OW 52
// PlaceHumanInUnit ( Davidov , dd ) ;
20719: LD_EXP 48
20723: PPUSH
20724: LD_INT 28
20726: PPUSH
20727: CALL_OW 52
// PlaceHumanInUnit ( Eisenstein , de ) ;
20731: LD_EXP 49
20735: PPUSH
20736: LD_INT 37
20738: PPUSH
20739: CALL_OW 52
// for i := 1 to 5 do
20743: LD_ADDR_VAR 0 2
20747: PUSH
20748: DOUBLE
20749: LD_INT 1
20751: DEC
20752: ST_TO_ADDR
20753: LD_INT 5
20755: PUSH
20756: FOR_TO
20757: IFFALSE 20859
// begin humans := replace ( humans , i , place_aici ( aici [ i ] , abase [ i ] , ai_s [ i ] , ai_nation ) ) ;
20759: LD_ADDR_EXP 76
20763: PUSH
20764: LD_EXP 76
20768: PPUSH
20769: LD_VAR 0 2
20773: PPUSH
20774: LD_LOC 24
20778: PUSH
20779: LD_VAR 0 2
20783: ARRAY
20784: PPUSH
20785: LD_LOC 26
20789: PUSH
20790: LD_VAR 0 2
20794: ARRAY
20795: PPUSH
20796: LD_EXP 23
20800: PUSH
20801: LD_VAR 0 2
20805: ARRAY
20806: PPUSH
20807: LD_EXP 22
20811: PPUSH
20812: CALL 21318 0 4
20816: PPUSH
20817: CALL_OW 1
20821: ST_TO_ADDR
// for j in humans [ i ] do
20822: LD_ADDR_VAR 0 3
20826: PUSH
20827: LD_EXP 76
20831: PUSH
20832: LD_VAR 0 2
20836: ARRAY
20837: PUSH
20838: FOR_IN
20839: IFFALSE 20855
// SetTag ( j , 1 ) ;
20841: LD_VAR 0 3
20845: PPUSH
20846: LD_INT 1
20848: PPUSH
20849: CALL_OW 109
20853: GO 20838
20855: POP
20856: POP
// end ;
20857: GO 20756
20859: POP
20860: POP
// end ;
20861: LD_VAR 0 1
20865: RET
// function place_base ( builds , in_depot , side , nat ) ; var i , base , b , tb , bb , cans , oil , sib ; begin
20866: LD_INT 0
20868: PPUSH
20869: PPUSH
20870: PPUSH
20871: PPUSH
20872: PPUSH
20873: PPUSH
20874: PPUSH
20875: PPUSH
20876: PPUSH
// cans := in_depot [ 1 ] ;
20877: LD_ADDR_VAR 0 11
20881: PUSH
20882: LD_VAR 0 2
20886: PUSH
20887: LD_INT 1
20889: ARRAY
20890: ST_TO_ADDR
// oil := in_depot [ 2 ] ;
20891: LD_ADDR_VAR 0 12
20895: PUSH
20896: LD_VAR 0 2
20900: PUSH
20901: LD_INT 2
20903: ARRAY
20904: ST_TO_ADDR
// sib := in_depot [ 3 ] ;
20905: LD_ADDR_VAR 0 13
20909: PUSH
20910: LD_VAR 0 2
20914: PUSH
20915: LD_INT 3
20917: ARRAY
20918: ST_TO_ADDR
// InitUc ;
20919: CALL_OW 18
// InitBc ;
20923: CALL_OW 21
// uc_side := side ;
20927: LD_ADDR_OWVAR 20
20931: PUSH
20932: LD_VAR 0 3
20936: ST_TO_ADDR
// uc_nation := nat ;
20937: LD_ADDR_OWVAR 21
20941: PUSH
20942: LD_VAR 0 4
20946: ST_TO_ADDR
// b := [ ] ;
20947: LD_ADDR_VAR 0 8
20951: PUSH
20952: EMPTY
20953: ST_TO_ADDR
// for i in builds do
20954: LD_ADDR_VAR 0 6
20958: PUSH
20959: LD_VAR 0 1
20963: PUSH
20964: FOR_IN
20965: IFFALSE 21195
// begin if i = 5 then
20967: LD_VAR 0 6
20971: PUSH
20972: LD_INT 5
20974: EQUAL
20975: IFFALSE 21193
// begin tb := get_build ( i [ 2 ] , i [ 3 ] , 0 ) ;
20977: LD_ADDR_VAR 0 9
20981: PUSH
20982: LD_VAR 0 6
20986: PUSH
20987: LD_INT 2
20989: ARRAY
20990: PPUSH
20991: LD_VAR 0 6
20995: PUSH
20996: LD_INT 3
20998: ARRAY
20999: PPUSH
21000: LD_INT 0
21002: PPUSH
21003: CALL 22163 0 3
21007: ST_TO_ADDR
// if not tb then
21008: LD_VAR 0 9
21012: NOT
21013: IFFALSE 21174
// begin bc_type := i [ 1 ] ;
21015: LD_ADDR_OWVAR 42
21019: PUSH
21020: LD_VAR 0 6
21024: PUSH
21025: LD_INT 1
21027: ARRAY
21028: ST_TO_ADDR
// if bc_type = b_lab or bc_type = b_lab_half or bc_type = b_lab_full then
21029: LD_OWVAR 42
21033: PUSH
21034: LD_INT 6
21036: EQUAL
21037: PUSH
21038: LD_OWVAR 42
21042: PUSH
21043: LD_INT 7
21045: EQUAL
21046: OR
21047: PUSH
21048: LD_OWVAR 42
21052: PUSH
21053: LD_INT 8
21055: EQUAL
21056: OR
21057: IFFALSE 21095
// begin bc_kind1 := i [ 5 ] [ 1 ] ;
21059: LD_ADDR_OWVAR 44
21063: PUSH
21064: LD_VAR 0 6
21068: PUSH
21069: LD_INT 5
21071: ARRAY
21072: PUSH
21073: LD_INT 1
21075: ARRAY
21076: ST_TO_ADDR
// bc_kind2 := i [ 5 ] [ 2 ] ;
21077: LD_ADDR_OWVAR 45
21081: PUSH
21082: LD_VAR 0 6
21086: PUSH
21087: LD_INT 5
21089: ARRAY
21090: PUSH
21091: LD_INT 2
21093: ARRAY
21094: ST_TO_ADDR
// end ; tb := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
21095: LD_ADDR_VAR 0 9
21099: PUSH
21100: LD_VAR 0 6
21104: PUSH
21105: LD_INT 2
21107: ARRAY
21108: PPUSH
21109: LD_VAR 0 6
21113: PUSH
21114: LD_INT 3
21116: ARRAY
21117: PPUSH
21118: LD_VAR 0 6
21122: PUSH
21123: LD_INT 4
21125: ARRAY
21126: PPUSH
21127: CALL_OW 47
21131: ST_TO_ADDR
// if bc_type = b_bunker or bc_type = b_turret then
21132: LD_OWVAR 42
21136: PUSH
21137: LD_INT 32
21139: EQUAL
21140: PUSH
21141: LD_OWVAR 42
21145: PUSH
21146: LD_INT 33
21148: EQUAL
21149: OR
21150: IFFALSE 21174
// PlaceWeaponTurret ( tb , i [ 5 ] [ 1 ] ) ;
21152: LD_VAR 0 9
21156: PPUSH
21157: LD_VAR 0 6
21161: PUSH
21162: LD_INT 5
21164: ARRAY
21165: PUSH
21166: LD_INT 1
21168: ARRAY
21169: PPUSH
21170: CALL_OW 431
// end ; b := b ^ [ tb ] ;
21174: LD_ADDR_VAR 0 8
21178: PUSH
21179: LD_VAR 0 8
21183: PUSH
21184: LD_VAR 0 9
21188: PUSH
21189: EMPTY
21190: LIST
21191: ADD
21192: ST_TO_ADDR
// end ; end ;
21193: GO 20964
21195: POP
21196: POP
// bb := UnitFilter ( b , [ mf_dep ] ) ;
21197: LD_ADDR_VAR 0 10
21201: PUSH
21202: LD_VAR 0 8
21206: PPUSH
21207: LD_EXP 58
21211: PUSH
21212: EMPTY
21213: LIST
21214: PPUSH
21215: CALL_OW 72
21219: ST_TO_ADDR
// for i in bb do
21220: LD_ADDR_VAR 0 6
21224: PUSH
21225: LD_VAR 0 10
21229: PUSH
21230: FOR_IN
21231: IFFALSE 21301
// begin base := GetBase ( i ) ;
21233: LD_ADDR_VAR 0 7
21237: PUSH
21238: LD_VAR 0 6
21242: PPUSH
21243: CALL_OW 274
21247: ST_TO_ADDR
// SetResourceType ( base , mat_cans , cans ) ;
21248: LD_VAR 0 7
21252: PPUSH
21253: LD_INT 1
21255: PPUSH
21256: LD_VAR 0 11
21260: PPUSH
21261: CALL_OW 277
// SetResourceType ( base , mat_oil , oil ) ;
21265: LD_VAR 0 7
21269: PPUSH
21270: LD_INT 2
21272: PPUSH
21273: LD_VAR 0 12
21277: PPUSH
21278: CALL_OW 277
// SetResourceType ( base , mat_siberit , sib ) ;
21282: LD_VAR 0 7
21286: PPUSH
21287: LD_INT 3
21289: PPUSH
21290: LD_VAR 0 13
21294: PPUSH
21295: CALL_OW 277
// end ;
21299: GO 21230
21301: POP
21302: POP
// result := b ;
21303: LD_ADDR_VAR 0 5
21307: PUSH
21308: LD_VAR 0 8
21312: ST_TO_ADDR
// end ;
21313: LD_VAR 0 5
21317: RET
// function place_aici ( aici , area , side , nat ) ; var i , j , a ; begin
21318: LD_INT 0
21320: PPUSH
21321: PPUSH
21322: PPUSH
21323: PPUSH
// InitUc ;
21324: CALL_OW 18
// InitHc ;
21328: CALL_OW 19
// uc_side := side ;
21332: LD_ADDR_OWVAR 20
21336: PUSH
21337: LD_VAR 0 3
21341: ST_TO_ADDR
// uc_nation := nat ;
21342: LD_ADDR_OWVAR 21
21346: PUSH
21347: LD_VAR 0 4
21351: ST_TO_ADDR
// a := [ ] ;
21352: LD_ADDR_VAR 0 8
21356: PUSH
21357: EMPTY
21358: ST_TO_ADDR
// for i in aici do
21359: LD_ADDR_VAR 0 6
21363: PUSH
21364: LD_VAR 0 1
21368: PUSH
21369: FOR_IN
21370: IFFALSE 21444
// begin for j := 1 to i [ 1 ] do
21372: LD_ADDR_VAR 0 7
21376: PUSH
21377: DOUBLE
21378: LD_INT 1
21380: DEC
21381: ST_TO_ADDR
21382: LD_VAR 0 6
21386: PUSH
21387: LD_INT 1
21389: ARRAY
21390: PUSH
21391: FOR_TO
21392: IFFALSE 21440
// begin PrepareHuman ( 0 , i [ 2 ] , i [ 3 ] ) ;
21394: LD_INT 0
21396: PPUSH
21397: LD_VAR 0 6
21401: PUSH
21402: LD_INT 2
21404: ARRAY
21405: PPUSH
21406: LD_VAR 0 6
21410: PUSH
21411: LD_INT 3
21413: ARRAY
21414: PPUSH
21415: CALL_OW 380
// a := a ^ [ CreateHuman ] ;
21419: LD_ADDR_VAR 0 8
21423: PUSH
21424: LD_VAR 0 8
21428: PUSH
21429: CALL_OW 44
21433: PUSH
21434: EMPTY
21435: LIST
21436: ADD
21437: ST_TO_ADDR
// end ;
21438: GO 21391
21440: POP
21441: POP
// end ;
21442: GO 21369
21444: POP
21445: POP
// for i in a do
21446: LD_ADDR_VAR 0 6
21450: PUSH
21451: LD_VAR 0 8
21455: PUSH
21456: FOR_IN
21457: IFFALSE 21478
// PlaceUnitArea ( i , area , false ) ;
21459: LD_VAR 0 6
21463: PPUSH
21464: LD_VAR 0 2
21468: PPUSH
21469: LD_INT 0
21471: PPUSH
21472: CALL_OW 49
21476: GO 21456
21478: POP
21479: POP
// result := a ;
21480: LD_ADDR_VAR 0 5
21484: PUSH
21485: LD_VAR 0 8
21489: ST_TO_ADDR
// end ;
21490: LD_VAR 0 5
21494: RET
// every 0 0$10 + 0 0$0.0 do var i , j , weap , k ;
21495: GO 21497
21497: DISABLE
21498: LD_INT 0
21500: PPUSH
21501: PPUSH
21502: PPUSH
21503: PPUSH
// begin for i in UnitFilter ( fort , [ mf_bunk ] ) do
21504: LD_ADDR_VAR 0 1
21508: PUSH
21509: LD_EXP 81
21513: PPUSH
21514: LD_EXP 57
21518: PUSH
21519: EMPTY
21520: LIST
21521: PPUSH
21522: CALL_OW 72
21526: PUSH
21527: FOR_IN
21528: IFFALSE 21698
// if not GetBWeapon ( i ) then
21530: LD_VAR 0 1
21534: PPUSH
21535: CALL_OW 269
21539: NOT
21540: IFFALSE 21696
// begin weap := 0 ;
21542: LD_ADDR_VAR 0 3
21546: PUSH
21547: LD_INT 0
21549: ST_TO_ADDR
// for k := 1 to 5 do
21550: LD_ADDR_VAR 0 4
21554: PUSH
21555: DOUBLE
21556: LD_INT 1
21558: DEC
21559: ST_TO_ADDR
21560: LD_INT 5
21562: PUSH
21563: FOR_TO
21564: IFFALSE 21674
// for j in builds [ k ] do
21566: LD_ADDR_VAR 0 2
21570: PUSH
21571: LD_LOC 23
21575: PUSH
21576: LD_VAR 0 4
21580: ARRAY
21581: PUSH
21582: FOR_IN
21583: IFFALSE 21670
// if GetX ( i ) = j [ 2 ] and GetY ( i ) = j [ 3 ] and GetBType ( i ) = j [ 1 ] then
21585: LD_VAR 0 1
21589: PPUSH
21590: CALL_OW 250
21594: PUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_INT 2
21602: ARRAY
21603: EQUAL
21604: PUSH
21605: LD_VAR 0 1
21609: PPUSH
21610: CALL_OW 251
21614: PUSH
21615: LD_VAR 0 2
21619: PUSH
21620: LD_INT 3
21622: ARRAY
21623: EQUAL
21624: AND
21625: PUSH
21626: LD_VAR 0 1
21630: PPUSH
21631: CALL_OW 266
21635: PUSH
21636: LD_VAR 0 2
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: EQUAL
21645: AND
21646: IFFALSE 21668
// begin weap := j [ 5 ] [ 1 ] ;
21648: LD_ADDR_VAR 0 3
21652: PUSH
21653: LD_VAR 0 2
21657: PUSH
21658: LD_INT 5
21660: ARRAY
21661: PUSH
21662: LD_INT 1
21664: ARRAY
21665: ST_TO_ADDR
// break ;
21666: GO 21670
// end ;
21668: GO 21582
21670: POP
21671: POP
21672: GO 21563
21674: POP
21675: POP
// if weap then
21676: LD_VAR 0 3
21680: IFFALSE 21696
// ComPlaceWeapon ( j , weap ) ;
21682: LD_VAR 0 2
21686: PPUSH
21687: LD_VAR 0 3
21691: PPUSH
21692: CALL_OW 148
// end ;
21696: GO 21527
21698: POP
21699: POP
// enable ;
21700: ENABLE
// end ;
21701: PPOPN 4
21703: END
// every 0 0$10 + 0 0$2.0 do var i , to_up , to_b , co_tam_stoji , k , je_cas_stavet ;
21704: GO 21706
21706: DISABLE
21707: LD_INT 0
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
21714: PPUSH
// begin for k := 1 to 5 do
21715: LD_ADDR_VAR 0 5
21719: PUSH
21720: DOUBLE
21721: LD_INT 1
21723: DEC
21724: ST_TO_ADDR
21725: LD_INT 5
21727: PUSH
21728: FOR_TO
21729: IFFALSE 22157
// begin if not under_attack [ k ] then
21731: LD_EXP 62
21735: PUSH
21736: LD_VAR 0 5
21740: ARRAY
21741: NOT
21742: IFFALSE 22155
// begin to_b := [ ] ;
21744: LD_ADDR_VAR 0 3
21748: PUSH
21749: EMPTY
21750: ST_TO_ADDR
// to_up := [ ] ;
21751: LD_ADDR_VAR 0 2
21755: PUSH
21756: EMPTY
21757: ST_TO_ADDR
// je_cas_stavet := false ;
21758: LD_ADDR_VAR 0 6
21762: PUSH
21763: LD_INT 0
21765: ST_TO_ADDR
// for i in builds [ k ] do
21766: LD_ADDR_VAR 0 1
21770: PUSH
21771: LD_LOC 23
21775: PUSH
21776: LD_VAR 0 5
21780: ARRAY
21781: PUSH
21782: FOR_IN
21783: IFFALSE 21984
// begin je_cas_stavet := true ;
21785: LD_ADDR_VAR 0 6
21789: PUSH
21790: LD_INT 1
21792: ST_TO_ADDR
// if i = 6 then
21793: LD_VAR 0 1
21797: PUSH
21798: LD_INT 6
21800: EQUAL
21801: IFFALSE 21827
// if i [ 6 ] < tick then
21803: LD_VAR 0 1
21807: PUSH
21808: LD_INT 6
21810: ARRAY
21811: PUSH
21812: LD_OWVAR 1
21816: LESS
21817: IFFALSE 21827
// je_cas_stavet := false ;
21819: LD_ADDR_VAR 0 6
21823: PUSH
21824: LD_INT 0
21826: ST_TO_ADDR
// if je_cas_stavet then
21827: LD_VAR 0 6
21831: IFFALSE 21982
// begin co_tam_stoji := GetBType ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
21833: LD_ADDR_VAR 0 4
21837: PUSH
21838: LD_VAR 0 1
21842: PUSH
21843: LD_INT 2
21845: ARRAY
21846: PPUSH
21847: LD_VAR 0 1
21851: PUSH
21852: LD_INT 3
21854: ARRAY
21855: PPUSH
21856: LD_INT 0
21858: PPUSH
21859: CALL 22163 0 3
21863: PPUSH
21864: CALL_OW 266
21868: ST_TO_ADDR
// if co_tam_stoji = - 1 then
21869: LD_VAR 0 4
21873: PUSH
21874: LD_INT 1
21876: NEG
21877: EQUAL
21878: IFFALSE 21944
// begin to_b := [ BasicFrom ( i [ 1 ] ) , i [ 2 ] , i [ 3 ] , i [ 4 ] , i [ 5 ] ] ;
21880: LD_ADDR_VAR 0 3
21884: PUSH
21885: LD_VAR 0 1
21889: PUSH
21890: LD_INT 1
21892: ARRAY
21893: PPUSH
21894: CALL 20361 0 1
21898: PUSH
21899: LD_VAR 0 1
21903: PUSH
21904: LD_INT 2
21906: ARRAY
21907: PUSH
21908: LD_VAR 0 1
21912: PUSH
21913: LD_INT 3
21915: ARRAY
21916: PUSH
21917: LD_VAR 0 1
21921: PUSH
21922: LD_INT 4
21924: ARRAY
21925: PUSH
21926: LD_VAR 0 1
21930: PUSH
21931: LD_INT 5
21933: ARRAY
21934: PUSH
21935: EMPTY
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: ST_TO_ADDR
// end else
21942: GO 21974
// if UpgradeableTo ( co_tam_stoji , i [ 1 ] ) then
21944: LD_VAR 0 4
21948: PPUSH
21949: LD_VAR 0 1
21953: PUSH
21954: LD_INT 1
21956: ARRAY
21957: PPUSH
21958: CALL 20097 0 2
21962: IFFALSE 21974
// begin to_up := i ;
21964: LD_ADDR_VAR 0 2
21968: PUSH
21969: LD_VAR 0 1
21973: ST_TO_ADDR
// end ; if to_b then
21974: LD_VAR 0 3
21978: IFFALSE 21982
// break ;
21980: GO 21984
// end ; end ;
21982: GO 21782
21984: POP
21985: POP
// if to_b then
21986: LD_VAR 0 3
21990: IFFALSE 22112
// ComBuild ( NearestUnitToXY ( UnitFilter ( eng isect humans [ k ] , [ [ f_distxy , to_b [ 2 ] , to_b [ 3 ] , 40 ] ] ) , to_b [ 2 ] , to_b [ 3 ] ) , to_b [ 1 ] , to_b [ 2 ] , to_b [ 3 ] , to_b [ 4 ] ) else
21992: LD_EXP 84
21996: PUSH
21997: LD_EXP 76
22001: PUSH
22002: LD_VAR 0 5
22006: ARRAY
22007: ISECT
22008: PPUSH
22009: LD_INT 92
22011: PUSH
22012: LD_VAR 0 3
22016: PUSH
22017: LD_INT 2
22019: ARRAY
22020: PUSH
22021: LD_VAR 0 3
22025: PUSH
22026: LD_INT 3
22028: ARRAY
22029: PUSH
22030: LD_INT 40
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: PUSH
22039: EMPTY
22040: LIST
22041: PPUSH
22042: CALL_OW 72
22046: PPUSH
22047: LD_VAR 0 3
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PPUSH
22056: LD_VAR 0 3
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PPUSH
22065: CALL_OW 73
22069: PPUSH
22070: LD_VAR 0 3
22074: PUSH
22075: LD_INT 1
22077: ARRAY
22078: PPUSH
22079: LD_VAR 0 3
22083: PUSH
22084: LD_INT 2
22086: ARRAY
22087: PPUSH
22088: LD_VAR 0 3
22092: PUSH
22093: LD_INT 3
22095: ARRAY
22096: PPUSH
22097: LD_VAR 0 3
22101: PUSH
22102: LD_INT 4
22104: ARRAY
22105: PPUSH
22106: CALL_OW 145
22110: GO 22148
// if to_up then
22112: LD_VAR 0 2
22116: IFFALSE 22148
// ComUpgrade ( get_build ( i [ 2 ] , i [ 3 ] , 0 ) ) ;
22118: LD_VAR 0 1
22122: PUSH
22123: LD_INT 2
22125: ARRAY
22126: PPUSH
22127: LD_VAR 0 1
22131: PUSH
22132: LD_INT 3
22134: ARRAY
22135: PPUSH
22136: LD_INT 0
22138: PPUSH
22139: CALL 22163 0 3
22143: PPUSH
22144: CALL_OW 146
// wait ( 0 0$1.1 ) ;
22148: LD_INT 39
22150: PPUSH
22151: CALL_OW 67
// end ; end ;
22155: GO 21728
22157: POP
22158: POP
// enable ;
22159: ENABLE
// end ;
22160: PPOPN 6
22162: END
// function get_build ( x , y , btype ) ; begin
22163: LD_INT 0
22165: PPUSH
// result := HexInfo ( x , y ) ;
22166: LD_ADDR_VAR 0 4
22170: PUSH
22171: LD_VAR 0 1
22175: PPUSH
22176: LD_VAR 0 2
22180: PPUSH
22181: CALL_OW 428
22185: ST_TO_ADDR
// if result < 1 then
22186: LD_VAR 0 4
22190: PUSH
22191: LD_INT 1
22193: LESS
22194: IFFALSE 22204
// result := 0 ;
22196: LD_ADDR_VAR 0 4
22200: PUSH
22201: LD_INT 0
22203: ST_TO_ADDR
// if btype then
22204: LD_VAR 0 3
22208: IFFALSE 22260
// if btype <> GetBType ( result ) then
22210: LD_VAR 0 3
22214: PUSH
22215: LD_VAR 0 4
22219: PPUSH
22220: CALL_OW 266
22224: NONEQUAL
22225: IFFALSE 22237
// result := 0 else
22227: LD_ADDR_VAR 0 4
22231: PUSH
22232: LD_INT 0
22234: ST_TO_ADDR
22235: GO 22260
// if unit_building <> GetType ( result ) then
22237: LD_INT 3
22239: PUSH
22240: LD_VAR 0 4
22244: PPUSH
22245: CALL_OW 247
22249: NONEQUAL
22250: IFFALSE 22260
// result := 0 ;
22252: LD_ADDR_VAR 0 4
22256: PUSH
22257: LD_INT 0
22259: ST_TO_ADDR
// end ; end_of_file
22260: LD_VAR 0 4
22264: RET
// var opravit ; export function inicializace_ai_b_repair ; begin
22265: LD_INT 0
22267: PPUSH
// opravit := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22268: LD_ADDR_LOC 29
22272: PUSH
22273: EMPTY
22274: PUSH
22275: EMPTY
22276: PUSH
22277: EMPTY
22278: PUSH
22279: EMPTY
22280: PUSH
22281: EMPTY
22282: PUSH
22283: EMPTY
22284: LIST
22285: LIST
22286: LIST
22287: LIST
22288: LIST
22289: ST_TO_ADDR
// end ;
22290: LD_VAR 0 1
22294: RET
// function HledejBudovyNaOpravy ( opravit_index , budovy ) ; var zivoty , i , opravit_tmp ; begin
22295: LD_INT 0
22297: PPUSH
22298: PPUSH
22299: PPUSH
22300: PPUSH
// opravit_tmp := [ ] ;
22301: LD_ADDR_VAR 0 6
22305: PUSH
22306: EMPTY
22307: ST_TO_ADDR
// zivoty := [ ] ;
22308: LD_ADDR_VAR 0 4
22312: PUSH
22313: EMPTY
22314: ST_TO_ADDR
// for i in budovy do
22315: LD_ADDR_VAR 0 5
22319: PUSH
22320: LD_VAR 0 2
22324: PUSH
22325: FOR_IN
22326: IFFALSE 22388
// begin if GetLives ( i ) < 1000 then
22328: LD_VAR 0 5
22332: PPUSH
22333: CALL_OW 256
22337: PUSH
22338: LD_INT 1000
22340: LESS
22341: IFFALSE 22386
// begin opravit_tmp := opravit_tmp ^ [ i ] ;
22343: LD_ADDR_VAR 0 6
22347: PUSH
22348: LD_VAR 0 6
22352: PUSH
22353: LD_VAR 0 5
22357: PUSH
22358: EMPTY
22359: LIST
22360: ADD
22361: ST_TO_ADDR
// zivoty := zivoty ^ [ GetLives ( i ) ] ;
22362: LD_ADDR_VAR 0 4
22366: PUSH
22367: LD_VAR 0 4
22371: PUSH
22372: LD_VAR 0 5
22376: PPUSH
22377: CALL_OW 256
22381: PUSH
22382: EMPTY
22383: LIST
22384: ADD
22385: ST_TO_ADDR
// end ; end ;
22386: GO 22325
22388: POP
22389: POP
// if opravit_tmp then
22390: LD_VAR 0 6
22394: IFFALSE 22416
// opravit_tmp := SortListByListAsc ( opravit_tmp , zivoty ) ;
22396: LD_ADDR_VAR 0 6
22400: PUSH
22401: LD_VAR 0 6
22405: PPUSH
22406: LD_VAR 0 4
22410: PPUSH
22411: CALL_OW 76
22415: ST_TO_ADDR
// opravit := Replace ( opravit , opravit_index , opravit_tmp ) ;
22416: LD_ADDR_LOC 29
22420: PUSH
22421: LD_LOC 29
22425: PPUSH
22426: LD_VAR 0 1
22430: PPUSH
22431: LD_VAR 0 6
22435: PPUSH
22436: CALL_OW 1
22440: ST_TO_ADDR
// end ;
22441: LD_VAR 0 3
22445: RET
// every 0 0$5 do var i ;
22446: GO 22448
22448: DISABLE
22449: LD_INT 0
22451: PPUSH
// begin for i := 1 to 5 do
22452: LD_ADDR_VAR 0 1
22456: PUSH
22457: DOUBLE
22458: LD_INT 1
22460: DEC
22461: ST_TO_ADDR
22462: LD_INT 5
22464: PUSH
22465: FOR_TO
22466: IFFALSE 22510
// begin if not under_attack [ i ] then
22468: LD_EXP 62
22472: PUSH
22473: LD_VAR 0 1
22477: ARRAY
22478: NOT
22479: IFFALSE 22508
// begin HledejBudovyNaOpravy ( i , buildings [ i ] ) ;
22481: LD_VAR 0 1
22485: PPUSH
22486: LD_EXP 75
22490: PUSH
22491: LD_VAR 0 1
22495: ARRAY
22496: PPUSH
22497: CALL 22295 0 2
// wait ( 0 0$0.6 ) ;
22501: LD_INT 21
22503: PPUSH
22504: CALL_OW 67
// end ; end ;
22508: GO 22465
22510: POP
22511: POP
// enable ;
22512: ENABLE
// end ;
22513: PPOPN 1
22515: END
// every 0 0$5 do var i ;
22516: GO 22518
22518: DISABLE
22519: LD_INT 0
22521: PPUSH
// begin for i := 1 to 5 do
22522: LD_ADDR_VAR 0 1
22526: PUSH
22527: DOUBLE
22528: LD_INT 1
22530: DEC
22531: ST_TO_ADDR
22532: LD_INT 5
22534: PUSH
22535: FOR_TO
22536: IFFALSE 22685
// begin if opravit [ i ] then
22538: LD_LOC 29
22542: PUSH
22543: LD_VAR 0 1
22547: ARRAY
22548: IFFALSE 22683
// begin ComRepairBuilding ( UnitFilter ( eng , [ [ f_not , [ f_hastask ] ] , [ f_side , GetSide ( opravit [ i ] [ 1 ] ) ] , [ f_dist , opravit [ i ] [ 1 ] , ( ( ( 1000 div 30 ) + 5 ) - GetLives ( opravit [ i ] [ 1 ] ) div 30 ) ] ] ) , opravit [ i ] [ 1 ] ) ;
22550: LD_EXP 84
22554: PPUSH
22555: LD_INT 3
22557: PUSH
22558: LD_INT 60
22560: PUSH
22561: EMPTY
22562: LIST
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: PUSH
22568: LD_INT 22
22570: PUSH
22571: LD_LOC 29
22575: PUSH
22576: LD_VAR 0 1
22580: ARRAY
22581: PUSH
22582: LD_INT 1
22584: ARRAY
22585: PPUSH
22586: CALL_OW 255
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: PUSH
22595: LD_INT 91
22597: PUSH
22598: LD_LOC 29
22602: PUSH
22603: LD_VAR 0 1
22607: ARRAY
22608: PUSH
22609: LD_INT 1
22611: ARRAY
22612: PUSH
22613: LD_INT 1000
22615: PUSH
22616: LD_INT 30
22618: DIV
22619: PUSH
22620: LD_INT 5
22622: PLUS
22623: PUSH
22624: LD_LOC 29
22628: PUSH
22629: LD_VAR 0 1
22633: ARRAY
22634: PUSH
22635: LD_INT 1
22637: ARRAY
22638: PPUSH
22639: CALL_OW 256
22643: PUSH
22644: LD_INT 30
22646: DIV
22647: MINUS
22648: PUSH
22649: EMPTY
22650: LIST
22651: LIST
22652: LIST
22653: PUSH
22654: EMPTY
22655: LIST
22656: LIST
22657: LIST
22658: PPUSH
22659: CALL_OW 72
22663: PPUSH
22664: LD_LOC 29
22668: PUSH
22669: LD_VAR 0 1
22673: ARRAY
22674: PUSH
22675: LD_INT 1
22677: ARRAY
22678: PPUSH
22679: CALL_OW 130
// end ; end ;
22683: GO 22535
22685: POP
22686: POP
// enable ;
22687: ENABLE
// end ; end_of_file
22688: PPOPN 1
22690: END
// export factories ; export depots ; export buildings ; export humans ; export vehicles ; export attack_units ; export defence_units ; export mcdef_units ; export fort , sol , dep , eng , fact , mec , lab , sci ; export function inicializace_ai ; begin
22691: LD_INT 0
22693: PPUSH
// factories := [ 0 , 0 , 0 , 0 , 0 ] ;
22694: LD_ADDR_EXP 73
22698: PUSH
22699: LD_INT 0
22701: PUSH
22702: LD_INT 0
22704: PUSH
22705: LD_INT 0
22707: PUSH
22708: LD_INT 0
22710: PUSH
22711: LD_INT 0
22713: PUSH
22714: EMPTY
22715: LIST
22716: LIST
22717: LIST
22718: LIST
22719: LIST
22720: ST_TO_ADDR
// depots := [ 0 , 0 , 0 , 0 , 0 ] ;
22721: LD_ADDR_EXP 74
22725: PUSH
22726: LD_INT 0
22728: PUSH
22729: LD_INT 0
22731: PUSH
22732: LD_INT 0
22734: PUSH
22735: LD_INT 0
22737: PUSH
22738: LD_INT 0
22740: PUSH
22741: EMPTY
22742: LIST
22743: LIST
22744: LIST
22745: LIST
22746: LIST
22747: ST_TO_ADDR
// buildings := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22748: LD_ADDR_EXP 75
22752: PUSH
22753: EMPTY
22754: PUSH
22755: EMPTY
22756: PUSH
22757: EMPTY
22758: PUSH
22759: EMPTY
22760: PUSH
22761: EMPTY
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: ST_TO_ADDR
// humans := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22770: LD_ADDR_EXP 76
22774: PUSH
22775: EMPTY
22776: PUSH
22777: EMPTY
22778: PUSH
22779: EMPTY
22780: PUSH
22781: EMPTY
22782: PUSH
22783: EMPTY
22784: PUSH
22785: EMPTY
22786: LIST
22787: LIST
22788: LIST
22789: LIST
22790: LIST
22791: ST_TO_ADDR
// vehicles := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
22792: LD_ADDR_EXP 77
22796: PUSH
22797: EMPTY
22798: PUSH
22799: EMPTY
22800: PUSH
22801: EMPTY
22802: PUSH
22803: EMPTY
22804: PUSH
22805: EMPTY
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: ST_TO_ADDR
// attack_units := [ ] ;
22814: LD_ADDR_EXP 78
22818: PUSH
22819: EMPTY
22820: ST_TO_ADDR
// defence_units := [ ] ;
22821: LD_ADDR_EXP 79
22825: PUSH
22826: EMPTY
22827: ST_TO_ADDR
// end ;
22828: LD_VAR 0 1
22832: RET
// export function get_groups ; var i ; begin
22833: LD_INT 0
22835: PPUSH
22836: PPUSH
// fort := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fort ] ) ;
22837: LD_ADDR_EXP 81
22841: PUSH
22842: LD_INT 3
22844: PUSH
22845: LD_INT 22
22847: PUSH
22848: LD_EXP 7
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: PUSH
22861: LD_EXP 56
22865: PUSH
22866: EMPTY
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 69
22874: ST_TO_ADDR
// sol := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sol ] ) diff hlavouni ;
22875: LD_ADDR_EXP 82
22879: PUSH
22880: LD_INT 3
22882: PUSH
22883: LD_INT 22
22885: PUSH
22886: LD_EXP 7
22890: PUSH
22891: EMPTY
22892: LIST
22893: LIST
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_EXP 51
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PUSH
22913: LD_EXP 72
22917: DIFF
22918: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_dep ] ) ;
22919: LD_ADDR_EXP 83
22923: PUSH
22924: LD_INT 3
22926: PUSH
22927: LD_INT 22
22929: PUSH
22930: LD_EXP 7
22934: PUSH
22935: EMPTY
22936: LIST
22937: LIST
22938: PUSH
22939: EMPTY
22940: LIST
22941: LIST
22942: PUSH
22943: LD_EXP 58
22947: PUSH
22948: EMPTY
22949: LIST
22950: LIST
22951: PPUSH
22952: CALL_OW 69
22956: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_eng ] ) diff hlavouni ;
22957: LD_ADDR_EXP 84
22961: PUSH
22962: LD_INT 3
22964: PUSH
22965: LD_INT 22
22967: PUSH
22968: LD_EXP 7
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: LD_EXP 52
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PPUSH
22990: CALL_OW 69
22994: PUSH
22995: LD_EXP 72
22999: DIFF
23000: ST_TO_ADDR
// fact := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_fact ] ) ;
23001: LD_ADDR_EXP 85
23005: PUSH
23006: LD_INT 3
23008: PUSH
23009: LD_INT 22
23011: PUSH
23012: LD_EXP 7
23016: PUSH
23017: EMPTY
23018: LIST
23019: LIST
23020: PUSH
23021: EMPTY
23022: LIST
23023: LIST
23024: PUSH
23025: LD_EXP 59
23029: PUSH
23030: EMPTY
23031: LIST
23032: LIST
23033: PPUSH
23034: CALL_OW 69
23038: ST_TO_ADDR
// mec := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_mec ] ) diff hlavouni ;
23039: LD_ADDR_EXP 86
23043: PUSH
23044: LD_INT 3
23046: PUSH
23047: LD_INT 22
23049: PUSH
23050: LD_EXP 7
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: PUSH
23059: EMPTY
23060: LIST
23061: LIST
23062: PUSH
23063: LD_EXP 53
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PPUSH
23072: CALL_OW 69
23076: PUSH
23077: LD_EXP 72
23081: DIFF
23082: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_lab ] ) ;
23083: LD_ADDR_EXP 87
23087: PUSH
23088: LD_INT 3
23090: PUSH
23091: LD_INT 22
23093: PUSH
23094: LD_EXP 7
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: PUSH
23103: EMPTY
23104: LIST
23105: LIST
23106: PUSH
23107: LD_EXP 55
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PPUSH
23116: CALL_OW 69
23120: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_not , [ f_side , you ] ] , mf_sci ] ) diff hlavouni ;
23121: LD_ADDR_EXP 88
23125: PUSH
23126: LD_INT 3
23128: PUSH
23129: LD_INT 22
23131: PUSH
23132: LD_EXP 7
23136: PUSH
23137: EMPTY
23138: LIST
23139: LIST
23140: PUSH
23141: EMPTY
23142: LIST
23143: LIST
23144: PUSH
23145: LD_EXP 54
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: PPUSH
23154: CALL_OW 69
23158: PUSH
23159: LD_EXP 72
23163: DIFF
23164: ST_TO_ADDR
// for i := 1 to 5 do
23165: LD_ADDR_VAR 0 2
23169: PUSH
23170: DOUBLE
23171: LD_INT 1
23173: DEC
23174: ST_TO_ADDR
23175: LD_INT 5
23177: PUSH
23178: FOR_TO
23179: IFFALSE 23364
// begin humans := replace ( humans , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_human ] ] ) diff hlavouni ) ;
23181: LD_ADDR_EXP 76
23185: PUSH
23186: LD_EXP 76
23190: PPUSH
23191: LD_VAR 0 2
23195: PPUSH
23196: LD_INT 22
23198: PUSH
23199: LD_EXP 23
23203: PUSH
23204: LD_VAR 0 2
23208: ARRAY
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 21
23216: PUSH
23217: LD_INT 1
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PPUSH
23228: CALL_OW 69
23232: PUSH
23233: LD_EXP 72
23237: DIFF
23238: PPUSH
23239: CALL_OW 1
23243: ST_TO_ADDR
// vehicles := replace ( vehicles , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_vehicle ] ] ) diff art_cargo ) ;
23244: LD_ADDR_EXP 77
23248: PUSH
23249: LD_EXP 77
23253: PPUSH
23254: LD_VAR 0 2
23258: PPUSH
23259: LD_INT 22
23261: PUSH
23262: LD_EXP 23
23266: PUSH
23267: LD_VAR 0 2
23271: ARRAY
23272: PUSH
23273: EMPTY
23274: LIST
23275: LIST
23276: PUSH
23277: LD_INT 21
23279: PUSH
23280: LD_INT 2
23282: PUSH
23283: EMPTY
23284: LIST
23285: LIST
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: PPUSH
23291: CALL_OW 69
23295: PUSH
23296: LD_INT 121
23298: DIFF
23299: PPUSH
23300: CALL_OW 1
23304: ST_TO_ADDR
// buildings := replace ( buildings , i , FilterAllUnits ( [ [ f_side , ai_s [ i ] ] , [ f_type , unit_building ] ] ) ) ;
23305: LD_ADDR_EXP 75
23309: PUSH
23310: LD_EXP 75
23314: PPUSH
23315: LD_VAR 0 2
23319: PPUSH
23320: LD_INT 22
23322: PUSH
23323: LD_EXP 23
23327: PUSH
23328: LD_VAR 0 2
23332: ARRAY
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: PUSH
23338: LD_INT 21
23340: PUSH
23341: LD_INT 3
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: PPUSH
23352: CALL_OW 69
23356: PPUSH
23357: CALL_OW 1
23361: ST_TO_ADDR
// end ;
23362: GO 23178
23364: POP
23365: POP
// attack_units := FilterAllUnits ( [ [ f_control , control_computer ] ] ) ;
23366: LD_ADDR_EXP 78
23370: PUSH
23371: LD_INT 33
23373: PUSH
23374: LD_INT 3
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: PUSH
23381: EMPTY
23382: LIST
23383: PPUSH
23384: CALL_OW 69
23388: ST_TO_ADDR
// defence_units := FilterAllUnits ( [ [ f_control , control_manual ] ] ) diff art_cargo ;
23389: LD_ADDR_EXP 79
23393: PUSH
23394: LD_INT 33
23396: PUSH
23397: LD_INT 1
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: PUSH
23404: EMPTY
23405: LIST
23406: PPUSH
23407: CALL_OW 69
23411: PUSH
23412: LD_INT 121
23414: DIFF
23415: ST_TO_ADDR
// write_deps ;
23416: CALL 23429 0 0
// write_facts ;
23420: CALL 23548 0 0
// end ;
23424: LD_VAR 0 1
23428: RET
// export function write_deps ; var i , a ; begin
23429: LD_INT 0
23431: PPUSH
23432: PPUSH
23433: PPUSH
// for i := 1 to 5 do
23434: LD_ADDR_VAR 0 2
23438: PUSH
23439: DOUBLE
23440: LD_INT 1
23442: DEC
23443: ST_TO_ADDR
23444: LD_INT 5
23446: PUSH
23447: FOR_TO
23448: IFFALSE 23541
// begin a := UnitFilter ( buildings [ i ] , [ mf_dep ] ) ;
23450: LD_ADDR_VAR 0 3
23454: PUSH
23455: LD_EXP 75
23459: PUSH
23460: LD_VAR 0 2
23464: ARRAY
23465: PPUSH
23466: LD_EXP 58
23470: PUSH
23471: EMPTY
23472: LIST
23473: PPUSH
23474: CALL_OW 72
23478: ST_TO_ADDR
// if a then
23479: LD_VAR 0 3
23483: IFFALSE 23516
// depots := replace ( depots , i , a [ 1 ] ) else
23485: LD_ADDR_EXP 74
23489: PUSH
23490: LD_EXP 74
23494: PPUSH
23495: LD_VAR 0 2
23499: PPUSH
23500: LD_VAR 0 3
23504: PUSH
23505: LD_INT 1
23507: ARRAY
23508: PPUSH
23509: CALL_OW 1
23513: ST_TO_ADDR
23514: GO 23539
// depots := replace ( depots , i , 0 ) ;
23516: LD_ADDR_EXP 74
23520: PUSH
23521: LD_EXP 74
23525: PPUSH
23526: LD_VAR 0 2
23530: PPUSH
23531: LD_INT 0
23533: PPUSH
23534: CALL_OW 1
23538: ST_TO_ADDR
// end ;
23539: GO 23447
23541: POP
23542: POP
// end ;
23543: LD_VAR 0 1
23547: RET
// export function write_facts ; var i , a ; begin
23548: LD_INT 0
23550: PPUSH
23551: PPUSH
23552: PPUSH
// for i := 1 to 5 do
23553: LD_ADDR_VAR 0 2
23557: PUSH
23558: DOUBLE
23559: LD_INT 1
23561: DEC
23562: ST_TO_ADDR
23563: LD_INT 5
23565: PUSH
23566: FOR_TO
23567: IFFALSE 23660
// begin a := UnitFilter ( buildings [ i ] , [ mf_fact ] ) ;
23569: LD_ADDR_VAR 0 3
23573: PUSH
23574: LD_EXP 75
23578: PUSH
23579: LD_VAR 0 2
23583: ARRAY
23584: PPUSH
23585: LD_EXP 59
23589: PUSH
23590: EMPTY
23591: LIST
23592: PPUSH
23593: CALL_OW 72
23597: ST_TO_ADDR
// if a then
23598: LD_VAR 0 3
23602: IFFALSE 23635
// factories := replace ( factories , i , a [ 1 ] ) else
23604: LD_ADDR_EXP 73
23608: PUSH
23609: LD_EXP 73
23613: PPUSH
23614: LD_VAR 0 2
23618: PPUSH
23619: LD_VAR 0 3
23623: PUSH
23624: LD_INT 1
23626: ARRAY
23627: PPUSH
23628: CALL_OW 1
23632: ST_TO_ADDR
23633: GO 23658
// factories := replace ( factories , i , 0 ) ;
23635: LD_ADDR_EXP 73
23639: PUSH
23640: LD_EXP 73
23644: PPUSH
23645: LD_VAR 0 2
23649: PPUSH
23650: LD_INT 0
23652: PPUSH
23653: CALL_OW 1
23657: ST_TO_ADDR
// end ;
23658: GO 23566
23660: POP
23661: POP
// end ;
23662: LD_VAR 0 1
23666: RET
// every 0 0$6 + 0 0$0.9 do var i , j , blds , hums , cars ;
23667: GO 23669
23669: DISABLE
23670: LD_INT 0
23672: PPUSH
23673: PPUSH
23674: PPUSH
23675: PPUSH
23676: PPUSH
// begin hums := [ ] ;
23677: LD_ADDR_VAR 0 4
23681: PUSH
23682: EMPTY
23683: ST_TO_ADDR
// for i in sol do
23684: LD_ADDR_VAR 0 1
23688: PUSH
23689: LD_EXP 82
23693: PUSH
23694: FOR_IN
23695: IFFALSE 23771
// if ( not HasTask ( i ) and not ( GetBType ( IsInUnit ( i ) ) = b_bunker or GetBType ( IsInUnit ( i ) ) = b_breastwork ) ) then
23697: LD_VAR 0 1
23701: PPUSH
23702: CALL_OW 314
23706: NOT
23707: PUSH
23708: LD_VAR 0 1
23712: PPUSH
23713: CALL_OW 310
23717: PPUSH
23718: CALL_OW 266
23722: PUSH
23723: LD_INT 32
23725: EQUAL
23726: PUSH
23727: LD_VAR 0 1
23731: PPUSH
23732: CALL_OW 310
23736: PPUSH
23737: CALL_OW 266
23741: PUSH
23742: LD_INT 31
23744: EQUAL
23745: OR
23746: NOT
23747: AND
23748: IFFALSE 23769
// hums := hums ^ [ i ] ;
23750: LD_ADDR_VAR 0 4
23754: PUSH
23755: LD_VAR 0 4
23759: PUSH
23760: LD_VAR 0 1
23764: PUSH
23765: EMPTY
23766: LIST
23767: ADD
23768: ST_TO_ADDR
23769: GO 23694
23771: POP
23772: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ mf_bunk ] ] ) ;
23773: LD_ADDR_VAR 0 3
23777: PUSH
23778: LD_EXP 81
23782: PPUSH
23783: LD_INT 3
23785: PUSH
23786: LD_INT 59
23788: PUSH
23789: EMPTY
23790: LIST
23791: PUSH
23792: EMPTY
23793: LIST
23794: LIST
23795: PUSH
23796: LD_EXP 57
23800: PUSH
23801: EMPTY
23802: LIST
23803: PUSH
23804: EMPTY
23805: LIST
23806: LIST
23807: PPUSH
23808: CALL_OW 72
23812: ST_TO_ADDR
// for i in blds do
23813: LD_ADDR_VAR 0 1
23817: PUSH
23818: LD_VAR 0 3
23822: PUSH
23823: FOR_IN
23824: IFFALSE 23929
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 40 ] ] ) , i ) ;
23826: LD_ADDR_VAR 0 2
23830: PUSH
23831: LD_VAR 0 4
23835: PPUSH
23836: LD_INT 22
23838: PUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: CALL_OW 255
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 91
23855: PUSH
23856: LD_VAR 0 1
23860: PUSH
23861: LD_INT 40
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: LIST
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: PPUSH
23873: CALL_OW 72
23877: PPUSH
23878: LD_VAR 0 1
23882: PPUSH
23883: CALL_OW 74
23887: ST_TO_ADDR
// ComExitBuilding ( j ) ;
23888: LD_VAR 0 2
23892: PPUSH
23893: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
23897: LD_VAR 0 2
23901: PPUSH
23902: LD_VAR 0 1
23906: PPUSH
23907: CALL_OW 180
// hums := hums diff j ;
23911: LD_ADDR_VAR 0 4
23915: PUSH
23916: LD_VAR 0 4
23920: PUSH
23921: LD_VAR 0 2
23925: DIFF
23926: ST_TO_ADDR
// end ;
23927: GO 23823
23929: POP
23930: POP
// cars := UnitFilter ( defence_units , [ f_not , [ f_occupied ] ] ) ;
23931: LD_ADDR_VAR 0 5
23935: PUSH
23936: LD_EXP 79
23940: PPUSH
23941: LD_INT 3
23943: PUSH
23944: LD_INT 59
23946: PUSH
23947: EMPTY
23948: LIST
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PPUSH
23954: CALL_OW 72
23958: ST_TO_ADDR
// for i in cars do
23959: LD_ADDR_VAR 0 1
23963: PUSH
23964: LD_VAR 0 5
23968: PUSH
23969: FOR_IN
23970: IFFALSE 24075
// begin j := NearestUnitToUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
23972: LD_ADDR_VAR 0 2
23976: PUSH
23977: LD_VAR 0 4
23981: PPUSH
23982: LD_INT 22
23984: PUSH
23985: LD_VAR 0 1
23989: PPUSH
23990: CALL_OW 255
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 91
24001: PUSH
24002: LD_VAR 0 1
24006: PUSH
24007: LD_INT 30
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: LIST
24014: PUSH
24015: EMPTY
24016: LIST
24017: LIST
24018: PPUSH
24019: CALL_OW 72
24023: PPUSH
24024: LD_VAR 0 1
24028: PPUSH
24029: CALL_OW 74
24033: ST_TO_ADDR
// ComExitBuilding ( j ) ;
24034: LD_VAR 0 2
24038: PPUSH
24039: CALL_OW 122
// AddComEnterUnit ( j , i ) ;
24043: LD_VAR 0 2
24047: PPUSH
24048: LD_VAR 0 1
24052: PPUSH
24053: CALL_OW 180
// hums := hums diff j ;
24057: LD_ADDR_VAR 0 4
24061: PUSH
24062: LD_VAR 0 4
24066: PUSH
24067: LD_VAR 0 2
24071: DIFF
24072: ST_TO_ADDR
// end ;
24073: GO 23969
24075: POP
24076: POP
// blds := UnitFilter ( fort , [ [ f_not , [ f_occupied ] ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
24077: LD_ADDR_VAR 0 3
24081: PUSH
24082: LD_EXP 81
24086: PPUSH
24087: LD_INT 3
24089: PUSH
24090: LD_INT 59
24092: PUSH
24093: EMPTY
24094: LIST
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: PUSH
24100: LD_INT 2
24102: PUSH
24103: LD_INT 30
24105: PUSH
24106: LD_INT 5
24108: PUSH
24109: EMPTY
24110: LIST
24111: LIST
24112: PUSH
24113: LD_INT 30
24115: PUSH
24116: LD_INT 4
24118: PUSH
24119: EMPTY
24120: LIST
24121: LIST
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: LIST
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PPUSH
24132: CALL_OW 72
24136: ST_TO_ADDR
// for i in blds do
24137: LD_ADDR_VAR 0 1
24141: PUSH
24142: LD_VAR 0 3
24146: PUSH
24147: FOR_IN
24148: IFFALSE 24208
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24150: LD_VAR 0 4
24154: PPUSH
24155: LD_INT 22
24157: PUSH
24158: LD_VAR 0 1
24162: PPUSH
24163: CALL_OW 255
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: PUSH
24172: LD_INT 91
24174: PUSH
24175: LD_VAR 0 1
24179: PUSH
24180: LD_INT 30
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: LIST
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PPUSH
24192: CALL_OW 72
24196: PPUSH
24197: LD_VAR 0 1
24201: PPUSH
24202: CALL_OW 120
24206: GO 24147
24208: POP
24209: POP
// enable ;
24210: ENABLE
// end ;
24211: PPOPN 5
24213: END
// every 0 0$2 + 0 0$0.5 do var i , j , blds , hums ;
24214: GO 24216
24216: DISABLE
24217: LD_INT 0
24219: PPUSH
24220: PPUSH
24221: PPUSH
24222: PPUSH
// begin blds := dep ;
24223: LD_ADDR_VAR 0 3
24227: PUSH
24228: LD_EXP 83
24232: ST_TO_ADDR
// hums := [ ] ;
24233: LD_ADDR_VAR 0 4
24237: PUSH
24238: EMPTY
24239: ST_TO_ADDR
// for i in eng do
24240: LD_ADDR_VAR 0 1
24244: PUSH
24245: LD_EXP 84
24249: PUSH
24250: FOR_IN
24251: IFFALSE 24298
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24253: LD_VAR 0 1
24257: PPUSH
24258: CALL_OW 315
24262: NOT
24263: PUSH
24264: LD_VAR 0 1
24268: PPUSH
24269: CALL_OW 310
24273: NOT
24274: AND
24275: IFFALSE 24296
// hums := hums ^ [ i ] ;
24277: LD_ADDR_VAR 0 4
24281: PUSH
24282: LD_VAR 0 4
24286: PUSH
24287: LD_VAR 0 1
24291: PUSH
24292: EMPTY
24293: LIST
24294: ADD
24295: ST_TO_ADDR
24296: GO 24250
24298: POP
24299: POP
// for i in blds do
24300: LD_ADDR_VAR 0 1
24304: PUSH
24305: LD_VAR 0 3
24309: PUSH
24310: FOR_IN
24311: IFFALSE 24371
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , GetSide ( i ) ] , [ f_dist , i , 25 ] ] ) , i ) ;
24313: LD_VAR 0 4
24317: PPUSH
24318: LD_INT 22
24320: PUSH
24321: LD_VAR 0 1
24325: PPUSH
24326: CALL_OW 255
24330: PUSH
24331: EMPTY
24332: LIST
24333: LIST
24334: PUSH
24335: LD_INT 91
24337: PUSH
24338: LD_VAR 0 1
24342: PUSH
24343: LD_INT 25
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: LIST
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: PPUSH
24355: CALL_OW 72
24359: PPUSH
24360: LD_VAR 0 1
24364: PPUSH
24365: CALL_OW 120
24369: GO 24310
24371: POP
24372: POP
// enable ;
24373: ENABLE
// end ;
24374: PPOPN 4
24376: END
// every 0 0$2 + 0 0$0.7 do var i , j , blds , hums ;
24377: GO 24379
24379: DISABLE
24380: LD_INT 0
24382: PPUSH
24383: PPUSH
24384: PPUSH
24385: PPUSH
// begin blds := fact ;
24386: LD_ADDR_VAR 0 3
24390: PUSH
24391: LD_EXP 85
24395: ST_TO_ADDR
// hums := [ ] ;
24396: LD_ADDR_VAR 0 4
24400: PUSH
24401: EMPTY
24402: ST_TO_ADDR
// for i in mec do
24403: LD_ADDR_VAR 0 1
24407: PUSH
24408: LD_EXP 86
24412: PUSH
24413: FOR_IN
24414: IFFALSE 24461
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24416: LD_VAR 0 1
24420: PPUSH
24421: CALL_OW 315
24425: NOT
24426: PUSH
24427: LD_VAR 0 1
24431: PPUSH
24432: CALL_OW 310
24436: NOT
24437: AND
24438: IFFALSE 24459
// hums := hums ^ [ i ] ;
24440: LD_ADDR_VAR 0 4
24444: PUSH
24445: LD_VAR 0 4
24449: PUSH
24450: LD_VAR 0 1
24454: PUSH
24455: EMPTY
24456: LIST
24457: ADD
24458: ST_TO_ADDR
24459: GO 24413
24461: POP
24462: POP
// for i in blds do
24463: LD_ADDR_VAR 0 1
24467: PUSH
24468: LD_VAR 0 3
24472: PUSH
24473: FOR_IN
24474: IFFALSE 24534
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24476: LD_VAR 0 4
24480: PPUSH
24481: LD_INT 22
24483: PUSH
24484: LD_VAR 0 1
24488: PPUSH
24489: CALL_OW 255
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: PUSH
24498: LD_INT 91
24500: PUSH
24501: LD_VAR 0 1
24505: PUSH
24506: LD_INT 30
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: LIST
24513: PUSH
24514: EMPTY
24515: LIST
24516: LIST
24517: PPUSH
24518: CALL_OW 72
24522: PPUSH
24523: LD_VAR 0 1
24527: PPUSH
24528: CALL_OW 120
24532: GO 24473
24534: POP
24535: POP
// enable ;
24536: ENABLE
// end ;
24537: PPOPN 4
24539: END
// every 0 0$2 + 0 0$0.9 do var i , j , blds , hums ;
24540: GO 24542
24542: DISABLE
24543: LD_INT 0
24545: PPUSH
24546: PPUSH
24547: PPUSH
24548: PPUSH
// begin blds := lab ;
24549: LD_ADDR_VAR 0 3
24553: PUSH
24554: LD_EXP 87
24558: ST_TO_ADDR
// hums := [ ] ;
24559: LD_ADDR_VAR 0 4
24563: PUSH
24564: EMPTY
24565: ST_TO_ADDR
// for i in sci do
24566: LD_ADDR_VAR 0 1
24570: PUSH
24571: LD_EXP 88
24575: PUSH
24576: FOR_IN
24577: IFFALSE 24624
// if not IsBusy ( i ) and not IsInUnit ( i ) then
24579: LD_VAR 0 1
24583: PPUSH
24584: CALL_OW 315
24588: NOT
24589: PUSH
24590: LD_VAR 0 1
24594: PPUSH
24595: CALL_OW 310
24599: NOT
24600: AND
24601: IFFALSE 24622
// hums := hums ^ [ i ] ;
24603: LD_ADDR_VAR 0 4
24607: PUSH
24608: LD_VAR 0 4
24612: PUSH
24613: LD_VAR 0 1
24617: PUSH
24618: EMPTY
24619: LIST
24620: ADD
24621: ST_TO_ADDR
24622: GO 24576
24624: POP
24625: POP
// for i in blds do
24626: LD_ADDR_VAR 0 1
24630: PUSH
24631: LD_VAR 0 3
24635: PUSH
24636: FOR_IN
24637: IFFALSE 24697
// ComEnterUnit ( UnitFilter ( hums , [ [ f_side , Getside ( i ) ] , [ f_dist , i , 30 ] ] ) , i ) ;
24639: LD_VAR 0 4
24643: PPUSH
24644: LD_INT 22
24646: PUSH
24647: LD_VAR 0 1
24651: PPUSH
24652: CALL_OW 255
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 91
24663: PUSH
24664: LD_VAR 0 1
24668: PUSH
24669: LD_INT 30
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: LIST
24676: PUSH
24677: EMPTY
24678: LIST
24679: LIST
24680: PPUSH
24681: CALL_OW 72
24685: PPUSH
24686: LD_VAR 0 1
24690: PPUSH
24691: CALL_OW 120
24695: GO 24636
24697: POP
24698: POP
// enable ;
24699: ENABLE
// end ; end_of_file
24700: PPOPN 4
24702: END
// on UnitDestroyed ( un ) do var h , hinfo , a ;
24703: LD_INT 0
24705: PPUSH
24706: PPUSH
24707: PPUSH
// begin if un = Burlak then
24708: LD_VAR 0 1
24712: PUSH
24713: LD_EXP 41
24717: EQUAL
24718: IFFALSE 24727
// begin YouLost ( Burlak ) ;
24720: LD_STRING Burlak
24722: PPUSH
24723: CALL_OW 104
// end ; if un = Platonov then
24727: LD_VAR 0 1
24731: PUSH
24732: LD_EXP 42
24736: EQUAL
24737: IFFALSE 24762
// begin SurrenderBase ( t_kill , GetSide ( un ) ) ;
24739: LD_EXP 1
24743: PPUSH
24744: LD_VAR 0 1
24748: PPUSH
24749: CALL_OW 255
24753: PPUSH
24754: CALL 30389 0 2
// VyhraPlaton ;
24758: CALL 358 0 0
// end ; if GetSide ( un ) <> you then
24762: LD_VAR 0 1
24766: PPUSH
24767: CALL_OW 255
24771: PUSH
24772: LD_EXP 7
24776: NONEQUAL
24777: IFFALSE 24806
// begin remove_from_vehicles ( un ) ;
24779: LD_VAR 0 1
24783: PPUSH
24784: CALL 28295 0 1
// remove_from_humans ( un ) ;
24788: LD_VAR 0 1
24792: PPUSH
24793: CALL 28057 0 1
// remove_from_builds ( un ) ;
24797: LD_VAR 0 1
24801: PPUSH
24802: CALL 27811 0 1
// end ; if not GetSide ( un ) in your_bases then
24806: LD_VAR 0 1
24810: PPUSH
24811: CALL_OW 255
24815: PUSH
24816: LD_EXP 18
24820: IN
24821: NOT
24822: IFFALSE 24944
// begin if un = Borodin then
24824: LD_VAR 0 1
24828: PUSH
24829: LD_EXP 46
24833: EQUAL
24834: IFFALSE 24854
// begin SurrenderBase ( t_kill , ai_s [ 2 ] ) ;
24836: LD_EXP 1
24840: PPUSH
24841: LD_EXP 23
24845: PUSH
24846: LD_INT 2
24848: ARRAY
24849: PPUSH
24850: CALL 30389 0 2
// end ; if un = Tsaritsyn then
24854: LD_VAR 0 1
24858: PUSH
24859: LD_EXP 47
24863: EQUAL
24864: IFFALSE 24884
// begin SurrenderBase ( t_kill , ai_s [ 3 ] ) ;
24866: LD_EXP 1
24870: PPUSH
24871: LD_EXP 23
24875: PUSH
24876: LD_INT 3
24878: ARRAY
24879: PPUSH
24880: CALL 30389 0 2
// end ; if un = Davidov then
24884: LD_VAR 0 1
24888: PUSH
24889: LD_EXP 48
24893: EQUAL
24894: IFFALSE 24914
// begin SurrenderBase ( t_kill , ai_s [ 4 ] ) ;
24896: LD_EXP 1
24900: PPUSH
24901: LD_EXP 23
24905: PUSH
24906: LD_INT 4
24908: ARRAY
24909: PPUSH
24910: CALL 30389 0 2
// end ; if un = Eisenstein then
24914: LD_VAR 0 1
24918: PUSH
24919: LD_EXP 49
24923: EQUAL
24924: IFFALSE 24944
// begin SurrenderBase ( t_kill , ai_s [ 5 ] ) ;
24926: LD_EXP 1
24930: PPUSH
24931: LD_EXP 23
24935: PUSH
24936: LD_INT 5
24938: ARRAY
24939: PPUSH
24940: CALL 30389 0 2
// end ; end ; if GetSide ( un ) = you then
24944: LD_VAR 0 1
24948: PPUSH
24949: CALL_OW 255
24953: PUSH
24954: LD_EXP 7
24958: EQUAL
24959: IFFALSE 25079
// case true of GetType ( un ) = unit_building :
24961: LD_INT 1
24963: PUSH
24964: LD_VAR 0 1
24968: PPUSH
24969: CALL_OW 247
24973: PUSH
24974: LD_INT 3
24976: EQUAL
24977: DOUBLE
24978: EQUAL
24979: IFTRUE 24983
24981: GO 25002
24983: POP
// your_builds := your_builds diff un ; GetType ( un ) = unit_vehicle :
24984: LD_ADDR_EXP 36
24988: PUSH
24989: LD_EXP 36
24993: PUSH
24994: LD_VAR 0 1
24998: DIFF
24999: ST_TO_ADDR
25000: GO 25079
25002: LD_VAR 0 1
25006: PPUSH
25007: CALL_OW 247
25011: PUSH
25012: LD_INT 2
25014: EQUAL
25015: DOUBLE
25016: EQUAL
25017: IFTRUE 25021
25019: GO 25040
25021: POP
// your_cars := your_cars diff un ; GetType ( un ) = unit_human :
25022: LD_ADDR_EXP 35
25026: PUSH
25027: LD_EXP 35
25031: PUSH
25032: LD_VAR 0 1
25036: DIFF
25037: ST_TO_ADDR
25038: GO 25079
25040: LD_VAR 0 1
25044: PPUSH
25045: CALL_OW 247
25049: PUSH
25050: LD_INT 1
25052: EQUAL
25053: DOUBLE
25054: EQUAL
25055: IFTRUE 25059
25057: GO 25078
25059: POP
// your_humans := your_humans diff un ; end ;
25060: LD_ADDR_EXP 37
25064: PUSH
25065: LD_EXP 37
25069: PUSH
25070: LD_VAR 0 1
25074: DIFF
25075: ST_TO_ADDR
25076: GO 25079
25078: POP
// end ;
25079: PPOPN 4
25081: END
// on UnitGoesToRed ( un ) do var a ;
25082: LD_INT 0
25084: PPUSH
// begin if not GetSide ( un ) in your_bases ^ you then
25085: LD_VAR 0 1
25089: PPUSH
25090: CALL_OW 255
25094: PUSH
25095: LD_EXP 18
25099: PUSH
25100: LD_EXP 7
25104: ADD
25105: IN
25106: NOT
25107: IFFALSE 25340
// begin if GetBType ( un ) in [ b_depot , b_warehouse ] then
25109: LD_VAR 0 1
25113: PPUSH
25114: CALL_OW 266
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: LD_INT 1
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: IN
25129: IFFALSE 25340
// begin a := FilterAllUnits ( [ [ f_side , GetSide ( un ) ] ] ) ;
25131: LD_ADDR_VAR 0 2
25135: PUSH
25136: LD_INT 22
25138: PUSH
25139: LD_VAR 0 1
25143: PPUSH
25144: CALL_OW 255
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: EMPTY
25154: LIST
25155: PPUSH
25156: CALL_OW 69
25160: ST_TO_ADDR
// if GetSide ( un ) = ai_s [ 1 ] and IsDead ( behemoth ) and UnitFilter ( a , [ mf_sol ] ) <= 2 and UnitFilter ( a , [ [ f_type , unit_vehicle ] , [ f_or , [ [ f_control , control_manual ] , [ f_occupied ] ] , [ f_control , control_computer ] ] ] ) <= 1 then
25161: LD_VAR 0 1
25165: PPUSH
25166: CALL_OW 255
25170: PUSH
25171: LD_EXP 23
25175: PUSH
25176: LD_INT 1
25178: ARRAY
25179: EQUAL
25180: PUSH
25181: LD_INT 125
25183: PPUSH
25184: CALL_OW 301
25188: AND
25189: PUSH
25190: LD_VAR 0 2
25194: PPUSH
25195: LD_EXP 51
25199: PUSH
25200: EMPTY
25201: LIST
25202: PPUSH
25203: CALL_OW 72
25207: PUSH
25208: LD_INT 2
25210: LESSEQUAL
25211: AND
25212: PUSH
25213: LD_VAR 0 2
25217: PPUSH
25218: LD_INT 21
25220: PUSH
25221: LD_INT 2
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 2
25230: PUSH
25231: LD_INT 33
25233: PUSH
25234: LD_INT 1
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: PUSH
25241: LD_INT 59
25243: PUSH
25244: EMPTY
25245: LIST
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PUSH
25251: LD_INT 33
25253: PUSH
25254: LD_INT 3
25256: PUSH
25257: EMPTY
25258: LIST
25259: LIST
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: LIST
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PPUSH
25270: CALL_OW 72
25274: PUSH
25275: LD_INT 1
25277: LESSEQUAL
25278: AND
25279: IFFALSE 25300
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25281: LD_EXP 6
25285: PPUSH
25286: LD_VAR 0 1
25290: PPUSH
25291: CALL_OW 255
25295: PPUSH
25296: CALL 30389 0 2
// if GetSide ( un ) <> ai_s [ 1 ] then
25300: LD_VAR 0 1
25304: PPUSH
25305: CALL_OW 255
25309: PUSH
25310: LD_EXP 23
25314: PUSH
25315: LD_INT 1
25317: ARRAY
25318: NONEQUAL
25319: IFFALSE 25340
// SurrenderBase ( t_killbeat , GetSide ( un ) ) ;
25321: LD_EXP 6
25325: PPUSH
25326: LD_VAR 0 1
25330: PPUSH
25331: CALL_OW 255
25335: PPUSH
25336: CALL 30389 0 2
// end ; end ; end ;
25340: PPOPN 2
25342: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside in ai then
25343: LD_VAR 0 3
25347: PUSH
25348: LD_EXP 24
25352: IN
25353: IFFALSE 25416
// begin remove_from_vehicles ( vehold ) ;
25355: LD_VAR 0 2
25359: PPUSH
25360: CALL 28295 0 1
// if GetAttitude ( origside , you ) = att_neutral then
25364: LD_VAR 0 3
25368: PPUSH
25369: LD_EXP 7
25373: PPUSH
25374: CALL_OW 81
25378: PUSH
25379: LD_INT 0
25381: EQUAL
25382: IFFALSE 25416
// begin ComExitVehicle ( vehnew ) ;
25384: LD_VAR 0 1
25388: PPUSH
25389: CALL_OW 121
// SetSide ( vehnew , origside ) ;
25393: LD_VAR 0 1
25397: PPUSH
25398: LD_VAR 0 3
25402: PPUSH
25403: CALL_OW 235
// add_to_vehicles ( vehnew ) ;
25407: LD_VAR 0 1
25411: PPUSH
25412: CALL 26964 0 1
// end ; end ; if Getside ( vehnew ) in ai then
25416: LD_VAR 0 1
25420: PPUSH
25421: CALL_OW 255
25425: PUSH
25426: LD_EXP 24
25430: IN
25431: IFFALSE 25442
// begin add_to_vehicles ( vehnew ) ;
25433: LD_VAR 0 1
25437: PPUSH
25438: CALL 26964 0 1
// end ; if origside = you then
25442: LD_VAR 0 3
25446: PUSH
25447: LD_EXP 7
25451: EQUAL
25452: IFFALSE 25470
// your_cars := your_cars diff vehold ;
25454: LD_ADDR_EXP 35
25458: PUSH
25459: LD_EXP 35
25463: PUSH
25464: LD_VAR 0 2
25468: DIFF
25469: ST_TO_ADDR
// if GetSide ( vehnew ) = you then
25470: LD_VAR 0 1
25474: PPUSH
25475: CALL_OW 255
25479: PUSH
25480: LD_EXP 7
25484: EQUAL
25485: IFFALSE 25503
// your_cars := your_cars union vehnew ;
25487: LD_ADDR_EXP 35
25491: PUSH
25492: LD_EXP 35
25496: PUSH
25497: LD_VAR 0 1
25501: UNION
25502: ST_TO_ADDR
// if getside ( vehnew ) and GetCargo ( vehnew , mat_artefact ) > 0 then
25503: LD_VAR 0 1
25507: PPUSH
25508: CALL_OW 255
25512: PUSH
25513: LD_VAR 0 1
25517: PPUSH
25518: LD_INT 4
25520: PPUSH
25521: CALL_OW 289
25525: PUSH
25526: LD_INT 0
25528: GREATER
25529: AND
25530: IFFALSE 25540
// maji_artifact := true ;
25532: LD_ADDR_EXP 39
25536: PUSH
25537: LD_INT 1
25539: ST_TO_ADDR
// if origside = you and GetCargo ( vehnew , mat_artefact ) > 0 then
25540: LD_VAR 0 3
25544: PUSH
25545: LD_EXP 7
25549: EQUAL
25550: PUSH
25551: LD_VAR 0 1
25555: PPUSH
25556: LD_INT 4
25558: PPUSH
25559: CALL_OW 289
25563: PUSH
25564: LD_INT 0
25566: GREATER
25567: AND
25568: IFFALSE 25578
// maji_artifact := false ;
25570: LD_ADDR_EXP 39
25574: PUSH
25575: LD_INT 0
25577: ST_TO_ADDR
// end ;
25578: PPOPN 4
25580: END
// on BuildingCaptured ( build , origside , eng ) do begin if origside = you then
25581: LD_VAR 0 2
25585: PUSH
25586: LD_EXP 7
25590: EQUAL
25591: IFFALSE 25609
// begin your_builds := your_builds diff build ;
25593: LD_ADDR_EXP 36
25597: PUSH
25598: LD_EXP 36
25602: PUSH
25603: LD_VAR 0 1
25607: DIFF
25608: ST_TO_ADDR
// end ; if GetSide ( build ) = you then
25609: LD_VAR 0 1
25613: PPUSH
25614: CALL_OW 255
25618: PUSH
25619: LD_EXP 7
25623: EQUAL
25624: IFFALSE 25642
// begin your_builds := your_builds union build ;
25626: LD_ADDR_EXP 36
25630: PUSH
25631: LD_EXP 36
25635: PUSH
25636: LD_VAR 0 1
25640: UNION
25641: ST_TO_ADDR
// end ; if origside in ai then
25642: LD_VAR 0 2
25646: PUSH
25647: LD_EXP 24
25651: IN
25652: IFFALSE 25663
// begin remove_from_builds ( build ) ;
25654: LD_VAR 0 1
25658: PPUSH
25659: CALL 27811 0 1
// end ; if GetSide ( build ) in ai then
25663: LD_VAR 0 1
25667: PPUSH
25668: CALL_OW 255
25672: PUSH
25673: LD_EXP 24
25677: IN
25678: IFFALSE 25689
// begin add_to_builds ( build ) ;
25680: LD_VAR 0 1
25684: PPUSH
25685: CALL 27309 0 1
// end ; end ;
25689: PPOPN 3
25691: END
// on BuildingComplete ( build ) do begin if GetSide ( build ) = you then
25692: LD_VAR 0 1
25696: PPUSH
25697: CALL_OW 255
25701: PUSH
25702: LD_EXP 7
25706: EQUAL
25707: IFFALSE 25725
// begin your_builds := your_builds union build ;
25709: LD_ADDR_EXP 36
25713: PUSH
25714: LD_EXP 36
25718: PUSH
25719: LD_VAR 0 1
25723: UNION
25724: ST_TO_ADDR
// end ; if GetSide ( build ) in ai then
25725: LD_VAR 0 1
25729: PPUSH
25730: CALL_OW 255
25734: PUSH
25735: LD_EXP 24
25739: IN
25740: IFFALSE 25751
// begin add_to_builds ( build ) ;
25742: LD_VAR 0 1
25746: PPUSH
25747: CALL 27309 0 1
// end ; end ;
25751: PPOPN 1
25753: END
// on VehicleConstructed ( veh , fact ) do begin if GetSide ( veh ) = you then
25754: LD_VAR 0 1
25758: PPUSH
25759: CALL_OW 255
25763: PUSH
25764: LD_EXP 7
25768: EQUAL
25769: IFFALSE 25787
// begin your_cars := your_cars union veh ;
25771: LD_ADDR_EXP 35
25775: PUSH
25776: LD_EXP 35
25780: PUSH
25781: LD_VAR 0 1
25785: UNION
25786: ST_TO_ADDR
// end ; if GetSide ( veh ) in ai then
25787: LD_VAR 0 1
25791: PPUSH
25792: CALL_OW 255
25796: PUSH
25797: LD_EXP 24
25801: IN
25802: IFFALSE 26151
// begin if GetControl ( veh ) = control_computer then
25804: LD_VAR 0 1
25808: PPUSH
25809: CALL_OW 263
25813: PUSH
25814: LD_INT 3
25816: EQUAL
25817: IFFALSE 25977
// case GetSide ( veh ) of ai_s [ 1 ] :
25819: LD_VAR 0 1
25823: PPUSH
25824: CALL_OW 255
25828: PUSH
25829: LD_EXP 23
25833: PUSH
25834: LD_INT 1
25836: ARRAY
25837: DOUBLE
25838: EQUAL
25839: IFTRUE 25843
25841: GO 25858
25843: POP
// ComMoveToArea ( veh , pro_attA ) ; ai_s [ 2 ] :
25844: LD_VAR 0 1
25848: PPUSH
25849: LD_INT 8
25851: PPUSH
25852: CALL_OW 113
25856: GO 25975
25858: LD_EXP 23
25862: PUSH
25863: LD_INT 2
25865: ARRAY
25866: DOUBLE
25867: EQUAL
25868: IFTRUE 25872
25870: GO 25887
25872: POP
// ComMoveToArea ( veh , pro_attB ) ; ai_s [ 3 ] :
25873: LD_VAR 0 1
25877: PPUSH
25878: LD_INT 10
25880: PPUSH
25881: CALL_OW 113
25885: GO 25975
25887: LD_EXP 23
25891: PUSH
25892: LD_INT 3
25894: ARRAY
25895: DOUBLE
25896: EQUAL
25897: IFTRUE 25901
25899: GO 25916
25901: POP
// ComMoveToArea ( veh , pro_attC ) ; ai_s [ 4 ] :
25902: LD_VAR 0 1
25906: PPUSH
25907: LD_INT 17
25909: PPUSH
25910: CALL_OW 113
25914: GO 25975
25916: LD_EXP 23
25920: PUSH
25921: LD_INT 4
25923: ARRAY
25924: DOUBLE
25925: EQUAL
25926: IFTRUE 25930
25928: GO 25945
25930: POP
// ComMoveToArea ( veh , pro_attD ) ; ai_s [ 5 ] :
25931: LD_VAR 0 1
25935: PPUSH
25936: LD_INT 15
25938: PPUSH
25939: CALL_OW 113
25943: GO 25975
25945: LD_EXP 23
25949: PUSH
25950: LD_INT 5
25952: ARRAY
25953: DOUBLE
25954: EQUAL
25955: IFTRUE 25959
25957: GO 25974
25959: POP
// ComMoveToArea ( veh , pro_attE ) ; end else
25960: LD_VAR 0 1
25964: PPUSH
25965: LD_INT 12
25967: PPUSH
25968: CALL_OW 113
25972: GO 25975
25974: POP
25975: GO 26133
// case GetSide ( veh ) of ai_s [ 1 ] :
25977: LD_VAR 0 1
25981: PPUSH
25982: CALL_OW 255
25986: PUSH
25987: LD_EXP 23
25991: PUSH
25992: LD_INT 1
25994: ARRAY
25995: DOUBLE
25996: EQUAL
25997: IFTRUE 26001
25999: GO 26016
26001: POP
// ComMoveToArea ( veh , pro_defA ) ; ai_s [ 2 ] :
26002: LD_VAR 0 1
26006: PPUSH
26007: LD_INT 9
26009: PPUSH
26010: CALL_OW 113
26014: GO 26133
26016: LD_EXP 23
26020: PUSH
26021: LD_INT 2
26023: ARRAY
26024: DOUBLE
26025: EQUAL
26026: IFTRUE 26030
26028: GO 26045
26030: POP
// ComMoveToArea ( veh , pro_defB ) ; ai_s [ 3 ] :
26031: LD_VAR 0 1
26035: PPUSH
26036: LD_INT 11
26038: PPUSH
26039: CALL_OW 113
26043: GO 26133
26045: LD_EXP 23
26049: PUSH
26050: LD_INT 3
26052: ARRAY
26053: DOUBLE
26054: EQUAL
26055: IFTRUE 26059
26057: GO 26074
26059: POP
// ComMoveToArea ( veh , pro_defC ) ; ai_s [ 4 ] :
26060: LD_VAR 0 1
26064: PPUSH
26065: LD_INT 16
26067: PPUSH
26068: CALL_OW 113
26072: GO 26133
26074: LD_EXP 23
26078: PUSH
26079: LD_INT 4
26081: ARRAY
26082: DOUBLE
26083: EQUAL
26084: IFTRUE 26088
26086: GO 26103
26088: POP
// ComMoveToArea ( veh , pro_defD ) ; ai_s [ 5 ] :
26089: LD_VAR 0 1
26093: PPUSH
26094: LD_INT 14
26096: PPUSH
26097: CALL_OW 113
26101: GO 26133
26103: LD_EXP 23
26107: PUSH
26108: LD_INT 5
26110: ARRAY
26111: DOUBLE
26112: EQUAL
26113: IFTRUE 26117
26115: GO 26132
26117: POP
// ComMoveToArea ( veh , pro_defE ) ; end ;
26118: LD_VAR 0 1
26122: PPUSH
26123: LD_INT 13
26125: PPUSH
26126: CALL_OW 113
26130: GO 26133
26132: POP
// AddComExitVehicle ( veh ) ;
26133: LD_VAR 0 1
26137: PPUSH
26138: CALL_OW 181
// add_to_vehicles ( veh ) ;
26142: LD_VAR 0 1
26146: PPUSH
26147: CALL 26964 0 1
// end ; end ;
26151: PPOPN 2
26153: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) = you then
26154: LD_VAR 0 1
26158: PPUSH
26159: CALL_OW 255
26163: PUSH
26164: LD_EXP 7
26168: EQUAL
26169: IFFALSE 26179
// maji_artifact := true ;
26171: LD_ADDR_EXP 39
26175: PUSH
26176: LD_INT 1
26178: ST_TO_ADDR
// art_cargo1 := un ;
26179: LD_ADDR_EXP 34
26183: PUSH
26184: LD_VAR 0 1
26188: ST_TO_ADDR
// end ;
26189: PPOPN 2
26191: END
// on ArtifactUnloaded ( un , size ) do begin if GetSide ( un ) = you then
26192: LD_VAR 0 1
26196: PPUSH
26197: CALL_OW 255
26201: PUSH
26202: LD_EXP 7
26206: EQUAL
26207: IFFALSE 26217
// maji_artifact := false ;
26209: LD_ADDR_EXP 39
26213: PUSH
26214: LD_INT 0
26216: ST_TO_ADDR
// art_cargo1 := 0 ;
26217: LD_ADDR_EXP 34
26221: PUSH
26222: LD_INT 0
26224: ST_TO_ADDR
// end ;
26225: PPOPN 2
26227: END
// on Command ( comm ) do begin if not Getside ( Eisenstein ) = you and IsInUnit ( Eisenstein ) then
26228: LD_EXP 49
26232: PPUSH
26233: CALL_OW 255
26237: PUSH
26238: LD_EXP 7
26242: EQUAL
26243: NOT
26244: PUSH
26245: LD_EXP 49
26249: PPUSH
26250: CALL_OW 310
26254: AND
26255: IFFALSE 26266
// RemoveTasks ( Eisenstein ) ;
26257: LD_EXP 49
26261: PPUSH
26262: CALL_OW 493
// if not Getside ( Davidov ) = you and IsInUnit ( Davidov ) then
26266: LD_EXP 48
26270: PPUSH
26271: CALL_OW 255
26275: PUSH
26276: LD_EXP 7
26280: EQUAL
26281: NOT
26282: PUSH
26283: LD_EXP 48
26287: PPUSH
26288: CALL_OW 310
26292: AND
26293: IFFALSE 26304
// RemoveTasks ( Davidov ) ;
26295: LD_EXP 48
26299: PPUSH
26300: CALL_OW 493
// if not Getside ( Tsaritsyn ) = you and IsInUnit ( Tsaritsyn ) then
26304: LD_EXP 47
26308: PPUSH
26309: CALL_OW 255
26313: PUSH
26314: LD_EXP 7
26318: EQUAL
26319: NOT
26320: PUSH
26321: LD_EXP 47
26325: PPUSH
26326: CALL_OW 310
26330: AND
26331: IFFALSE 26342
// RemoveTasks ( Tsaritsyn ) ;
26333: LD_EXP 47
26337: PPUSH
26338: CALL_OW 493
// if not Getside ( Borodin ) = you and IsInUnit ( Borodin ) then
26342: LD_EXP 46
26346: PPUSH
26347: CALL_OW 255
26351: PUSH
26352: LD_EXP 7
26356: EQUAL
26357: NOT
26358: PUSH
26359: LD_EXP 46
26363: PPUSH
26364: CALL_OW 310
26368: AND
26369: IFFALSE 26380
// RemoveTasks ( Borodin ) ;
26371: LD_EXP 46
26375: PPUSH
26376: CALL_OW 493
// end ;
26380: PPOPN 1
26382: END
// on McAttackDone ( mcid , surv ) do begin msg ( [ mcid , McAttackDone , surv ] ) ;
26383: LD_VAR 0 1
26387: PUSH
26388: LD_STRING McAttackDone
26390: PUSH
26391: LD_VAR 0 2
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: LIST
26400: PPUSH
26401: CALL_OW 100
// end ;
26405: PPOPN 2
26407: END
// on McRegistryResultChanges ( mcid , count , strength ) do begin if mcid = BehMcRegId then
26408: LD_VAR 0 1
26412: PUSH
26413: LD_EXP 64
26417: EQUAL
26418: IFFALSE 26469
// debug_strings := replace ( debug_strings , 2 , [ mcid , count , strength , GetMcUnits ( BehMcAttId ) ] ) ;
26420: LD_ADDR_OWVAR 48
26424: PUSH
26425: LD_OWVAR 48
26429: PPUSH
26430: LD_INT 2
26432: PPUSH
26433: LD_VAR 0 1
26437: PUSH
26438: LD_VAR 0 2
26442: PUSH
26443: LD_VAR 0 3
26447: PUSH
26448: LD_EXP 65
26452: PPUSH
26453: CALL_OW 389
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: LIST
26462: LIST
26463: PPUSH
26464: CALL_OW 1
26468: ST_TO_ADDR
// end ;
26469: PPOPN 3
26471: END
// export function add_to ( un ) ; begin
26472: LD_INT 0
26474: PPUSH
// add_to_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
26475: LD_VAR 0 1
26479: PPUSH
26480: LD_INT 21
26482: PUSH
26483: LD_INT 1
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: PUSH
26490: EMPTY
26491: LIST
26492: PPUSH
26493: CALL_OW 72
26497: PPUSH
26498: CALL 26561 0 1
// add_to_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
26502: LD_VAR 0 1
26506: PPUSH
26507: LD_INT 21
26509: PUSH
26510: LD_INT 3
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: EMPTY
26518: LIST
26519: PPUSH
26520: CALL_OW 72
26524: PPUSH
26525: CALL 27309 0 1
// add_to_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
26529: LD_VAR 0 1
26533: PPUSH
26534: LD_INT 21
26536: PUSH
26537: LD_INT 2
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: PPUSH
26547: CALL_OW 72
26551: PPUSH
26552: CALL 26964 0 1
// end ;
26556: LD_VAR 0 2
26560: RET
// export function add_to_humans ( un ) ; var i ; begin
26561: LD_INT 0
26563: PPUSH
26564: PPUSH
// sol := sol union UnitFilter ( un , [ mf_sol ] ) ;
26565: LD_ADDR_EXP 82
26569: PUSH
26570: LD_EXP 82
26574: PUSH
26575: LD_VAR 0 1
26579: PPUSH
26580: LD_EXP 51
26584: PUSH
26585: EMPTY
26586: LIST
26587: PPUSH
26588: CALL_OW 72
26592: UNION
26593: ST_TO_ADDR
// eng := eng union UnitFilter ( un , [ mf_eng ] ) ;
26594: LD_ADDR_EXP 84
26598: PUSH
26599: LD_EXP 84
26603: PUSH
26604: LD_VAR 0 1
26608: PPUSH
26609: LD_EXP 52
26613: PUSH
26614: EMPTY
26615: LIST
26616: PPUSH
26617: CALL_OW 72
26621: UNION
26622: ST_TO_ADDR
// mec := mec union UnitFilter ( un , [ mf_mec ] ) ;
26623: LD_ADDR_EXP 86
26627: PUSH
26628: LD_EXP 86
26632: PUSH
26633: LD_VAR 0 1
26637: PPUSH
26638: LD_EXP 53
26642: PUSH
26643: EMPTY
26644: LIST
26645: PPUSH
26646: CALL_OW 72
26650: UNION
26651: ST_TO_ADDR
// sci := sci union UnitFilter ( un , [ mf_sci ] ) ;
26652: LD_ADDR_EXP 88
26656: PUSH
26657: LD_EXP 88
26661: PUSH
26662: LD_VAR 0 1
26666: PPUSH
26667: LD_EXP 54
26671: PUSH
26672: EMPTY
26673: LIST
26674: PPUSH
26675: CALL_OW 72
26679: UNION
26680: ST_TO_ADDR
// for i in un do
26681: LD_ADDR_VAR 0 3
26685: PUSH
26686: LD_VAR 0 1
26690: PUSH
26691: FOR_IN
26692: IFFALSE 26957
// begin case GetSide ( i ) of ai_s [ 1 ] :
26694: LD_VAR 0 3
26698: PPUSH
26699: CALL_OW 255
26703: PUSH
26704: LD_EXP 23
26708: PUSH
26709: LD_INT 1
26711: ARRAY
26712: DOUBLE
26713: EQUAL
26714: IFTRUE 26718
26716: GO 26754
26718: POP
// humans := replace ( humans , 1 , humans [ 1 ] union i ) ; ai_s [ 2 ] :
26719: LD_ADDR_EXP 76
26723: PUSH
26724: LD_EXP 76
26728: PPUSH
26729: LD_INT 1
26731: PPUSH
26732: LD_EXP 76
26736: PUSH
26737: LD_INT 1
26739: ARRAY
26740: PUSH
26741: LD_VAR 0 3
26745: UNION
26746: PPUSH
26747: CALL_OW 1
26751: ST_TO_ADDR
26752: GO 26955
26754: LD_EXP 23
26758: PUSH
26759: LD_INT 2
26761: ARRAY
26762: DOUBLE
26763: EQUAL
26764: IFTRUE 26768
26766: GO 26804
26768: POP
// humans := replace ( humans , 2 , humans [ 2 ] union i ) ; ai_s [ 3 ] :
26769: LD_ADDR_EXP 76
26773: PUSH
26774: LD_EXP 76
26778: PPUSH
26779: LD_INT 2
26781: PPUSH
26782: LD_EXP 76
26786: PUSH
26787: LD_INT 2
26789: ARRAY
26790: PUSH
26791: LD_VAR 0 3
26795: UNION
26796: PPUSH
26797: CALL_OW 1
26801: ST_TO_ADDR
26802: GO 26955
26804: LD_EXP 23
26808: PUSH
26809: LD_INT 3
26811: ARRAY
26812: DOUBLE
26813: EQUAL
26814: IFTRUE 26818
26816: GO 26854
26818: POP
// humans := replace ( humans , 3 , humans [ 3 ] union i ) ; ai_s [ 4 ] :
26819: LD_ADDR_EXP 76
26823: PUSH
26824: LD_EXP 76
26828: PPUSH
26829: LD_INT 3
26831: PPUSH
26832: LD_EXP 76
26836: PUSH
26837: LD_INT 3
26839: ARRAY
26840: PUSH
26841: LD_VAR 0 3
26845: UNION
26846: PPUSH
26847: CALL_OW 1
26851: ST_TO_ADDR
26852: GO 26955
26854: LD_EXP 23
26858: PUSH
26859: LD_INT 4
26861: ARRAY
26862: DOUBLE
26863: EQUAL
26864: IFTRUE 26868
26866: GO 26904
26868: POP
// humans := replace ( humans , 4 , humans [ 4 ] union i ) ; ai_s [ 5 ] :
26869: LD_ADDR_EXP 76
26873: PUSH
26874: LD_EXP 76
26878: PPUSH
26879: LD_INT 4
26881: PPUSH
26882: LD_EXP 76
26886: PUSH
26887: LD_INT 4
26889: ARRAY
26890: PUSH
26891: LD_VAR 0 3
26895: UNION
26896: PPUSH
26897: CALL_OW 1
26901: ST_TO_ADDR
26902: GO 26955
26904: LD_EXP 23
26908: PUSH
26909: LD_INT 5
26911: ARRAY
26912: DOUBLE
26913: EQUAL
26914: IFTRUE 26918
26916: GO 26954
26918: POP
// humans := replace ( humans , 5 , humans [ 5 ] union i ) ; end ;
26919: LD_ADDR_EXP 76
26923: PUSH
26924: LD_EXP 76
26928: PPUSH
26929: LD_INT 5
26931: PPUSH
26932: LD_EXP 76
26936: PUSH
26937: LD_INT 5
26939: ARRAY
26940: PUSH
26941: LD_VAR 0 3
26945: UNION
26946: PPUSH
26947: CALL_OW 1
26951: ST_TO_ADDR
26952: GO 26955
26954: POP
// end ;
26955: GO 26691
26957: POP
26958: POP
// end ;
26959: LD_VAR 0 2
26963: RET
// export function add_to_vehicles ( un ) ; var i ; begin
26964: LD_INT 0
26966: PPUSH
26967: PPUSH
// attack_units := attack_units union UnitFilter ( un , [ mf_comp ] ) ;
26968: LD_ADDR_EXP 78
26972: PUSH
26973: LD_EXP 78
26977: PUSH
26978: LD_VAR 0 1
26982: PPUSH
26983: LD_EXP 60
26987: PUSH
26988: EMPTY
26989: LIST
26990: PPUSH
26991: CALL_OW 72
26995: UNION
26996: ST_TO_ADDR
// defence_units := defence_units union UnitFilter ( un , [ mf_manu ] ) ;
26997: LD_ADDR_EXP 79
27001: PUSH
27002: LD_EXP 79
27006: PUSH
27007: LD_VAR 0 1
27011: PPUSH
27012: LD_EXP 61
27016: PUSH
27017: EMPTY
27018: LIST
27019: PPUSH
27020: CALL_OW 72
27024: UNION
27025: ST_TO_ADDR
// for i in un do
27026: LD_ADDR_VAR 0 3
27030: PUSH
27031: LD_VAR 0 1
27035: PUSH
27036: FOR_IN
27037: IFFALSE 27302
// begin case getside ( i ) of ai_s [ 1 ] :
27039: LD_VAR 0 3
27043: PPUSH
27044: CALL_OW 255
27048: PUSH
27049: LD_EXP 23
27053: PUSH
27054: LD_INT 1
27056: ARRAY
27057: DOUBLE
27058: EQUAL
27059: IFTRUE 27063
27061: GO 27099
27063: POP
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] union i ) ; ai_s [ 2 ] :
27064: LD_ADDR_EXP 77
27068: PUSH
27069: LD_EXP 77
27073: PPUSH
27074: LD_INT 1
27076: PPUSH
27077: LD_EXP 77
27081: PUSH
27082: LD_INT 1
27084: ARRAY
27085: PUSH
27086: LD_VAR 0 3
27090: UNION
27091: PPUSH
27092: CALL_OW 1
27096: ST_TO_ADDR
27097: GO 27300
27099: LD_EXP 23
27103: PUSH
27104: LD_INT 2
27106: ARRAY
27107: DOUBLE
27108: EQUAL
27109: IFTRUE 27113
27111: GO 27149
27113: POP
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] union i ) ; ai_s [ 3 ] :
27114: LD_ADDR_EXP 77
27118: PUSH
27119: LD_EXP 77
27123: PPUSH
27124: LD_INT 2
27126: PPUSH
27127: LD_EXP 77
27131: PUSH
27132: LD_INT 2
27134: ARRAY
27135: PUSH
27136: LD_VAR 0 3
27140: UNION
27141: PPUSH
27142: CALL_OW 1
27146: ST_TO_ADDR
27147: GO 27300
27149: LD_EXP 23
27153: PUSH
27154: LD_INT 3
27156: ARRAY
27157: DOUBLE
27158: EQUAL
27159: IFTRUE 27163
27161: GO 27199
27163: POP
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] union i ) ; ai_s [ 4 ] :
27164: LD_ADDR_EXP 77
27168: PUSH
27169: LD_EXP 77
27173: PPUSH
27174: LD_INT 3
27176: PPUSH
27177: LD_EXP 77
27181: PUSH
27182: LD_INT 3
27184: ARRAY
27185: PUSH
27186: LD_VAR 0 3
27190: UNION
27191: PPUSH
27192: CALL_OW 1
27196: ST_TO_ADDR
27197: GO 27300
27199: LD_EXP 23
27203: PUSH
27204: LD_INT 4
27206: ARRAY
27207: DOUBLE
27208: EQUAL
27209: IFTRUE 27213
27211: GO 27249
27213: POP
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] union i ) ; ai_s [ 5 ] :
27214: LD_ADDR_EXP 77
27218: PUSH
27219: LD_EXP 77
27223: PPUSH
27224: LD_INT 4
27226: PPUSH
27227: LD_EXP 77
27231: PUSH
27232: LD_INT 4
27234: ARRAY
27235: PUSH
27236: LD_VAR 0 3
27240: UNION
27241: PPUSH
27242: CALL_OW 1
27246: ST_TO_ADDR
27247: GO 27300
27249: LD_EXP 23
27253: PUSH
27254: LD_INT 5
27256: ARRAY
27257: DOUBLE
27258: EQUAL
27259: IFTRUE 27263
27261: GO 27299
27263: POP
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] union i ) ; end ;
27264: LD_ADDR_EXP 77
27268: PUSH
27269: LD_EXP 77
27273: PPUSH
27274: LD_INT 5
27276: PPUSH
27277: LD_EXP 77
27281: PUSH
27282: LD_INT 5
27284: ARRAY
27285: PUSH
27286: LD_VAR 0 3
27290: UNION
27291: PPUSH
27292: CALL_OW 1
27296: ST_TO_ADDR
27297: GO 27300
27299: POP
// end ;
27300: GO 27036
27302: POP
27303: POP
// end ;
27304: LD_VAR 0 2
27308: RET
// export function add_to_builds ( un ) ; var i , j , bt ; begin
27309: LD_INT 0
27311: PPUSH
27312: PPUSH
27313: PPUSH
27314: PPUSH
// fort := fort union UnitFilter ( un , [ mf_fort ] ) ;
27315: LD_ADDR_EXP 81
27319: PUSH
27320: LD_EXP 81
27324: PUSH
27325: LD_VAR 0 1
27329: PPUSH
27330: LD_EXP 56
27334: PUSH
27335: EMPTY
27336: LIST
27337: PPUSH
27338: CALL_OW 72
27342: UNION
27343: ST_TO_ADDR
// dep := dep union UnitFilter ( un , [ mf_dep ] ) ;
27344: LD_ADDR_EXP 83
27348: PUSH
27349: LD_EXP 83
27353: PUSH
27354: LD_VAR 0 1
27358: PPUSH
27359: LD_EXP 58
27363: PUSH
27364: EMPTY
27365: LIST
27366: PPUSH
27367: CALL_OW 72
27371: UNION
27372: ST_TO_ADDR
// fact := fact union UnitFilter ( un , [ mf_fact ] ) ;
27373: LD_ADDR_EXP 85
27377: PUSH
27378: LD_EXP 85
27382: PUSH
27383: LD_VAR 0 1
27387: PPUSH
27388: LD_EXP 59
27392: PUSH
27393: EMPTY
27394: LIST
27395: PPUSH
27396: CALL_OW 72
27400: UNION
27401: ST_TO_ADDR
// lab := lab union UnitFilter ( un , [ mf_lab ] ) ;
27402: LD_ADDR_EXP 87
27406: PUSH
27407: LD_EXP 87
27411: PUSH
27412: LD_VAR 0 1
27416: PPUSH
27417: LD_EXP 55
27421: PUSH
27422: EMPTY
27423: LIST
27424: PPUSH
27425: CALL_OW 72
27429: UNION
27430: ST_TO_ADDR
// for i in un do
27431: LD_ADDR_VAR 0 3
27435: PUSH
27436: LD_VAR 0 1
27440: PUSH
27441: FOR_IN
27442: IFFALSE 27707
// begin case GetSide ( i ) of ai_s [ 1 ] :
27444: LD_VAR 0 3
27448: PPUSH
27449: CALL_OW 255
27453: PUSH
27454: LD_EXP 23
27458: PUSH
27459: LD_INT 1
27461: ARRAY
27462: DOUBLE
27463: EQUAL
27464: IFTRUE 27468
27466: GO 27504
27468: POP
// buildings := replace ( buildings , 1 , buildings [ 1 ] union i ) ; ai_s [ 2 ] :
27469: LD_ADDR_EXP 75
27473: PUSH
27474: LD_EXP 75
27478: PPUSH
27479: LD_INT 1
27481: PPUSH
27482: LD_EXP 75
27486: PUSH
27487: LD_INT 1
27489: ARRAY
27490: PUSH
27491: LD_VAR 0 3
27495: UNION
27496: PPUSH
27497: CALL_OW 1
27501: ST_TO_ADDR
27502: GO 27705
27504: LD_EXP 23
27508: PUSH
27509: LD_INT 2
27511: ARRAY
27512: DOUBLE
27513: EQUAL
27514: IFTRUE 27518
27516: GO 27554
27518: POP
// buildings := replace ( buildings , 2 , buildings [ 2 ] union i ) ; ai_s [ 3 ] :
27519: LD_ADDR_EXP 75
27523: PUSH
27524: LD_EXP 75
27528: PPUSH
27529: LD_INT 2
27531: PPUSH
27532: LD_EXP 75
27536: PUSH
27537: LD_INT 2
27539: ARRAY
27540: PUSH
27541: LD_VAR 0 3
27545: UNION
27546: PPUSH
27547: CALL_OW 1
27551: ST_TO_ADDR
27552: GO 27705
27554: LD_EXP 23
27558: PUSH
27559: LD_INT 3
27561: ARRAY
27562: DOUBLE
27563: EQUAL
27564: IFTRUE 27568
27566: GO 27604
27568: POP
// buildings := replace ( buildings , 3 , buildings [ 3 ] union i ) ; ai_s [ 4 ] :
27569: LD_ADDR_EXP 75
27573: PUSH
27574: LD_EXP 75
27578: PPUSH
27579: LD_INT 3
27581: PPUSH
27582: LD_EXP 75
27586: PUSH
27587: LD_INT 3
27589: ARRAY
27590: PUSH
27591: LD_VAR 0 3
27595: UNION
27596: PPUSH
27597: CALL_OW 1
27601: ST_TO_ADDR
27602: GO 27705
27604: LD_EXP 23
27608: PUSH
27609: LD_INT 4
27611: ARRAY
27612: DOUBLE
27613: EQUAL
27614: IFTRUE 27618
27616: GO 27654
27618: POP
// buildings := replace ( buildings , 4 , buildings [ 4 ] union i ) ; ai_s [ 5 ] :
27619: LD_ADDR_EXP 75
27623: PUSH
27624: LD_EXP 75
27628: PPUSH
27629: LD_INT 4
27631: PPUSH
27632: LD_EXP 75
27636: PUSH
27637: LD_INT 4
27639: ARRAY
27640: PUSH
27641: LD_VAR 0 3
27645: UNION
27646: PPUSH
27647: CALL_OW 1
27651: ST_TO_ADDR
27652: GO 27705
27654: LD_EXP 23
27658: PUSH
27659: LD_INT 5
27661: ARRAY
27662: DOUBLE
27663: EQUAL
27664: IFTRUE 27668
27666: GO 27704
27668: POP
// buildings := replace ( buildings , 5 , buildings [ 5 ] union i ) ; end ;
27669: LD_ADDR_EXP 75
27673: PUSH
27674: LD_EXP 75
27678: PPUSH
27679: LD_INT 5
27681: PPUSH
27682: LD_EXP 75
27686: PUSH
27687: LD_INT 5
27689: ARRAY
27690: PUSH
27691: LD_VAR 0 3
27695: UNION
27696: PPUSH
27697: CALL_OW 1
27701: ST_TO_ADDR
27702: GO 27705
27704: POP
// end ;
27705: GO 27441
27707: POP
27708: POP
// write_deps ;
27709: CALL 23429 0 0
// write_facts ;
27713: CALL 23548 0 0
// end ;
27717: LD_VAR 0 2
27721: RET
// export function remove_from ( un ) ; begin
27722: LD_INT 0
27724: PPUSH
// remove_from_humans ( UnitFilter ( un , [ [ f_type , unit_human ] ] ) ) ;
27725: LD_VAR 0 1
27729: PPUSH
27730: LD_INT 21
27732: PUSH
27733: LD_INT 1
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PUSH
27740: EMPTY
27741: LIST
27742: PPUSH
27743: CALL_OW 72
27747: PPUSH
27748: CALL 28057 0 1
// remove_from_builds ( UnitFilter ( un , [ [ f_type , unit_building ] ] ) ) ;
27752: LD_VAR 0 1
27756: PPUSH
27757: LD_INT 21
27759: PUSH
27760: LD_INT 3
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: EMPTY
27768: LIST
27769: PPUSH
27770: CALL_OW 72
27774: PPUSH
27775: CALL 27811 0 1
// remove_from_vehicles ( UnitFilter ( un , [ [ f_type , unit_vehicle ] ] ) ) ;
27779: LD_VAR 0 1
27783: PPUSH
27784: LD_INT 21
27786: PUSH
27787: LD_INT 2
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: EMPTY
27795: LIST
27796: PPUSH
27797: CALL_OW 72
27801: PPUSH
27802: CALL 28295 0 1
// end ;
27806: LD_VAR 0 2
27810: RET
// export function remove_from_builds ( un ) ; var i ; begin
27811: LD_INT 0
27813: PPUSH
27814: PPUSH
// fact := fact diff un ;
27815: LD_ADDR_EXP 85
27819: PUSH
27820: LD_EXP 85
27824: PUSH
27825: LD_VAR 0 1
27829: DIFF
27830: ST_TO_ADDR
// fort := fort diff un ;
27831: LD_ADDR_EXP 81
27835: PUSH
27836: LD_EXP 81
27840: PUSH
27841: LD_VAR 0 1
27845: DIFF
27846: ST_TO_ADDR
// lab := lab diff un ;
27847: LD_ADDR_EXP 87
27851: PUSH
27852: LD_EXP 87
27856: PUSH
27857: LD_VAR 0 1
27861: DIFF
27862: ST_TO_ADDR
// dep := dep diff un ;
27863: LD_ADDR_EXP 83
27867: PUSH
27868: LD_EXP 83
27872: PUSH
27873: LD_VAR 0 1
27877: DIFF
27878: ST_TO_ADDR
// buildings := replace ( buildings , 1 , buildings [ 1 ] diff un ) ;
27879: LD_ADDR_EXP 75
27883: PUSH
27884: LD_EXP 75
27888: PPUSH
27889: LD_INT 1
27891: PPUSH
27892: LD_EXP 75
27896: PUSH
27897: LD_INT 1
27899: ARRAY
27900: PUSH
27901: LD_VAR 0 1
27905: DIFF
27906: PPUSH
27907: CALL_OW 1
27911: ST_TO_ADDR
// buildings := replace ( buildings , 2 , buildings [ 2 ] diff un ) ;
27912: LD_ADDR_EXP 75
27916: PUSH
27917: LD_EXP 75
27921: PPUSH
27922: LD_INT 2
27924: PPUSH
27925: LD_EXP 75
27929: PUSH
27930: LD_INT 2
27932: ARRAY
27933: PUSH
27934: LD_VAR 0 1
27938: DIFF
27939: PPUSH
27940: CALL_OW 1
27944: ST_TO_ADDR
// buildings := replace ( buildings , 3 , buildings [ 3 ] diff un ) ;
27945: LD_ADDR_EXP 75
27949: PUSH
27950: LD_EXP 75
27954: PPUSH
27955: LD_INT 3
27957: PPUSH
27958: LD_EXP 75
27962: PUSH
27963: LD_INT 3
27965: ARRAY
27966: PUSH
27967: LD_VAR 0 1
27971: DIFF
27972: PPUSH
27973: CALL_OW 1
27977: ST_TO_ADDR
// buildings := replace ( buildings , 4 , buildings [ 4 ] diff un ) ;
27978: LD_ADDR_EXP 75
27982: PUSH
27983: LD_EXP 75
27987: PPUSH
27988: LD_INT 4
27990: PPUSH
27991: LD_EXP 75
27995: PUSH
27996: LD_INT 4
27998: ARRAY
27999: PUSH
28000: LD_VAR 0 1
28004: DIFF
28005: PPUSH
28006: CALL_OW 1
28010: ST_TO_ADDR
// buildings := replace ( buildings , 5 , buildings [ 5 ] diff un ) ;
28011: LD_ADDR_EXP 75
28015: PUSH
28016: LD_EXP 75
28020: PPUSH
28021: LD_INT 5
28023: PPUSH
28024: LD_EXP 75
28028: PUSH
28029: LD_INT 5
28031: ARRAY
28032: PUSH
28033: LD_VAR 0 1
28037: DIFF
28038: PPUSH
28039: CALL_OW 1
28043: ST_TO_ADDR
// write_deps ;
28044: CALL 23429 0 0
// write_facts ;
28048: CALL 23548 0 0
// end ;
28052: LD_VAR 0 2
28056: RET
// export function remove_from_humans ( un ) ; var i ; begin
28057: LD_INT 0
28059: PPUSH
28060: PPUSH
// sol := sol diff un ;
28061: LD_ADDR_EXP 82
28065: PUSH
28066: LD_EXP 82
28070: PUSH
28071: LD_VAR 0 1
28075: DIFF
28076: ST_TO_ADDR
// eng := eng diff un ;
28077: LD_ADDR_EXP 84
28081: PUSH
28082: LD_EXP 84
28086: PUSH
28087: LD_VAR 0 1
28091: DIFF
28092: ST_TO_ADDR
// mec := mec diff un ;
28093: LD_ADDR_EXP 86
28097: PUSH
28098: LD_EXP 86
28102: PUSH
28103: LD_VAR 0 1
28107: DIFF
28108: ST_TO_ADDR
// sci := sci diff un ;
28109: LD_ADDR_EXP 88
28113: PUSH
28114: LD_EXP 88
28118: PUSH
28119: LD_VAR 0 1
28123: DIFF
28124: ST_TO_ADDR
// humans := replace ( humans , 1 , humans [ 1 ] diff un ) ;
28125: LD_ADDR_EXP 76
28129: PUSH
28130: LD_EXP 76
28134: PPUSH
28135: LD_INT 1
28137: PPUSH
28138: LD_EXP 76
28142: PUSH
28143: LD_INT 1
28145: ARRAY
28146: PUSH
28147: LD_VAR 0 1
28151: DIFF
28152: PPUSH
28153: CALL_OW 1
28157: ST_TO_ADDR
// humans := replace ( humans , 2 , humans [ 2 ] diff un ) ;
28158: LD_ADDR_EXP 76
28162: PUSH
28163: LD_EXP 76
28167: PPUSH
28168: LD_INT 2
28170: PPUSH
28171: LD_EXP 76
28175: PUSH
28176: LD_INT 2
28178: ARRAY
28179: PUSH
28180: LD_VAR 0 1
28184: DIFF
28185: PPUSH
28186: CALL_OW 1
28190: ST_TO_ADDR
// humans := replace ( humans , 3 , humans [ 3 ] diff un ) ;
28191: LD_ADDR_EXP 76
28195: PUSH
28196: LD_EXP 76
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 76
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PUSH
28213: LD_VAR 0 1
28217: DIFF
28218: PPUSH
28219: CALL_OW 1
28223: ST_TO_ADDR
// humans := replace ( humans , 4 , humans [ 4 ] diff un ) ;
28224: LD_ADDR_EXP 76
28228: PUSH
28229: LD_EXP 76
28233: PPUSH
28234: LD_INT 4
28236: PPUSH
28237: LD_EXP 76
28241: PUSH
28242: LD_INT 4
28244: ARRAY
28245: PUSH
28246: LD_VAR 0 1
28250: DIFF
28251: PPUSH
28252: CALL_OW 1
28256: ST_TO_ADDR
// humans := replace ( humans , 5 , humans [ 5 ] diff un ) ;
28257: LD_ADDR_EXP 76
28261: PUSH
28262: LD_EXP 76
28266: PPUSH
28267: LD_INT 5
28269: PPUSH
28270: LD_EXP 76
28274: PUSH
28275: LD_INT 5
28277: ARRAY
28278: PUSH
28279: LD_VAR 0 1
28283: DIFF
28284: PPUSH
28285: CALL_OW 1
28289: ST_TO_ADDR
// end ;
28290: LD_VAR 0 2
28294: RET
// export function remove_from_vehicles ( un ) ; var i ; begin
28295: LD_INT 0
28297: PPUSH
28298: PPUSH
// attack_units := attack_units diff un ;
28299: LD_ADDR_EXP 78
28303: PUSH
28304: LD_EXP 78
28308: PUSH
28309: LD_VAR 0 1
28313: DIFF
28314: ST_TO_ADDR
// defence_units := defence_units diff un ;
28315: LD_ADDR_EXP 79
28319: PUSH
28320: LD_EXP 79
28324: PUSH
28325: LD_VAR 0 1
28329: DIFF
28330: ST_TO_ADDR
// vehicles := replace ( vehicles , 1 , vehicles [ 1 ] diff un ) ;
28331: LD_ADDR_EXP 77
28335: PUSH
28336: LD_EXP 77
28340: PPUSH
28341: LD_INT 1
28343: PPUSH
28344: LD_EXP 77
28348: PUSH
28349: LD_INT 1
28351: ARRAY
28352: PUSH
28353: LD_VAR 0 1
28357: DIFF
28358: PPUSH
28359: CALL_OW 1
28363: ST_TO_ADDR
// vehicles := replace ( vehicles , 2 , vehicles [ 2 ] diff un ) ;
28364: LD_ADDR_EXP 77
28368: PUSH
28369: LD_EXP 77
28373: PPUSH
28374: LD_INT 2
28376: PPUSH
28377: LD_EXP 77
28381: PUSH
28382: LD_INT 2
28384: ARRAY
28385: PUSH
28386: LD_VAR 0 1
28390: DIFF
28391: PPUSH
28392: CALL_OW 1
28396: ST_TO_ADDR
// vehicles := replace ( vehicles , 3 , vehicles [ 3 ] diff un ) ;
28397: LD_ADDR_EXP 77
28401: PUSH
28402: LD_EXP 77
28406: PPUSH
28407: LD_INT 3
28409: PPUSH
28410: LD_EXP 77
28414: PUSH
28415: LD_INT 3
28417: ARRAY
28418: PUSH
28419: LD_VAR 0 1
28423: DIFF
28424: PPUSH
28425: CALL_OW 1
28429: ST_TO_ADDR
// vehicles := replace ( vehicles , 4 , vehicles [ 4 ] diff un ) ;
28430: LD_ADDR_EXP 77
28434: PUSH
28435: LD_EXP 77
28439: PPUSH
28440: LD_INT 4
28442: PPUSH
28443: LD_EXP 77
28447: PUSH
28448: LD_INT 4
28450: ARRAY
28451: PUSH
28452: LD_VAR 0 1
28456: DIFF
28457: PPUSH
28458: CALL_OW 1
28462: ST_TO_ADDR
// vehicles := replace ( vehicles , 5 , vehicles [ 5 ] diff un ) ;
28463: LD_ADDR_EXP 77
28467: PUSH
28468: LD_EXP 77
28472: PPUSH
28473: LD_INT 5
28475: PPUSH
28476: LD_EXP 77
28480: PUSH
28481: LD_INT 5
28483: ARRAY
28484: PUSH
28485: LD_VAR 0 1
28489: DIFF
28490: PPUSH
28491: CALL_OW 1
28495: ST_TO_ADDR
// bc := replace ( bc , 1 , bc [ 1 ] diff un ) ;
28496: LD_ADDR_EXP 71
28500: PUSH
28501: LD_EXP 71
28505: PPUSH
28506: LD_INT 1
28508: PPUSH
28509: LD_EXP 71
28513: PUSH
28514: LD_INT 1
28516: ARRAY
28517: PUSH
28518: LD_VAR 0 1
28522: DIFF
28523: PPUSH
28524: CALL_OW 1
28528: ST_TO_ADDR
// bc := replace ( bc , 2 , bc [ 2 ] diff un ) ;
28529: LD_ADDR_EXP 71
28533: PUSH
28534: LD_EXP 71
28538: PPUSH
28539: LD_INT 2
28541: PPUSH
28542: LD_EXP 71
28546: PUSH
28547: LD_INT 2
28549: ARRAY
28550: PUSH
28551: LD_VAR 0 1
28555: DIFF
28556: PPUSH
28557: CALL_OW 1
28561: ST_TO_ADDR
// bc := replace ( bc , 3 , bc [ 3 ] diff un ) ;
28562: LD_ADDR_EXP 71
28566: PUSH
28567: LD_EXP 71
28571: PPUSH
28572: LD_INT 3
28574: PPUSH
28575: LD_EXP 71
28579: PUSH
28580: LD_INT 3
28582: ARRAY
28583: PUSH
28584: LD_VAR 0 1
28588: DIFF
28589: PPUSH
28590: CALL_OW 1
28594: ST_TO_ADDR
// bc := replace ( bc , 4 , bc [ 4 ] diff un ) ;
28595: LD_ADDR_EXP 71
28599: PUSH
28600: LD_EXP 71
28604: PPUSH
28605: LD_INT 4
28607: PPUSH
28608: LD_EXP 71
28612: PUSH
28613: LD_INT 4
28615: ARRAY
28616: PUSH
28617: LD_VAR 0 1
28621: DIFF
28622: PPUSH
28623: CALL_OW 1
28627: ST_TO_ADDR
// bc := replace ( bc , 5 , bc [ 5 ] diff un ) ;
28628: LD_ADDR_EXP 71
28632: PUSH
28633: LD_EXP 71
28637: PPUSH
28638: LD_INT 5
28640: PPUSH
28641: LD_EXP 71
28645: PUSH
28646: LD_INT 5
28648: ARRAY
28649: PUSH
28650: LD_VAR 0 1
28654: DIFF
28655: PPUSH
28656: CALL_OW 1
28660: ST_TO_ADDR
// rc := replace ( rc , 1 , rc [ 1 ] diff un ) ;
28661: LD_ADDR_EXP 70
28665: PUSH
28666: LD_EXP 70
28670: PPUSH
28671: LD_INT 1
28673: PPUSH
28674: LD_EXP 70
28678: PUSH
28679: LD_INT 1
28681: ARRAY
28682: PUSH
28683: LD_VAR 0 1
28687: DIFF
28688: PPUSH
28689: CALL_OW 1
28693: ST_TO_ADDR
// rc := replace ( rc , 2 , rc [ 2 ] diff un ) ;
28694: LD_ADDR_EXP 70
28698: PUSH
28699: LD_EXP 70
28703: PPUSH
28704: LD_INT 2
28706: PPUSH
28707: LD_EXP 70
28711: PUSH
28712: LD_INT 2
28714: ARRAY
28715: PUSH
28716: LD_VAR 0 1
28720: DIFF
28721: PPUSH
28722: CALL_OW 1
28726: ST_TO_ADDR
// rc := replace ( rc , 3 , rc [ 3 ] diff un ) ;
28727: LD_ADDR_EXP 70
28731: PUSH
28732: LD_EXP 70
28736: PPUSH
28737: LD_INT 3
28739: PPUSH
28740: LD_EXP 70
28744: PUSH
28745: LD_INT 3
28747: ARRAY
28748: PUSH
28749: LD_VAR 0 1
28753: DIFF
28754: PPUSH
28755: CALL_OW 1
28759: ST_TO_ADDR
// rc := replace ( rc , 4 , rc [ 4 ] diff un ) ;
28760: LD_ADDR_EXP 70
28764: PUSH
28765: LD_EXP 70
28769: PPUSH
28770: LD_INT 4
28772: PPUSH
28773: LD_EXP 70
28777: PUSH
28778: LD_INT 4
28780: ARRAY
28781: PUSH
28782: LD_VAR 0 1
28786: DIFF
28787: PPUSH
28788: CALL_OW 1
28792: ST_TO_ADDR
// rc := replace ( rc , 5 , rc [ 5 ] diff un ) ;
28793: LD_ADDR_EXP 70
28797: PUSH
28798: LD_EXP 70
28802: PPUSH
28803: LD_INT 5
28805: PPUSH
28806: LD_EXP 70
28810: PUSH
28811: LD_INT 5
28813: ARRAY
28814: PUSH
28815: LD_VAR 0 1
28819: DIFF
28820: PPUSH
28821: CALL_OW 1
28825: ST_TO_ADDR
// end ; end_of_file
28826: LD_VAR 0 2
28830: RET
// var objevovani_zasilek ; every 1 do
28831: GO 28833
28833: DISABLE
// begin objevovani_zasilek := [ 2 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 , 3 , 1 , 5 , 1 , 1 , 4 , 1 , 0 , 3 ] ;
28834: LD_ADDR_LOC 30
28838: PUSH
28839: LD_INT 2
28841: PUSH
28842: LD_INT 3
28844: PUSH
28845: LD_INT 1
28847: PUSH
28848: LD_INT 5
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: LD_INT 1
28856: PUSH
28857: LD_INT 4
28859: PUSH
28860: LD_INT 1
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: LD_INT 3
28868: PUSH
28869: LD_INT 3
28871: PUSH
28872: LD_INT 1
28874: PUSH
28875: LD_INT 5
28877: PUSH
28878: LD_INT 1
28880: PUSH
28881: LD_INT 1
28883: PUSH
28884: LD_INT 4
28886: PUSH
28887: LD_INT 1
28889: PUSH
28890: LD_INT 0
28892: PUSH
28893: LD_INT 3
28895: PUSH
28896: LD_INT 3
28898: PUSH
28899: LD_INT 1
28901: PUSH
28902: LD_INT 5
28904: PUSH
28905: LD_INT 1
28907: PUSH
28908: LD_INT 1
28910: PUSH
28911: LD_INT 4
28913: PUSH
28914: LD_INT 1
28916: PUSH
28917: LD_INT 0
28919: PUSH
28920: LD_INT 3
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: ST_TO_ADDR
// Randomize ;
28953: CALL_OW 10
// end ;
28957: END
// every 5 5$0 do
28958: GO 28960
28960: DISABLE
// begin Randomize ;
28961: CALL_OW 10
// enable ;
28965: ENABLE
// end ;
28966: END
// every 0 0$15 do
28967: GO 28969
28969: DISABLE
// begin padaji_bedny ;
28970: CALL 28984 0 0
// end ;
28974: END
// every 5 5$0 + 0 0$15 do
28975: GO 28977
28977: DISABLE
// begin padaji_bedny ;
28978: CALL 28984 0 0
// enable ;
28982: ENABLE
// end ;
28983: END
// function padaji_bedny ; var x , i , cek , cek2 , last , min5 ; begin
28984: LD_INT 0
28986: PPUSH
28987: PPUSH
28988: PPUSH
28989: PPUSH
28990: PPUSH
28991: PPUSH
28992: PPUSH
// min5 := ( ( tick div 5 5$0 ) + 1 ) mod objevovani_zasilek ;
28993: LD_ADDR_VAR 0 7
28997: PUSH
28998: LD_OWVAR 1
29002: PUSH
29003: LD_INT 10500
29005: DIV
29006: PUSH
29007: LD_INT 1
29009: PLUS
29010: PUSH
29011: LD_LOC 30
29015: MOD
29016: ST_TO_ADDR
// cek := [ ] ;
29017: LD_ADDR_VAR 0 4
29021: PUSH
29022: EMPTY
29023: ST_TO_ADDR
// cek2 := [ ] ;
29024: LD_ADDR_VAR 0 5
29028: PUSH
29029: EMPTY
29030: ST_TO_ADDR
// last := 0 ;
29031: LD_ADDR_VAR 0 6
29035: PUSH
29036: LD_INT 0
29038: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
29039: LD_ADDR_VAR 0 2
29043: PUSH
29044: LD_LOC 30
29048: PUSH
29049: LD_VAR 0 7
29053: ARRAY
29054: ST_TO_ADDR
// for i := 1 to x do
29055: LD_ADDR_VAR 0 3
29059: PUSH
29060: DOUBLE
29061: LD_INT 1
29063: DEC
29064: ST_TO_ADDR
29065: LD_VAR 0 2
29069: PUSH
29070: FOR_TO
29071: IFFALSE 29097
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
29073: LD_ADDR_VAR 0 4
29077: PUSH
29078: LD_VAR 0 4
29082: PUSH
29083: LD_INT 525
29085: PPUSH
29086: LD_INT 10500
29088: PPUSH
29089: CALL_OW 12
29093: ADD
29094: ST_TO_ADDR
29095: GO 29070
29097: POP
29098: POP
// cek := SortListByListAsc ( cek , cek ) ;
29099: LD_ADDR_VAR 0 4
29103: PUSH
29104: LD_VAR 0 4
29108: PPUSH
29109: LD_VAR 0 4
29113: PPUSH
29114: CALL_OW 76
29118: ST_TO_ADDR
// for i in cek do
29119: LD_ADDR_VAR 0 3
29123: PUSH
29124: LD_VAR 0 4
29128: PUSH
29129: FOR_IN
29130: IFFALSE 29166
// begin cek2 := cek2 ^ i - last ;
29132: LD_ADDR_VAR 0 5
29136: PUSH
29137: LD_VAR 0 5
29141: PUSH
29142: LD_VAR 0 3
29146: PUSH
29147: LD_VAR 0 6
29151: MINUS
29152: ADD
29153: ST_TO_ADDR
// last := i ;
29154: LD_ADDR_VAR 0 6
29158: PUSH
29159: LD_VAR 0 3
29163: ST_TO_ADDR
// end ;
29164: GO 29129
29166: POP
29167: POP
// for i := 1 to x do
29168: LD_ADDR_VAR 0 3
29172: PUSH
29173: DOUBLE
29174: LD_INT 1
29176: DEC
29177: ST_TO_ADDR
29178: LD_VAR 0 2
29182: PUSH
29183: FOR_TO
29184: IFFALSE 29213
// begin CreateCratesAnywhere ( 5 , true ) ;
29186: LD_INT 5
29188: PPUSH
29189: LD_INT 1
29191: PPUSH
29192: CALL_OW 57
// Wait ( cek2 [ i ] ) ;
29196: LD_VAR 0 5
29200: PUSH
29201: LD_VAR 0 3
29205: ARRAY
29206: PPUSH
29207: CALL_OW 67
// end ;
29211: GO 29183
29213: POP
29214: POP
// end ; end_of_file
29215: LD_VAR 0 1
29219: RET
// var rDef1 , rDef2 , rDef3 , rDef4 , rDef5 ; var idDef1 , idDef2 , idDef3 , idDef4 , idDef5 ; export toDef1 , toDef2 , toDef3 , toDef4 , toDef5 ; every 0 0$1 do
29220: GO 29222
29222: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29223: LD_ADDR_EXP 89
29227: PUSH
29228: LD_EXP 76
29232: PUSH
29233: LD_INT 1
29235: ARRAY
29236: PPUSH
29237: LD_EXP 51
29241: PUSH
29242: EMPTY
29243: LIST
29244: PPUSH
29245: CALL_OW 72
29249: PUSH
29250: LD_EXP 77
29254: PUSH
29255: LD_INT 1
29257: ARRAY
29258: ADD
29259: PUSH
29260: LD_EXP 75
29264: PUSH
29265: LD_INT 1
29267: ARRAY
29268: PPUSH
29269: LD_EXP 56
29273: PUSH
29274: EMPTY
29275: LIST
29276: PPUSH
29277: CALL_OW 72
29281: ADD
29282: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
29283: LD_ADDR_EXP 90
29287: PUSH
29288: LD_EXP 76
29292: PUSH
29293: LD_INT 2
29295: ARRAY
29296: PPUSH
29297: LD_EXP 51
29301: PUSH
29302: EMPTY
29303: LIST
29304: PPUSH
29305: CALL_OW 72
29309: PUSH
29310: LD_EXP 77
29314: PUSH
29315: LD_INT 2
29317: ARRAY
29318: ADD
29319: PUSH
29320: LD_EXP 75
29324: PUSH
29325: LD_INT 2
29327: ARRAY
29328: PPUSH
29329: LD_EXP 56
29333: PUSH
29334: EMPTY
29335: LIST
29336: PPUSH
29337: CALL_OW 72
29341: ADD
29342: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
29343: LD_ADDR_EXP 91
29347: PUSH
29348: LD_EXP 76
29352: PUSH
29353: LD_INT 3
29355: ARRAY
29356: PPUSH
29357: LD_EXP 51
29361: PUSH
29362: EMPTY
29363: LIST
29364: PPUSH
29365: CALL_OW 72
29369: PUSH
29370: LD_EXP 77
29374: PUSH
29375: LD_INT 3
29377: ARRAY
29378: ADD
29379: PUSH
29380: LD_EXP 75
29384: PUSH
29385: LD_INT 3
29387: ARRAY
29388: PPUSH
29389: LD_EXP 56
29393: PUSH
29394: EMPTY
29395: LIST
29396: PPUSH
29397: CALL_OW 72
29401: ADD
29402: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
29403: LD_ADDR_EXP 92
29407: PUSH
29408: LD_EXP 76
29412: PUSH
29413: LD_INT 4
29415: ARRAY
29416: PPUSH
29417: LD_EXP 51
29421: PUSH
29422: EMPTY
29423: LIST
29424: PPUSH
29425: CALL_OW 72
29429: PUSH
29430: LD_EXP 77
29434: PUSH
29435: LD_INT 4
29437: ARRAY
29438: ADD
29439: PUSH
29440: LD_EXP 75
29444: PUSH
29445: LD_INT 4
29447: ARRAY
29448: PPUSH
29449: LD_EXP 56
29453: PUSH
29454: EMPTY
29455: LIST
29456: PPUSH
29457: CALL_OW 72
29461: ADD
29462: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
29463: LD_ADDR_EXP 93
29467: PUSH
29468: LD_EXP 76
29472: PUSH
29473: LD_INT 5
29475: ARRAY
29476: PPUSH
29477: LD_EXP 51
29481: PUSH
29482: EMPTY
29483: LIST
29484: PPUSH
29485: CALL_OW 72
29489: PUSH
29490: LD_EXP 77
29494: PUSH
29495: LD_INT 5
29497: ARRAY
29498: ADD
29499: PUSH
29500: LD_EXP 75
29504: PUSH
29505: LD_INT 5
29507: ARRAY
29508: PPUSH
29509: LD_EXP 56
29513: PUSH
29514: EMPTY
29515: LIST
29516: PPUSH
29517: CALL_OW 72
29521: ADD
29522: ST_TO_ADDR
// rDef1 := McRegistry ( ai_s [ 1 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearA ] , [ mc_reg_area_to_protect , nearA ] ] ) ;
29523: LD_ADDR_LOC 31
29527: PUSH
29528: LD_EXP 23
29532: PUSH
29533: LD_INT 1
29535: ARRAY
29536: PPUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 70
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 2
29549: PUSH
29550: LD_INT 24
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 3
29559: PUSH
29560: LD_INT 24
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: LIST
29571: PPUSH
29572: CALL_OW 399
29576: ST_TO_ADDR
// rDef2 := McRegistry ( ai_s [ 2 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearB ] , [ mc_reg_area_to_protect , nearB ] ] ) ;
29577: LD_ADDR_LOC 32
29581: PUSH
29582: LD_EXP 23
29586: PUSH
29587: LD_INT 2
29589: ARRAY
29590: PPUSH
29591: LD_INT 1
29593: PUSH
29594: LD_INT 70
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 2
29603: PUSH
29604: LD_INT 25
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: LD_INT 3
29613: PUSH
29614: LD_INT 25
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: LIST
29625: PPUSH
29626: CALL_OW 399
29630: ST_TO_ADDR
// rDef3 := McRegistry ( ai_s [ 3 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearC ] , [ mc_reg_area_to_protect , nearC ] ] ) ;
29631: LD_ADDR_LOC 33
29635: PUSH
29636: LD_EXP 23
29640: PUSH
29641: LD_INT 3
29643: ARRAY
29644: PPUSH
29645: LD_INT 1
29647: PUSH
29648: LD_INT 70
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 2
29657: PUSH
29658: LD_INT 26
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 3
29667: PUSH
29668: LD_INT 26
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: LIST
29679: PPUSH
29680: CALL_OW 399
29684: ST_TO_ADDR
// rDef4 := McRegistry ( ai_s [ 4 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearD ] , [ mc_reg_area_to_protect , nearD ] ] ) ;
29685: LD_ADDR_LOC 34
29689: PUSH
29690: LD_EXP 23
29694: PUSH
29695: LD_INT 4
29697: ARRAY
29698: PPUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 70
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 2
29711: PUSH
29712: LD_INT 27
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 3
29721: PUSH
29722: LD_INT 27
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: LIST
29733: PPUSH
29734: CALL_OW 399
29738: ST_TO_ADDR
// rDef5 := McRegistry ( ai_s [ 5 ] , [ [ mc_reg_refresh_time , 0 0$2 ] , [ mc_reg_area_to_guard , nearE ] , [ mc_reg_area_to_protect , nearE ] ] ) ;
29739: LD_ADDR_LOC 35
29743: PUSH
29744: LD_EXP 23
29748: PUSH
29749: LD_INT 5
29751: ARRAY
29752: PPUSH
29753: LD_INT 1
29755: PUSH
29756: LD_INT 70
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 2
29765: PUSH
29766: LD_INT 28
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 3
29775: PUSH
29776: LD_INT 28
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: LIST
29787: PPUSH
29788: CALL_OW 399
29792: ST_TO_ADDR
// idDef1 := McDefend ( 10 , rDef1 , toDef1 , [ mc_def_advantage , mcdef1_difficulty ] ) ;
29793: LD_ADDR_LOC 36
29797: PUSH
29798: LD_INT 10
29800: PPUSH
29801: LD_LOC 31
29805: PPUSH
29806: LD_EXP 89
29810: PPUSH
29811: LD_INT 1
29813: PUSH
29814: LD_EXP 11
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PPUSH
29823: CALL_OW 401
29827: ST_TO_ADDR
// idDef2 := McDefend ( 10 , rDef2 , toDef2 , [ mc_def_advantage , mcdef2_difficulty ] ) ;
29828: LD_ADDR_LOC 37
29832: PUSH
29833: LD_INT 10
29835: PPUSH
29836: LD_LOC 32
29840: PPUSH
29841: LD_EXP 90
29845: PPUSH
29846: LD_INT 1
29848: PUSH
29849: LD_EXP 12
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 401
29862: ST_TO_ADDR
// idDef3 := McDefend ( 10 , rDef3 , toDef3 , [ mc_def_advantage , mcdef3_difficulty ] ) ;
29863: LD_ADDR_LOC 38
29867: PUSH
29868: LD_INT 10
29870: PPUSH
29871: LD_LOC 33
29875: PPUSH
29876: LD_EXP 91
29880: PPUSH
29881: LD_INT 1
29883: PUSH
29884: LD_EXP 13
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PPUSH
29893: CALL_OW 401
29897: ST_TO_ADDR
// idDef4 := McDefend ( 10 , rDef4 , toDef4 , [ mc_def_advantage , mcdef4_difficulty ] ) ;
29898: LD_ADDR_LOC 39
29902: PUSH
29903: LD_INT 10
29905: PPUSH
29906: LD_LOC 34
29910: PPUSH
29911: LD_EXP 92
29915: PPUSH
29916: LD_INT 1
29918: PUSH
29919: LD_EXP 14
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PPUSH
29928: CALL_OW 401
29932: ST_TO_ADDR
// idDef5 := McDefend ( 10 , rDef5 , toDef5 , [ mc_def_advantage , mcdef5_difficulty ] ) ;
29933: LD_ADDR_LOC 40
29937: PUSH
29938: LD_INT 10
29940: PPUSH
29941: LD_LOC 35
29945: PPUSH
29946: LD_EXP 93
29950: PPUSH
29951: LD_INT 1
29953: PUSH
29954: LD_EXP 15
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PPUSH
29963: CALL_OW 401
29967: ST_TO_ADDR
// end ;
29968: END
// every 0 0$10 do
29969: GO 29971
29971: DISABLE
// begin todef1 := UnitFilter ( humans [ 1 ] , [ mf_sol ] ) ^ vehicles [ 1 ] ^ UnitFilter ( buildings [ 1 ] , [ mf_fort ] ) ;
29972: LD_ADDR_EXP 89
29976: PUSH
29977: LD_EXP 76
29981: PUSH
29982: LD_INT 1
29984: ARRAY
29985: PPUSH
29986: LD_EXP 51
29990: PUSH
29991: EMPTY
29992: LIST
29993: PPUSH
29994: CALL_OW 72
29998: PUSH
29999: LD_EXP 77
30003: PUSH
30004: LD_INT 1
30006: ARRAY
30007: ADD
30008: PUSH
30009: LD_EXP 75
30013: PUSH
30014: LD_INT 1
30016: ARRAY
30017: PPUSH
30018: LD_EXP 56
30022: PUSH
30023: EMPTY
30024: LIST
30025: PPUSH
30026: CALL_OW 72
30030: ADD
30031: ST_TO_ADDR
// todef2 := UnitFilter ( humans [ 2 ] , [ mf_sol ] ) ^ vehicles [ 2 ] ^ UnitFilter ( buildings [ 2 ] , [ mf_fort ] ) ;
30032: LD_ADDR_EXP 90
30036: PUSH
30037: LD_EXP 76
30041: PUSH
30042: LD_INT 2
30044: ARRAY
30045: PPUSH
30046: LD_EXP 51
30050: PUSH
30051: EMPTY
30052: LIST
30053: PPUSH
30054: CALL_OW 72
30058: PUSH
30059: LD_EXP 77
30063: PUSH
30064: LD_INT 2
30066: ARRAY
30067: ADD
30068: PUSH
30069: LD_EXP 75
30073: PUSH
30074: LD_INT 2
30076: ARRAY
30077: PPUSH
30078: LD_EXP 56
30082: PUSH
30083: EMPTY
30084: LIST
30085: PPUSH
30086: CALL_OW 72
30090: ADD
30091: ST_TO_ADDR
// todef3 := UnitFilter ( humans [ 3 ] , [ mf_sol ] ) ^ vehicles [ 3 ] ^ UnitFilter ( buildings [ 3 ] , [ mf_fort ] ) ;
30092: LD_ADDR_EXP 91
30096: PUSH
30097: LD_EXP 76
30101: PUSH
30102: LD_INT 3
30104: ARRAY
30105: PPUSH
30106: LD_EXP 51
30110: PUSH
30111: EMPTY
30112: LIST
30113: PPUSH
30114: CALL_OW 72
30118: PUSH
30119: LD_EXP 77
30123: PUSH
30124: LD_INT 3
30126: ARRAY
30127: ADD
30128: PUSH
30129: LD_EXP 75
30133: PUSH
30134: LD_INT 3
30136: ARRAY
30137: PPUSH
30138: LD_EXP 56
30142: PUSH
30143: EMPTY
30144: LIST
30145: PPUSH
30146: CALL_OW 72
30150: ADD
30151: ST_TO_ADDR
// todef4 := UnitFilter ( humans [ 4 ] , [ mf_sol ] ) ^ vehicles [ 4 ] ^ UnitFilter ( buildings [ 4 ] , [ mf_fort ] ) ;
30152: LD_ADDR_EXP 92
30156: PUSH
30157: LD_EXP 76
30161: PUSH
30162: LD_INT 4
30164: ARRAY
30165: PPUSH
30166: LD_EXP 51
30170: PUSH
30171: EMPTY
30172: LIST
30173: PPUSH
30174: CALL_OW 72
30178: PUSH
30179: LD_EXP 77
30183: PUSH
30184: LD_INT 4
30186: ARRAY
30187: ADD
30188: PUSH
30189: LD_EXP 75
30193: PUSH
30194: LD_INT 4
30196: ARRAY
30197: PPUSH
30198: LD_EXP 56
30202: PUSH
30203: EMPTY
30204: LIST
30205: PPUSH
30206: CALL_OW 72
30210: ADD
30211: ST_TO_ADDR
// todef5 := UnitFilter ( humans [ 5 ] , [ mf_sol ] ) ^ vehicles [ 5 ] ^ UnitFilter ( buildings [ 5 ] , [ mf_fort ] ) ;
30212: LD_ADDR_EXP 93
30216: PUSH
30217: LD_EXP 76
30221: PUSH
30222: LD_INT 5
30224: ARRAY
30225: PPUSH
30226: LD_EXP 51
30230: PUSH
30231: EMPTY
30232: LIST
30233: PPUSH
30234: CALL_OW 72
30238: PUSH
30239: LD_EXP 77
30243: PUSH
30244: LD_INT 5
30246: ARRAY
30247: ADD
30248: PUSH
30249: LD_EXP 75
30253: PUSH
30254: LD_INT 5
30256: ARRAY
30257: PPUSH
30258: LD_EXP 56
30262: PUSH
30263: EMPTY
30264: LIST
30265: PPUSH
30266: CALL_OW 72
30270: ADD
30271: ST_TO_ADDR
// ClearMcUnits ( idDef1 ) ;
30272: LD_LOC 36
30276: PPUSH
30277: CALL_OW 392
// AddMcUnits ( idDef1 , todef1 ) ;
30281: LD_LOC 36
30285: PPUSH
30286: LD_EXP 89
30290: PPUSH
30291: CALL_OW 390
// ClearMcUnits ( idDef2 ) ;
30295: LD_LOC 37
30299: PPUSH
30300: CALL_OW 392
// AddMcUnits ( idDef2 , todef2 ) ;
30304: LD_LOC 37
30308: PPUSH
30309: LD_EXP 90
30313: PPUSH
30314: CALL_OW 390
// ClearMcUnits ( idDef3 ) ;
30318: LD_LOC 38
30322: PPUSH
30323: CALL_OW 392
// AddMcUnits ( idDef3 , todef3 ) ;
30327: LD_LOC 38
30331: PPUSH
30332: LD_EXP 91
30336: PPUSH
30337: CALL_OW 390
// ClearMcUnits ( idDef4 ) ;
30341: LD_LOC 39
30345: PPUSH
30346: CALL_OW 392
// AddMcUnits ( idDef4 , todef4 ) ;
30350: LD_LOC 39
30354: PPUSH
30355: LD_EXP 92
30359: PPUSH
30360: CALL_OW 390
// ClearMcUnits ( idDef5 ) ;
30364: LD_LOC 40
30368: PPUSH
30369: CALL_OW 392
// AddMcUnits ( idDef5 , todef5 ) ;
30373: LD_LOC 40
30377: PPUSH
30378: LD_EXP 93
30382: PPUSH
30383: CALL_OW 390
// enable ;
30387: ENABLE
// end ; end_of_file
30388: END
// export function SurrenderBase ( type , side ) ; var a , cars ; begin
30389: LD_INT 0
30391: PPUSH
30392: PPUSH
30393: PPUSH
// if not ( side in your_bases ) then
30394: LD_VAR 0 2
30398: PUSH
30399: LD_EXP 18
30403: IN
30404: NOT
30405: IFFALSE 31019
// begin SetAttitude ( you , side , att_friend , true ) ;
30407: LD_EXP 7
30411: PPUSH
30412: LD_VAR 0 2
30416: PPUSH
30417: LD_INT 1
30419: PPUSH
30420: LD_INT 1
30422: PPUSH
30423: CALL_OW 80
// case type of t_kill :
30427: LD_VAR 0 1
30431: PUSH
30432: LD_EXP 1
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30513
30442: POP
// begin if side = ai_s [ 1 ] then
30443: LD_VAR 0 2
30447: PUSH
30448: LD_EXP 23
30452: PUSH
30453: LD_INT 1
30455: ARRAY
30456: EQUAL
30457: IFFALSE 30482
// begin DXbaseSurrender ( side ) ;
30459: LD_VAR 0 2
30463: PPUSH
30464: CALL 7968 0 1
// SurrenderNormal ( true , side ) ;
30468: LD_INT 1
30470: PPUSH
30471: LD_VAR 0 2
30475: PPUSH
30476: CALL 31024 0 2
// end else
30480: GO 30511
// begin diplomacy := false ;
30482: LD_ADDR_EXP 27
30486: PUSH
30487: LD_INT 0
30489: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30490: LD_VAR 0 2
30494: PPUSH
30495: CALL 7968 0 1
// SurrenderNormal ( true , side ) ;
30499: LD_INT 1
30501: PPUSH
30502: LD_VAR 0 2
30506: PPUSH
30507: CALL 31024 0 2
// end ; end ; t_killbeat :
30511: GO 30851
30513: LD_EXP 6
30517: DOUBLE
30518: EQUAL
30519: IFTRUE 30523
30521: GO 30594
30523: POP
// begin if side = ai_s [ 1 ] then
30524: LD_VAR 0 2
30528: PUSH
30529: LD_EXP 23
30533: PUSH
30534: LD_INT 1
30536: ARRAY
30537: EQUAL
30538: IFFALSE 30563
// begin DXbaseSurrender ( side ) ;
30540: LD_VAR 0 2
30544: PPUSH
30545: CALL 7968 0 1
// SurrenderNormal ( true , side ) ;
30549: LD_INT 1
30551: PPUSH
30552: LD_VAR 0 2
30556: PPUSH
30557: CALL 31024 0 2
// end else
30561: GO 30592
// begin diplomacy := false ;
30563: LD_ADDR_EXP 27
30567: PUSH
30568: LD_INT 0
30570: ST_TO_ADDR
// DXbaseSurrender ( side ) ;
30571: LD_VAR 0 2
30575: PPUSH
30576: CALL 7968 0 1
// SurrenderNormal ( true , side ) ;
30580: LD_INT 1
30582: PPUSH
30583: LD_VAR 0 2
30587: PPUSH
30588: CALL 31024 0 2
// end ; end ; t_intimidate :
30592: GO 30851
30594: LD_EXP 2
30598: DOUBLE
30599: EQUAL
30600: IFTRUE 30604
30602: GO 30658
30604: POP
// begin if side = ai_s [ 2 ] then
30605: LD_VAR 0 2
30609: PUSH
30610: LD_EXP 23
30614: PUSH
30615: LD_INT 2
30617: ARRAY
30618: EQUAL
30619: IFFALSE 30656
// begin DB_BaseAccept ( cap_bases = 0 ) ;
30621: LD_EXP 17
30625: PUSH
30626: LD_INT 0
30628: EQUAL
30629: PPUSH
30630: CALL 4632 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 2 ] ) ;
30634: LD_EXP 17
30638: PUSH
30639: LD_INT 0
30641: EQUAL
30642: PPUSH
30643: LD_EXP 23
30647: PUSH
30648: LD_INT 2
30650: ARRAY
30651: PPUSH
30652: CALL 31024 0 2
// end ; end ; t_persuade :
30656: GO 30851
30658: LD_EXP 3
30662: DOUBLE
30663: EQUAL
30664: IFTRUE 30668
30666: GO 30722
30668: POP
// begin if side = ai_s [ 3 ] then
30669: LD_VAR 0 2
30673: PUSH
30674: LD_EXP 23
30678: PUSH
30679: LD_INT 3
30681: ARRAY
30682: EQUAL
30683: IFFALSE 30720
// begin DQrML_Right ( cap_bases = 0 ) ;
30685: LD_EXP 17
30689: PUSH
30690: LD_INT 0
30692: EQUAL
30693: PPUSH
30694: CALL 6791 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 3 ] ) ;
30698: LD_EXP 17
30702: PUSH
30703: LD_INT 0
30705: EQUAL
30706: PPUSH
30707: LD_EXP 23
30711: PUSH
30712: LD_INT 3
30714: ARRAY
30715: PPUSH
30716: CALL 31024 0 2
// end ; end ; t_pay :
30720: GO 30851
30722: LD_EXP 4
30726: DOUBLE
30727: EQUAL
30728: IFTRUE 30732
30730: GO 30786
30732: POP
// begin if side = ai_s [ 4 ] then
30733: LD_VAR 0 2
30737: PUSH
30738: LD_EXP 23
30742: PUSH
30743: LD_INT 4
30745: ARRAY
30746: EQUAL
30747: IFFALSE 30784
// begin DD_BaseAccept ( cap_bases = 0 ) ;
30749: LD_EXP 17
30753: PUSH
30754: LD_INT 0
30756: EQUAL
30757: PPUSH
30758: CALL 7355 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 4 ] ) ;
30762: LD_EXP 17
30766: PUSH
30767: LD_INT 0
30769: EQUAL
30770: PPUSH
30771: LD_EXP 23
30775: PUSH
30776: LD_INT 4
30778: ARRAY
30779: PPUSH
30780: CALL 31024 0 2
// end ; end ; t_beat :
30784: GO 30851
30786: LD_EXP 5
30790: DOUBLE
30791: EQUAL
30792: IFTRUE 30796
30794: GO 30850
30796: POP
// begin if side = ai_s [ 5 ] then
30797: LD_VAR 0 2
30801: PUSH
30802: LD_EXP 23
30806: PUSH
30807: LD_INT 5
30809: ARRAY
30810: EQUAL
30811: IFFALSE 30848
// begin DE_BaseAccept ( cap_bases = 0 ) ;
30813: LD_EXP 17
30817: PUSH
30818: LD_INT 0
30820: EQUAL
30821: PPUSH
30822: CALL 7908 0 1
// SurrenderNormal ( cap_bases = 0 , ai_s [ 5 ] ) ;
30826: LD_EXP 17
30830: PUSH
30831: LD_INT 0
30833: EQUAL
30834: PPUSH
30835: LD_EXP 23
30839: PUSH
30840: LD_INT 5
30842: ARRAY
30843: PPUSH
30844: CALL 31024 0 2
// end ; end ; end ;
30848: GO 30851
30850: POP
// your_humans := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
30851: LD_ADDR_EXP 37
30855: PUSH
30856: LD_INT 22
30858: PUSH
30859: LD_EXP 7
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 21
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PPUSH
30882: CALL_OW 69
30886: ST_TO_ADDR
// your_builds := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
30887: LD_ADDR_EXP 36
30891: PUSH
30892: LD_INT 22
30894: PUSH
30895: LD_EXP 7
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 21
30906: PUSH
30907: LD_INT 3
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PPUSH
30918: CALL_OW 69
30922: ST_TO_ADDR
// your_cars := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
30923: LD_ADDR_EXP 35
30927: PUSH
30928: LD_INT 22
30930: PUSH
30931: LD_EXP 7
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 21
30942: PUSH
30943: LD_INT 2
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PPUSH
30954: CALL_OW 69
30958: ST_TO_ADDR
// remove_from_humans ( your_humans ) ;
30959: LD_EXP 37
30963: PPUSH
30964: CALL 28057 0 1
// remove_from_builds ( your_builds ) ;
30968: LD_EXP 36
30972: PPUSH
30973: CALL 27811 0 1
// remove_from_vehicles ( your_cars ) ;
30977: LD_EXP 35
30981: PPUSH
30982: CALL 28295 0 1
// cap_bases := cap_bases + 1 ;
30986: LD_ADDR_EXP 17
30990: PUSH
30991: LD_EXP 17
30995: PUSH
30996: LD_INT 1
30998: PLUS
30999: ST_TO_ADDR
// your_bases := your_bases ^ [ side ] ;
31000: LD_ADDR_EXP 18
31004: PUSH
31005: LD_EXP 18
31009: PUSH
31010: LD_VAR 0 2
31014: PUSH
31015: EMPTY
31016: LIST
31017: ADD
31018: ST_TO_ADDR
// end ; end ;
31019: LD_VAR 0 3
31023: RET
// function SurrenderNormal ( first , side ) ; var yours , take , theirs , i , max , t_sci , t_lab ; begin
31024: LD_INT 0
31026: PPUSH
31027: PPUSH
31028: PPUSH
31029: PPUSH
31030: PPUSH
31031: PPUSH
31032: PPUSH
31033: PPUSH
// yours := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
31034: LD_ADDR_VAR 0 4
31038: PUSH
31039: LD_INT 22
31041: PUSH
31042: LD_EXP 7
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 21
31053: PUSH
31054: LD_INT 1
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 23
31063: PUSH
31064: LD_INT 3
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: LIST
31075: PPUSH
31076: CALL_OW 69
31080: ST_TO_ADDR
// theirs := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_nation , nation_russian ] ] ) ;
31081: LD_ADDR_VAR 0 6
31085: PUSH
31086: LD_INT 22
31088: PUSH
31089: LD_VAR 0 2
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 21
31100: PUSH
31101: LD_INT 1
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 23
31110: PUSH
31111: LD_INT 3
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: LIST
31122: PPUSH
31123: CALL_OW 69
31127: ST_TO_ADDR
// for i in theirs do
31128: LD_ADDR_VAR 0 7
31132: PUSH
31133: LD_VAR 0 6
31137: PUSH
31138: FOR_IN
31139: IFFALSE 31174
// if GetLives ( i ) < hranice_umirani then
31141: LD_VAR 0 7
31145: PPUSH
31146: CALL_OW 256
31150: PUSH
31151: LD_INT 250
31153: LESS
31154: IFFALSE 31172
// SetLives ( i , hranice_umirani + 50 ) ;
31156: LD_VAR 0 7
31160: PPUSH
31161: LD_INT 250
31163: PUSH
31164: LD_INT 50
31166: PLUS
31167: PPUSH
31168: CALL_OW 234
31172: GO 31138
31174: POP
31175: POP
// InGameOn ;
31176: CALL_OW 8
// ComExitBuilding ( theirs ) ;
31180: LD_VAR 0 6
31184: PPUSH
31185: CALL_OW 122
// AddComExitVehicle ( theirs ) ;
31189: LD_VAR 0 6
31193: PPUSH
31194: CALL_OW 181
// wait ( 0 0$2 ) ;
31198: LD_INT 70
31200: PPUSH
31201: CALL_OW 67
// InGameOff ;
31205: CALL_OW 9
// if first then
31209: LD_VAR 0 1
31213: IFFALSE 31879
// begin SetTech ( tech_SibLoc , you , state_researched ) ;
31215: LD_INT 19
31217: PPUSH
31218: LD_EXP 7
31222: PPUSH
31223: LD_INT 2
31225: PPUSH
31226: CALL_OW 322
// ai := ai diff side ;
31230: LD_ADDR_EXP 24
31234: PUSH
31235: LD_EXP 24
31239: PUSH
31240: LD_VAR 0 2
31244: DIFF
31245: ST_TO_ADDR
// case side of ai_s [ 1 ] :
31246: LD_VAR 0 2
31250: PUSH
31251: LD_EXP 23
31255: PUSH
31256: LD_INT 1
31258: ARRAY
31259: DOUBLE
31260: EQUAL
31261: IFTRUE 31265
31263: GO 31327
31265: POP
// begin SetSideBase_custom ( GetBase ( depots [ 1 ] ) , you ) ;
31266: LD_EXP 74
31270: PUSH
31271: LD_INT 1
31273: ARRAY
31274: PPUSH
31275: CALL_OW 274
31279: PPUSH
31280: LD_EXP 7
31284: PPUSH
31285: CALL 32766 0 2
// SetSide ( humans [ 1 ] , you ) ;
31289: LD_EXP 76
31293: PUSH
31294: LD_INT 1
31296: ARRAY
31297: PPUSH
31298: LD_EXP 7
31302: PPUSH
31303: CALL_OW 235
// SetSide ( vehicles [ 1 ] , you ) ;
31307: LD_EXP 77
31311: PUSH
31312: LD_INT 1
31314: ARRAY
31315: PPUSH
31316: LD_EXP 7
31320: PPUSH
31321: CALL_OW 235
// end ; ai_s [ 2 ] :
31325: GO 31877
31327: LD_EXP 23
31331: PUSH
31332: LD_INT 2
31334: ARRAY
31335: DOUBLE
31336: EQUAL
31337: IFTRUE 31341
31339: GO 31417
31341: POP
// begin SetSideBase_custom ( GetBase ( depots [ 2 ] ) , you ) ;
31342: LD_EXP 74
31346: PUSH
31347: LD_INT 2
31349: ARRAY
31350: PPUSH
31351: CALL_OW 274
31355: PPUSH
31356: LD_EXP 7
31360: PPUSH
31361: CALL 32766 0 2
// SetSide ( humans [ 2 ] , you ) ;
31365: LD_EXP 76
31369: PUSH
31370: LD_INT 2
31372: ARRAY
31373: PPUSH
31374: LD_EXP 7
31378: PPUSH
31379: CALL_OW 235
// SetSide ( vehicles [ 2 ] , you ) ;
31383: LD_EXP 77
31387: PUSH
31388: LD_INT 2
31390: ARRAY
31391: PPUSH
31392: LD_EXP 7
31396: PPUSH
31397: CALL_OW 235
// SetSide ( Borodin , you ) ;
31401: LD_EXP 46
31405: PPUSH
31406: LD_EXP 7
31410: PPUSH
31411: CALL_OW 235
// end ; ai_s [ 3 ] :
31415: GO 31877
31417: LD_EXP 23
31421: PUSH
31422: LD_INT 3
31424: ARRAY
31425: DOUBLE
31426: EQUAL
31427: IFTRUE 31431
31429: GO 31507
31431: POP
// begin SetSideBase_custom ( GetBase ( depots [ 3 ] ) , you ) ;
31432: LD_EXP 74
31436: PUSH
31437: LD_INT 3
31439: ARRAY
31440: PPUSH
31441: CALL_OW 274
31445: PPUSH
31446: LD_EXP 7
31450: PPUSH
31451: CALL 32766 0 2
// SetSide ( humans [ 3 ] , you ) ;
31455: LD_EXP 76
31459: PUSH
31460: LD_INT 3
31462: ARRAY
31463: PPUSH
31464: LD_EXP 7
31468: PPUSH
31469: CALL_OW 235
// SetSide ( vehicles [ 3 ] , you ) ;
31473: LD_EXP 77
31477: PUSH
31478: LD_INT 3
31480: ARRAY
31481: PPUSH
31482: LD_EXP 7
31486: PPUSH
31487: CALL_OW 235
// SetSide ( Tsaritsyn , you ) ;
31491: LD_EXP 47
31495: PPUSH
31496: LD_EXP 7
31500: PPUSH
31501: CALL_OW 235
// end ; ai_s [ 4 ] :
31505: GO 31877
31507: LD_EXP 23
31511: PUSH
31512: LD_INT 4
31514: ARRAY
31515: DOUBLE
31516: EQUAL
31517: IFTRUE 31521
31519: GO 31786
31521: POP
// begin t_sci := sci isect humans [ 4 ] ;
31522: LD_ADDR_VAR 0 9
31526: PUSH
31527: LD_EXP 88
31531: PUSH
31532: LD_EXP 76
31536: PUSH
31537: LD_INT 4
31539: ARRAY
31540: ISECT
31541: ST_TO_ADDR
// if t_sci > 3 then
31542: LD_VAR 0 9
31546: PUSH
31547: LD_INT 3
31549: GREATER
31550: IFFALSE 31586
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
31552: LD_ADDR_VAR 0 9
31556: PUSH
31557: LD_VAR 0 9
31561: PUSH
31562: LD_INT 1
31564: ARRAY
31565: PUSH
31566: LD_VAR 0 9
31570: PUSH
31571: LD_INT 2
31573: ARRAY
31574: ADD
31575: PUSH
31576: LD_VAR 0 9
31580: PUSH
31581: LD_INT 3
31583: ARRAY
31584: ADD
31585: ST_TO_ADDR
// t_lab := UnitFilter ( buildings [ 4 ] , [ mf_lab ] ) ;
31586: LD_ADDR_VAR 0 10
31590: PUSH
31591: LD_EXP 75
31595: PUSH
31596: LD_INT 4
31598: ARRAY
31599: PPUSH
31600: LD_EXP 55
31604: PUSH
31605: EMPTY
31606: LIST
31607: PPUSH
31608: CALL_OW 72
31612: ST_TO_ADDR
// for i in t_lab do
31613: LD_ADDR_VAR 0 7
31617: PUSH
31618: LD_VAR 0 10
31622: PUSH
31623: FOR_IN
31624: IFFALSE 31676
// if GetLabKind ( i , 1 ) = b_lab_spacetime or GetLabKind ( i , 2 ) = b_lab_spacetime then
31626: LD_VAR 0 7
31630: PPUSH
31631: LD_INT 1
31633: PPUSH
31634: CALL_OW 268
31638: PUSH
31639: LD_INT 14
31641: EQUAL
31642: PUSH
31643: LD_VAR 0 7
31647: PPUSH
31648: LD_INT 2
31650: PPUSH
31651: CALL_OW 268
31655: PUSH
31656: LD_INT 14
31658: EQUAL
31659: OR
31660: IFFALSE 31674
// begin t_lab := i ;
31662: LD_ADDR_VAR 0 10
31666: PUSH
31667: LD_VAR 0 7
31671: ST_TO_ADDR
// break ;
31672: GO 31676
// end ;
31674: GO 31623
31676: POP
31677: POP
// SetSideBase_custom ( GetBase ( depots [ 4 ] ) , you ) ;
31678: LD_EXP 74
31682: PUSH
31683: LD_INT 4
31685: ARRAY
31686: PPUSH
31687: CALL_OW 274
31691: PPUSH
31692: LD_EXP 7
31696: PPUSH
31697: CALL 32766 0 2
// SetSide ( humans [ 4 ] diff t_sci , you ) ;
31701: LD_EXP 76
31705: PUSH
31706: LD_INT 4
31708: ARRAY
31709: PUSH
31710: LD_VAR 0 9
31714: DIFF
31715: PPUSH
31716: LD_EXP 7
31720: PPUSH
31721: CALL_OW 235
// SetSide ( vehicles [ 4 ] , you ) ;
31725: LD_EXP 77
31729: PUSH
31730: LD_INT 4
31732: ARRAY
31733: PPUSH
31734: LD_EXP 7
31738: PPUSH
31739: CALL_OW 235
// SetSide ( t_lab , ai_s [ 4 ] ) ;
31743: LD_VAR 0 10
31747: PPUSH
31748: LD_EXP 23
31752: PUSH
31753: LD_INT 4
31755: ARRAY
31756: PPUSH
31757: CALL_OW 235
// ComEnterUnit ( t_sci ^ [ Davidov ] , t_lab ) ;
31761: LD_VAR 0 9
31765: PUSH
31766: LD_EXP 48
31770: PUSH
31771: EMPTY
31772: LIST
31773: ADD
31774: PPUSH
31775: LD_VAR 0 10
31779: PPUSH
31780: CALL_OW 120
// end ; ai_s [ 5 ] :
31784: GO 31877
31786: LD_EXP 23
31790: PUSH
31791: LD_INT 5
31793: ARRAY
31794: DOUBLE
31795: EQUAL
31796: IFTRUE 31800
31798: GO 31876
31800: POP
// begin SetSideBase_custom ( GetBase ( depots [ 5 ] ) , you ) ;
31801: LD_EXP 74
31805: PUSH
31806: LD_INT 5
31808: ARRAY
31809: PPUSH
31810: CALL_OW 274
31814: PPUSH
31815: LD_EXP 7
31819: PPUSH
31820: CALL 32766 0 2
// SetSide ( humans [ 5 ] , you ) ;
31824: LD_EXP 76
31828: PUSH
31829: LD_INT 5
31831: ARRAY
31832: PPUSH
31833: LD_EXP 7
31837: PPUSH
31838: CALL_OW 235
// SetSide ( vehicles [ 5 ] , you ) ;
31842: LD_EXP 77
31846: PUSH
31847: LD_INT 5
31849: ARRAY
31850: PPUSH
31851: LD_EXP 7
31855: PPUSH
31856: CALL_OW 235
// SetSide ( Eisenstein , you ) ;
31860: LD_EXP 49
31864: PPUSH
31865: LD_EXP 7
31869: PPUSH
31870: CALL_OW 235
// end ; end ;
31874: GO 31877
31876: POP
// end else
31877: GO 32676
// begin case side of ai_s [ 1 ] :
31879: LD_VAR 0 2
31883: PUSH
31884: LD_EXP 23
31888: PUSH
31889: LD_INT 1
31891: ARRAY
31892: DOUBLE
31893: EQUAL
31894: IFTRUE 31898
31896: GO 31935
31898: POP
// take := humans [ 1 ] ^ buildings [ 1 ] ^ vehicles [ 1 ] ; ai_s [ 2 ] :
31899: LD_ADDR_VAR 0 5
31903: PUSH
31904: LD_EXP 76
31908: PUSH
31909: LD_INT 1
31911: ARRAY
31912: PUSH
31913: LD_EXP 75
31917: PUSH
31918: LD_INT 1
31920: ARRAY
31921: ADD
31922: PUSH
31923: LD_EXP 77
31927: PUSH
31928: LD_INT 1
31930: ARRAY
31931: ADD
31932: ST_TO_ADDR
31933: GO 32676
31935: LD_EXP 23
31939: PUSH
31940: LD_INT 2
31942: ARRAY
31943: DOUBLE
31944: EQUAL
31945: IFTRUE 31949
31947: GO 32101
31949: POP
// begin if humans [ 2 ] < 3 then
31950: LD_EXP 76
31954: PUSH
31955: LD_INT 2
31957: ARRAY
31958: PUSH
31959: LD_INT 3
31961: LESS
31962: IFFALSE 31974
// max := 1 else
31964: LD_ADDR_VAR 0 8
31968: PUSH
31969: LD_INT 1
31971: ST_TO_ADDR
31972: GO 31992
// max := humans [ 2 ] - 2 ;
31974: LD_ADDR_VAR 0 8
31978: PUSH
31979: LD_EXP 76
31983: PUSH
31984: LD_INT 2
31986: ARRAY
31987: PUSH
31988: LD_INT 2
31990: MINUS
31991: ST_TO_ADDR
// if max > 5 then
31992: LD_VAR 0 8
31996: PUSH
31997: LD_INT 5
31999: GREATER
32000: IFFALSE 32010
// max := 5 ;
32002: LD_ADDR_VAR 0 8
32006: PUSH
32007: LD_INT 5
32009: ST_TO_ADDR
// take := CharacterSelection ( B-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 2 ] ^ [ sel_not_changeable ] ^ [ Borodin ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32010: LD_ADDR_VAR 0 5
32014: PUSH
32015: LD_STRING B-Base
32017: PPUSH
32018: LD_INT 1
32020: PPUSH
32021: LD_VAR 0 8
32025: PPUSH
32026: LD_VAR 0 4
32030: PUSH
32031: LD_INT -2
32033: PUSH
32034: LD_INT -3
32036: PUSH
32037: LD_INT -6
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: ADD
32045: PUSH
32046: LD_EXP 76
32050: PUSH
32051: LD_INT 2
32053: ARRAY
32054: ADD
32055: PUSH
32056: LD_INT -4
32058: PUSH
32059: EMPTY
32060: LIST
32061: ADD
32062: PUSH
32063: LD_EXP 46
32067: PUSH
32068: EMPTY
32069: LIST
32070: ADD
32071: PPUSH
32072: LD_INT 1
32074: PUSH
32075: LD_INT 3
32077: PUSH
32078: LD_INT 2
32080: PUSH
32081: LD_INT 4
32083: PUSH
32084: LD_INT 9
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: PPUSH
32094: CALL_OW 42
32098: ST_TO_ADDR
// end ; ai_s [ 3 ] :
32099: GO 32676
32101: LD_EXP 23
32105: PUSH
32106: LD_INT 3
32108: ARRAY
32109: DOUBLE
32110: EQUAL
32111: IFTRUE 32115
32113: GO 32267
32115: POP
// begin if humans [ 3 ] < 3 then
32116: LD_EXP 76
32120: PUSH
32121: LD_INT 3
32123: ARRAY
32124: PUSH
32125: LD_INT 3
32127: LESS
32128: IFFALSE 32140
// max := 1 else
32130: LD_ADDR_VAR 0 8
32134: PUSH
32135: LD_INT 1
32137: ST_TO_ADDR
32138: GO 32158
// max := humans [ 3 ] - 2 ;
32140: LD_ADDR_VAR 0 8
32144: PUSH
32145: LD_EXP 76
32149: PUSH
32150: LD_INT 3
32152: ARRAY
32153: PUSH
32154: LD_INT 2
32156: MINUS
32157: ST_TO_ADDR
// if max > 3 then
32158: LD_VAR 0 8
32162: PUSH
32163: LD_INT 3
32165: GREATER
32166: IFFALSE 32176
// max := 3 ;
32168: LD_ADDR_VAR 0 8
32172: PUSH
32173: LD_INT 3
32175: ST_TO_ADDR
// take := CharacterSelection ( C-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 3 ] ^ [ sel_not_changeable ] ^ [ Tsaritsyn ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32176: LD_ADDR_VAR 0 5
32180: PUSH
32181: LD_STRING C-Base
32183: PPUSH
32184: LD_INT 1
32186: PPUSH
32187: LD_VAR 0 8
32191: PPUSH
32192: LD_VAR 0 4
32196: PUSH
32197: LD_INT -2
32199: PUSH
32200: LD_INT -3
32202: PUSH
32203: LD_INT -6
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: LIST
32210: ADD
32211: PUSH
32212: LD_EXP 76
32216: PUSH
32217: LD_INT 3
32219: ARRAY
32220: ADD
32221: PUSH
32222: LD_INT -4
32224: PUSH
32225: EMPTY
32226: LIST
32227: ADD
32228: PUSH
32229: LD_EXP 47
32233: PUSH
32234: EMPTY
32235: LIST
32236: ADD
32237: PPUSH
32238: LD_INT 1
32240: PUSH
32241: LD_INT 3
32243: PUSH
32244: LD_INT 2
32246: PUSH
32247: LD_INT 4
32249: PUSH
32250: LD_INT 9
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: PPUSH
32260: CALL_OW 42
32264: ST_TO_ADDR
// end ; ai_s [ 4 ] :
32265: GO 32676
32267: LD_EXP 23
32271: PUSH
32272: LD_INT 4
32274: ARRAY
32275: DOUBLE
32276: EQUAL
32277: IFTRUE 32281
32279: GO 32509
32281: POP
// begin if humans [ 4 ] < 3 then
32282: LD_EXP 76
32286: PUSH
32287: LD_INT 4
32289: ARRAY
32290: PUSH
32291: LD_INT 3
32293: LESS
32294: IFFALSE 32306
// max := 1 else
32296: LD_ADDR_VAR 0 8
32300: PUSH
32301: LD_INT 1
32303: ST_TO_ADDR
32304: GO 32324
// max := humans [ 4 ] - 2 ;
32306: LD_ADDR_VAR 0 8
32310: PUSH
32311: LD_EXP 76
32315: PUSH
32316: LD_INT 4
32318: ARRAY
32319: PUSH
32320: LD_INT 2
32322: MINUS
32323: ST_TO_ADDR
// if max > 2 then
32324: LD_VAR 0 8
32328: PUSH
32329: LD_INT 2
32331: GREATER
32332: IFFALSE 32342
// max := 2 ;
32334: LD_ADDR_VAR 0 8
32338: PUSH
32339: LD_INT 2
32341: ST_TO_ADDR
// t_sci := sci isect humans [ 4 ] ;
32342: LD_ADDR_VAR 0 9
32346: PUSH
32347: LD_EXP 88
32351: PUSH
32352: LD_EXP 76
32356: PUSH
32357: LD_INT 4
32359: ARRAY
32360: ISECT
32361: ST_TO_ADDR
// if t_sci > 3 then
32362: LD_VAR 0 9
32366: PUSH
32367: LD_INT 3
32369: GREATER
32370: IFFALSE 32406
// t_sci := t_sci [ 1 ] ^ t_sci [ 2 ] ^ t_sci [ 3 ] ;
32372: LD_ADDR_VAR 0 9
32376: PUSH
32377: LD_VAR 0 9
32381: PUSH
32382: LD_INT 1
32384: ARRAY
32385: PUSH
32386: LD_VAR 0 9
32390: PUSH
32391: LD_INT 2
32393: ARRAY
32394: ADD
32395: PUSH
32396: LD_VAR 0 9
32400: PUSH
32401: LD_INT 3
32403: ARRAY
32404: ADD
32405: ST_TO_ADDR
// take := CharacterSelection ( D-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ ( humans [ 4 ] diff t_sci ) ^ [ sel_not_changeable ] ^ t_sci ^ [ Davidov ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32406: LD_ADDR_VAR 0 5
32410: PUSH
32411: LD_STRING D-Base
32413: PPUSH
32414: LD_INT 1
32416: PPUSH
32417: LD_VAR 0 8
32421: PPUSH
32422: LD_VAR 0 4
32426: PUSH
32427: LD_INT -2
32429: PUSH
32430: LD_INT -3
32432: PUSH
32433: LD_INT -6
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: LIST
32440: ADD
32441: PUSH
32442: LD_EXP 76
32446: PUSH
32447: LD_INT 4
32449: ARRAY
32450: PUSH
32451: LD_VAR 0 9
32455: DIFF
32456: ADD
32457: PUSH
32458: LD_INT -4
32460: PUSH
32461: EMPTY
32462: LIST
32463: ADD
32464: PUSH
32465: LD_VAR 0 9
32469: ADD
32470: PUSH
32471: LD_EXP 48
32475: PUSH
32476: EMPTY
32477: LIST
32478: ADD
32479: PPUSH
32480: LD_INT 1
32482: PUSH
32483: LD_INT 3
32485: PUSH
32486: LD_INT 2
32488: PUSH
32489: LD_INT 4
32491: PUSH
32492: LD_INT 9
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: PPUSH
32502: CALL_OW 42
32506: ST_TO_ADDR
// end ; ai_s [ 5 ] :
32507: GO 32676
32509: LD_EXP 23
32513: PUSH
32514: LD_INT 5
32516: ARRAY
32517: DOUBLE
32518: EQUAL
32519: IFTRUE 32523
32521: GO 32675
32523: POP
// begin if humans [ 5 ] < 3 then
32524: LD_EXP 76
32528: PUSH
32529: LD_INT 5
32531: ARRAY
32532: PUSH
32533: LD_INT 3
32535: LESS
32536: IFFALSE 32548
// max := 1 else
32538: LD_ADDR_VAR 0 8
32542: PUSH
32543: LD_INT 1
32545: ST_TO_ADDR
32546: GO 32566
// max := humans [ 5 ] - 2 ;
32548: LD_ADDR_VAR 0 8
32552: PUSH
32553: LD_EXP 76
32557: PUSH
32558: LD_INT 5
32560: ARRAY
32561: PUSH
32562: LD_INT 2
32564: MINUS
32565: ST_TO_ADDR
// if max > 5 then
32566: LD_VAR 0 8
32570: PUSH
32571: LD_INT 5
32573: GREATER
32574: IFFALSE 32584
// max := 5 ;
32576: LD_ADDR_VAR 0 8
32580: PUSH
32581: LD_INT 5
32583: ST_TO_ADDR
// take := CharacterSelection ( E-Base , 1 , max , yours ^ [ sel_not_hired , sel_changeable , sel_dont_change_class ] ^ humans [ 5 ] ^ [ sel_not_changeable ] ^ [ Eisenstein ] , [ class_soldier , class_mechanic , class_engineer , class_scientistic , class_bazooker ] ) ;
32584: LD_ADDR_VAR 0 5
32588: PUSH
32589: LD_STRING E-Base
32591: PPUSH
32592: LD_INT 1
32594: PPUSH
32595: LD_VAR 0 8
32599: PPUSH
32600: LD_VAR 0 4
32604: PUSH
32605: LD_INT -2
32607: PUSH
32608: LD_INT -3
32610: PUSH
32611: LD_INT -6
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: LIST
32618: ADD
32619: PUSH
32620: LD_EXP 76
32624: PUSH
32625: LD_INT 5
32627: ARRAY
32628: ADD
32629: PUSH
32630: LD_INT -4
32632: PUSH
32633: EMPTY
32634: LIST
32635: ADD
32636: PUSH
32637: LD_EXP 49
32641: PUSH
32642: EMPTY
32643: LIST
32644: ADD
32645: PPUSH
32646: LD_INT 1
32648: PUSH
32649: LD_INT 3
32651: PUSH
32652: LD_INT 2
32654: PUSH
32655: LD_INT 4
32657: PUSH
32658: LD_INT 9
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: PPUSH
32668: CALL_OW 42
32672: ST_TO_ADDR
// end ; end ;
32673: GO 32676
32675: POP
// end ; ComExitVehicle ( take ) ;
32676: LD_VAR 0 5
32680: PPUSH
32681: CALL_OW 121
// AddComExitBuilding ( take ) ;
32685: LD_VAR 0 5
32689: PPUSH
32690: CALL_OW 182
// take := take union FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_control , control_manual ] ] ) ;
32694: LD_ADDR_VAR 0 5
32698: PUSH
32699: LD_VAR 0 5
32703: PUSH
32704: LD_INT 22
32706: PUSH
32707: LD_VAR 0 2
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 21
32718: PUSH
32719: LD_INT 2
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 33
32728: PUSH
32729: LD_INT 1
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: LIST
32740: PPUSH
32741: CALL_OW 69
32745: UNION
32746: ST_TO_ADDR
// SetSide ( take , you ) ;
32747: LD_VAR 0 5
32751: PPUSH
32752: LD_EXP 7
32756: PPUSH
32757: CALL_OW 235
// end ;
32761: LD_VAR 0 3
32765: RET
// export function SetSideBase_custom ( base , side ) ; var b , depot , orig_side ; begin
32766: LD_INT 0
32768: PPUSH
32769: PPUSH
32770: PPUSH
32771: PPUSH
// depot = - 1 ;
32772: LD_ADDR_VAR 0 5
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do
32781: LD_ADDR_VAR 0 4
32785: PUSH
32786: LD_INT 2
32788: PUSH
32789: LD_INT 30
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 30
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: LIST
32813: PUSH
32814: EMPTY
32815: LIST
32816: PPUSH
32817: CALL_OW 69
32821: PUSH
32822: FOR_IN
32823: IFFALSE 32856
// if GetBase ( b ) = base then
32825: LD_VAR 0 4
32829: PPUSH
32830: CALL_OW 274
32834: PUSH
32835: LD_VAR 0 1
32839: EQUAL
32840: IFFALSE 32854
// begin depot = b ;
32842: LD_ADDR_VAR 0 5
32846: PUSH
32847: LD_VAR 0 4
32851: ST_TO_ADDR
// break ;
32852: GO 32856
// end ;
32854: GO 32822
32856: POP
32857: POP
// orig_side = GetSide ( depot ) ;
32858: LD_ADDR_VAR 0 6
32862: PUSH
32863: LD_VAR 0 5
32867: PPUSH
32868: CALL_OW 255
32872: ST_TO_ADDR
// for b in FilterAllUnits ( [ [ f_side , orig_side ] , [ f_type , unit_building ] ] ) diff depot do
32873: LD_ADDR_VAR 0 4
32877: PUSH
32878: LD_INT 22
32880: PUSH
32881: LD_VAR 0 6
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 21
32892: PUSH
32893: LD_INT 3
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PPUSH
32904: CALL_OW 69
32908: PUSH
32909: LD_VAR 0 5
32913: DIFF
32914: PUSH
32915: FOR_IN
32916: IFFALSE 32951
// if GetBase ( b ) = base then
32918: LD_VAR 0 4
32922: PPUSH
32923: CALL_OW 274
32927: PUSH
32928: LD_VAR 0 1
32932: EQUAL
32933: IFFALSE 32949
// SetSide ( b , side ) ;
32935: LD_VAR 0 4
32939: PPUSH
32940: LD_VAR 0 2
32944: PPUSH
32945: CALL_OW 235
32949: GO 32915
32951: POP
32952: POP
// SetSide ( depot , side ) ;
32953: LD_VAR 0 5
32957: PPUSH
32958: LD_VAR 0 2
32962: PPUSH
32963: CALL_OW 235
// end ; end_of_file
32967: LD_VAR 0 3
32971: RET
// every 0 0$2 + 0 0$0.1 do
32972: GO 32974
32974: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
32975: LD_INT 22
32977: PUSH
32978: LD_INT 3
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 2
32987: PUSH
32988: LD_INT 25
32990: PUSH
32991: LD_INT 12
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 25
33000: PUSH
33001: LD_INT 16
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 25
33010: PUSH
33011: LD_INT 15
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 25
33020: PUSH
33021: LD_INT 17
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PPUSH
33039: CALL_OW 69
33043: PUSH
33044: LD_INT 22
33046: PUSH
33047: LD_INT 3
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 21
33056: PUSH
33057: LD_INT 1
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 3
33066: PUSH
33067: LD_INT 2
33069: PUSH
33070: LD_INT 25
33072: PUSH
33073: LD_INT 12
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 25
33082: PUSH
33083: LD_INT 16
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 25
33092: PUSH
33093: LD_INT 15
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 25
33102: PUSH
33103: LD_INT 17
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: LIST
33125: PPUSH
33126: CALL_OW 69
33130: GREATER
33131: IFFALSE 33142
// begin SetAchievement ( ACH_POTA ) ;
33133: LD_STRING ACH_POTA
33135: PPUSH
33136: CALL_OW 543
// exit ;
33140: GO 33143
// end ; enable ;
33142: ENABLE
// end ;
33143: END
// export function SA_OnMissionStart ; begin
33144: LD_INT 0
33146: PPUSH
// SetAchievement ( ACH_RPAT ) ;
33147: LD_STRING ACH_RPAT
33149: PPUSH
33150: CALL_OW 543
// end ;
33154: LD_VAR 0 1
33158: RET
// export function SA_OnTsaritsynQuizPerfectCleared ( qg ) ; begin
33159: LD_INT 0
33161: PPUSH
// SetAchievementEX ( ACH_CAD , qg ) ;
33162: LD_STRING ACH_CAD
33164: PPUSH
33165: LD_VAR 0 1
33169: PPUSH
33170: CALL_OW 564
// if qg = 6 then
33174: LD_VAR 0 1
33178: PUSH
33179: LD_INT 6
33181: EQUAL
33182: IFFALSE 33191
// SetAchievement ( ACH_CAD ) ;
33184: LD_STRING ACH_CAD
33186: PPUSH
33187: CALL_OW 543
// end ; end_of_file
33191: LD_VAR 0 2
33195: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
33196: LD_INT 0
33198: PPUSH
33199: PPUSH
// if not missionNumber then
33200: LD_VAR 0 2
33204: NOT
33205: IFFALSE 33209
// exit ;
33207: GO 33339
// achiv := false ;
33209: LD_ADDR_VAR 0 7
33213: PUSH
33214: LD_INT 0
33216: ST_TO_ADDR
// case campaignNumber of 1 :
33217: LD_VAR 0 1
33221: PUSH
33222: LD_INT 1
33224: DOUBLE
33225: EQUAL
33226: IFTRUE 33230
33228: GO 33241
33230: POP
// achiv := ACH_GOTA ; 2 :
33231: LD_ADDR_VAR 0 7
33235: PUSH
33236: LD_STRING ACH_GOTA
33238: ST_TO_ADDR
33239: GO 33291
33241: LD_INT 2
33243: DOUBLE
33244: EQUAL
33245: IFTRUE 33249
33247: GO 33252
33249: POP
// ; 3 :
33250: GO 33291
33252: LD_INT 3
33254: DOUBLE
33255: EQUAL
33256: IFTRUE 33260
33258: GO 33271
33260: POP
// achiv := ACH_MOTSU ; 4 :
33261: LD_ADDR_VAR 0 7
33265: PUSH
33266: LD_STRING ACH_MOTSU
33268: ST_TO_ADDR
33269: GO 33291
33271: LD_INT 4
33273: DOUBLE
33274: EQUAL
33275: IFTRUE 33279
33277: GO 33290
33279: POP
// achiv := ACH_LOP ; end ;
33280: LD_ADDR_VAR 0 7
33284: PUSH
33285: LD_STRING ACH_LOP
33287: ST_TO_ADDR
33288: GO 33291
33290: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
33291: LD_OWVAR 67
33295: PUSH
33296: LD_INT 3
33298: EQUAL
33299: PUSH
33300: LD_VAR 0 7
33304: AND
33305: PUSH
33306: LD_VAR 0 3
33310: AND
33311: PUSH
33312: LD_VAR 0 4
33316: AND
33317: PUSH
33318: LD_VAR 0 5
33322: AND
33323: IFFALSE 33339
// SetAchievementEX ( achiv , missionNumber ) ;
33325: LD_VAR 0 7
33329: PPUSH
33330: LD_VAR 0 2
33334: PPUSH
33335: CALL_OW 564
// end ;
33339: LD_VAR 0 6
33343: RET
// export function SA_BehemothConstructed ; begin
33344: LD_INT 0
33346: PPUSH
// SetAchievement ( ACH_SMC ) ;
33347: LD_STRING ACH_SMC
33349: PPUSH
33350: CALL_OW 543
// end ;
33354: LD_VAR 0 1
33358: RET
