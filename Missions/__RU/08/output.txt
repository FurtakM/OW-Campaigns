// export Burlak , Popov , Belkov , Kirilenkova , Gnyevko , Kapitsova , Dietrich , Gleb , Petrosyan , Kuzmov , Heike , Kovalyuk , Kurt , Mercenary1 , Scholtze , ASoldier1 , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Dolgov , Xavier , other , player_units , amattack , depot_build , depotX , depotY , you , ally , arab , merc , usa , GenscherBetrayed , HeikeCaptured , HeikeKilled , MercPaid , MercHandedOver , MercWillBeHandedOver , MercHandoverDone , MercHandoverArabsSpawned , MercAccepted , HeikeDismissed , PopovAsked , HuntingAccepted , BuildingsDone , TurretsDone , WeaponsDone , TechnoDone , MortarDone , GalleryBuild , AvailableWeapons , AvailableBuildings , AvailableTechno , FreeMan , FreeWoman , FreeTimeGranted , Masha , CompVehConstructed , LimitTeleportResearched , LimitTeleportTested , AmAttackDone , HeikeSend , GalleryAsked , HuntingAsked , FreetimeAsked , MortarAsked , MashaAsked , AmAttackStarted , hunter , speed , am_attack_skill , weaker , stronger , countdown , pocetmercenaries , snipers_positions , ar_human , MercenaryWillBeHealen , KurtWillBeHealen , WasSelected , CountTrees , GenCount , disabled2 , disabled3 , disabled4 , disabled5 , disabled6 , disabled7 , disabled8 , disabled9 , disabled102 ; export testing ; function read_parameters ; var i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
// you := 3 ;
   4: LD_ADDR_EXP 31
   8: PUSH
   9: LD_INT 3
  11: ST_TO_ADDR
// ally := 6 ;
  12: LD_ADDR_EXP 32
  16: PUSH
  17: LD_INT 6
  19: ST_TO_ADDR
// arab := 2 ;
  20: LD_ADDR_EXP 33
  24: PUSH
  25: LD_INT 2
  27: ST_TO_ADDR
// merc := 5 ;
  28: LD_ADDR_EXP 34
  32: PUSH
  33: LD_INT 5
  35: ST_TO_ADDR
// usa := 1 ;
  36: LD_ADDR_EXP 35
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// HeikeCaptured := LoadVariable ( HeikeCaptured , true ) ;
  44: LD_ADDR_EXP 37
  48: PUSH
  49: LD_STRING HeikeCaptured
  51: PPUSH
  52: LD_INT 1
  54: PPUSH
  55: CALL_OW 30
  59: ST_TO_ADDR
// SetAttitude ( you , ally , att_friend , true ) ;
  60: LD_EXP 31
  64: PPUSH
  65: LD_EXP 32
  69: PPUSH
  70: LD_INT 1
  72: PPUSH
  73: LD_INT 1
  75: PPUSH
  76: CALL_OW 80
// SetAttitude ( you , merc , att_neutral , true ) ;
  80: LD_EXP 31
  84: PPUSH
  85: LD_EXP 34
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: CALL_OW 80
// SetAttitude ( you , arab , att_neutral , true ) ;
 100: LD_EXP 31
 104: PPUSH
 105: LD_EXP 33
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: CALL_OW 80
// SetAttitude ( you , usa , att_enemy , true ) ;
 120: LD_EXP 31
 124: PPUSH
 125: LD_EXP 35
 129: PPUSH
 130: LD_INT 2
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: CALL_OW 80
// SetAttitude ( ally , merc , att_friend , true ) ;
 140: LD_EXP 32
 144: PPUSH
 145: LD_EXP 34
 149: PPUSH
 150: LD_INT 1
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: CALL_OW 80
// SetAttitude ( ally , arab , att_friend , true ) ;
 160: LD_EXP 32
 164: PPUSH
 165: LD_EXP 33
 169: PPUSH
 170: LD_INT 1
 172: PPUSH
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 80
// SetAttitude ( ally , usa , att_friend , true ) ;
 180: LD_EXP 32
 184: PPUSH
 185: LD_EXP 35
 189: PPUSH
 190: LD_INT 1
 192: PPUSH
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 80
// SetAttitude ( merc , usa , att_neutral , true ) ;
 200: LD_EXP 34
 204: PPUSH
 205: LD_EXP 35
 209: PPUSH
 210: LD_INT 0
 212: PPUSH
 213: LD_INT 1
 215: PPUSH
 216: CALL_OW 80
// SetAttitude ( arab , usa , att_neutral , true ) ;
 220: LD_EXP 33
 224: PPUSH
 225: LD_EXP 35
 229: PPUSH
 230: LD_INT 0
 232: PPUSH
 233: LD_INT 1
 235: PPUSH
 236: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 240: LD_EXP 32
 244: PPUSH
 245: LD_EXP 31
 249: PPUSH
 250: CALL_OW 343
// HeikeDismissed := false ;
 254: LD_ADDR_EXP 45
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// MercAccepted := false ;
 262: LD_ADDR_EXP 44
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// MercPaid := false ;
 270: LD_ADDR_EXP 39
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// BuildingsDone := false ;
 278: LD_ADDR_EXP 48
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// WeaponsDone := false ;
 286: LD_ADDR_EXP 50
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// TechnoDone := false ;
 294: LD_ADDR_EXP 51
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// MortarDone := false ;
 302: LD_ADDR_EXP 52
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// TurretsDone := false ;
 310: LD_ADDR_EXP 49
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// GalleryBuild := false ;
 318: LD_ADDR_EXP 53
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// CompVehConstructed := false ;
 326: LD_ADDR_EXP 61
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// LimitTeleportResearched := false ;
 334: LD_ADDR_EXP 62
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// LimitTeleportTested := false ;
 342: LD_ADDR_EXP 63
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// AmAttackDone := false ;
 350: LD_ADDR_EXP 64
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// HeikeSend := false ;
 358: LD_ADDR_EXP 65
 362: PUSH
 363: LD_INT 0
 365: ST_TO_ADDR
// HeikeKilled := false ;
 366: LD_ADDR_EXP 38
 370: PUSH
 371: LD_INT 0
 373: ST_TO_ADDR
// Masha := 0 ;
 374: LD_ADDR_EXP 60
 378: PUSH
 379: LD_INT 0
 381: ST_TO_ADDR
// GalleryAsked := false ;
 382: LD_ADDR_EXP 66
 386: PUSH
 387: LD_INT 0
 389: ST_TO_ADDR
// HuntingAsked := false ;
 390: LD_ADDR_EXP 67
 394: PUSH
 395: LD_INT 0
 397: ST_TO_ADDR
// FreetimeAsked := false ;
 398: LD_ADDR_EXP 68
 402: PUSH
 403: LD_INT 0
 405: ST_TO_ADDR
// MashaAsked := false ;
 406: LD_ADDR_EXP 70
 410: PUSH
 411: LD_INT 0
 413: ST_TO_ADDR
// GenscherBetrayed := false ;
 414: LD_ADDR_EXP 36
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// AvailableWeapons := [ 42 , 43 , 44 , 45 , 46 ] ;
 422: LD_ADDR_EXP 54
 426: PUSH
 427: LD_INT 42
 429: PUSH
 430: LD_INT 43
 432: PUSH
 433: LD_INT 44
 435: PUSH
 436: LD_INT 45
 438: PUSH
 439: LD_INT 46
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// AvailableBuildings = [ ] ;
 449: LD_ADDR_EXP 55
 453: PUSH
 454: EMPTY
 455: ST_TO_ADDR
// for i := 0 to 50 do
 456: LD_ADDR_VAR 0 2
 460: PUSH
 461: DOUBLE
 462: LD_INT 0
 464: DEC
 465: ST_TO_ADDR
 466: LD_INT 50
 468: PUSH
 469: FOR_TO
 470: IFFALSE 510
// if GetRestrict ( i , you ) = 1 then
 472: LD_VAR 0 2
 476: PPUSH
 477: LD_EXP 31
 481: PPUSH
 482: CALL_OW 323
 486: PUSH
 487: LD_INT 1
 489: EQUAL
 490: IFFALSE 508
// AvailableBuildings := AvailableBuildings ^ i ;
 492: LD_ADDR_EXP 55
 496: PUSH
 497: LD_EXP 55
 501: PUSH
 502: LD_VAR 0 2
 506: ADD
 507: ST_TO_ADDR
 508: GO 469
 510: POP
 511: POP
// AvailableBuildings := AvailableBuildings diff [ 0 , 2 , 4 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 14 , 22 , 31 , 32 , 33 , 39 , 40 ] ;
 512: LD_ADDR_EXP 55
 516: PUSH
 517: LD_EXP 55
 521: PUSH
 522: LD_INT 0
 524: PUSH
 525: LD_INT 2
 527: PUSH
 528: LD_INT 4
 530: PUSH
 531: LD_INT 6
 533: PUSH
 534: LD_INT 7
 536: PUSH
 537: LD_INT 8
 539: PUSH
 540: LD_INT 9
 542: PUSH
 543: LD_INT 10
 545: PUSH
 546: LD_INT 11
 548: PUSH
 549: LD_INT 12
 551: PUSH
 552: LD_INT 14
 554: PUSH
 555: LD_INT 22
 557: PUSH
 558: LD_INT 31
 560: PUSH
 561: LD_INT 32
 563: PUSH
 564: LD_INT 33
 566: PUSH
 567: LD_INT 39
 569: PUSH
 570: LD_INT 40
 572: PUSH
 573: EMPTY
 574: LIST
 575: LIST
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: DIFF
 592: ST_TO_ADDR
// AvailableTechno = [ ] ;
 593: LD_ADDR_EXP 56
 597: PUSH
 598: EMPTY
 599: ST_TO_ADDR
// for i := 0 to 72 do
 600: LD_ADDR_VAR 0 2
 604: PUSH
 605: DOUBLE
 606: LD_INT 0
 608: DEC
 609: ST_TO_ADDR
 610: LD_INT 72
 612: PUSH
 613: FOR_TO
 614: IFFALSE 654
// if GetTech ( i , you ) = 1 then
 616: LD_VAR 0 2
 620: PPUSH
 621: LD_EXP 31
 625: PPUSH
 626: CALL_OW 321
 630: PUSH
 631: LD_INT 1
 633: EQUAL
 634: IFFALSE 652
// AvailableTechno := AvailableTechno ^ i ;
 636: LD_ADDR_EXP 56
 640: PUSH
 641: LD_EXP 56
 645: PUSH
 646: LD_VAR 0 2
 650: ADD
 651: ST_TO_ADDR
 652: GO 613
 654: POP
 655: POP
// AvailableTechno := AvailableTechno diff 72 ;
 656: LD_ADDR_EXP 56
 660: PUSH
 661: LD_EXP 56
 665: PUSH
 666: LD_INT 72
 668: DIFF
 669: ST_TO_ADDR
// end ;
 670: LD_VAR 0 1
 674: RET
// function set_difficulty ; begin
 675: LD_INT 0
 677: PPUSH
// countdown := [ 2 2$0 , 1 1$30 , 1 1$0 ] [ difficulty ] ;
 678: LD_ADDR_EXP 77
 682: PUSH
 683: LD_INT 4200
 685: PUSH
 686: LD_INT 3150
 688: PUSH
 689: LD_INT 2100
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_OWVAR 67
 701: ARRAY
 702: ST_TO_ADDR
// pocetmercenaries := [ 20 , 40 , 60 ] [ difficulty ] ;
 703: LD_ADDR_EXP 78
 707: PUSH
 708: LD_INT 20
 710: PUSH
 711: LD_INT 40
 713: PUSH
 714: LD_INT 60
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: ST_TO_ADDR
// am_attack_skill := [ 4 , 6 , 8 ] [ difficulty ] ;
 728: LD_ADDR_EXP 74
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: LD_INT 6
 738: PUSH
 739: LD_INT 8
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: PUSH
 747: LD_OWVAR 67
 751: ARRAY
 752: ST_TO_ADDR
// weaker := [ 10 , 15 , 20 ] [ difficulty ] ;
 753: LD_ADDR_EXP 75
 757: PUSH
 758: LD_INT 10
 760: PUSH
 761: LD_INT 15
 763: PUSH
 764: LD_INT 20
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_OWVAR 67
 776: ARRAY
 777: ST_TO_ADDR
// stronger := [ 20 , 25 , 30 ] [ difficulty ] ;
 778: LD_ADDR_EXP 76
 782: PUSH
 783: LD_INT 20
 785: PUSH
 786: LD_INT 25
 788: PUSH
 789: LD_INT 30
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: PUSH
 797: LD_OWVAR 67
 801: ARRAY
 802: ST_TO_ADDR
// speed := [ 60 60$0 , 45 45$0 , 38 38$0 ] [ difficulty ] ;
 803: LD_ADDR_EXP 73
 807: PUSH
 808: LD_INT 126000
 810: PUSH
 811: LD_INT 94500
 813: PUSH
 814: LD_INT 79800
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: PUSH
 822: LD_OWVAR 67
 826: ARRAY
 827: ST_TO_ADDR
// snipers_positions := [ [ [ 115 , 77 ] , [ 127 , 67 ] , [ 15 , 2 ] , [ 71 , 1 ] ] , [ [ 120 , 70 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] , [ [ 115 , 77 ] , [ 127 , 67 ] , [ 11 , 20 ] , [ 15 , 2 ] , [ 50 , 1 ] , [ 71 , 1 ] ] ] [ difficulty ] ;
 828: LD_ADDR_EXP 79
 832: PUSH
 833: LD_INT 115
 835: PUSH
 836: LD_INT 77
 838: PUSH
 839: EMPTY
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 127
 845: PUSH
 846: LD_INT 67
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: PUSH
 853: LD_INT 15
 855: PUSH
 856: LD_INT 2
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PUSH
 863: LD_INT 71
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: EMPTY
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 120
 881: PUSH
 882: LD_INT 70
 884: PUSH
 885: EMPTY
 886: LIST
 887: LIST
 888: PUSH
 889: LD_INT 11
 891: PUSH
 892: LD_INT 20
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: LD_INT 2
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: PUSH
 909: LD_INT 50
 911: PUSH
 912: LD_INT 1
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 71
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: LIST
 933: LIST
 934: LIST
 935: PUSH
 936: LD_INT 115
 938: PUSH
 939: LD_INT 77
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: PUSH
 946: LD_INT 127
 948: PUSH
 949: LD_INT 67
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 11
 958: PUSH
 959: LD_INT 20
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: PUSH
 966: LD_INT 15
 968: PUSH
 969: LD_INT 2
 971: PUSH
 972: EMPTY
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 50
 978: PUSH
 979: LD_INT 1
 981: PUSH
 982: EMPTY
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 71
 988: PUSH
 989: LD_INT 1
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: ST_TO_ADDR
// end ;
1015: LD_VAR 0 1
1019: RET
// function nacti_osobu ( ident ) ; begin
1020: LD_INT 0
1022: PPUSH
// if CheckCharacterSet ( ident ) then
1023: LD_VAR 0 1
1027: PPUSH
1028: CALL_OW 29
1032: IFFALSE 1051
// result := CreateCharacter ( ident ) else
1034: LD_ADDR_VAR 0 2
1038: PUSH
1039: LD_VAR 0 1
1043: PPUSH
1044: CALL_OW 34
1048: ST_TO_ADDR
1049: GO 1059
// result := 0 ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// function create_people ; var def , i , x , y , un ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
1068: PPUSH
1069: PPUSH
1070: PPUSH
1071: PPUSH
// uc_side = you ;
1072: LD_ADDR_OWVAR 20
1076: PUSH
1077: LD_EXP 31
1081: ST_TO_ADDR
// uc_nation := nation_russian ;
1082: LD_ADDR_OWVAR 21
1086: PUSH
1087: LD_INT 3
1089: ST_TO_ADDR
// other := CreateCharacterSet ( survivors1 ) ;
1090: LD_ADDR_EXP 25
1094: PUSH
1095: LD_STRING survivors1
1097: PPUSH
1098: CALL_OW 31
1102: ST_TO_ADDR
// other := other union CreateCharacterSet ( survivors2 ) ;
1103: LD_ADDR_EXP 25
1107: PUSH
1108: LD_EXP 25
1112: PUSH
1113: LD_STRING survivors2
1115: PPUSH
1116: CALL_OW 31
1120: UNION
1121: ST_TO_ADDR
// other := other diff 0 ;
1122: LD_ADDR_EXP 25
1126: PUSH
1127: LD_EXP 25
1131: PUSH
1132: LD_INT 0
1134: DIFF
1135: ST_TO_ADDR
// if not testing then
1136: LD_EXP 95
1140: NOT
1141: IFFALSE 1158
// Burlak := nacti_osobu ( Burlak ) else
1143: LD_ADDR_EXP 1
1147: PUSH
1148: LD_STRING Burlak
1150: PPUSH
1151: CALL 1020 0 1
1155: ST_TO_ADDR
1156: GO 1186
// begin PrepareMechanic ( sex_male , 7 ) ;
1158: LD_INT 1
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 383
// hc_name = Burlak ;
1168: LD_ADDR_OWVAR 26
1172: PUSH
1173: LD_STRING Burlak
1175: ST_TO_ADDR
// Burlak = CreateHuman ;
1176: LD_ADDR_EXP 1
1180: PUSH
1181: CALL_OW 44
1185: ST_TO_ADDR
// end ; Belkov := nacti_osobu ( Belkov ) ;
1186: LD_ADDR_EXP 3
1190: PUSH
1191: LD_STRING Belkov
1193: PPUSH
1194: CALL 1020 0 1
1198: ST_TO_ADDR
// Gnyevko := nacti_osobu ( Gnyevko ) ;
1199: LD_ADDR_EXP 5
1203: PUSH
1204: LD_STRING Gnyevko
1206: PPUSH
1207: CALL 1020 0 1
1211: ST_TO_ADDR
// Kirilenkova := nacti_osobu ( Kirilenkova ) ;
1212: LD_ADDR_EXP 4
1216: PUSH
1217: LD_STRING Kirilenkova
1219: PPUSH
1220: CALL 1020 0 1
1224: ST_TO_ADDR
// Kovalyuk := nacti_osobu ( Kovalyuk ) ;
1225: LD_ADDR_EXP 12
1229: PUSH
1230: LD_STRING Kovalyuk
1232: PPUSH
1233: CALL 1020 0 1
1237: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
1238: LD_ADDR_EXP 2
1242: PUSH
1243: LD_STRING Popov
1245: PPUSH
1246: CALL_OW 25
1250: ST_TO_ADDR
// Scholtze := nacti_osobu ( Scholtze ) ;
1251: LD_ADDR_EXP 15
1255: PUSH
1256: LD_STRING Scholtze
1258: PPUSH
1259: CALL 1020 0 1
1263: ST_TO_ADDR
// Kuzmov := nacti_osobu ( Kuzmov ) ;
1264: LD_ADDR_EXP 10
1268: PUSH
1269: LD_STRING Kuzmov
1271: PPUSH
1272: CALL 1020 0 1
1276: ST_TO_ADDR
// Karamazov := nacti_osobu ( Karamazov ) ;
1277: LD_ADDR_EXP 17
1281: PUSH
1282: LD_STRING Karamazov
1284: PPUSH
1285: CALL 1020 0 1
1289: ST_TO_ADDR
// Petrovova := nacti_osobu ( Petrovova ) ;
1290: LD_ADDR_EXP 21
1294: PUSH
1295: LD_STRING Petrovova
1297: PPUSH
1298: CALL 1020 0 1
1302: ST_TO_ADDR
// Gleb := nacti_osobu ( Gleb ) ;
1303: LD_ADDR_EXP 8
1307: PUSH
1308: LD_STRING Gleb
1310: PPUSH
1311: CALL 1020 0 1
1315: ST_TO_ADDR
// Petrosyan := nacti_osobu ( Petrosyan ) ;
1316: LD_ADDR_EXP 9
1320: PUSH
1321: LD_STRING Petrosyan
1323: PPUSH
1324: CALL 1020 0 1
1328: ST_TO_ADDR
// Lipshchin := nacti_osobu ( Lipshchin ) ;
1329: LD_ADDR_EXP 22
1333: PUSH
1334: LD_STRING Lipshchin
1336: PPUSH
1337: CALL 1020 0 1
1341: ST_TO_ADDR
// Titov := nacti_osobu ( Titov ) ;
1342: LD_ADDR_EXP 18
1346: PUSH
1347: LD_STRING Titov
1349: PPUSH
1350: CALL 1020 0 1
1354: ST_TO_ADDR
// Dolgov := nacti_osobu ( Dolgov ) ;
1355: LD_ADDR_EXP 23
1359: PUSH
1360: LD_STRING Dolgov
1362: PPUSH
1363: CALL 1020 0 1
1367: ST_TO_ADDR
// Xavier := nacti_osobu ( Xavier ) ;
1368: LD_ADDR_EXP 24
1372: PUSH
1373: LD_STRING Xavier
1375: PPUSH
1376: CALL 1020 0 1
1380: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1381: LD_ADDR_EXP 19
1385: PUSH
1386: LD_STRING Oblukov
1388: PPUSH
1389: CALL_OW 25
1393: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
1394: LD_ADDR_EXP 20
1398: PUSH
1399: LD_STRING Kozlov
1401: PPUSH
1402: CALL_OW 25
1406: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1407: LD_ADDR_EXP 6
1411: PUSH
1412: LD_STRING Kapitsova
1414: PPUSH
1415: CALL_OW 25
1419: ST_TO_ADDR
// uc_side = ally ;
1420: LD_ADDR_OWVAR 20
1424: PUSH
1425: LD_EXP 32
1429: ST_TO_ADDR
// uc_nation := nation_arabian ;
1430: LD_ADDR_OWVAR 21
1434: PUSH
1435: LD_INT 2
1437: ST_TO_ADDR
// if not testing then
1438: LD_EXP 95
1442: NOT
1443: IFFALSE 1460
// Heike := nacti_osobu ( Heike ) else
1445: LD_ADDR_EXP 11
1449: PUSH
1450: LD_STRING Heike
1452: PPUSH
1453: CALL 1020 0 1
1457: ST_TO_ADDR
1458: GO 1488
// begin PrepareSoldier ( sex_female , 7 ) ;
1460: LD_INT 2
1462: PPUSH
1463: LD_INT 7
1465: PPUSH
1466: CALL_OW 381
// hc_name = Heike ;
1470: LD_ADDR_OWVAR 26
1474: PUSH
1475: LD_STRING Heike
1477: ST_TO_ADDR
// Heike = CreateHuman ;
1478: LD_ADDR_EXP 11
1482: PUSH
1483: CALL_OW 44
1487: ST_TO_ADDR
// end ; SetClass ( Heike , class_engineer ) ;
1488: LD_EXP 11
1492: PPUSH
1493: LD_INT 2
1495: PPUSH
1496: CALL_OW 336
// uc_side = arab ;
1500: LD_ADDR_OWVAR 20
1504: PUSH
1505: LD_EXP 33
1509: ST_TO_ADDR
// uc_nation := nation_arabian ;
1510: LD_ADDR_OWVAR 21
1514: PUSH
1515: LD_INT 2
1517: ST_TO_ADDR
// Dietrich := NewCharacter ( Dietrich ) ;
1518: LD_ADDR_EXP 7
1522: PUSH
1523: LD_STRING Dietrich
1525: PPUSH
1526: CALL_OW 25
1530: ST_TO_ADDR
// uc_side = merc ;
1531: LD_ADDR_OWVAR 20
1535: PUSH
1536: LD_EXP 34
1540: ST_TO_ADDR
// uc_nation := nation_arabian ;
1541: LD_ADDR_OWVAR 21
1545: PUSH
1546: LD_INT 2
1548: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
1549: LD_ADDR_EXP 13
1553: PUSH
1554: LD_STRING Kurt
1556: PPUSH
1557: CALL_OW 25
1561: ST_TO_ADDR
// PrepareHuman ( sex_male , class_engineer , 2 ) ;
1562: LD_INT 1
1564: PPUSH
1565: LD_INT 2
1567: PPUSH
1568: LD_INT 2
1570: PPUSH
1571: CALL_OW 380
// hc_name :=  ;
1575: LD_ADDR_OWVAR 26
1579: PUSH
1580: LD_STRING 
1582: ST_TO_ADDR
// Mercenary1 := CreateHuman ;
1583: LD_ADDR_EXP 14
1587: PUSH
1588: CALL_OW 44
1592: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 1 ) ;
1593: LD_INT 1
1595: PPUSH
1596: LD_INT 1
1598: PPUSH
1599: LD_INT 1
1601: PPUSH
1602: CALL_OW 380
// hc_name :=  ;
1606: LD_ADDR_OWVAR 26
1610: PUSH
1611: LD_STRING 
1613: ST_TO_ADDR
// ASoldier1 := CreateHuman ;
1614: LD_ADDR_EXP 16
1618: PUSH
1619: CALL_OW 44
1623: ST_TO_ADDR
// player_units := ( [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) diff [ 0 ] ;
1624: LD_ADDR_EXP 26
1628: PUSH
1629: LD_EXP 1
1633: PUSH
1634: LD_EXP 3
1638: PUSH
1639: LD_EXP 4
1643: PUSH
1644: LD_EXP 5
1648: PUSH
1649: LD_EXP 6
1653: PUSH
1654: LD_EXP 8
1658: PUSH
1659: LD_EXP 10
1663: PUSH
1664: LD_EXP 12
1668: PUSH
1669: LD_EXP 15
1673: PUSH
1674: LD_EXP 17
1678: PUSH
1679: LD_EXP 18
1683: PUSH
1684: LD_EXP 19
1688: PUSH
1689: LD_EXP 20
1693: PUSH
1694: LD_EXP 21
1698: PUSH
1699: LD_EXP 22
1703: PUSH
1704: LD_EXP 9
1708: PUSH
1709: LD_EXP 23
1713: PUSH
1714: LD_EXP 24
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_INT 0
1741: PUSH
1742: EMPTY
1743: LIST
1744: DIFF
1745: ST_TO_ADDR
// for i = 1 to 2 do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: DOUBLE
1752: LD_INT 1
1754: DEC
1755: ST_TO_ADDR
1756: LD_INT 2
1758: PUSH
1759: FOR_TO
1760: IFFALSE 1814
// if other >= i and other [ i ] > 0 then
1762: LD_EXP 25
1766: PUSH
1767: LD_VAR 0 3
1771: GREATEREQUAL
1772: PUSH
1773: LD_EXP 25
1777: PUSH
1778: LD_VAR 0 3
1782: ARRAY
1783: PUSH
1784: LD_INT 0
1786: GREATER
1787: AND
1788: IFFALSE 1812
// player_units = player_units ^ other [ i ] ;
1790: LD_ADDR_EXP 26
1794: PUSH
1795: LD_EXP 26
1799: PUSH
1800: LD_EXP 25
1804: PUSH
1805: LD_VAR 0 3
1809: ARRAY
1810: ADD
1811: ST_TO_ADDR
1812: GO 1759
1814: POP
1815: POP
// uc_side = you ;
1816: LD_ADDR_OWVAR 20
1820: PUSH
1821: LD_EXP 31
1825: ST_TO_ADDR
// uc_nation := nation_russian ;
1826: LD_ADDR_OWVAR 21
1830: PUSH
1831: LD_INT 3
1833: ST_TO_ADDR
// if 0 + player_units < 15 then
1834: LD_INT 0
1836: PUSH
1837: LD_EXP 26
1841: PLUS
1842: PUSH
1843: LD_INT 15
1845: LESS
1846: IFFALSE 1910
// for i := 1 to 0 + other do
1848: LD_ADDR_VAR 0 3
1852: PUSH
1853: DOUBLE
1854: LD_INT 1
1856: DEC
1857: ST_TO_ADDR
1858: LD_INT 0
1860: PUSH
1861: LD_EXP 25
1865: PLUS
1866: PUSH
1867: FOR_TO
1868: IFFALSE 1908
// if 0 + player_units < 15 then
1870: LD_INT 0
1872: PUSH
1873: LD_EXP 26
1877: PLUS
1878: PUSH
1879: LD_INT 15
1881: LESS
1882: IFFALSE 1906
// player_units := player_units ^ other [ i ] ;
1884: LD_ADDR_EXP 26
1888: PUSH
1889: LD_EXP 26
1893: PUSH
1894: LD_EXP 25
1898: PUSH
1899: LD_VAR 0 3
1903: ARRAY
1904: ADD
1905: ST_TO_ADDR
1906: GO 1867
1908: POP
1909: POP
// if 0 + player_units < 15 then
1910: LD_INT 0
1912: PUSH
1913: LD_EXP 26
1917: PLUS
1918: PUSH
1919: LD_INT 15
1921: LESS
1922: IFFALSE 1987
// for i := 1 to 15 - player_units do
1924: LD_ADDR_VAR 0 3
1928: PUSH
1929: DOUBLE
1930: LD_INT 1
1932: DEC
1933: ST_TO_ADDR
1934: LD_INT 15
1936: PUSH
1937: LD_EXP 26
1941: MINUS
1942: PUSH
1943: FOR_TO
1944: IFFALSE 1985
// begin PrepareHuman ( 0 , 0 , 4 ) ;
1946: LD_INT 0
1948: PPUSH
1949: LD_INT 0
1951: PPUSH
1952: LD_INT 4
1954: PPUSH
1955: CALL_OW 380
// hc_name :=  ;
1959: LD_ADDR_OWVAR 26
1963: PUSH
1964: LD_STRING 
1966: ST_TO_ADDR
// player_units := player_units ^ CreateHuman ;
1967: LD_ADDR_EXP 26
1971: PUSH
1972: LD_EXP 26
1976: PUSH
1977: CALL_OW 44
1981: ADD
1982: ST_TO_ADDR
// end ;
1983: GO 1943
1985: POP
1986: POP
// Randomize ;
1987: CALL_OW 10
// RandomizeAll ;
1991: CALL_OW 11
// for un in player_units do
1995: LD_ADDR_VAR 0 6
1999: PUSH
2000: LD_EXP 26
2004: PUSH
2005: FOR_IN
2006: IFFALSE 2025
// PlaceUnitArea ( un , EnterArea , false ) ;
2008: LD_VAR 0 6
2012: PPUSH
2013: LD_INT 3
2015: PPUSH
2016: LD_INT 0
2018: PPUSH
2019: CALL_OW 49
2023: GO 2005
2025: POP
2026: POP
// end ;
2027: LD_VAR 0 1
2031: RET
// function create_vehicles ; var i , auto ; begin
2032: LD_INT 0
2034: PPUSH
2035: PPUSH
2036: PPUSH
// for i := 1 to 5 do
2037: LD_ADDR_VAR 0 2
2041: PUSH
2042: DOUBLE
2043: LD_INT 1
2045: DEC
2046: ST_TO_ADDR
2047: LD_INT 5
2049: PUSH
2050: FOR_TO
2051: IFFALSE 2208
// begin uc_side := you ;
2053: LD_ADDR_OWVAR 20
2057: PUSH
2058: LD_EXP 31
2062: ST_TO_ADDR
// uc_nation := nation_russian ;
2063: LD_ADDR_OWVAR 21
2067: PUSH
2068: LD_INT 3
2070: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2071: LD_ADDR_OWVAR 24
2075: PUSH
2076: LD_INT 0
2078: PPUSH
2079: LD_INT 5
2081: PPUSH
2082: CALL_OW 12
2086: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2087: LD_ADDR_OWVAR 37
2091: PUSH
2092: LD_INT 21
2094: ST_TO_ADDR
// vc_engine := engine_combustion ;
2095: LD_ADDR_OWVAR 39
2099: PUSH
2100: LD_INT 1
2102: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2103: LD_ADDR_OWVAR 40
2107: PUSH
2108: LD_INT 51
2110: ST_TO_ADDR
// vc_control := control_manual ;
2111: LD_ADDR_OWVAR 38
2115: PUSH
2116: LD_INT 1
2118: ST_TO_ADDR
// auto := CreateVehicle ;
2119: LD_ADDR_VAR 0 3
2123: PUSH
2124: CALL_OW 45
2128: ST_TO_ADDR
// if i <= 4 then
2129: LD_VAR 0 2
2133: PUSH
2134: LD_INT 4
2136: LESSEQUAL
2137: IFFALSE 2156
// SetCargo ( auto , mat_cans , 100 ) else
2139: LD_VAR 0 3
2143: PPUSH
2144: LD_INT 1
2146: PPUSH
2147: LD_INT 100
2149: PPUSH
2150: CALL_OW 290
2154: GO 2171
// SetCargo ( auto , mat_oil , 100 ) ;
2156: LD_VAR 0 3
2160: PPUSH
2161: LD_INT 2
2163: PPUSH
2164: LD_INT 100
2166: PPUSH
2167: CALL_OW 290
// SetFuel ( auto , Rand ( 40 , 80 ) ) ;
2171: LD_VAR 0 3
2175: PPUSH
2176: LD_INT 40
2178: PPUSH
2179: LD_INT 80
2181: PPUSH
2182: CALL_OW 12
2186: PPUSH
2187: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2191: LD_VAR 0 3
2195: PPUSH
2196: LD_INT 3
2198: PPUSH
2199: LD_INT 0
2201: PPUSH
2202: CALL_OW 49
// end ;
2206: GO 2050
2208: POP
2209: POP
// uc_side := you ;
2210: LD_ADDR_OWVAR 20
2214: PUSH
2215: LD_EXP 31
2219: ST_TO_ADDR
// uc_nation := nation_russian ;
2220: LD_ADDR_OWVAR 21
2224: PUSH
2225: LD_INT 3
2227: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2228: LD_ADDR_OWVAR 24
2232: PUSH
2233: LD_INT 0
2235: PPUSH
2236: LD_INT 5
2238: PPUSH
2239: CALL_OW 12
2243: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2244: LD_ADDR_OWVAR 37
2248: PUSH
2249: LD_INT 22
2251: ST_TO_ADDR
// vc_engine := engine_combustion ;
2252: LD_ADDR_OWVAR 39
2256: PUSH
2257: LD_INT 1
2259: ST_TO_ADDR
// vc_weapon := ru_crane ;
2260: LD_ADDR_OWVAR 40
2264: PUSH
2265: LD_INT 52
2267: ST_TO_ADDR
// vc_control := control_manual ;
2268: LD_ADDR_OWVAR 38
2272: PUSH
2273: LD_INT 1
2275: ST_TO_ADDR
// auto := CreateVehicle ;
2276: LD_ADDR_VAR 0 3
2280: PUSH
2281: CALL_OW 45
2285: ST_TO_ADDR
// SetFuel ( auto , Rand ( 90 , 100 ) ) ;
2286: LD_VAR 0 3
2290: PPUSH
2291: LD_INT 90
2293: PPUSH
2294: LD_INT 100
2296: PPUSH
2297: CALL_OW 12
2301: PPUSH
2302: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2306: LD_VAR 0 3
2310: PPUSH
2311: LD_INT 3
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 49
// for i := 1 to 3 do
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 3
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2450
// begin uc_side := you ;
2337: LD_ADDR_OWVAR 20
2341: PUSH
2342: LD_EXP 31
2346: ST_TO_ADDR
// uc_nation := nation_russian ;
2347: LD_ADDR_OWVAR 21
2351: PUSH
2352: LD_INT 3
2354: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
2355: LD_ADDR_OWVAR 24
2359: PUSH
2360: LD_INT 0
2362: PPUSH
2363: LD_INT 5
2365: PPUSH
2366: CALL_OW 12
2370: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
2371: LD_ADDR_OWVAR 37
2375: PUSH
2376: LD_INT 24
2378: ST_TO_ADDR
// vc_engine := engine_combustion ;
2379: LD_ADDR_OWVAR 39
2383: PUSH
2384: LD_INT 1
2386: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2387: LD_ADDR_OWVAR 40
2391: PUSH
2392: LD_INT 53
2394: ST_TO_ADDR
// vc_control := control_manual ;
2395: LD_ADDR_OWVAR 38
2399: PUSH
2400: LD_INT 1
2402: ST_TO_ADDR
// auto := CreateVehicle ;
2403: LD_ADDR_VAR 0 3
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetFuel ( auto , Rand ( 80 , 100 ) ) ;
2413: LD_VAR 0 3
2417: PPUSH
2418: LD_INT 80
2420: PPUSH
2421: LD_INT 100
2423: PPUSH
2424: CALL_OW 12
2428: PPUSH
2429: CALL_OW 240
// PlaceUnitArea ( auto , EnterArea , false ) ;
2433: LD_VAR 0 3
2437: PPUSH
2438: LD_INT 3
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL_OW 49
// end ;
2448: GO 2334
2450: POP
2451: POP
// end ;
2452: LD_VAR 0 1
2456: RET
// export function create_snipers ; var xy ; begin
2457: LD_INT 0
2459: PPUSH
2460: PPUSH
// for xy in snipers_positions do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_EXP 79
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2616
// begin uc_side = usa ;
2474: LD_ADDR_OWVAR 20
2478: PUSH
2479: LD_EXP 35
2483: ST_TO_ADDR
// uc_nation := nation_american ;
2484: LD_ADDR_OWVAR 21
2488: PUSH
2489: LD_INT 1
2491: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
2492: LD_ADDR_OWVAR 30
2496: PUSH
2497: LD_INT 0
2499: PUSH
2500: LD_INT 0
2502: PUSH
2503: LD_INT 0
2505: PUSH
2506: LD_INT 0
2508: PUSH
2509: EMPTY
2510: LIST
2511: LIST
2512: LIST
2513: LIST
2514: ST_TO_ADDR
// hc_skills := [ difficulty - 1 , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) , Rand ( 0 , 2 ) ] ;
2515: LD_ADDR_OWVAR 31
2519: PUSH
2520: LD_OWVAR 67
2524: PUSH
2525: LD_INT 1
2527: MINUS
2528: PUSH
2529: LD_INT 0
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: PUSH
2540: LD_INT 0
2542: PPUSH
2543: LD_INT 2
2545: PPUSH
2546: CALL_OW 12
2550: PUSH
2551: LD_INT 0
2553: PPUSH
2554: LD_INT 2
2556: PPUSH
2557: CALL_OW 12
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: LIST
2566: LIST
2567: ST_TO_ADDR
// hc_class := class_sniper ;
2568: LD_ADDR_OWVAR 28
2572: PUSH
2573: LD_INT 5
2575: ST_TO_ADDR
// hc_name :=  ;
2576: LD_ADDR_OWVAR 26
2580: PUSH
2581: LD_STRING 
2583: ST_TO_ADDR
// PlaceUnitXY ( CreateHuman , xy [ 1 ] , xy [ 2 ] , false ) ;
2584: CALL_OW 44
2588: PPUSH
2589: LD_VAR 0 2
2593: PUSH
2594: LD_INT 1
2596: ARRAY
2597: PPUSH
2598: LD_VAR 0 2
2602: PUSH
2603: LD_INT 2
2605: ARRAY
2606: PPUSH
2607: LD_INT 0
2609: PPUSH
2610: CALL_OW 48
// end ;
2614: GO 2471
2616: POP
2617: POP
// end ;
2618: LD_VAR 0 1
2622: RET
// export function create_heike ; var auto , filter , x , y , d , Guard1 , Guard2 ; begin
2623: LD_INT 0
2625: PPUSH
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
2632: PPUSH
// uc_side := ally ;
2633: LD_ADDR_OWVAR 20
2637: PUSH
2638: LD_EXP 32
2642: ST_TO_ADDR
// uc_nation := nation_russian ;
2643: LD_ADDR_OWVAR 21
2647: PUSH
2648: LD_INT 3
2650: ST_TO_ADDR
// uc_direction := Rand ( 3 , 5 ) ;
2651: LD_ADDR_OWVAR 24
2655: PUSH
2656: LD_INT 3
2658: PPUSH
2659: LD_INT 5
2661: PPUSH
2662: CALL_OW 12
2666: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2667: LD_INT 0
2669: PPUSH
2670: LD_INT 1
2672: PPUSH
2673: LD_INT 6
2675: PPUSH
2676: CALL_OW 380
// hc_name :=  ;
2680: LD_ADDR_OWVAR 26
2684: PUSH
2685: LD_STRING 
2687: ST_TO_ADDR
// Guard1 := CreateHuman ;
2688: LD_ADDR_VAR 0 7
2692: PUSH
2693: CALL_OW 44
2697: ST_TO_ADDR
// PrepareHuman ( 0 , class_soldier , 6 ) ;
2698: LD_INT 0
2700: PPUSH
2701: LD_INT 1
2703: PPUSH
2704: LD_INT 6
2706: PPUSH
2707: CALL_OW 380
// hc_name :=  ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING 
2718: ST_TO_ADDR
// Guard2 := CreateHuman ;
2719: LD_ADDR_VAR 0 8
2723: PUSH
2724: CALL_OW 44
2728: ST_TO_ADDR
// PlaceUnitArea ( Guard1 , EnterArea , false ) ;
2729: LD_VAR 0 7
2733: PPUSH
2734: LD_INT 3
2736: PPUSH
2737: LD_INT 0
2739: PPUSH
2740: CALL_OW 49
// PlaceUnitArea ( Guard2 , EnterArea , false ) ;
2744: LD_VAR 0 8
2748: PPUSH
2749: LD_INT 3
2751: PPUSH
2752: LD_INT 0
2754: PPUSH
2755: CALL_OW 49
// PlaceUnitArea ( Heike , EnterArea , false ) ;
2759: LD_EXP 11
2763: PPUSH
2764: LD_INT 3
2766: PPUSH
2767: LD_INT 0
2769: PPUSH
2770: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
2774: LD_ADDR_VAR 0 3
2778: PUSH
2779: LD_INT 22
2781: PUSH
2782: LD_EXP 31
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: PUSH
2791: LD_INT 2
2793: PUSH
2794: LD_INT 30
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: PUSH
2804: LD_INT 30
2806: PUSH
2807: LD_INT 1
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: PUSH
2819: EMPTY
2820: LIST
2821: PUSH
2822: EMPTY
2823: LIST
2824: LIST
2825: PPUSH
2826: CALL_OW 69
2830: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
2831: LD_INT 0
2833: PUSH
2834: LD_VAR 0 3
2838: PLUS
2839: PUSH
2840: LD_INT 0
2842: NONEQUAL
2843: IFFALSE 2904
// begin x := GetX ( filter [ 1 ] ) ;
2845: LD_ADDR_VAR 0 4
2849: PUSH
2850: LD_VAR 0 3
2854: PUSH
2855: LD_INT 1
2857: ARRAY
2858: PPUSH
2859: CALL_OW 250
2863: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
2864: LD_ADDR_VAR 0 5
2868: PUSH
2869: LD_VAR 0 3
2873: PUSH
2874: LD_INT 1
2876: ARRAY
2877: PPUSH
2878: CALL_OW 251
2882: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
2883: LD_ADDR_VAR 0 6
2887: PUSH
2888: LD_VAR 0 3
2892: PUSH
2893: LD_INT 1
2895: ARRAY
2896: PPUSH
2897: CALL_OW 254
2901: ST_TO_ADDR
// end else
2902: GO 2942
// begin x := GetX ( Burlak ) ;
2904: LD_ADDR_VAR 0 4
2908: PUSH
2909: LD_EXP 1
2913: PPUSH
2914: CALL_OW 250
2918: ST_TO_ADDR
// y := GetY ( Burlak ) ;
2919: LD_ADDR_VAR 0 5
2923: PUSH
2924: LD_EXP 1
2928: PPUSH
2929: CALL_OW 251
2933: ST_TO_ADDR
// d := 1 ;
2934: LD_ADDR_VAR 0 6
2938: PUSH
2939: LD_INT 1
2941: ST_TO_ADDR
// end ; repeat ComMoveXY ( Guard1 , x , y ) ;
2942: LD_VAR 0 7
2946: PPUSH
2947: LD_VAR 0 4
2951: PPUSH
2952: LD_VAR 0 5
2956: PPUSH
2957: CALL_OW 111
// ComMoveUnit ( Heike , Guard1 ) ;
2961: LD_EXP 11
2965: PPUSH
2966: LD_VAR 0 7
2970: PPUSH
2971: CALL_OW 112
// ComMoveUnit ( Guard2 , Heike ) ;
2975: LD_VAR 0 8
2979: PPUSH
2980: LD_EXP 11
2984: PPUSH
2985: CALL_OW 112
// Wait ( 0 0$1 ) ;
2989: LD_INT 35
2991: PPUSH
2992: CALL_OW 67
// until ( GetDistUnitXY ( Guard1 , x , y ) < 10 ) and ( GetDistUnitXY ( Guard2 , x , y ) < 10 ) ;
2996: LD_VAR 0 7
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_VAR 0 5
3010: PPUSH
3011: CALL_OW 297
3015: PUSH
3016: LD_INT 10
3018: LESS
3019: PUSH
3020: LD_VAR 0 8
3024: PPUSH
3025: LD_VAR 0 4
3029: PPUSH
3030: LD_VAR 0 5
3034: PPUSH
3035: CALL_OW 297
3039: PUSH
3040: LD_INT 10
3042: LESS
3043: AND
3044: IFFALSE 2942
// ComStop ( [ Guard1 , Guard2 , Heike ] ) ;
3046: LD_VAR 0 7
3050: PUSH
3051: LD_VAR 0 8
3055: PUSH
3056: LD_EXP 11
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: LIST
3065: PPUSH
3066: CALL_OW 141
// Wait ( 10 ) ;
3070: LD_INT 10
3072: PPUSH
3073: CALL_OW 67
// ComMoveXY ( [ Guard1 , Guard2 ] , 113 , 29 ) ;
3077: LD_VAR 0 7
3081: PUSH
3082: LD_VAR 0 8
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PPUSH
3091: LD_INT 113
3093: PPUSH
3094: LD_INT 29
3096: PPUSH
3097: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
3101: LD_INT 35
3103: PPUSH
3104: CALL_OW 67
// until not HasTask ( Guard1 ) and not HasTask ( Guard2 ) ;
3108: LD_VAR 0 7
3112: PPUSH
3113: CALL_OW 314
3117: NOT
3118: PUSH
3119: LD_VAR 0 8
3123: PPUSH
3124: CALL_OW 314
3128: NOT
3129: AND
3130: IFFALSE 3101
// DestroyUnit ( Guard1 ) ;
3132: LD_VAR 0 7
3136: PPUSH
3137: CALL_OW 65
// DestroyUnit ( Guard2 ) ;
3141: LD_VAR 0 8
3145: PPUSH
3146: CALL_OW 65
// end ;
3150: LD_VAR 0 1
3154: RET
// export function create_kurt ; begin
3155: LD_INT 0
3157: PPUSH
// PlaceUnitArea ( Mercenary1 , MercEnterArea , false ) ;
3158: LD_EXP 14
3162: PPUSH
3163: LD_INT 4
3165: PPUSH
3166: LD_INT 0
3168: PPUSH
3169: CALL_OW 49
// PlaceUnitArea ( Kurt , MercEnterArea , false ) ;
3173: LD_EXP 13
3177: PPUSH
3178: LD_INT 4
3180: PPUSH
3181: LD_INT 0
3183: PPUSH
3184: CALL_OW 49
// enable ( 2 ) ;
3188: LD_INT 2
3190: ENABLE_MARKED
// end ;
3191: LD_VAR 0 1
3195: RET
// starting begin FogOff ( false ) ;
3196: LD_INT 0
3198: PPUSH
3199: CALL_OW 344
// Randomize ;
3203: CALL_OW 10
// RandomizeAll ;
3207: CALL_OW 11
// testing = false ;
3211: LD_ADDR_EXP 95
3215: PUSH
3216: LD_INT 0
3218: ST_TO_ADDR
// InitBc ;
3219: CALL_OW 21
// InitHc ;
3223: CALL_OW 19
// InitUc ;
3227: CALL_OW 18
// InitVc ;
3231: CALL_OW 20
// disable ( 1 ) ;
3235: LD_INT 1
3237: DISABLE_MARKED
// disable ( 2 ) ;
3238: LD_INT 2
3240: DISABLE_MARKED
// disable ( 3 ) ;
3241: LD_INT 3
3243: DISABLE_MARKED
// disable ( 4 ) ;
3244: LD_INT 4
3246: DISABLE_MARKED
// disable ( 5 ) ;
3247: LD_INT 5
3249: DISABLE_MARKED
// disable ( 6 ) ;
3250: LD_INT 6
3252: DISABLE_MARKED
// disable ( 7 ) ;
3253: LD_INT 7
3255: DISABLE_MARKED
// disable ( 8 ) ;
3256: LD_INT 8
3258: DISABLE_MARKED
// disable ( 9 ) ;
3259: LD_INT 9
3261: DISABLE_MARKED
// disable ( 10 ) ;
3262: LD_INT 10
3264: DISABLE_MARKED
// disable ( 11 ) ;
3265: LD_INT 11
3267: DISABLE_MARKED
// disable ( 13 ) ;
3268: LD_INT 13
3270: DISABLE_MARKED
// disable ( 20 ) ;
3271: LD_INT 20
3273: DISABLE_MARKED
// disable ( 23 ) ;
3274: LD_INT 23
3276: DISABLE_MARKED
// disable ( 24 ) ;
3277: LD_INT 24
3279: DISABLE_MARKED
// disable ( 50 ) ;
3280: LD_INT 50
3282: DISABLE_MARKED
// disable ( 101 ) ;
3283: LD_INT 101
3285: DISABLE_MARKED
// disable ( 102 ) ;
3286: LD_INT 102
3288: DISABLE_MARKED
// disable ( 201 ) ;
3289: LD_INT 201
3291: DISABLE_MARKED
// disable ( 202 ) ;
3292: LD_INT 202
3294: DISABLE_MARKED
// disable ( 203 ) ;
3295: LD_INT 203
3297: DISABLE_MARKED
// disable ( 301 ) ;
3298: LD_INT 301
3300: DISABLE_MARKED
// disable ( 401 ) ;
3301: LD_INT 401
3303: DISABLE_MARKED
// disable ( 402 ) ;
3304: LD_INT 402
3306: DISABLE_MARKED
// disable ( 501 ) ;
3307: LD_INT 501
3309: DISABLE_MARKED
// disable ( 502 ) ;
3310: LD_INT 502
3312: DISABLE_MARKED
// disable ( 601 ) ;
3313: LD_INT 601
3315: DISABLE_MARKED
// disable ( 999 ) ;
3316: LD_INT 999
3318: DISABLE_MARKED
// PlaceTreesToArea ( TreeArea1 , [ 2 , 10 , 11 , 27 , 35 ] , 20 , 10 , 4 ) ;
3319: LD_INT 24
3321: PPUSH
3322: LD_INT 2
3324: PUSH
3325: LD_INT 10
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 27
3333: PUSH
3334: LD_INT 35
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: LD_INT 20
3346: PPUSH
3347: LD_INT 10
3349: PPUSH
3350: LD_INT 4
3352: PPUSH
3353: CALL_OW 352
// PlaceTreesToArea ( TreeArea2 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3357: LD_INT 25
3359: PPUSH
3360: LD_INT 9
3362: PUSH
3363: LD_INT 10
3365: PUSH
3366: LD_INT 27
3368: PUSH
3369: LD_INT 35
3371: PUSH
3372: LD_INT 48
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: PPUSH
3382: LD_INT 20
3384: PPUSH
3385: LD_INT 10
3387: PPUSH
3388: LD_INT 4
3390: PPUSH
3391: CALL_OW 352
// PlaceTreesToArea ( TreeArea3 , [ 2 , 9 , 10 , 11 , 27 ] , 20 , 10 , 4 ) ;
3395: LD_INT 26
3397: PPUSH
3398: LD_INT 2
3400: PUSH
3401: LD_INT 9
3403: PUSH
3404: LD_INT 10
3406: PUSH
3407: LD_INT 11
3409: PUSH
3410: LD_INT 27
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PPUSH
3420: LD_INT 20
3422: PPUSH
3423: LD_INT 10
3425: PPUSH
3426: LD_INT 4
3428: PPUSH
3429: CALL_OW 352
// PlaceTreesToArea ( TreeArea4 , [ 9 , 10 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3433: LD_INT 27
3435: PPUSH
3436: LD_INT 9
3438: PUSH
3439: LD_INT 10
3441: PUSH
3442: LD_INT 27
3444: PUSH
3445: LD_INT 35
3447: PUSH
3448: LD_INT 48
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: PPUSH
3458: LD_INT 20
3460: PPUSH
3461: LD_INT 10
3463: PPUSH
3464: LD_INT 4
3466: PPUSH
3467: CALL_OW 352
// PlaceTreesToArea ( TreeArea5 , [ 2 , 9 , 10 , 11 , 48 ] , 20 , 10 , 4 ) ;
3471: LD_INT 28
3473: PPUSH
3474: LD_INT 2
3476: PUSH
3477: LD_INT 9
3479: PUSH
3480: LD_INT 10
3482: PUSH
3483: LD_INT 11
3485: PUSH
3486: LD_INT 48
3488: PUSH
3489: EMPTY
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: PPUSH
3496: LD_INT 20
3498: PPUSH
3499: LD_INT 10
3501: PPUSH
3502: LD_INT 4
3504: PPUSH
3505: CALL_OW 352
// PlaceTreesToArea ( TreeArea6 , [ 2 , 11 , 27 , 35 , 48 ] , 20 , 10 , 4 ) ;
3509: LD_INT 29
3511: PPUSH
3512: LD_INT 2
3514: PUSH
3515: LD_INT 11
3517: PUSH
3518: LD_INT 27
3520: PUSH
3521: LD_INT 35
3523: PUSH
3524: LD_INT 48
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: PPUSH
3534: LD_INT 20
3536: PPUSH
3537: LD_INT 10
3539: PPUSH
3540: LD_INT 4
3542: PPUSH
3543: CALL_OW 352
// read_parameters ;
3547: CALL 0 0 0
// set_difficulty ;
3551: CALL 675 0 0
// create_people ;
3555: CALL 1064 0 0
// create_vehicles ;
3559: CALL 2032 0 0
// create_snipers ;
3563: CALL 2457 0 0
// prepare_am_attack ;
3567: CALL 18649 0 0
// CenterNowOnXY ( 112 , 32 ) ;
3571: LD_INT 112
3573: PPUSH
3574: LD_INT 32
3576: PPUSH
3577: CALL_OW 86
// D_Start ;
3581: CALL 4902 0 0
// SaveForQuickRestart ;
3585: CALL_OW 22
// end ;
3589: END
// every 0 0$10 marked 999 do var filter , prumer , un , un1 , un2 , distance , pole , budova1 , budova2 , i , trotskij , medal1 , medal2 , medal3 ;
3590: GO 3592
3592: DISABLE
3593: LD_INT 0
3595: PPUSH
3596: PPUSH
3597: PPUSH
3598: PPUSH
3599: PPUSH
3600: PPUSH
3601: PPUSH
3602: PPUSH
3603: PPUSH
3604: PPUSH
3605: PPUSH
3606: PPUSH
3607: PPUSH
3608: PPUSH
// begin if BuildingsDone and WeaponsDone and TechnoDone and CompVehConstructed and LimitTeleportTested and Masha and AmAttackDone then
3609: LD_EXP 48
3613: PUSH
3614: LD_EXP 50
3618: AND
3619: PUSH
3620: LD_EXP 51
3624: AND
3625: PUSH
3626: LD_EXP 61
3630: AND
3631: PUSH
3632: LD_EXP 63
3636: AND
3637: PUSH
3638: LD_EXP 60
3642: AND
3643: PUSH
3644: LD_EXP 64
3648: AND
3649: IFFALSE 4898
// begin medal1 := false ;
3651: LD_ADDR_VAR 0 12
3655: PUSH
3656: LD_INT 0
3658: ST_TO_ADDR
// medal2 := false ;
3659: LD_ADDR_VAR 0 13
3663: PUSH
3664: LD_INT 0
3666: ST_TO_ADDR
// medal3 := false ;
3667: LD_ADDR_VAR 0 14
3671: PUSH
3672: LD_INT 0
3674: ST_TO_ADDR
// disable ;
3675: DISABLE
// gained_medals := [ ] ;
3676: LD_ADDR_OWVAR 61
3680: PUSH
3681: EMPTY
3682: ST_TO_ADDR
// missing_medals := [ ] ;
3683: LD_ADDR_OWVAR 62
3687: PUSH
3688: EMPTY
3689: ST_TO_ADDR
// if HeikeCaptured then
3690: LD_EXP 37
3694: IFFALSE 3735
// if MortarDone then
3696: LD_EXP 52
3700: IFFALSE 3722
// begin medal1 := true ;
3702: LD_ADDR_VAR 0 12
3706: PUSH
3707: LD_INT 1
3709: ST_TO_ADDR
// AddMedal ( ArabBarracks , 1 ) ;
3710: LD_STRING ArabBarracks
3712: PPUSH
3713: LD_INT 1
3715: PPUSH
3716: CALL_OW 101
// end else
3720: GO 3733
// AddMedal ( ArabBarracks , - 1 ) else
3722: LD_STRING ArabBarracks
3724: PPUSH
3725: LD_INT 1
3727: NEG
3728: PPUSH
3729: CALL_OW 101
3733: GO 3778
// if tick < speed then
3735: LD_OWVAR 1
3739: PUSH
3740: LD_EXP 73
3744: LESS
3745: IFFALSE 3767
// begin medal1 := true ;
3747: LD_ADDR_VAR 0 12
3751: PUSH
3752: LD_INT 1
3754: ST_TO_ADDR
// AddMedal ( Speed , 1 ) ;
3755: LD_STRING Speed
3757: PPUSH
3758: LD_INT 1
3760: PPUSH
3761: CALL_OW 101
// end else
3765: GO 3778
// AddMedal ( Speed , - 1 ) ;
3767: LD_STRING Speed
3769: PPUSH
3770: LD_INT 1
3772: NEG
3773: PPUSH
3774: CALL_OW 101
// AddMedal ( ArtisticImpression , 1 ) ;
3778: LD_STRING ArtisticImpression
3780: PPUSH
3781: LD_INT 1
3783: PPUSH
3784: CALL_OW 101
// medal2 := true ;
3788: LD_ADDR_VAR 0 13
3792: PUSH
3793: LD_INT 1
3795: ST_TO_ADDR
// if ( 0 + player_units ) <= 11 then
3796: LD_INT 0
3798: PUSH
3799: LD_EXP 26
3803: PLUS
3804: PUSH
3805: LD_INT 11
3807: LESSEQUAL
3808: IFFALSE 3823
// AddMedal ( FavouriteCommander , - 1 ) else
3810: LD_STRING FavouriteCommander
3812: PPUSH
3813: LD_INT 1
3815: NEG
3816: PPUSH
3817: CALL_OW 101
3821: GO 3903
// if FreeTimeGranted and HuntingAccepted and GalleryBuild then
3823: LD_EXP 59
3827: PUSH
3828: LD_EXP 47
3832: AND
3833: PUSH
3834: LD_EXP 53
3838: AND
3839: IFFALSE 3861
// begin medal3 := true ;
3841: LD_ADDR_VAR 0 14
3845: PUSH
3846: LD_INT 1
3848: ST_TO_ADDR
// AddMedal ( FavouriteCommander , 1 ) ;
3849: LD_STRING FavouriteCommander
3851: PPUSH
3852: LD_INT 1
3854: PPUSH
3855: CALL_OW 101
// end else
3859: GO 3903
// if FreeTimeGranted or HuntingAccepted or GalleryBuild then
3861: LD_EXP 59
3865: PUSH
3866: LD_EXP 47
3870: OR
3871: PUSH
3872: LD_EXP 53
3876: OR
3877: IFFALSE 3892
// AddMedal ( FavouriteCommander , - 3 ) else
3879: LD_STRING FavouriteCommander
3881: PPUSH
3882: LD_INT 3
3884: NEG
3885: PPUSH
3886: CALL_OW 101
3890: GO 3903
// AddMedal ( FavouriteCommander , - 2 ) ;
3892: LD_STRING FavouriteCommander
3894: PPUSH
3895: LD_INT 2
3897: NEG
3898: PPUSH
3899: CALL_OW 101
// if MortarDone and not HeikeDismissed then
3903: LD_EXP 52
3907: PUSH
3908: LD_EXP 45
3912: NOT
3913: AND
3914: IFFALSE 3920
// SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ;
3916: CALL 19233 0 0
// SA_EndMission ( 3 , 8 , medal1 , medal2 , medal3 ) ;
3920: LD_INT 3
3922: PPUSH
3923: LD_INT 8
3925: PPUSH
3926: LD_VAR 0 12
3930: PPUSH
3931: LD_VAR 0 13
3935: PPUSH
3936: LD_VAR 0 14
3940: PPUSH
3941: CALL 19248 0 5
// GiveMedals ( Main ) ;
3945: LD_STRING Main
3947: PPUSH
3948: CALL_OW 102
// for un1 in player_units do
3952: LD_ADDR_VAR 0 4
3956: PUSH
3957: LD_EXP 26
3961: PUSH
3962: FOR_IN
3963: IFFALSE 3994
// if IsDead ( un1 ) then
3965: LD_VAR 0 4
3969: PPUSH
3970: CALL_OW 301
3974: IFFALSE 3992
// player_units := player_units diff un1 ;
3976: LD_ADDR_EXP 26
3980: PUSH
3981: LD_EXP 26
3985: PUSH
3986: LD_VAR 0 4
3990: DIFF
3991: ST_TO_ADDR
3992: GO 3962
3994: POP
3995: POP
// RewardPeople ( player_units ) ;
3996: LD_EXP 26
4000: PPUSH
4001: CALL_OW 43
// trotskij := [ ] ;
4005: LD_ADDR_VAR 0 11
4009: PUSH
4010: EMPTY
4011: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_btype , b_factory ] ] ] ) ;
4012: LD_ADDR_VAR 0 1
4016: PUSH
4017: LD_INT 22
4019: PUSH
4020: LD_INT 3
4022: PUSH
4023: EMPTY
4024: LIST
4025: LIST
4026: PUSH
4027: LD_INT 30
4029: PUSH
4030: LD_INT 3
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PUSH
4037: EMPTY
4038: LIST
4039: LIST
4040: PPUSH
4041: CALL_OW 69
4045: PUSH
4046: LD_INT 22
4048: PUSH
4049: LD_INT 3
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: PUSH
4056: LD_INT 21
4058: PUSH
4059: LD_INT 3
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: PUSH
4066: LD_INT 3
4068: PUSH
4069: LD_INT 30
4071: PUSH
4072: LD_INT 3
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: PUSH
4079: EMPTY
4080: LIST
4081: LIST
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: LIST
4087: PPUSH
4088: CALL_OW 69
4092: ADD
4093: ST_TO_ADDR
// for un in filter do
4094: LD_ADDR_VAR 0 3
4098: PUSH
4099: LD_VAR 0 1
4103: PUSH
4104: FOR_IN
4105: IFFALSE 4446
// begin if GetBType ( un ) in [ b_lab , b_lab_half , b_lab_full ] then
4107: LD_VAR 0 3
4111: PPUSH
4112: CALL_OW 266
4116: PUSH
4117: LD_INT 6
4119: PUSH
4120: LD_INT 7
4122: PUSH
4123: LD_INT 8
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: LIST
4130: IN
4131: IFFALSE 4245
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetLabKind ( un , 1 ) , GetLabKind ( un , 2 ) ] ] else
4133: LD_ADDR_VAR 0 11
4137: PUSH
4138: LD_VAR 0 11
4142: PUSH
4143: LD_VAR 0 3
4147: PPUSH
4148: CALL_OW 266
4152: PUSH
4153: LD_VAR 0 3
4157: PPUSH
4158: CALL_OW 250
4162: PUSH
4163: LD_VAR 0 3
4167: PPUSH
4168: CALL_OW 251
4172: PUSH
4173: LD_VAR 0 3
4177: PPUSH
4178: CALL_OW 254
4182: PUSH
4183: LD_VAR 0 3
4187: PPUSH
4188: CALL_OW 267
4192: PUSH
4193: LD_VAR 0 3
4197: PPUSH
4198: CALL_OW 248
4202: PUSH
4203: LD_VAR 0 3
4207: PPUSH
4208: LD_INT 1
4210: PPUSH
4211: CALL_OW 268
4215: PUSH
4216: LD_VAR 0 3
4220: PPUSH
4221: LD_INT 2
4223: PPUSH
4224: CALL_OW 268
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: ADD
4242: ST_TO_ADDR
4243: GO 4444
// if GetBType ( un ) in [ b_bunker , b_turret ] then
4245: LD_VAR 0 3
4249: PPUSH
4250: CALL_OW 266
4254: PUSH
4255: LD_INT 32
4257: PUSH
4258: LD_INT 33
4260: PUSH
4261: EMPTY
4262: LIST
4263: LIST
4264: IN
4265: IFFALSE 4362
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) , GetBWeapon ( un ) ] ] else
4267: LD_ADDR_VAR 0 11
4271: PUSH
4272: LD_VAR 0 11
4276: PUSH
4277: LD_VAR 0 3
4281: PPUSH
4282: CALL_OW 266
4286: PUSH
4287: LD_VAR 0 3
4291: PPUSH
4292: CALL_OW 250
4296: PUSH
4297: LD_VAR 0 3
4301: PPUSH
4302: CALL_OW 251
4306: PUSH
4307: LD_VAR 0 3
4311: PPUSH
4312: CALL_OW 254
4316: PUSH
4317: LD_VAR 0 3
4321: PPUSH
4322: CALL_OW 267
4326: PUSH
4327: LD_VAR 0 3
4331: PPUSH
4332: CALL_OW 248
4336: PUSH
4337: LD_VAR 0 3
4341: PPUSH
4342: CALL_OW 269
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: PUSH
4356: EMPTY
4357: LIST
4358: ADD
4359: ST_TO_ADDR
4360: GO 4444
// trotskij := trotskij ^ [ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) , GetBLevel ( un ) , GetNation ( un ) ] ] ;
4362: LD_ADDR_VAR 0 11
4366: PUSH
4367: LD_VAR 0 11
4371: PUSH
4372: LD_VAR 0 3
4376: PPUSH
4377: CALL_OW 266
4381: PUSH
4382: LD_VAR 0 3
4386: PPUSH
4387: CALL_OW 250
4391: PUSH
4392: LD_VAR 0 3
4396: PPUSH
4397: CALL_OW 251
4401: PUSH
4402: LD_VAR 0 3
4406: PPUSH
4407: CALL_OW 254
4411: PUSH
4412: LD_VAR 0 3
4416: PPUSH
4417: CALL_OW 267
4421: PUSH
4422: LD_VAR 0 3
4426: PPUSH
4427: CALL_OW 248
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: ADD
4443: ST_TO_ADDR
// end ;
4444: GO 4104
4446: POP
4447: POP
// SaveVariable ( trotskij , Trotskij ) ;
4448: LD_VAR 0 11
4452: PPUSH
4453: LD_STRING Trotskij
4455: PPUSH
4456: CALL_OW 39
// SaveVariable ( ListEnvironmentArea ( WholeMapArea ) , Environment ) ;
4460: LD_INT 10
4462: PPUSH
4463: CALL_OW 353
4467: PPUSH
4468: LD_STRING Environment
4470: PPUSH
4471: CALL_OW 39
// SaveVariable ( HeikeKilled , HeikeKilled ) ;
4475: LD_EXP 38
4479: PPUSH
4480: LD_STRING HeikeKilled
4482: PPUSH
4483: CALL_OW 39
// SaveVariable ( MercPaid , MercPaid ) ;
4487: LD_EXP 39
4491: PPUSH
4492: LD_STRING MercPaid
4494: PPUSH
4495: CALL_OW 39
// SaveVariable ( MercHandedOver , MercHandedOver ) ;
4499: LD_EXP 40
4503: PPUSH
4504: LD_STRING MercHandedOver
4506: PPUSH
4507: CALL_OW 39
// SaveVariable ( MercAccepted , MercAccepted ) ;
4511: LD_EXP 44
4515: PPUSH
4516: LD_STRING MercAccepted
4518: PPUSH
4519: CALL_OW 39
// SaveVariable ( GenscherBetrayed , GenscherBetrayed ) ;
4523: LD_EXP 36
4527: PPUSH
4528: LD_STRING GenscherBetrayed
4530: PPUSH
4531: CALL_OW 39
// SaveCharacters ( Heike , Heike ) ;
4535: LD_EXP 11
4539: PPUSH
4540: LD_STRING Heike
4542: PPUSH
4543: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
4547: LD_EXP 9
4551: PPUSH
4552: LD_STRING Petrosyan
4554: PPUSH
4555: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
4559: LD_EXP 23
4563: PPUSH
4564: LD_STRING Dolgov
4566: PPUSH
4567: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4571: LD_EXP 24
4575: PPUSH
4576: LD_STRING Xavier
4578: PPUSH
4579: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
4583: LD_EXP 1
4587: PPUSH
4588: LD_STRING Burlak
4590: PPUSH
4591: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
4595: LD_EXP 3
4599: PPUSH
4600: LD_STRING Belkov
4602: PPUSH
4603: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
4607: LD_EXP 4
4611: PPUSH
4612: LD_STRING Kirilenkova
4614: PPUSH
4615: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
4619: LD_EXP 5
4623: PPUSH
4624: LD_STRING Gnyevko
4626: PPUSH
4627: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4631: LD_EXP 6
4635: PPUSH
4636: LD_STRING Kapitsova
4638: PPUSH
4639: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
4643: LD_EXP 8
4647: PPUSH
4648: LD_STRING Gleb
4650: PPUSH
4651: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
4655: LD_EXP 10
4659: PPUSH
4660: LD_STRING Kuzmov
4662: PPUSH
4663: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
4667: LD_EXP 12
4671: PPUSH
4672: LD_STRING Kovalyuk
4674: PPUSH
4675: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
4679: LD_EXP 15
4683: PPUSH
4684: LD_STRING Scholtze
4686: PPUSH
4687: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
4691: LD_EXP 17
4695: PPUSH
4696: LD_STRING Karamazov
4698: PPUSH
4699: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
4703: LD_EXP 18
4707: PPUSH
4708: LD_STRING Titov
4710: PPUSH
4711: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4715: LD_EXP 19
4719: PPUSH
4720: LD_STRING Oblukov
4722: PPUSH
4723: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4727: LD_EXP 20
4731: PPUSH
4732: LD_STRING Kozlov
4734: PPUSH
4735: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
4739: LD_EXP 21
4743: PPUSH
4744: LD_STRING Petrovova
4746: PPUSH
4747: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
4751: LD_EXP 22
4755: PPUSH
4756: LD_STRING Lipshchin
4758: PPUSH
4759: CALL_OW 38
// SaveCharacters ( ( ( player_units union other ) diff [ Burlak , Belkov , Kirilenkova , Gnyevko , Kapitsova , Gleb , Kuzmov , Kovalyuk , Scholtze , Karamazov , Titov , Oblukov , Kozlov , Petrovova , Lipshchin , Petrosyan , Dolgov , Xavier ] ) , survivors3 ) ;
4763: LD_EXP 26
4767: PUSH
4768: LD_EXP 25
4772: UNION
4773: PUSH
4774: LD_EXP 1
4778: PUSH
4779: LD_EXP 3
4783: PUSH
4784: LD_EXP 4
4788: PUSH
4789: LD_EXP 5
4793: PUSH
4794: LD_EXP 6
4798: PUSH
4799: LD_EXP 8
4803: PUSH
4804: LD_EXP 10
4808: PUSH
4809: LD_EXP 12
4813: PUSH
4814: LD_EXP 15
4818: PUSH
4819: LD_EXP 17
4823: PUSH
4824: LD_EXP 18
4828: PUSH
4829: LD_EXP 19
4833: PUSH
4834: LD_EXP 20
4838: PUSH
4839: LD_EXP 21
4843: PUSH
4844: LD_EXP 22
4848: PUSH
4849: LD_EXP 9
4853: PUSH
4854: LD_EXP 23
4858: PUSH
4859: LD_EXP 24
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: DIFF
4884: PPUSH
4885: LD_STRING survivors3
4887: PPUSH
4888: CALL_OW 38
// YouWin ;
4892: CALL_OW 103
// exit ;
4896: GO 4899
// end ; enable ;
4898: ENABLE
// end ; end_of_file
4899: PPOPN 14
4901: END
// export function D_Start ; begin
4902: LD_INT 0
4904: PPUSH
// DialogueOn ;
4905: CALL_OW 6
// SayRadio ( Popov , DStart-Pop-1 ) ;
4909: LD_EXP 2
4913: PPUSH
4914: LD_STRING DStart-Pop-1
4916: PPUSH
4917: CALL_OW 94
// Say ( Burlak , DStart-Bur-1 ) ;
4921: LD_EXP 1
4925: PPUSH
4926: LD_STRING DStart-Bur-1
4928: PPUSH
4929: CALL_OW 88
// Wait ( 0 0$2 ) ;
4933: LD_INT 70
4935: PPUSH
4936: CALL_OW 67
// ChangeMissionObjectives ( MStart ) ;
4940: LD_STRING MStart
4942: PPUSH
4943: CALL_OW 337
// display_strings := [ #Ru08-1 , ( 3 + AvailableBuildings ) , #Ru08-2 , ( 0 + AvailableWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
4947: LD_ADDR_OWVAR 47
4951: PUSH
4952: LD_STRING #Ru08-1
4954: PUSH
4955: LD_INT 3
4957: PUSH
4958: LD_EXP 55
4962: PLUS
4963: PUSH
4964: LD_STRING #Ru08-2
4966: PUSH
4967: LD_INT 0
4969: PUSH
4970: LD_EXP 54
4974: PLUS
4975: PUSH
4976: LD_STRING #Ru08-3
4978: PUSH
4979: LD_INT 0
4981: PUSH
4982: LD_EXP 56
4986: PLUS
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: ST_TO_ADDR
// DialogueOff ;
4996: CALL_OW 7
// end ;
5000: LD_VAR 0 1
5004: RET
// export function D_Heike ; begin
5005: LD_INT 0
5007: PPUSH
// Say ( Popov , DHeike-Pop-1 ) ;
5008: LD_EXP 2
5012: PPUSH
5013: LD_STRING DHeike-Pop-1
5015: PPUSH
5016: CALL_OW 88
// Wait ( 0 0$2 ) ;
5020: LD_INT 70
5022: PPUSH
5023: CALL_OW 67
// create_heike ;
5027: CALL 2623 0 0
// end ;
5031: LD_VAR 0 1
5035: RET
// export function D_HeikeKilled ; begin
5036: LD_INT 0
5038: PPUSH
// ForceSay ( Heike , DHeikeKilled-Hke-1 ) ;
5039: LD_EXP 11
5043: PPUSH
5044: LD_STRING DHeikeKilled-Hke-1
5046: PPUSH
5047: CALL_OW 91
// end ;
5051: LD_VAR 0 1
5055: RET
// export function D_MercHelp ; begin
5056: LD_INT 0
5058: PPUSH
// DialogueOn ;
5059: CALL_OW 6
// Say ( Kurt , DMercHelp-Kurt-1 ) ;
5063: LD_EXP 13
5067: PPUSH
5068: LD_STRING DMercHelp-Kurt-1
5070: PPUSH
5071: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-1 ) ;
5075: LD_EXP 1
5079: PPUSH
5080: LD_STRING DMercHelp-Bur-1
5082: PPUSH
5083: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-2 ) ;
5087: LD_EXP 13
5091: PPUSH
5092: LD_STRING DMercHelp-Kurt-2
5094: PPUSH
5095: CALL_OW 88
// Say ( Burlak , DMercHelp-Bur-2 ) ;
5099: LD_EXP 1
5103: PPUSH
5104: LD_STRING DMercHelp-Bur-2
5106: PPUSH
5107: CALL_OW 88
// Say ( Kurt , DMercHelp-Kurt-3 ) ;
5111: LD_EXP 13
5115: PPUSH
5116: LD_STRING DMercHelp-Kurt-3
5118: PPUSH
5119: CALL_OW 88
// DialogueOff ;
5123: CALL_OW 7
// end ;
5127: LD_VAR 0 1
5131: RET
// export function D_QrMerc1 ; begin
5132: LD_INT 0
5134: PPUSH
// DialogueOn ;
5135: CALL_OW 6
// Say ( Burlak , DQrMerc#1-Bur-1 ) ;
5139: LD_EXP 1
5143: PPUSH
5144: LD_STRING DQrMerc#1-Bur-1
5146: PPUSH
5147: CALL_OW 88
// Say ( Kurt , DQrMerc#1-Kurt-1 ) ;
5151: LD_EXP 13
5155: PPUSH
5156: LD_STRING DQrMerc#1-Kurt-1
5158: PPUSH
5159: CALL_OW 88
// DialogueOff ;
5163: CALL_OW 7
// end ;
5167: LD_VAR 0 1
5171: RET
// export function D_QrMerc2 ; begin
5172: LD_INT 0
5174: PPUSH
// DialogueOn ;
5175: CALL_OW 6
// Say ( Burlak , DQrMerc#2-Bur-1 ) ;
5179: LD_EXP 1
5183: PPUSH
5184: LD_STRING DQrMerc#2-Bur-1
5186: PPUSH
5187: CALL_OW 88
// SayRadio ( Popov , DQrMerc#2-Pop-1 ) ;
5191: LD_EXP 2
5195: PPUSH
5196: LD_STRING DQrMerc#2-Pop-1
5198: PPUSH
5199: CALL_OW 94
// Say ( Burlak , DQrMerc#2-Bur-2 ) ;
5203: LD_EXP 1
5207: PPUSH
5208: LD_STRING DQrMerc#2-Bur-2
5210: PPUSH
5211: CALL_OW 88
// DialogueOff ;
5215: CALL_OW 7
// end ;
5219: LD_VAR 0 1
5223: RET
// export function D_QrMerc3 ; begin
5224: LD_INT 0
5226: PPUSH
// DialogueOn ;
5227: CALL_OW 6
// Say ( Burlak , DQrMerc#3-Bur-1 ) ;
5231: LD_EXP 1
5235: PPUSH
5236: LD_STRING DQrMerc#3-Bur-1
5238: PPUSH
5239: CALL_OW 88
// DialogueOff ;
5243: CALL_OW 7
// end ;
5247: LD_VAR 0 1
5251: RET
// export function D_MercRefuseBuild ; begin
5252: LD_INT 0
5254: PPUSH
// Say ( Kurt , DMercRefuseBuild-Kurt-1 ) ;
5255: LD_EXP 13
5259: PPUSH
5260: LD_STRING DMercRefuseBuild-Kurt-1
5262: PPUSH
5263: CALL_OW 88
// end ;
5267: LD_VAR 0 1
5271: RET
// export function D_MercCompleted ; begin
5272: LD_INT 0
5274: PPUSH
// Say ( Kurt , DMercCompleted-Kurt-1 ) ;
5275: LD_EXP 13
5279: PPUSH
5280: LD_STRING DMercCompleted-Kurt-1
5282: PPUSH
5283: CALL_OW 88
// end ;
5287: LD_VAR 0 1
5291: RET
// export function D_MercPopov ; begin
5292: LD_INT 0
5294: PPUSH
// DialogueOn ;
5295: CALL_OW 6
// SayRadio ( Popov , DMercPopov-Pop-1 ) ;
5299: LD_EXP 2
5303: PPUSH
5304: LD_STRING DMercPopov-Pop-1
5306: PPUSH
5307: CALL_OW 94
// Say ( Burlak , DMercPopov-Bur-1 ) ;
5311: LD_EXP 1
5315: PPUSH
5316: LD_STRING DMercPopov-Bur-1
5318: PPUSH
5319: CALL_OW 88
// SayRadio ( Popov , DMercPopov-Pop-2 ) ;
5323: LD_EXP 2
5327: PPUSH
5328: LD_STRING DMercPopov-Pop-2
5330: PPUSH
5331: CALL_OW 94
// DialogueOff ;
5335: CALL_OW 7
// end ;
5339: LD_VAR 0 1
5343: RET
// export function D_MercAmbush ; begin
5344: LD_INT 0
5346: PPUSH
// Say ( Kurt , DMercAmbush-Kurt-1 ) ;
5347: LD_EXP 13
5351: PPUSH
5352: LD_STRING DMercAmbush-Kurt-1
5354: PPUSH
5355: CALL_OW 88
// SetAttitude ( you , merc , att_enemy , true ) ;
5359: LD_EXP 31
5363: PPUSH
5364: LD_EXP 34
5368: PPUSH
5369: LD_INT 2
5371: PPUSH
5372: LD_INT 1
5374: PPUSH
5375: CALL_OW 80
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
5379: LD_INT 8
5381: PPUSH
5382: LD_INT 0
5384: PPUSH
5385: CALL_OW 424
// disable ( 20 ) ;
5389: LD_INT 20
5391: DISABLE_MARKED
// end ;
5392: LD_VAR 0 1
5396: RET
// export function D_MercAttack ; begin
5397: LD_INT 0
5399: PPUSH
// Say ( Kurt , DMercAttack-Kurt-1 ) ;
5400: LD_EXP 13
5404: PPUSH
5405: LD_STRING DMercAttack-Kurt-1
5407: PPUSH
5408: CALL_OW 88
// end ;
5412: LD_VAR 0 1
5416: RET
// export function D_MercDeceived ; begin
5417: LD_INT 0
5419: PPUSH
// Say ( Kurt , DMercDeceived-Kurt-1 ) ;
5420: LD_EXP 13
5424: PPUSH
5425: LD_STRING DMercDeceived-Kurt-1
5427: PPUSH
5428: CALL_OW 88
// end ;
5432: LD_VAR 0 1
5436: RET
// export function D_ArabianRequest ; begin
5437: LD_INT 0
5439: PPUSH
// DialogueOn ;
5440: CALL_OW 6
// SayRadio ( Dietrich , DArabianRequest-Diet-1 ) ;
5444: LD_EXP 7
5448: PPUSH
5449: LD_STRING DArabianRequest-Diet-1
5451: PPUSH
5452: CALL_OW 94
// Say ( Burlak , DArabianRequest-Bur-1 ) ;
5456: LD_EXP 1
5460: PPUSH
5461: LD_STRING DArabianRequest-Bur-1
5463: PPUSH
5464: CALL_OW 88
// SayRadio ( Dietrich , DArabianRequest-Diet-2 ) ;
5468: LD_EXP 7
5472: PPUSH
5473: LD_STRING DArabianRequest-Diet-2
5475: PPUSH
5476: CALL_OW 94
// case Query ( QHandOver ) of 1 :
5480: LD_STRING QHandOver
5482: PPUSH
5483: CALL_OW 97
5487: PUSH
5488: LD_INT 1
5490: DOUBLE
5491: EQUAL
5492: IFTRUE 5496
5494: GO 5511
5496: POP
// begin D_QrHandOver1 ;
5497: CALL 5544 0 0
// MercWillBeHandedOver := true ;
5501: LD_ADDR_EXP 41
5505: PUSH
5506: LD_INT 1
5508: ST_TO_ADDR
// end ; 2 :
5509: GO 5535
5511: LD_INT 2
5513: DOUBLE
5514: EQUAL
5515: IFTRUE 5519
5517: GO 5534
5519: POP
// begin MercHandedOver = false ;
5520: LD_ADDR_EXP 40
5524: PUSH
5525: LD_INT 0
5527: ST_TO_ADDR
// D_QrHandOver2 ;
5528: CALL 5588 0 0
// end ; end ;
5532: GO 5535
5534: POP
// DialogueOff ;
5535: CALL_OW 7
// end ;
5539: LD_VAR 0 1
5543: RET
// export function D_QrHandOver1 ; begin
5544: LD_INT 0
5546: PPUSH
// DialogueOn ;
5547: CALL_OW 6
// Say ( Burlak , DQrHandOver#1-Bur-1 ) ;
5551: LD_EXP 1
5555: PPUSH
5556: LD_STRING DQrHandOver#1-Bur-1
5558: PPUSH
5559: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#1-Diet-1 ) ;
5563: LD_EXP 7
5567: PPUSH
5568: LD_STRING DQrHandOver#1-Diet-1
5570: PPUSH
5571: CALL_OW 94
// DialogueOff ;
5575: CALL_OW 7
// hand_over ;
5579: CALL 8500 0 0
// end ;
5583: LD_VAR 0 1
5587: RET
// export function D_QrHandOver2 ; begin
5588: LD_INT 0
5590: PPUSH
// DialogueOn ;
5591: CALL_OW 6
// Say ( Burlak , DQrHandOver#2-Bur-1 ) ;
5595: LD_EXP 1
5599: PPUSH
5600: LD_STRING DQrHandOver#2-Bur-1
5602: PPUSH
5603: CALL_OW 88
// SayRadio ( Dietrich , DQrHandOver#2-Diet-1 ) ;
5607: LD_EXP 7
5611: PPUSH
5612: LD_STRING DQrHandOver#2-Diet-1
5614: PPUSH
5615: CALL_OW 94
// Say ( Burlak , DQrHandOver#2-Bur-2 ) ;
5619: LD_EXP 1
5623: PPUSH
5624: LD_STRING DQrHandOver#2-Bur-2
5626: PPUSH
5627: CALL_OW 88
// DialogueOff ;
5631: CALL_OW 7
// end ;
5635: LD_VAR 0 1
5639: RET
// export function D_HandOverCome ; begin
5640: LD_INT 0
5642: PPUSH
// DialogueOn ;
5643: CALL_OW 6
// Say ( ASoldier1 , DHandOverCome-ASol1-1 ) ;
5647: LD_EXP 16
5651: PPUSH
5652: LD_STRING DHandOverCome-ASol1-1
5654: PPUSH
5655: CALL_OW 88
// Say ( Kurt , DHandOverCome-Kurt-1 ) ;
5659: LD_EXP 13
5663: PPUSH
5664: LD_STRING DHandOverCome-Kurt-1
5666: PPUSH
5667: CALL_OW 88
// DialogueOff ;
5671: CALL_OW 7
// end ;
5675: LD_VAR 0 1
5679: RET
// export function D_HandOverSpoiled ; begin
5680: LD_INT 0
5682: PPUSH
// DialogueOn ;
5683: CALL_OW 6
// SayRadio ( Dietrich , DHandOverSpoiled-Diet-1 ) ;
5687: LD_EXP 7
5691: PPUSH
5692: LD_STRING DHandOverSpoiled-Diet-1
5694: PPUSH
5695: CALL_OW 94
// DialogueOff ;
5699: CALL_OW 7
// end ;
5703: LD_VAR 0 1
5707: RET
// export function D_LegionFormed ; begin
5708: LD_INT 0
5710: PPUSH
// DialogueOn ;
5711: CALL_OW 6
// Say ( Heike , DLegionFormed-Hke-1 ) ;
5715: LD_EXP 11
5719: PPUSH
5720: LD_STRING DLegionFormed-Hke-1
5722: PPUSH
5723: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-1 ) ;
5727: LD_EXP 1
5731: PPUSH
5732: LD_STRING DLegionFormed-Bur-1
5734: PPUSH
5735: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-2 ) ;
5739: LD_EXP 11
5743: PPUSH
5744: LD_STRING DLegionFormed-Hke-2
5746: PPUSH
5747: CALL_OW 88
// Say ( Burlak , DLegionFormed-Bur-2 ) ;
5751: LD_EXP 1
5755: PPUSH
5756: LD_STRING DLegionFormed-Bur-2
5758: PPUSH
5759: CALL_OW 88
// Say ( Heike , DLegionFormed-Hke-3 ) ;
5763: LD_EXP 11
5767: PPUSH
5768: LD_STRING DLegionFormed-Hke-3
5770: PPUSH
5771: CALL_OW 88
// DialogueOff ;
5775: CALL_OW 7
// end ;
5779: LD_VAR 0 1
5783: RET
// export function D_QrLegion1 ; begin
5784: LD_INT 0
5786: PPUSH
// DialogueOn ;
5787: CALL_OW 6
// Say ( Burlak , DQrLegion#1-Bur-1 ) ;
5791: LD_EXP 1
5795: PPUSH
5796: LD_STRING DQrLegion#1-Bur-1
5798: PPUSH
5799: CALL_OW 88
// DialogueOff ;
5803: CALL_OW 7
// end ;
5807: LD_VAR 0 1
5811: RET
// export function D_QrLegion2 ; begin
5812: LD_INT 0
5814: PPUSH
// DialogueOn ;
5815: CALL_OW 6
// Say ( Burlak , DQrLegion#2-Bur-1 ) ;
5819: LD_EXP 1
5823: PPUSH
5824: LD_STRING DQrLegion#2-Bur-1
5826: PPUSH
5827: CALL_OW 88
// DialogueOff ;
5831: CALL_OW 7
// end ;
5835: LD_VAR 0 1
5839: RET
// export function D_FiringRange ; begin
5840: LD_INT 0
5842: PPUSH
// DialogueOn ;
5843: CALL_OW 6
// if IsOK ( Kuzmov ) then
5847: LD_EXP 10
5851: PPUSH
5852: CALL_OW 302
5856: IFFALSE 5872
// Say ( Kuzmov , DFiringRange-Kuz-1 ) else
5858: LD_EXP 10
5862: PPUSH
5863: LD_STRING DFiringRange-Kuz-1
5865: PPUSH
5866: CALL_OW 88
5870: GO 5884
// Say ( Oblukov , DFiringRange-Obl-1 ) ;
5872: LD_EXP 19
5876: PPUSH
5877: LD_STRING DFiringRange-Obl-1
5879: PPUSH
5880: CALL_OW 88
// Say ( Burlak , DFiringRange-Bur-1 ) ;
5884: LD_EXP 1
5888: PPUSH
5889: LD_STRING DFiringRange-Bur-1
5891: PPUSH
5892: CALL_OW 88
// CenterOnXY ( 59 , 34 ) ;
5896: LD_INT 59
5898: PPUSH
5899: LD_INT 34
5901: PPUSH
5902: CALL_OW 84
// Wait ( 0 0$0.5 ) ;
5906: LD_INT 18
5908: PPUSH
5909: CALL_OW 67
// RevealFogArea ( you , ShootArea ) ;
5913: LD_EXP 31
5917: PPUSH
5918: LD_INT 11
5920: PPUSH
5921: CALL_OW 332
// SetAreaMapShow ( ShootArea , 1 ) ;
5925: LD_INT 11
5927: PPUSH
5928: LD_INT 1
5930: PPUSH
5931: CALL_OW 424
// if IsOK ( Kuzmov ) then
5935: LD_EXP 10
5939: PPUSH
5940: CALL_OW 302
5944: IFFALSE 5960
// Say ( Kuzmov , DFiringRange-Kuz-2 ) else
5946: LD_EXP 10
5950: PPUSH
5951: LD_STRING DFiringRange-Kuz-2
5953: PPUSH
5954: CALL_OW 88
5958: GO 5972
// Say ( Oblukov , DFiringRange-Obl-2 ) ;
5960: LD_EXP 19
5964: PPUSH
5965: LD_STRING DFiringRange-Obl-2
5967: PPUSH
5968: CALL_OW 88
// DialogueOff ;
5972: CALL_OW 7
// end ;
5976: LD_VAR 0 1
5980: RET
// export function D_QrShootingGallery1 ; begin
5981: LD_INT 0
5983: PPUSH
// Say ( Burlak , DQrShootingGallery#1-Bur-1 ) ;
5984: LD_EXP 1
5988: PPUSH
5989: LD_STRING DQrShootingGallery#1-Bur-1
5991: PPUSH
5992: CALL_OW 88
// end ;
5996: LD_VAR 0 1
6000: RET
// export function D_QrShootingGallery2 ; begin
6001: LD_INT 0
6003: PPUSH
// Say ( Burlak , DQrShootingGallery#2-Bur-1 ) ;
6004: LD_EXP 1
6008: PPUSH
6009: LD_STRING DQrShootingGallery#2-Bur-1
6011: PPUSH
6012: CALL_OW 88
// end ;
6016: LD_VAR 0 1
6020: RET
// export function D_Hunting ; var allhunters ; begin
6021: LD_INT 0
6023: PPUSH
6024: PPUSH
// DialogueOn ;
6025: CALL_OW 6
// allhunters := [ ] ;
6029: LD_ADDR_VAR 0 2
6033: PUSH
6034: EMPTY
6035: ST_TO_ADDR
// if IsOK ( Belkov ) then
6036: LD_EXP 3
6040: PPUSH
6041: CALL_OW 302
6045: IFFALSE 6063
// allhunters := allhunters ^ Belkov ;
6047: LD_ADDR_VAR 0 2
6051: PUSH
6052: LD_VAR 0 2
6056: PUSH
6057: LD_EXP 3
6061: ADD
6062: ST_TO_ADDR
// if IsOK ( Karamazov ) then
6063: LD_EXP 17
6067: PPUSH
6068: CALL_OW 302
6072: IFFALSE 6090
// allhunters := allhunters ^ Karamazov ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PUSH
6084: LD_EXP 17
6088: ADD
6089: ST_TO_ADDR
// if IsOK ( Kozlov ) then
6090: LD_EXP 20
6094: PPUSH
6095: CALL_OW 302
6099: IFFALSE 6117
// allhunters := allhunters ^ Kozlov ;
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_VAR 0 2
6110: PUSH
6111: LD_EXP 20
6115: ADD
6116: ST_TO_ADDR
// Randomize ;
6117: CALL_OW 10
// RandomizeAll ;
6121: CALL_OW 11
// hunter := allhunters [ Rand ( 1 , ( allhunters + 0 ) ) ] ;
6125: LD_ADDR_EXP 72
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_INT 1
6137: PPUSH
6138: LD_VAR 0 2
6142: PUSH
6143: LD_INT 0
6145: PLUS
6146: PPUSH
6147: CALL_OW 12
6151: ARRAY
6152: ST_TO_ADDR
// case hunter of Belkov :
6153: LD_EXP 72
6157: PUSH
6158: LD_EXP 3
6162: DOUBLE
6163: EQUAL
6164: IFTRUE 6168
6166: GO 6183
6168: POP
// Say ( Belkov , DHunting-Bel-1 ) ; Karamazov :
6169: LD_EXP 3
6173: PPUSH
6174: LD_STRING DHunting-Bel-1
6176: PPUSH
6177: CALL_OW 88
6181: GO 6234
6183: LD_EXP 17
6187: DOUBLE
6188: EQUAL
6189: IFTRUE 6193
6191: GO 6208
6193: POP
// Say ( Karamazov , DHunting-Kar-1 ) ; Kozlov :
6194: LD_EXP 17
6198: PPUSH
6199: LD_STRING DHunting-Kar-1
6201: PPUSH
6202: CALL_OW 88
6206: GO 6234
6208: LD_EXP 20
6212: DOUBLE
6213: EQUAL
6214: IFTRUE 6218
6216: GO 6233
6218: POP
// Say ( Kozlov , DHunting-Koz-1 ) ; end ;
6219: LD_EXP 20
6223: PPUSH
6224: LD_STRING DHunting-Koz-1
6226: PPUSH
6227: CALL_OW 88
6231: GO 6234
6233: POP
// Say ( Burlak , DHunting-Bur-1 ) ;
6234: LD_EXP 1
6238: PPUSH
6239: LD_STRING DHunting-Bur-1
6241: PPUSH
6242: CALL_OW 88
// case hunter of Belkov :
6246: LD_EXP 72
6250: PUSH
6251: LD_EXP 3
6255: DOUBLE
6256: EQUAL
6257: IFTRUE 6261
6259: GO 6276
6261: POP
// Say ( Belkov , DHunting-Bel-2 ) ; Karamazov :
6262: LD_EXP 3
6266: PPUSH
6267: LD_STRING DHunting-Bel-2
6269: PPUSH
6270: CALL_OW 88
6274: GO 6327
6276: LD_EXP 17
6280: DOUBLE
6281: EQUAL
6282: IFTRUE 6286
6284: GO 6301
6286: POP
// Say ( Karamazov , DHunting-Kar-2 ) ; Kozlov :
6287: LD_EXP 17
6291: PPUSH
6292: LD_STRING DHunting-Kar-2
6294: PPUSH
6295: CALL_OW 88
6299: GO 6327
6301: LD_EXP 20
6305: DOUBLE
6306: EQUAL
6307: IFTRUE 6311
6309: GO 6326
6311: POP
// Say ( Kozlov , DHunting-Koz-2 ) ; end ;
6312: LD_EXP 20
6316: PPUSH
6317: LD_STRING DHunting-Koz-2
6319: PPUSH
6320: CALL_OW 88
6324: GO 6327
6326: POP
// DialogueOff ;
6327: CALL_OW 7
// end ;
6331: LD_VAR 0 1
6335: RET
// export function D_QrHunting1 ; begin
6336: LD_INT 0
6338: PPUSH
// Say ( Burlak , DQrHunting#1-Bur-1 ) ;
6339: LD_EXP 1
6343: PPUSH
6344: LD_STRING DQrHunting#1-Bur-1
6346: PPUSH
6347: CALL_OW 88
// end ;
6351: LD_VAR 0 1
6355: RET
// export function D_QrHunting2 ; begin
6356: LD_INT 0
6358: PPUSH
// Say ( Burlak , DQrHunting#2-Bur-1 ) ;
6359: LD_EXP 1
6363: PPUSH
6364: LD_STRING DQrHunting#2-Bur-1
6366: PPUSH
6367: CALL_OW 88
// end ;
6371: LD_VAR 0 1
6375: RET
// export function D_FreeTime ; var pole ; begin
6376: LD_INT 0
6378: PPUSH
6379: PPUSH
// DialogueOn ;
6380: CALL_OW 6
// Randomize ;
6384: CALL_OW 10
// RandomizeAll ;
6388: CALL_OW 11
// pole := [ ] ;
6392: LD_ADDR_VAR 0 2
6396: PUSH
6397: EMPTY
6398: ST_TO_ADDR
// if IsOK ( Kapitsova ) then
6399: LD_EXP 6
6403: PPUSH
6404: CALL_OW 302
6408: IFFALSE 6426
// pole := pole ^ Kapitsova ;
6410: LD_ADDR_VAR 0 2
6414: PUSH
6415: LD_VAR 0 2
6419: PUSH
6420: LD_EXP 6
6424: ADD
6425: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Petrovova :
6426: LD_VAR 0 2
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 0
6436: PUSH
6437: LD_VAR 0 2
6441: PLUS
6442: PPUSH
6443: CALL_OW 12
6447: ARRAY
6448: PUSH
6449: LD_EXP 21
6453: DOUBLE
6454: EQUAL
6455: IFTRUE 6459
6457: GO 6484
6459: POP
// begin Say ( Petrovova , DFreeTime-Ptr-1 ) ;
6460: LD_EXP 21
6464: PPUSH
6465: LD_STRING DFreeTime-Ptr-1
6467: PPUSH
6468: CALL_OW 88
// FreeWoman := Petrovova ;
6472: LD_ADDR_EXP 58
6476: PUSH
6477: LD_EXP 21
6481: ST_TO_ADDR
// end ; Kirilenkova :
6482: GO 6555
6484: LD_EXP 4
6488: DOUBLE
6489: EQUAL
6490: IFTRUE 6494
6492: GO 6519
6494: POP
// begin Say ( Kirilenkova , DFreeTime-Kir-1 ) ;
6495: LD_EXP 4
6499: PPUSH
6500: LD_STRING DFreeTime-Kir-1
6502: PPUSH
6503: CALL_OW 88
// FreeWoman := Kirilenkova ;
6507: LD_ADDR_EXP 58
6511: PUSH
6512: LD_EXP 4
6516: ST_TO_ADDR
// end ; Kapitsova :
6517: GO 6555
6519: LD_EXP 6
6523: DOUBLE
6524: EQUAL
6525: IFTRUE 6529
6527: GO 6554
6529: POP
// begin Say ( Kapitsova , DFreeTime-Kap-1 ) ;
6530: LD_EXP 6
6534: PPUSH
6535: LD_STRING DFreeTime-Kap-1
6537: PPUSH
6538: CALL_OW 88
// FreeWoman := Kapitsova ;
6542: LD_ADDR_EXP 58
6546: PUSH
6547: LD_EXP 6
6551: ST_TO_ADDR
// end ; end ;
6552: GO 6555
6554: POP
// pole := [ ] ;
6555: LD_ADDR_VAR 0 2
6559: PUSH
6560: EMPTY
6561: ST_TO_ADDR
// if IsOK ( Kuzmov ) then
6562: LD_EXP 10
6566: PPUSH
6567: CALL_OW 302
6571: IFFALSE 6589
// pole := pole ^ Kuzmov ;
6573: LD_ADDR_VAR 0 2
6577: PUSH
6578: LD_VAR 0 2
6582: PUSH
6583: LD_EXP 10
6587: ADD
6588: ST_TO_ADDR
// if IsOK ( Titov ) then
6589: LD_EXP 18
6593: PPUSH
6594: CALL_OW 302
6598: IFFALSE 6616
// pole := pole ^ Titov ;
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_VAR 0 2
6609: PUSH
6610: LD_EXP 18
6614: ADD
6615: ST_TO_ADDR
// if IsOK ( Gnyevko ) then
6616: LD_EXP 5
6620: PPUSH
6621: CALL_OW 302
6625: IFFALSE 6643
// pole := pole ^ Gnyevko ;
6627: LD_ADDR_VAR 0 2
6631: PUSH
6632: LD_VAR 0 2
6636: PUSH
6637: LD_EXP 5
6641: ADD
6642: ST_TO_ADDR
// if IsOK ( Oblukov ) then
6643: LD_EXP 19
6647: PPUSH
6648: CALL_OW 302
6652: IFFALSE 6670
// pole := pole ^ Oblukov ;
6654: LD_ADDR_VAR 0 2
6658: PUSH
6659: LD_VAR 0 2
6663: PUSH
6664: LD_EXP 19
6668: ADD
6669: ST_TO_ADDR
// case pole [ Rand ( 1 , 0 + pole ) ] of Kuzmov :
6670: LD_VAR 0 2
6674: PUSH
6675: LD_INT 1
6677: PPUSH
6678: LD_INT 0
6680: PUSH
6681: LD_VAR 0 2
6685: PLUS
6686: PPUSH
6687: CALL_OW 12
6691: ARRAY
6692: PUSH
6693: LD_EXP 10
6697: DOUBLE
6698: EQUAL
6699: IFTRUE 6703
6701: GO 6728
6703: POP
// begin Say ( Kuzmov , DFreeTime-Kuz-1 ) ;
6704: LD_EXP 10
6708: PPUSH
6709: LD_STRING DFreeTime-Kuz-1
6711: PPUSH
6712: CALL_OW 88
// FreeMan := Kuzmov ;
6716: LD_ADDR_EXP 57
6720: PUSH
6721: LD_EXP 10
6725: ST_TO_ADDR
// end ; Titov :
6726: GO 6834
6728: LD_EXP 18
6732: DOUBLE
6733: EQUAL
6734: IFTRUE 6738
6736: GO 6763
6738: POP
// begin Say ( Titov , DFreeTime-Tit-1 ) ;
6739: LD_EXP 18
6743: PPUSH
6744: LD_STRING DFreeTime-Tit-1
6746: PPUSH
6747: CALL_OW 88
// FreeMan := Titov ;
6751: LD_ADDR_EXP 57
6755: PUSH
6756: LD_EXP 18
6760: ST_TO_ADDR
// end ; Gnyevko :
6761: GO 6834
6763: LD_EXP 5
6767: DOUBLE
6768: EQUAL
6769: IFTRUE 6773
6771: GO 6798
6773: POP
// begin Say ( Gnyevko , DFreeTime-Gny-1 ) ;
6774: LD_EXP 5
6778: PPUSH
6779: LD_STRING DFreeTime-Gny-1
6781: PPUSH
6782: CALL_OW 88
// FreeMan := Gnyevko ;
6786: LD_ADDR_EXP 57
6790: PUSH
6791: LD_EXP 5
6795: ST_TO_ADDR
// end ; Oblukov :
6796: GO 6834
6798: LD_EXP 19
6802: DOUBLE
6803: EQUAL
6804: IFTRUE 6808
6806: GO 6833
6808: POP
// begin Say ( Oblukov , DFreeTime-Obl-1 ) ;
6809: LD_EXP 19
6813: PPUSH
6814: LD_STRING DFreeTime-Obl-1
6816: PPUSH
6817: CALL_OW 88
// FreeMan := Oblukov ;
6821: LD_ADDR_EXP 57
6825: PUSH
6826: LD_EXP 19
6830: ST_TO_ADDR
// end ; end ;
6831: GO 6834
6833: POP
// DialogueOff ;
6834: CALL_OW 7
// end ;
6838: LD_VAR 0 1
6842: RET
// export function D_QrFreeTime1 ; begin
6843: LD_INT 0
6845: PPUSH
// Say ( Burlak , DQrFreeTime#1-Bur-1 ) ;
6846: LD_EXP 1
6850: PPUSH
6851: LD_STRING DQrFreeTime#1-Bur-1
6853: PPUSH
6854: CALL_OW 88
// end ;
6858: LD_VAR 0 1
6862: RET
// export function D_QrFreeTime2 ; begin
6863: LD_INT 0
6865: PPUSH
// Say ( Burlak , DQrFreeTime#2-Bur-1 ) ;
6866: LD_EXP 1
6870: PPUSH
6871: LD_STRING DQrFreeTime#2-Bur-1
6873: PPUSH
6874: CALL_OW 88
// end ;
6878: LD_VAR 0 1
6882: RET
// export function D_Masha ; begin
6883: LD_INT 0
6885: PPUSH
// DialogueOn ;
6886: CALL_OW 6
// Say ( Kozlov , DMasha-Koz-1 ) ;
6890: LD_EXP 20
6894: PPUSH
6895: LD_STRING DMasha-Koz-1
6897: PPUSH
6898: CALL_OW 88
// DialogueOff ;
6902: CALL_OW 7
// end ;
6906: LD_VAR 0 1
6910: RET
// export function D_Masha2 ; begin
6911: LD_INT 0
6913: PPUSH
// Say ( Burlak , DMasha2-Bur-1 ) ;
6914: LD_EXP 1
6918: PPUSH
6919: LD_STRING DMasha2-Bur-1
6921: PPUSH
6922: CALL_OW 88
// end ;
6926: LD_VAR 0 1
6930: RET
// export function D_AI ; begin
6931: LD_INT 0
6933: PPUSH
// DialogueOn ;
6934: CALL_OW 6
// if IsOK ( Scholtze ) then
6938: LD_EXP 15
6942: PPUSH
6943: CALL_OW 302
6947: IFFALSE 6963
// Say ( Scholtze , DAI-Sch-1 ) else
6949: LD_EXP 15
6953: PPUSH
6954: LD_STRING DAI-Sch-1
6956: PPUSH
6957: CALL_OW 88
6961: GO 6975
// Say ( Kapitsova , DAI-Kap-1 ) ;
6963: LD_EXP 6
6967: PPUSH
6968: LD_STRING DAI-Kap-1
6970: PPUSH
6971: CALL_OW 88
// Say ( Burlak , DAI-Bur-1 ) ;
6975: LD_EXP 1
6979: PPUSH
6980: LD_STRING DAI-Bur-1
6982: PPUSH
6983: CALL_OW 88
// if IsOK ( Scholtze ) then
6987: LD_EXP 15
6991: PPUSH
6992: CALL_OW 302
6996: IFFALSE 7012
// Say ( Scholtze , DAI-Sch-2 ) else
6998: LD_EXP 15
7002: PPUSH
7003: LD_STRING DAI-Sch-2
7005: PPUSH
7006: CALL_OW 88
7010: GO 7024
// Say ( Kapitsova , DAI-Kap-2 ) ;
7012: LD_EXP 6
7016: PPUSH
7017: LD_STRING DAI-Kap-2
7019: PPUSH
7020: CALL_OW 88
// DialogueOff ;
7024: CALL_OW 7
// end ;
7028: LD_VAR 0 1
7032: RET
// export function D_SpontTelep ; begin
7033: LD_INT 0
7035: PPUSH
// DialogueOn ;
7036: CALL_OW 6
// if IsOK ( Scholtze ) then
7040: LD_EXP 15
7044: PPUSH
7045: CALL_OW 302
7049: IFFALSE 7065
// Say ( Scholtze , DSpontTelep-Sch-1 ) else
7051: LD_EXP 15
7055: PPUSH
7056: LD_STRING DSpontTelep-Sch-1
7058: PPUSH
7059: CALL_OW 88
7063: GO 7077
// Say ( Kapitsova , DSpontTelep-Kap-1 ) ;
7065: LD_EXP 6
7069: PPUSH
7070: LD_STRING DSpontTelep-Kap-1
7072: PPUSH
7073: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-1 ) ;
7077: LD_EXP 1
7081: PPUSH
7082: LD_STRING DSpontTelep-Bur-1
7084: PPUSH
7085: CALL_OW 88
// if IsOK ( Scholtze ) then
7089: LD_EXP 15
7093: PPUSH
7094: CALL_OW 302
7098: IFFALSE 7114
// Say ( Scholtze , DSpontTelep-Sch-2 ) else
7100: LD_EXP 15
7104: PPUSH
7105: LD_STRING DSpontTelep-Sch-2
7107: PPUSH
7108: CALL_OW 88
7112: GO 7126
// Say ( Kapitsova , DSpontTelep-Kap-2 ) ;
7114: LD_EXP 6
7118: PPUSH
7119: LD_STRING DSpontTelep-Kap-2
7121: PPUSH
7122: CALL_OW 88
// Say ( Burlak , DSpontTelep-Bur-2 ) ;
7126: LD_EXP 1
7130: PPUSH
7131: LD_STRING DSpontTelep-Bur-2
7133: PPUSH
7134: CALL_OW 88
// DialogueOff ;
7138: CALL_OW 7
// end ;
7142: LD_VAR 0 1
7146: RET
// export function D_AmAttackStart ; begin
7147: LD_INT 0
7149: PPUSH
// SayRadio ( Popov , DAmAttackStart-Pop-1 ) ;
7150: LD_EXP 2
7154: PPUSH
7155: LD_STRING DAmAttackStart-Pop-1
7157: PPUSH
7158: CALL_OW 94
// enable ( 50 ) ;
7162: LD_INT 50
7164: ENABLE_MARKED
// end ;
7165: LD_VAR 0 1
7169: RET
// every 0 0$1 marked 50 do
7170: GO 7172
7172: DISABLE
// begin Wait ( 0 0$10 ) ;
7173: LD_INT 350
7175: PPUSH
7176: CALL_OW 67
// if MercPaid then
7180: LD_EXP 39
7184: IFFALSE 7223
// begin Say ( Burlak , DAmAttackStart-Bur-1 ) ;
7186: LD_EXP 1
7190: PPUSH
7191: LD_STRING DAmAttackStart-Bur-1
7193: PPUSH
7194: CALL_OW 88
// if IsOK ( Gleb ) then
7198: LD_EXP 8
7202: PPUSH
7203: CALL_OW 302
7207: IFFALSE 7221
// Say ( Gleb , DAmAttackStart-Glb-1 ) ;
7209: LD_EXP 8
7213: PPUSH
7214: LD_STRING DAmAttackStart-Glb-1
7216: PPUSH
7217: CALL_OW 88
// end else
7221: GO 7235
// Say ( Burlak , DAmAttackStart-Bur-2 ) ;
7223: LD_EXP 1
7227: PPUSH
7228: LD_STRING DAmAttackStart-Bur-2
7230: PPUSH
7231: CALL_OW 88
// end ;
7235: END
// export function D_AmAttackFin ; var rnd , bool ; begin
7236: LD_INT 0
7238: PPUSH
7239: PPUSH
7240: PPUSH
// DialogueOn ;
7241: CALL_OW 6
// repeat rnd := Rand ( 1 , 7 ) ;
7245: LD_ADDR_VAR 0 2
7249: PUSH
7250: LD_INT 1
7252: PPUSH
7253: LD_INT 7
7255: PPUSH
7256: CALL_OW 12
7260: ST_TO_ADDR
// case rnd of 1 :
7261: LD_VAR 0 2
7265: PUSH
7266: LD_INT 1
7268: DOUBLE
7269: EQUAL
7270: IFTRUE 7274
7272: GO 7306
7274: POP
// if IsOK ( Belkov ) then
7275: LD_EXP 3
7279: PPUSH
7280: CALL_OW 302
7284: IFFALSE 7304
// bool := Say ( Belkov , DAmAttackFin-Bel-1 ) ; 2 :
7286: LD_ADDR_VAR 0 3
7290: PUSH
7291: LD_EXP 3
7295: PPUSH
7296: LD_STRING DAmAttackFin-Bel-1
7298: PPUSH
7299: CALL_OW 88
7303: ST_TO_ADDR
7304: GO 7547
7306: LD_INT 2
7308: DOUBLE
7309: EQUAL
7310: IFTRUE 7314
7312: GO 7346
7314: POP
// if IsOK ( Gnyevko ) then
7315: LD_EXP 5
7319: PPUSH
7320: CALL_OW 302
7324: IFFALSE 7344
// bool := Say ( Gnyevko , DAmAttackFin-Gny-1 ) ; 3 :
7326: LD_ADDR_VAR 0 3
7330: PUSH
7331: LD_EXP 5
7335: PPUSH
7336: LD_STRING DAmAttackFin-Gny-1
7338: PPUSH
7339: CALL_OW 88
7343: ST_TO_ADDR
7344: GO 7547
7346: LD_INT 3
7348: DOUBLE
7349: EQUAL
7350: IFTRUE 7354
7352: GO 7386
7354: POP
// if IsOK ( Titov ) then
7355: LD_EXP 18
7359: PPUSH
7360: CALL_OW 302
7364: IFFALSE 7384
// bool := Say ( Titov , DAmAttackFin-Tit-1 ) ; 4 :
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: LD_EXP 18
7375: PPUSH
7376: LD_STRING DAmAttackFin-Tit-1
7378: PPUSH
7379: CALL_OW 88
7383: ST_TO_ADDR
7384: GO 7547
7386: LD_INT 4
7388: DOUBLE
7389: EQUAL
7390: IFTRUE 7394
7392: GO 7426
7394: POP
// if IsOK ( Lipshchin ) then
7395: LD_EXP 22
7399: PPUSH
7400: CALL_OW 302
7404: IFFALSE 7424
// bool := Say ( Lipshchin , DAmAttackFin-Lip-1 ) ; 5 :
7406: LD_ADDR_VAR 0 3
7410: PUSH
7411: LD_EXP 22
7415: PPUSH
7416: LD_STRING DAmAttackFin-Lip-1
7418: PPUSH
7419: CALL_OW 88
7423: ST_TO_ADDR
7424: GO 7547
7426: LD_INT 5
7428: DOUBLE
7429: EQUAL
7430: IFTRUE 7434
7432: GO 7466
7434: POP
// if IsOK ( Karamazov ) then
7435: LD_EXP 17
7439: PPUSH
7440: CALL_OW 302
7444: IFFALSE 7464
// bool := Say ( Karamazov , DAmAttackFin-Kar-1 ) ; 6 :
7446: LD_ADDR_VAR 0 3
7450: PUSH
7451: LD_EXP 17
7455: PPUSH
7456: LD_STRING DAmAttackFin-Kar-1
7458: PPUSH
7459: CALL_OW 88
7463: ST_TO_ADDR
7464: GO 7547
7466: LD_INT 6
7468: DOUBLE
7469: EQUAL
7470: IFTRUE 7474
7472: GO 7506
7474: POP
// if IsOK ( Oblukov ) then
7475: LD_EXP 19
7479: PPUSH
7480: CALL_OW 302
7484: IFFALSE 7504
// bool := Say ( Oblukov , DAmAttackFin-Obl-1 ) ; 7 :
7486: LD_ADDR_VAR 0 3
7490: PUSH
7491: LD_EXP 19
7495: PPUSH
7496: LD_STRING DAmAttackFin-Obl-1
7498: PPUSH
7499: CALL_OW 88
7503: ST_TO_ADDR
7504: GO 7547
7506: LD_INT 7
7508: DOUBLE
7509: EQUAL
7510: IFTRUE 7514
7512: GO 7546
7514: POP
// if IsOK ( Burlak ) then
7515: LD_EXP 1
7519: PPUSH
7520: CALL_OW 302
7524: IFFALSE 7544
// bool := Say ( Burlak , DAmAttackFin-Bur-1 ) ; end ;
7526: LD_ADDR_VAR 0 3
7530: PUSH
7531: LD_EXP 1
7535: PPUSH
7536: LD_STRING DAmAttackFin-Bur-1
7538: PPUSH
7539: CALL_OW 88
7543: ST_TO_ADDR
7544: GO 7547
7546: POP
// until bool ;
7547: LD_VAR 0 3
7551: IFFALSE 7245
// Say ( Popov , DAmAttackFin-Pop-1 ) ;
7553: LD_EXP 2
7557: PPUSH
7558: LD_STRING DAmAttackFin-Pop-1
7560: PPUSH
7561: CALL_OW 88
// DialogueOff ;
7565: CALL_OW 7
// end ; end_of_file
7569: LD_VAR 0 1
7573: RET
// export function merc_help ; var rnd ; begin
7574: LD_INT 0
7576: PPUSH
7577: PPUSH
// rnd := Rand ( 2 2$0 , 3 3$0 ) ;
7578: LD_ADDR_VAR 0 2
7582: PUSH
7583: LD_INT 4200
7585: PPUSH
7586: LD_INT 6300
7588: PPUSH
7589: CALL_OW 12
7593: ST_TO_ADDR
// Wait ( rnd ) ;
7594: LD_VAR 0 2
7598: PPUSH
7599: CALL_OW 67
// if not HeikeKilled then
7603: LD_EXP 38
7607: NOT
7608: IFFALSE 7770
// begin D_MercHelp ;
7610: CALL 5056 0 0
// case Query ( QMerc ) of 1 :
7614: LD_STRING QMerc
7616: PPUSH
7617: CALL_OW 97
7621: PUSH
7622: LD_INT 1
7624: DOUBLE
7625: EQUAL
7626: IFTRUE 7630
7628: GO 7653
7630: POP
// begin D_QrMerc1 ;
7631: CALL 5132 0 0
// create_kurt ;
7635: CALL 3155 0 0
// MercAccepted := true ;
7639: LD_ADDR_EXP 44
7643: PUSH
7644: LD_INT 1
7646: ST_TO_ADDR
// come_to_build_barracks ;
7647: CALL 8243 0 0
// end ; 2 :
7651: GO 7762
7653: LD_INT 2
7655: DOUBLE
7656: EQUAL
7657: IFTRUE 7661
7659: GO 7692
7661: POP
// begin D_QrMerc2 ;
7662: CALL 5172 0 0
// PopovAsked := true ;
7666: LD_ADDR_EXP 46
7670: PUSH
7671: LD_INT 1
7673: ST_TO_ADDR
// create_kurt ;
7674: CALL 3155 0 0
// MercAccepted := true ;
7678: LD_ADDR_EXP 44
7682: PUSH
7683: LD_INT 1
7685: ST_TO_ADDR
// come_to_build_barracks ;
7686: CALL 8243 0 0
// end ; 3 :
7690: GO 7762
7692: LD_INT 3
7694: DOUBLE
7695: EQUAL
7696: IFTRUE 7700
7698: GO 7761
7700: POP
// begin D_QrMerc3 ;
7701: CALL 5224 0 0
// PopovAsked := true ;
7705: LD_ADDR_EXP 46
7709: PUSH
7710: LD_INT 1
7712: ST_TO_ADDR
// Wait ( 0 0$13 ) ;
7713: LD_INT 455
7715: PPUSH
7716: CALL_OW 67
// create_kurt ;
7720: CALL 3155 0 0
// ComMoveToArea ( [ Kurt , Mercenary1 ] , WaitHeikeArea ) ;
7724: LD_EXP 13
7728: PUSH
7729: LD_EXP 14
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: LD_INT 8
7740: PPUSH
7741: CALL_OW 113
// enable ( 6 ) ;
7745: LD_INT 6
7747: ENABLE_MARKED
// enable ( 20 ) ;
7748: LD_INT 20
7750: ENABLE_MARKED
// D_MercAttack ;
7751: CALL 5397 0 0
// merc_attack ;
7755: CALL 7775 0 0
// end ; end ;
7759: GO 7762
7761: POP
// MortarAsked := true ;
7762: LD_ADDR_EXP 69
7766: PUSH
7767: LD_INT 1
7769: ST_TO_ADDR
// end ; end ;
7770: LD_VAR 0 1
7774: RET
// export function merc_attack ; var grp , celkemgrp , rnd , pocet , mercenaries , filter ; begin
7775: LD_INT 0
7777: PPUSH
7778: PPUSH
7779: PPUSH
7780: PPUSH
7781: PPUSH
7782: PPUSH
7783: PPUSH
// repeat SetAttitude ( you , merc , att_enemy , true ) ;
7784: LD_EXP 31
7788: PPUSH
7789: LD_EXP 34
7793: PPUSH
7794: LD_INT 2
7796: PPUSH
7797: LD_INT 1
7799: PPUSH
7800: CALL_OW 80
// mercenaries := [ ] ;
7804: LD_ADDR_VAR 0 6
7808: PUSH
7809: EMPTY
7810: ST_TO_ADDR
// grp := Rand ( 1 , 6 ) ;
7811: LD_ADDR_VAR 0 2
7815: PUSH
7816: LD_INT 1
7818: PPUSH
7819: LD_INT 6
7821: PPUSH
7822: CALL_OW 12
7826: ST_TO_ADDR
// for pocet := 1 to grp do
7827: LD_ADDR_VAR 0 5
7831: PUSH
7832: DOUBLE
7833: LD_INT 1
7835: DEC
7836: ST_TO_ADDR
7837: LD_VAR 0 2
7841: PUSH
7842: FOR_TO
7843: IFFALSE 7966
// begin uc_side = merc ;
7845: LD_ADDR_OWVAR 20
7849: PUSH
7850: LD_EXP 34
7854: ST_TO_ADDR
// uc_nation := nation_arabian ;
7855: LD_ADDR_OWVAR 21
7859: PUSH
7860: LD_INT 2
7862: ST_TO_ADDR
// rnd := Rand ( 1 , 2 ) ;
7863: LD_ADDR_VAR 0 4
7867: PUSH
7868: LD_INT 1
7870: PPUSH
7871: LD_INT 2
7873: PPUSH
7874: CALL_OW 12
7878: ST_TO_ADDR
// case rnd of 1 :
7879: LD_VAR 0 4
7883: PUSH
7884: LD_INT 1
7886: DOUBLE
7887: EQUAL
7888: IFTRUE 7892
7890: GO 7908
7892: POP
// PrepareHuman ( sex_male , class_soldier , 2 ) ; 2 :
7893: LD_INT 1
7895: PPUSH
7896: LD_INT 1
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 380
7906: GO 7933
7908: LD_INT 2
7910: DOUBLE
7911: EQUAL
7912: IFTRUE 7916
7914: GO 7932
7916: POP
// PrepareHuman ( sex_male , class_mortar , 2 ) ; end ;
7917: LD_INT 1
7919: PPUSH
7920: LD_INT 8
7922: PPUSH
7923: LD_INT 2
7925: PPUSH
7926: CALL_OW 380
7930: GO 7933
7932: POP
// hc_name :=  ;
7933: LD_ADDR_OWVAR 26
7937: PUSH
7938: LD_STRING 
7940: ST_TO_ADDR
// mercenaries := mercenaries ^ CreateHuman ;
7941: LD_ADDR_VAR 0 6
7945: PUSH
7946: LD_VAR 0 6
7950: PUSH
7951: CALL_OW 44
7955: ADD
7956: ST_TO_ADDR
// Wait ( 2 ) ;
7957: LD_INT 2
7959: PPUSH
7960: CALL_OW 67
// end ;
7964: GO 7842
7966: POP
7967: POP
// for pocet := 1 to grp do
7968: LD_ADDR_VAR 0 5
7972: PUSH
7973: DOUBLE
7974: LD_INT 1
7976: DEC
7977: ST_TO_ADDR
7978: LD_VAR 0 2
7982: PUSH
7983: FOR_TO
7984: IFFALSE 8061
// begin if HeikeDismissed then
7986: LD_EXP 45
7990: IFFALSE 7996
// exit ;
7992: POP
7993: POP
7994: GO 8238
// PlaceUnitArea ( mercenaries [ pocet ] , AttackArea , false ) ;
7996: LD_VAR 0 6
8000: PUSH
8001: LD_VAR 0 5
8005: ARRAY
8006: PPUSH
8007: LD_INT 5
8009: PPUSH
8010: LD_INT 0
8012: PPUSH
8013: CALL_OW 49
// ComAgressiveMove ( mercenaries [ pocet ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
8017: LD_VAR 0 6
8021: PUSH
8022: LD_VAR 0 5
8026: ARRAY
8027: PPUSH
8028: LD_EXP 1
8032: PPUSH
8033: CALL_OW 250
8037: PPUSH
8038: LD_EXP 1
8042: PPUSH
8043: CALL_OW 251
8047: PPUSH
8048: CALL_OW 114
// Wait ( 1 ) ;
8052: LD_INT 1
8054: PPUSH
8055: CALL_OW 67
// end ;
8059: GO 7983
8061: POP
8062: POP
// celkemgrp := celkemgrp + grp ;
8063: LD_ADDR_VAR 0 3
8067: PUSH
8068: LD_VAR 0 3
8072: PUSH
8073: LD_VAR 0 2
8077: PLUS
8078: ST_TO_ADDR
// Wait ( 1 1$0 ) ;
8079: LD_INT 2100
8081: PPUSH
8082: CALL_OW 67
// until HeikeSend or celkemgrp > pocetmercenaries ;
8086: LD_EXP 65
8090: PUSH
8091: LD_VAR 0 3
8095: PUSH
8096: LD_EXP 78
8100: GREATER
8101: OR
8102: IFFALSE 7784
// repeat Wait ( 0 0$1 ) ;
8104: LD_INT 35
8106: PPUSH
8107: CALL_OW 67
// until HeikeDismissed or celkemgrp > pocetmercenaries ;
8111: LD_EXP 45
8115: PUSH
8116: LD_VAR 0 3
8120: PUSH
8121: LD_EXP 78
8125: GREATER
8126: OR
8127: IFFALSE 8104
// if HeikeDismissed then
8129: LD_EXP 45
8133: IFFALSE 8238
// begin SetAttitude ( you , merc , att_friend , true ) ;
8135: LD_EXP 31
8139: PPUSH
8140: LD_EXP 34
8144: PPUSH
8145: LD_INT 1
8147: PPUSH
8148: LD_INT 1
8150: PPUSH
8151: CALL_OW 80
// filter := FilterAllUnits ( [ f_side , merc ] ) ;
8155: LD_ADDR_VAR 0 7
8159: PUSH
8160: LD_INT 22
8162: PUSH
8163: LD_EXP 34
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PPUSH
8172: CALL_OW 69
8176: ST_TO_ADDR
// ComAgressiveMove ( filter , 29 , 57 ) ;
8177: LD_VAR 0 7
8181: PPUSH
8182: LD_INT 29
8184: PPUSH
8185: LD_INT 57
8187: PPUSH
8188: CALL_OW 114
// enable ( 5 ) ;
8192: LD_INT 5
8194: ENABLE_MARKED
// repeat Wait ( 0 0$3 ) ;
8195: LD_INT 105
8197: PPUSH
8198: CALL_OW 67
// ComAgressiveMove ( filter , 29 , 57 ) ;
8202: LD_VAR 0 7
8206: PPUSH
8207: LD_INT 29
8209: PPUSH
8210: LD_INT 57
8212: PPUSH
8213: CALL_OW 114
// until FilterAllUnits ( [ f_side , merc ] ) = [ ] ;
8217: LD_INT 22
8219: PUSH
8220: LD_EXP 34
8224: PUSH
8225: EMPTY
8226: LIST
8227: LIST
8228: PPUSH
8229: CALL_OW 69
8233: PUSH
8234: EMPTY
8235: EQUAL
8236: IFFALSE 8195
// end ; end ;
8238: LD_VAR 0 1
8242: RET
// function come_to_build_barracks ; var x , y , d , filter ; begin
8243: LD_INT 0
8245: PPUSH
8246: PPUSH
8247: PPUSH
8248: PPUSH
8249: PPUSH
// SetAttitude ( you , merc , att_neutral , true ) ;
8250: LD_EXP 31
8254: PPUSH
8255: LD_EXP 34
8259: PPUSH
8260: LD_INT 0
8262: PPUSH
8263: LD_INT 1
8265: PPUSH
8266: CALL_OW 80
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8270: LD_ADDR_VAR 0 5
8274: PUSH
8275: LD_INT 22
8277: PUSH
8278: LD_EXP 31
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: PUSH
8287: LD_INT 2
8289: PUSH
8290: LD_INT 30
8292: PUSH
8293: LD_INT 0
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: PUSH
8300: LD_INT 30
8302: PUSH
8303: LD_INT 1
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: LIST
8314: PUSH
8315: EMPTY
8316: LIST
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PPUSH
8322: CALL_OW 69
8326: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8327: LD_INT 0
8329: PUSH
8330: LD_VAR 0 5
8334: PLUS
8335: PUSH
8336: LD_INT 0
8338: NONEQUAL
8339: IFFALSE 8400
// begin x := GetX ( filter [ 1 ] ) ;
8341: LD_ADDR_VAR 0 2
8345: PUSH
8346: LD_VAR 0 5
8350: PUSH
8351: LD_INT 1
8353: ARRAY
8354: PPUSH
8355: CALL_OW 250
8359: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_VAR 0 5
8369: PUSH
8370: LD_INT 1
8372: ARRAY
8373: PPUSH
8374: CALL_OW 251
8378: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8379: LD_ADDR_VAR 0 4
8383: PUSH
8384: LD_VAR 0 5
8388: PUSH
8389: LD_INT 1
8391: ARRAY
8392: PPUSH
8393: CALL_OW 254
8397: ST_TO_ADDR
// end else
8398: GO 8438
// begin x := GetX ( Burlak ) ;
8400: LD_ADDR_VAR 0 2
8404: PUSH
8405: LD_EXP 1
8409: PPUSH
8410: CALL_OW 250
8414: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8415: LD_ADDR_VAR 0 3
8419: PUSH
8420: LD_EXP 1
8424: PPUSH
8425: CALL_OW 251
8429: ST_TO_ADDR
// d := 1 ;
8430: LD_ADDR_VAR 0 4
8434: PUSH
8435: LD_INT 1
8437: ST_TO_ADDR
// end ; ComMoveXY ( [ Kurt , Mercenary1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8438: LD_EXP 13
8442: PUSH
8443: LD_EXP 14
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: PPUSH
8452: LD_VAR 0 2
8456: PPUSH
8457: LD_VAR 0 4
8461: PPUSH
8462: LD_INT 5
8464: PPUSH
8465: CALL_OW 272
8469: PPUSH
8470: LD_VAR 0 3
8474: PPUSH
8475: LD_VAR 0 4
8479: PPUSH
8480: LD_INT 5
8482: PPUSH
8483: CALL_OW 273
8487: PPUSH
8488: CALL_OW 111
// enable ( 1 ) ;
8492: LD_INT 1
8494: ENABLE_MARKED
// end ;
8495: LD_VAR 0 1
8499: RET
// export function hand_over ; var i , filter , auto , x , y , d ; begin
8500: LD_INT 0
8502: PPUSH
8503: PPUSH
8504: PPUSH
8505: PPUSH
8506: PPUSH
8507: PPUSH
8508: PPUSH
// SetAttitude ( arab , merc , att_enemy , true ) ;
8509: LD_EXP 33
8513: PPUSH
8514: LD_EXP 34
8518: PPUSH
8519: LD_INT 2
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: CALL_OW 80
// SetAttitude ( arab , you , att_friend , true ) ;
8529: LD_EXP 33
8533: PPUSH
8534: LD_EXP 31
8538: PPUSH
8539: LD_INT 1
8541: PPUSH
8542: LD_INT 1
8544: PPUSH
8545: CALL_OW 80
// auto := [ ] ;
8549: LD_ADDR_VAR 0 4
8553: PUSH
8554: EMPTY
8555: ST_TO_ADDR
// ar_human := [ ] ;
8556: LD_ADDR_EXP 80
8560: PUSH
8561: EMPTY
8562: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
8563: LD_ADDR_VAR 0 3
8567: PUSH
8568: LD_INT 22
8570: PUSH
8571: LD_EXP 31
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PUSH
8580: LD_INT 2
8582: PUSH
8583: LD_INT 30
8585: PUSH
8586: LD_INT 0
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: PUSH
8593: LD_INT 30
8595: PUSH
8596: LD_INT 1
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: PUSH
8608: EMPTY
8609: LIST
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: PPUSH
8615: CALL_OW 69
8619: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
8620: LD_INT 0
8622: PUSH
8623: LD_VAR 0 3
8627: PLUS
8628: PUSH
8629: LD_INT 0
8631: NONEQUAL
8632: IFFALSE 8693
// begin x := GetX ( filter [ 1 ] ) ;
8634: LD_ADDR_VAR 0 5
8638: PUSH
8639: LD_VAR 0 3
8643: PUSH
8644: LD_INT 1
8646: ARRAY
8647: PPUSH
8648: CALL_OW 250
8652: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
8653: LD_ADDR_VAR 0 6
8657: PUSH
8658: LD_VAR 0 3
8662: PUSH
8663: LD_INT 1
8665: ARRAY
8666: PPUSH
8667: CALL_OW 251
8671: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
8672: LD_ADDR_VAR 0 7
8676: PUSH
8677: LD_VAR 0 3
8681: PUSH
8682: LD_INT 1
8684: ARRAY
8685: PPUSH
8686: CALL_OW 254
8690: ST_TO_ADDR
// end else
8691: GO 8731
// begin x := GetX ( Burlak ) ;
8693: LD_ADDR_VAR 0 5
8697: PUSH
8698: LD_EXP 1
8702: PPUSH
8703: CALL_OW 250
8707: ST_TO_ADDR
// y := GetY ( Burlak ) ;
8708: LD_ADDR_VAR 0 6
8712: PUSH
8713: LD_EXP 1
8717: PPUSH
8718: CALL_OW 251
8722: ST_TO_ADDR
// d := 1 ;
8723: LD_ADDR_VAR 0 7
8727: PUSH
8728: LD_INT 1
8730: ST_TO_ADDR
// end ; enable ( 7 ) ;
8731: LD_INT 7
8733: ENABLE_MARKED
// for i := 1 to 3 do
8734: LD_ADDR_VAR 0 2
8738: PUSH
8739: DOUBLE
8740: LD_INT 1
8742: DEC
8743: ST_TO_ADDR
8744: LD_INT 3
8746: PUSH
8747: FOR_TO
8748: IFFALSE 9313
// begin uc_side := arab ;
8750: LD_ADDR_OWVAR 20
8754: PUSH
8755: LD_EXP 33
8759: ST_TO_ADDR
// uc_nation := nation_arabian ;
8760: LD_ADDR_OWVAR 21
8764: PUSH
8765: LD_INT 2
8767: ST_TO_ADDR
// uc_direction := 3 ;
8768: LD_ADDR_OWVAR 24
8772: PUSH
8773: LD_INT 3
8775: ST_TO_ADDR
// if i <= 2 then
8776: LD_VAR 0 2
8780: PUSH
8781: LD_INT 2
8783: LESSEQUAL
8784: IFFALSE 8801
// PrepareHuman ( sex_male , class_soldier , 7 ) else
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 1
8791: PPUSH
8792: LD_INT 7
8794: PPUSH
8795: CALL_OW 380
8799: GO 8814
// PrepareHuman ( sex_male , class_scientistic , 7 ) ;
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 4
8806: PPUSH
8807: LD_INT 7
8809: PPUSH
8810: CALL_OW 380
// Wait ( 1 ) ;
8814: LD_INT 1
8816: PPUSH
8817: CALL_OW 67
// hc_name :=  ;
8821: LD_ADDR_OWVAR 26
8825: PUSH
8826: LD_STRING 
8828: ST_TO_ADDR
// ar_human := ar_human ^ CreateHuman ;
8829: LD_ADDR_EXP 80
8833: PUSH
8834: LD_EXP 80
8838: PUSH
8839: CALL_OW 44
8843: ADD
8844: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
8845: LD_ADDR_OWVAR 37
8849: PUSH
8850: LD_INT 13
8852: ST_TO_ADDR
// vc_engine := engine_combustion ;
8853: LD_ADDR_OWVAR 39
8857: PUSH
8858: LD_INT 1
8860: ST_TO_ADDR
// vc_weapon := ar_cargo_bay ;
8861: LD_ADDR_OWVAR 40
8865: PUSH
8866: LD_INT 32
8868: ST_TO_ADDR
// vc_control := control_manual ;
8869: LD_ADDR_OWVAR 38
8873: PUSH
8874: LD_INT 1
8876: ST_TO_ADDR
// auto := auto ^ CreateVehicle ;
8877: LD_ADDR_VAR 0 4
8881: PUSH
8882: LD_VAR 0 4
8886: PUSH
8887: CALL_OW 45
8891: ADD
8892: ST_TO_ADDR
// PlaceHumanInUnit ( ar_human [ i ] , auto [ i ] ) ;
8893: LD_EXP 80
8897: PUSH
8898: LD_VAR 0 2
8902: ARRAY
8903: PPUSH
8904: LD_VAR 0 4
8908: PUSH
8909: LD_VAR 0 2
8913: ARRAY
8914: PPUSH
8915: CALL_OW 52
// PlaceUnitArea ( auto [ i ] , HandOverEnterArea , false ) ;
8919: LD_VAR 0 4
8923: PUSH
8924: LD_VAR 0 2
8928: ARRAY
8929: PPUSH
8930: LD_INT 6
8932: PPUSH
8933: LD_INT 0
8935: PPUSH
8936: CALL_OW 49
// enable ( 6 ) ;
8940: LD_INT 6
8942: ENABLE_MARKED
// case i of 1 :
8943: LD_VAR 0 2
8947: PUSH
8948: LD_INT 1
8950: DOUBLE
8951: EQUAL
8952: IFTRUE 8956
8954: GO 9047
8956: POP
// begin SetCargo ( auto [ 1 ] , mat_cans , 100 ) ;
8957: LD_VAR 0 4
8961: PUSH
8962: LD_INT 1
8964: ARRAY
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 100
8971: PPUSH
8972: CALL_OW 290
// ComMoveXY ( auto [ 1 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
8976: LD_VAR 0 4
8980: PUSH
8981: LD_INT 1
8983: ARRAY
8984: PPUSH
8985: LD_VAR 0 5
8989: PPUSH
8990: LD_VAR 0 7
8994: PPUSH
8995: LD_INT 5
8997: PPUSH
8998: CALL_OW 272
9002: PPUSH
9003: LD_VAR 0 6
9007: PPUSH
9008: LD_VAR 0 7
9012: PPUSH
9013: LD_INT 5
9015: PPUSH
9016: CALL_OW 273
9020: PPUSH
9021: CALL_OW 111
// Wait ( 1 ) ;
9025: LD_INT 1
9027: PPUSH
9028: CALL_OW 67
// AddComExitVehicle ( auto [ 1 ] ) ;
9032: LD_VAR 0 4
9036: PUSH
9037: LD_INT 1
9039: ARRAY
9040: PPUSH
9041: CALL_OW 181
// end ; 2 :
9045: GO 9304
9047: LD_INT 2
9049: DOUBLE
9050: EQUAL
9051: IFTRUE 9055
9053: GO 9175
9055: POP
// begin SetCargo ( auto [ 2 ] , mat_oil , 100 ) ;
9056: LD_VAR 0 4
9060: PUSH
9061: LD_INT 2
9063: ARRAY
9064: PPUSH
9065: LD_INT 2
9067: PPUSH
9068: LD_INT 100
9070: PPUSH
9071: CALL_OW 290
// ComMoveXY ( auto [ 2 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9075: LD_VAR 0 4
9079: PUSH
9080: LD_INT 2
9082: ARRAY
9083: PPUSH
9084: LD_VAR 0 5
9088: PPUSH
9089: LD_VAR 0 7
9093: PPUSH
9094: LD_INT 5
9096: PPUSH
9097: CALL_OW 272
9101: PPUSH
9102: LD_VAR 0 6
9106: PPUSH
9107: LD_VAR 0 7
9111: PPUSH
9112: LD_INT 5
9114: PPUSH
9115: CALL_OW 273
9119: PPUSH
9120: CALL_OW 111
// Wait ( 1 ) ;
9124: LD_INT 1
9126: PPUSH
9127: CALL_OW 67
// AddComExitVehicle ( auto [ 2 ] ) ;
9131: LD_VAR 0 4
9135: PUSH
9136: LD_INT 2
9138: ARRAY
9139: PPUSH
9140: CALL_OW 181
// Wait ( 1 ) ;
9144: LD_INT 1
9146: PPUSH
9147: CALL_OW 67
// AddComMoveUnit ( auto [ 2 ] , auto [ 1 ] ) ;
9151: LD_VAR 0 4
9155: PUSH
9156: LD_INT 2
9158: ARRAY
9159: PPUSH
9160: LD_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ARRAY
9168: PPUSH
9169: CALL_OW 172
// end ; 3 :
9173: GO 9304
9175: LD_INT 3
9177: DOUBLE
9178: EQUAL
9179: IFTRUE 9183
9181: GO 9303
9183: POP
// begin SetCargo ( auto [ 3 ] , mat_siberit , 100 ) ;
9184: LD_VAR 0 4
9188: PUSH
9189: LD_INT 3
9191: ARRAY
9192: PPUSH
9193: LD_INT 3
9195: PPUSH
9196: LD_INT 100
9198: PPUSH
9199: CALL_OW 290
// ComMoveXY ( auto [ 3 ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
9203: LD_VAR 0 4
9207: PUSH
9208: LD_INT 3
9210: ARRAY
9211: PPUSH
9212: LD_VAR 0 5
9216: PPUSH
9217: LD_VAR 0 7
9221: PPUSH
9222: LD_INT 5
9224: PPUSH
9225: CALL_OW 272
9229: PPUSH
9230: LD_VAR 0 6
9234: PPUSH
9235: LD_VAR 0 7
9239: PPUSH
9240: LD_INT 5
9242: PPUSH
9243: CALL_OW 273
9247: PPUSH
9248: CALL_OW 111
// Wait ( 1 ) ;
9252: LD_INT 1
9254: PPUSH
9255: CALL_OW 67
// AddComExitVehicle ( auto [ 3 ] ) ;
9259: LD_VAR 0 4
9263: PUSH
9264: LD_INT 3
9266: ARRAY
9267: PPUSH
9268: CALL_OW 181
// Wait ( 1 ) ;
9272: LD_INT 1
9274: PPUSH
9275: CALL_OW 67
// AddComMoveUnit ( auto [ 3 ] , auto [ 1 ] ) ;
9279: LD_VAR 0 4
9283: PUSH
9284: LD_INT 3
9286: ARRAY
9287: PPUSH
9288: LD_VAR 0 4
9292: PUSH
9293: LD_INT 1
9295: ARRAY
9296: PPUSH
9297: CALL_OW 172
// end ; end ;
9301: GO 9304
9303: POP
// Wait ( 0 0$3 ) ;
9304: LD_INT 105
9306: PPUSH
9307: CALL_OW 67
// end ;
9311: GO 8747
9313: POP
9314: POP
// MercHandoverArabsSpawned = true ;
9315: LD_ADDR_EXP 43
9319: PUSH
9320: LD_INT 1
9322: ST_TO_ADDR
// enable ( 9 ) ;
9323: LD_INT 9
9325: ENABLE_MARKED
// end ;
9326: LD_VAR 0 1
9330: RET
// every 0 0$1 + 0 0$0.5 do var filter ;
9331: GO 9333
9333: DISABLE
9334: LD_INT 0
9336: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
9337: LD_ADDR_VAR 0 1
9341: PUSH
9342: LD_INT 22
9344: PUSH
9345: LD_EXP 31
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: PUSH
9354: LD_INT 2
9356: PUSH
9357: LD_INT 30
9359: PUSH
9360: LD_INT 0
9362: PUSH
9363: EMPTY
9364: LIST
9365: LIST
9366: PUSH
9367: LD_INT 30
9369: PUSH
9370: LD_INT 1
9372: PUSH
9373: EMPTY
9374: LIST
9375: LIST
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: LIST
9381: PUSH
9382: EMPTY
9383: LIST
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PPUSH
9389: CALL_OW 69
9393: ST_TO_ADDR
// if filter then
9394: LD_VAR 0 1
9398: IFFALSE 9412
// SetBName ( filter , trockij ) ;
9400: LD_VAR 0 1
9404: PPUSH
9405: LD_STRING trockij
9407: PPUSH
9408: CALL_OW 500
// enable ;
9412: ENABLE
// end ;
9413: PPOPN 1
9415: END
// var crates_amount , crates_creating ; every 1 1$30 do
9416: GO 9418
9418: DISABLE
// begin crates_amount := GetResourceArea ( TreesArea , mat_cans ) ;
9419: LD_ADDR_LOC 1
9423: PUSH
9424: LD_INT 1
9426: PPUSH
9427: LD_INT 1
9429: PPUSH
9430: CALL_OW 287
9434: ST_TO_ADDR
// if crates_amount >= 80 then
9435: LD_LOC 1
9439: PUSH
9440: LD_INT 80
9442: GREATEREQUAL
9443: IFFALSE 9453
// crates_creating := false ;
9445: LD_ADDR_LOC 2
9449: PUSH
9450: LD_INT 0
9452: ST_TO_ADDR
// if crates_amount <= 30 then
9453: LD_LOC 1
9457: PUSH
9458: LD_INT 30
9460: LESSEQUAL
9461: IFFALSE 9471
// crates_creating := true ;
9463: LD_ADDR_LOC 2
9467: PUSH
9468: LD_INT 1
9470: ST_TO_ADDR
// if crates_creating then
9471: LD_LOC 2
9475: IFFALSE 9498
// CreateCratesArea ( Rand ( 3 , 5 ) , TreesArea , true ) ;
9477: LD_INT 3
9479: PPUSH
9480: LD_INT 5
9482: PPUSH
9483: CALL_OW 12
9487: PPUSH
9488: LD_INT 1
9490: PPUSH
9491: LD_INT 1
9493: PPUSH
9494: CALL_OW 55
// enable ;
9498: ENABLE
// end ;
9499: END
// var NonBuildBuildings , NonBuildWeapons ; every 0 0$3 do var filter , filter_tur , un , filter_weap , budova , NonBuild ;
9500: GO 9502
9502: DISABLE
9503: LD_INT 0
9505: PPUSH
9506: PPUSH
9507: PPUSH
9508: PPUSH
9509: PPUSH
9510: PPUSH
// begin NonBuild := AvailableBuildings ;
9511: LD_ADDR_VAR 0 6
9515: PUSH
9516: LD_EXP 55
9520: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] , [ f_ready ] ] ) ;
9521: LD_ADDR_VAR 0 1
9525: PUSH
9526: LD_INT 21
9528: PUSH
9529: LD_INT 3
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PUSH
9536: LD_INT 22
9538: PUSH
9539: LD_EXP 31
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 53
9550: PUSH
9551: EMPTY
9552: LIST
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: ST_TO_ADDR
// TurretsDone := false ;
9564: LD_ADDR_EXP 49
9568: PUSH
9569: LD_INT 0
9571: ST_TO_ADDR
// filter_tur := FilterAllUnits ( [ [ f_btype , b_turret ] , [ f_side , you ] , [ f_ready ] ] ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_INT 30
9579: PUSH
9580: LD_INT 33
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: PUSH
9587: LD_INT 22
9589: PUSH
9590: LD_EXP 31
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PUSH
9599: LD_INT 53
9601: PUSH
9602: EMPTY
9603: LIST
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: ST_TO_ADDR
// filter_weap := [ ] ;
9615: LD_ADDR_VAR 0 4
9619: PUSH
9620: EMPTY
9621: ST_TO_ADDR
// for un in filter_tur do
9622: LD_ADDR_VAR 0 3
9626: PUSH
9627: LD_VAR 0 2
9631: PUSH
9632: FOR_IN
9633: IFFALSE 9665
// begin filter_weap := filter_weap union GetBWeapon ( un ) ;
9635: LD_ADDR_VAR 0 4
9639: PUSH
9640: LD_VAR 0 4
9644: PUSH
9645: LD_VAR 0 3
9649: PPUSH
9650: CALL_OW 269
9654: UNION
9655: ST_TO_ADDR
// Wait ( 2 ) ;
9656: LD_INT 2
9658: PPUSH
9659: CALL_OW 67
// end ;
9663: GO 9632
9665: POP
9666: POP
// if ( filter_weap diff 0 ) >= 3 then
9667: LD_VAR 0 4
9671: PUSH
9672: LD_INT 0
9674: DIFF
9675: PUSH
9676: LD_INT 3
9678: GREATEREQUAL
9679: IFFALSE 9689
// TurretsDone := true ;
9681: LD_ADDR_EXP 49
9685: PUSH
9686: LD_INT 1
9688: ST_TO_ADDR
// for budova in filter do
9689: LD_ADDR_VAR 0 5
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: FOR_IN
9700: IFFALSE 9732
// begin NonBuild := NonBuild diff GetBType ( budova ) ;
9702: LD_ADDR_VAR 0 6
9706: PUSH
9707: LD_VAR 0 6
9711: PUSH
9712: LD_VAR 0 5
9716: PPUSH
9717: CALL_OW 266
9721: DIFF
9722: ST_TO_ADDR
// Wait ( 1 ) ;
9723: LD_INT 1
9725: PPUSH
9726: CALL_OW 67
// end ;
9730: GO 9699
9732: POP
9733: POP
// if NonBuild = [ ] and TurretsDone and not BuildingsDone then
9734: LD_VAR 0 6
9738: PUSH
9739: EMPTY
9740: EQUAL
9741: PUSH
9742: LD_EXP 49
9746: AND
9747: PUSH
9748: LD_EXP 48
9752: NOT
9753: AND
9754: IFFALSE 9773
// begin ChangeMissionObjectives ( MBuildingsDone ) ;
9756: LD_STRING MBuildingsDone
9758: PPUSH
9759: CALL_OW 337
// BuildingsDone := true ;
9763: LD_ADDR_EXP 48
9767: PUSH
9768: LD_INT 1
9770: ST_TO_ADDR
// end else
9771: GO 9810
// if ( NonBuild <> [ ] or not TurretsDone ) and BuildingsDone then
9773: LD_VAR 0 6
9777: PUSH
9778: EMPTY
9779: NONEQUAL
9780: PUSH
9781: LD_EXP 49
9785: NOT
9786: OR
9787: PUSH
9788: LD_EXP 48
9792: AND
9793: IFFALSE 9810
// begin ChangeMissionObjectives ( MBuildings ) ;
9795: LD_STRING MBuildings
9797: PPUSH
9798: CALL_OW 337
// BuildingsDone := false ;
9802: LD_ADDR_EXP 48
9806: PUSH
9807: LD_INT 0
9809: ST_TO_ADDR
// end ; if not ( ( filter_weap diff 0 ) > 3 ) then
9810: LD_VAR 0 4
9814: PUSH
9815: LD_INT 0
9817: DIFF
9818: PUSH
9819: LD_INT 3
9821: GREATER
9822: NOT
9823: IFFALSE 9849
// NonBuild := NonBuild + 3 - ( filter_weap diff 0 ) ;
9825: LD_ADDR_VAR 0 6
9829: PUSH
9830: LD_VAR 0 6
9834: PUSH
9835: LD_INT 3
9837: PLUS
9838: PUSH
9839: LD_VAR 0 4
9843: PUSH
9844: LD_INT 0
9846: DIFF
9847: MINUS
9848: ST_TO_ADDR
// NonBuildBuildings := NonBuild ;
9849: LD_ADDR_LOC 3
9853: PUSH
9854: LD_VAR 0 6
9858: ST_TO_ADDR
// if HeikeCratesTime then
9859: LD_LOC 5
9863: IFFALSE 9926
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
9865: LD_ADDR_OWVAR 47
9869: PUSH
9870: LD_STRING #Ru08-1
9872: PUSH
9873: LD_INT 0
9875: PUSH
9876: LD_LOC 3
9880: PLUS
9881: PUSH
9882: LD_STRING #Ru08-2
9884: PUSH
9885: LD_INT 0
9887: PUSH
9888: LD_LOC 4
9892: PLUS
9893: PUSH
9894: LD_STRING #Ru08-3
9896: PUSH
9897: LD_INT 0
9899: PUSH
9900: LD_EXP 56
9904: PLUS
9905: PUSH
9906: LD_STRING #Ru08-4
9908: PUSH
9909: LD_LOC 5
9913: PUSH
9914: EMPTY
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
9924: GO 9975
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
9926: LD_ADDR_OWVAR 47
9930: PUSH
9931: LD_STRING #Ru08-1
9933: PUSH
9934: LD_INT 0
9936: PUSH
9937: LD_LOC 3
9941: PLUS
9942: PUSH
9943: LD_STRING #Ru08-2
9945: PUSH
9946: LD_INT 0
9948: PUSH
9949: LD_LOC 4
9953: PLUS
9954: PUSH
9955: LD_STRING #Ru08-3
9957: PUSH
9958: LD_INT 0
9960: PUSH
9961: LD_EXP 56
9965: PLUS
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: ST_TO_ADDR
// if NonBuild + 0 = 11 and not GalleryAsked then
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 0
9982: PLUS
9983: PUSH
9984: LD_INT 11
9986: EQUAL
9987: PUSH
9988: LD_EXP 66
9992: NOT
9993: AND
9994: IFFALSE 9999
// enable ( 201 ) ;
9996: LD_INT 201
9998: ENABLE_MARKED
// if NonBuild + 0 = 7 and not HuntingAsked then
9999: LD_VAR 0 6
10003: PUSH
10004: LD_INT 0
10006: PLUS
10007: PUSH
10008: LD_INT 7
10010: EQUAL
10011: PUSH
10012: LD_EXP 67
10016: NOT
10017: AND
10018: IFFALSE 10023
// enable ( 101 ) ;
10020: LD_INT 101
10022: ENABLE_MARKED
// if NonBuild + 0 = 3 and not FreetimeAsked then
10023: LD_VAR 0 6
10027: PUSH
10028: LD_INT 0
10030: PLUS
10031: PUSH
10032: LD_INT 3
10034: EQUAL
10035: PUSH
10036: LD_EXP 68
10040: NOT
10041: AND
10042: IFFALSE 10047
// enable ( 301 ) ;
10044: LD_INT 301
10046: ENABLE_MARKED
// enable ;
10047: ENABLE
// end ;
10048: PPOPN 6
10050: END
// every 0 0$3 + 0 0$0.5 do var filter , veh , NonBuild ;
10051: GO 10053
10053: DISABLE
10054: LD_INT 0
10056: PPUSH
10057: PPUSH
10058: PPUSH
// begin NonBuild := AvailableWeapons ;
10059: LD_ADDR_VAR 0 3
10063: PUSH
10064: LD_EXP 54
10068: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10069: LD_ADDR_VAR 0 1
10073: PUSH
10074: LD_INT 21
10076: PUSH
10077: LD_INT 2
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 22
10086: PUSH
10087: LD_EXP 31
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: PPUSH
10100: CALL_OW 69
10104: ST_TO_ADDR
// for veh in filter do
10105: LD_ADDR_VAR 0 2
10109: PUSH
10110: LD_VAR 0 1
10114: PUSH
10115: FOR_IN
10116: IFFALSE 10148
// begin NonBuild := NonBuild diff GetWeapon ( veh ) ;
10118: LD_ADDR_VAR 0 3
10122: PUSH
10123: LD_VAR 0 3
10127: PUSH
10128: LD_VAR 0 2
10132: PPUSH
10133: CALL_OW 264
10137: DIFF
10138: ST_TO_ADDR
// Wait ( 1 ) ;
10139: LD_INT 1
10141: PPUSH
10142: CALL_OW 67
// end ;
10146: GO 10115
10148: POP
10149: POP
// if NonBuild = [ ] and not WeaponsDone then
10150: LD_VAR 0 3
10154: PUSH
10155: EMPTY
10156: EQUAL
10157: PUSH
10158: LD_EXP 50
10162: NOT
10163: AND
10164: IFFALSE 10183
// begin ChangeMissionObjectives ( MWeaponsDone ) ;
10166: LD_STRING MWeaponsDone
10168: PPUSH
10169: CALL_OW 337
// WeaponsDone := true ;
10173: LD_ADDR_EXP 50
10177: PUSH
10178: LD_INT 1
10180: ST_TO_ADDR
// end else
10181: GO 10213
// if NonBuild <> [ ] and WeaponsDone then
10183: LD_VAR 0 3
10187: PUSH
10188: EMPTY
10189: NONEQUAL
10190: PUSH
10191: LD_EXP 50
10195: AND
10196: IFFALSE 10213
// begin ChangeMissionObjectives ( Mweapons ) ;
10198: LD_STRING Mweapons
10200: PPUSH
10201: CALL_OW 337
// WeaponsDone := false ;
10205: LD_ADDR_EXP 50
10209: PUSH
10210: LD_INT 0
10212: ST_TO_ADDR
// end ; NonBuildWeapons := NonBuild ;
10213: LD_ADDR_LOC 4
10217: PUSH
10218: LD_VAR 0 3
10222: ST_TO_ADDR
// if HeikeCratesTime then
10223: LD_LOC 5
10227: IFFALSE 10290
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
10229: LD_ADDR_OWVAR 47
10233: PUSH
10234: LD_STRING #Ru08-1
10236: PUSH
10237: LD_INT 0
10239: PUSH
10240: LD_LOC 3
10244: PLUS
10245: PUSH
10246: LD_STRING #Ru08-2
10248: PUSH
10249: LD_INT 0
10251: PUSH
10252: LD_LOC 4
10256: PLUS
10257: PUSH
10258: LD_STRING #Ru08-3
10260: PUSH
10261: LD_INT 0
10263: PUSH
10264: LD_EXP 56
10268: PLUS
10269: PUSH
10270: LD_STRING #Ru08-4
10272: PUSH
10273: LD_LOC 5
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: ST_TO_ADDR
10288: GO 10339
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
10290: LD_ADDR_OWVAR 47
10294: PUSH
10295: LD_STRING #Ru08-1
10297: PUSH
10298: LD_INT 0
10300: PUSH
10301: LD_LOC 3
10305: PLUS
10306: PUSH
10307: LD_STRING #Ru08-2
10309: PUSH
10310: LD_INT 0
10312: PUSH
10313: LD_LOC 4
10317: PLUS
10318: PUSH
10319: LD_STRING #Ru08-3
10321: PUSH
10322: LD_INT 0
10324: PUSH
10325: LD_EXP 56
10329: PLUS
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: ST_TO_ADDR
// enable ;
10339: ENABLE
// end ;
10340: PPOPN 3
10342: END
// every 0 0$2 marked 1 do var filter ;
10343: GO 10345
10345: DISABLE
10346: LD_INT 0
10348: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
10349: LD_ADDR_VAR 0 1
10353: PUSH
10354: LD_INT 22
10356: PUSH
10357: LD_EXP 31
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PUSH
10366: LD_INT 2
10368: PUSH
10369: LD_INT 30
10371: PUSH
10372: LD_INT 0
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: PUSH
10379: LD_INT 30
10381: PUSH
10382: LD_INT 1
10384: PUSH
10385: EMPTY
10386: LIST
10387: LIST
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: LIST
10393: PUSH
10394: EMPTY
10395: LIST
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PPUSH
10401: CALL_OW 69
10405: ST_TO_ADDR
// if ( 0 + filter ) = 0 then
10406: LD_INT 0
10408: PUSH
10409: LD_VAR 0 1
10413: PLUS
10414: PUSH
10415: LD_INT 0
10417: EQUAL
10418: IFFALSE 10436
// filter := filter union Burlak ;
10420: LD_ADDR_VAR 0 1
10424: PUSH
10425: LD_VAR 0 1
10429: PUSH
10430: LD_EXP 1
10434: UNION
10435: ST_TO_ADDR
// if ( GetDistUnits ( Kurt , filter [ 1 ] ) < 8 ) or ( GetDistUnits ( Mercenary1 , filter [ 1 ] ) < 8 ) then
10436: LD_EXP 13
10440: PPUSH
10441: LD_VAR 0 1
10445: PUSH
10446: LD_INT 1
10448: ARRAY
10449: PPUSH
10450: CALL_OW 296
10454: PUSH
10455: LD_INT 8
10457: LESS
10458: PUSH
10459: LD_EXP 14
10463: PPUSH
10464: LD_VAR 0 1
10468: PUSH
10469: LD_INT 1
10471: ARRAY
10472: PPUSH
10473: CALL_OW 296
10477: PUSH
10478: LD_INT 8
10480: LESS
10481: OR
10482: IFFALSE 10513
// begin SetSide ( [ Kurt , Mercenary1 ] , you ) ;
10484: LD_EXP 13
10488: PUSH
10489: LD_EXP 14
10493: PUSH
10494: EMPTY
10495: LIST
10496: LIST
10497: PPUSH
10498: LD_EXP 31
10502: PPUSH
10503: CALL_OW 235
// enable ( 10 ) ;
10507: LD_INT 10
10509: ENABLE_MARKED
// enable ( 601 ) ;
10510: LD_INT 601
10512: ENABLE_MARKED
// end ; if GetSide ( Kurt ) = you and GetSide ( Mercenary1 ) = you then
10513: LD_EXP 13
10517: PPUSH
10518: CALL_OW 255
10522: PUSH
10523: LD_EXP 31
10527: EQUAL
10528: PUSH
10529: LD_EXP 14
10533: PPUSH
10534: CALL_OW 255
10538: PUSH
10539: LD_EXP 31
10543: EQUAL
10544: AND
10545: IFFALSE 10550
// disable else
10547: DISABLE
10548: GO 10551
// enable ;
10550: ENABLE
// end ;
10551: PPOPN 1
10553: END
// every 0 0$1 + 0 0$0.2 marked 2 do var list ;
10554: GO 10556
10556: DISABLE
10557: LD_INT 0
10559: PPUSH
// begin list = [ false , false ] ;
10560: LD_ADDR_VAR 0 1
10564: PUSH
10565: LD_INT 0
10567: PUSH
10568: LD_INT 0
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: ST_TO_ADDR
// if IsLive ( Kurt ) and UnitShoot ( Kurt ) > 0 then
10575: LD_EXP 13
10579: PPUSH
10580: CALL_OW 300
10584: PUSH
10585: LD_EXP 13
10589: PPUSH
10590: CALL_OW 504
10594: PUSH
10595: LD_INT 0
10597: GREATER
10598: AND
10599: IFFALSE 10644
// if GetSide ( UnitShoot ( Kurt ) ) = you then
10601: LD_EXP 13
10605: PPUSH
10606: CALL_OW 504
10610: PPUSH
10611: CALL_OW 255
10615: PUSH
10616: LD_EXP 31
10620: EQUAL
10621: IFFALSE 10644
// list = Replace ( list , 1 , true ) ;
10623: LD_ADDR_VAR 0 1
10627: PUSH
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 1
10635: PPUSH
10636: LD_INT 1
10638: PPUSH
10639: CALL_OW 1
10643: ST_TO_ADDR
// if IsLive ( Mercenary1 ) and UnitShoot ( Mercenary1 ) > 0 then
10644: LD_EXP 14
10648: PPUSH
10649: CALL_OW 300
10653: PUSH
10654: LD_EXP 14
10658: PPUSH
10659: CALL_OW 504
10663: PUSH
10664: LD_INT 0
10666: GREATER
10667: AND
10668: IFFALSE 10713
// if GetSide ( UnitShoot ( Mercenary1 ) ) = you then
10670: LD_EXP 14
10674: PPUSH
10675: CALL_OW 504
10679: PPUSH
10680: CALL_OW 255
10684: PUSH
10685: LD_EXP 31
10689: EQUAL
10690: IFFALSE 10713
// list = Replace ( list , 2 , true ) ;
10692: LD_ADDR_VAR 0 1
10696: PUSH
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_INT 2
10704: PPUSH
10705: LD_INT 1
10707: PPUSH
10708: CALL_OW 1
10712: ST_TO_ADDR
// if true in list then
10713: LD_INT 1
10715: PUSH
10716: LD_VAR 0 1
10720: IN
10721: IFFALSE 10812
// begin disable ( 601 ) ;
10723: LD_INT 601
10725: DISABLE_MARKED
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
10726: LD_EXP 13
10730: PUSH
10731: LD_EXP 14
10735: PUSH
10736: EMPTY
10737: LIST
10738: LIST
10739: PPUSH
10740: LD_EXP 34
10744: PPUSH
10745: CALL_OW 235
// SetAttitude ( you , merc , att_enemy , true ) ;
10749: LD_EXP 31
10753: PPUSH
10754: LD_EXP 34
10758: PPUSH
10759: LD_INT 2
10761: PPUSH
10762: LD_INT 1
10764: PPUSH
10765: CALL_OW 80
// D_MercAmbush ;
10769: CALL 5344 0 0
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , 27 , 52 ) ;
10773: LD_EXP 13
10777: PUSH
10778: LD_EXP 14
10782: PUSH
10783: EMPTY
10784: LIST
10785: LIST
10786: PPUSH
10787: LD_INT 27
10789: PPUSH
10790: LD_INT 52
10792: PPUSH
10793: CALL_OW 114
// enable ( 23 ) ;
10797: LD_INT 23
10799: ENABLE_MARKED
// merc_attack ;
10800: CALL 7775 0 0
// disabled2 := true ;
10804: LD_ADDR_EXP 86
10808: PUSH
10809: LD_INT 1
10811: ST_TO_ADDR
// end ; if not disabled2 then
10812: LD_EXP 86
10816: NOT
10817: IFFALSE 10820
// enable ;
10819: ENABLE
// end ;
10820: PPOPN 1
10822: END
// every 0 0$10 marked 3 do
10823: GO 10825
10825: DISABLE
// begin countdown := countdown - 10 * 35 ;
10826: LD_ADDR_EXP 77
10830: PUSH
10831: LD_EXP 77
10835: PUSH
10836: LD_INT 10
10838: PUSH
10839: LD_INT 35
10841: MUL
10842: MINUS
10843: ST_TO_ADDR
// if countdown < 0 and not HeikeDismissed then
10844: LD_EXP 77
10848: PUSH
10849: LD_INT 0
10851: LESS
10852: PUSH
10853: LD_EXP 45
10857: NOT
10858: AND
10859: IFFALSE 10876
// begin disabled3 := true ;
10861: LD_ADDR_EXP 87
10865: PUSH
10866: LD_INT 1
10868: ST_TO_ADDR
// enable ( 24 ) ;
10869: LD_INT 24
10871: ENABLE_MARKED
// merc_attack ;
10872: CALL 7775 0 0
// end ; if not disabled3 then
10876: LD_EXP 87
10880: NOT
10881: IFFALSE 10884
// enable ;
10883: ENABLE
// end ;
10884: END
// every 0 0$1 marked 24 do
10885: GO 10887
10887: DISABLE
// begin Wait ( 0 0$20 ) ;
10888: LD_INT 700
10890: PPUSH
10891: CALL_OW 67
// D_MercAttack ;
10895: CALL 5397 0 0
// end ;
10899: END
// every 0 0$1 + 0 0$0.4 marked 4 do
10900: GO 10902
10902: DISABLE
// begin if IsInArea ( Heike , WaitHeikeArea ) and not HeikeDismissed then
10903: LD_EXP 11
10907: PPUSH
10908: LD_INT 8
10910: PPUSH
10911: CALL_OW 308
10915: PUSH
10916: LD_EXP 45
10920: NOT
10921: AND
10922: IFFALSE 11015
// begin SetSide ( Heike , merc ) ;
10924: LD_EXP 11
10928: PPUSH
10929: LD_EXP 34
10933: PPUSH
10934: CALL_OW 235
// ComMoveToArea ( [ Kurt , Mercenary1 , Heike ] , MercExitArea ) ;
10938: LD_EXP 13
10942: PUSH
10943: LD_EXP 14
10947: PUSH
10948: LD_EXP 11
10952: PUSH
10953: EMPTY
10954: LIST
10955: LIST
10956: LIST
10957: PPUSH
10958: LD_INT 7
10960: PPUSH
10961: CALL_OW 113
// SetAreaMapShow ( WaitHeikeArea , 0 ) ;
10965: LD_INT 8
10967: PPUSH
10968: LD_INT 0
10970: PPUSH
10971: CALL_OW 424
// HeikeDismissed := true ;
10975: LD_ADDR_EXP 45
10979: PUSH
10980: LD_INT 1
10982: ST_TO_ADDR
// if not PopovAsked then
10983: LD_EXP 46
10987: NOT
10988: IFFALSE 10994
// D_MercPopov ;
10990: CALL 5292 0 0
// enable ( 5 ) ;
10994: LD_INT 5
10996: ENABLE_MARKED
// disabled6 := true ;
10997: LD_ADDR_EXP 90
11001: PUSH
11002: LD_INT 1
11004: ST_TO_ADDR
// disabled3 := true ;
11005: LD_ADDR_EXP 87
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// end else
11013: GO 11016
// enable ;
11015: ENABLE
// end ;
11016: END
// every 0 0$1 + 0 0$0.5 marked 5 do var filter , un ;
11017: GO 11019
11019: DISABLE
11020: LD_INT 0
11022: PPUSH
11023: PPUSH
// begin filter := FilterUnitsInArea ( MercExitArea , [ f_or , [ f_side , merc ] , [ f_side , arab ] ] ) ;
11024: LD_ADDR_VAR 0 1
11028: PUSH
11029: LD_INT 7
11031: PPUSH
11032: LD_INT 2
11034: PUSH
11035: LD_INT 22
11037: PUSH
11038: LD_EXP 34
11042: PUSH
11043: EMPTY
11044: LIST
11045: LIST
11046: PUSH
11047: LD_INT 22
11049: PUSH
11050: LD_EXP 33
11054: PUSH
11055: EMPTY
11056: LIST
11057: LIST
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: LIST
11063: PPUSH
11064: CALL_OW 70
11068: ST_TO_ADDR
// for un in filter do
11069: LD_ADDR_VAR 0 2
11073: PUSH
11074: LD_VAR 0 1
11078: PUSH
11079: FOR_IN
11080: IFFALSE 11100
// begin RemoveUnit ( un ) ;
11082: LD_VAR 0 2
11086: PPUSH
11087: CALL_OW 64
// Wait ( 1 ) ;
11091: LD_INT 1
11093: PPUSH
11094: CALL_OW 67
// end ;
11098: GO 11079
11100: POP
11101: POP
// if not disabled5 then
11102: LD_EXP 89
11106: NOT
11107: IFFALSE 11110
// enable ;
11109: ENABLE
// end ;
11110: PPOPN 2
11112: END
// every 0 0$1 + 0 0$0.6 marked 6 do
11113: GO 11115
11115: DISABLE
// begin if IsInArea ( Kurt , WaitHeikeArea ) then
11116: LD_EXP 13
11120: PPUSH
11121: LD_INT 8
11123: PPUSH
11124: CALL_OW 308
11128: IFFALSE 11135
// enable ( 4 ) else
11130: LD_INT 4
11132: ENABLE_MARKED
11133: GO 11136
// enable ;
11135: ENABLE
// end ;
11136: END
// every 0 0$1 + 0 0$0.7 marked 7 do var un , i , done ;
11137: GO 11139
11139: DISABLE
11140: LD_INT 0
11142: PPUSH
11143: PPUSH
11144: PPUSH
// begin for un in player_units do
11145: LD_ADDR_VAR 0 1
11149: PUSH
11150: LD_EXP 26
11154: PUSH
11155: FOR_IN
11156: IFFALSE 11387
// begin if GetSide ( Attacks ( un ) ) = arab and not disabled7 then
11158: LD_VAR 0 1
11162: PPUSH
11163: CALL_OW 320
11167: PPUSH
11168: CALL_OW 255
11172: PUSH
11173: LD_EXP 33
11177: EQUAL
11178: PUSH
11179: LD_EXP 91
11183: NOT
11184: AND
11185: IFFALSE 11385
// begin GenscherBetrayed := true ;
11187: LD_ADDR_EXP 36
11191: PUSH
11192: LD_INT 1
11194: ST_TO_ADDR
// disabled7 := true ;
11195: LD_ADDR_EXP 91
11199: PUSH
11200: LD_INT 1
11202: ST_TO_ADDR
// D_HandOverSpoiled ;
11203: CALL 5680 0 0
// SetAttitude ( you , arab , att_enemy , true ) ;
11207: LD_EXP 31
11211: PPUSH
11212: LD_EXP 33
11216: PPUSH
11217: LD_INT 2
11219: PPUSH
11220: LD_INT 1
11222: PPUSH
11223: CALL_OW 80
// repeat wait ( 0 0$0.5 ) ;
11227: LD_INT 18
11229: PPUSH
11230: CALL_OW 67
// done = true ;
11234: LD_ADDR_VAR 0 3
11238: PUSH
11239: LD_INT 1
11241: ST_TO_ADDR
// for i in ar_human do
11242: LD_ADDR_VAR 0 2
11246: PUSH
11247: LD_EXP 80
11251: PUSH
11252: FOR_IN
11253: IFFALSE 11371
// begin if not IsPlaced ( i ) and GetLives ( i ) > 0 then
11255: LD_VAR 0 2
11259: PPUSH
11260: CALL_OW 305
11264: NOT
11265: PUSH
11266: LD_VAR 0 2
11270: PPUSH
11271: CALL_OW 256
11275: PUSH
11276: LD_INT 0
11278: GREATER
11279: AND
11280: IFFALSE 11292
// begin done = false ;
11282: LD_ADDR_VAR 0 3
11286: PUSH
11287: LD_INT 0
11289: ST_TO_ADDR
// continue ;
11290: GO 11252
// end ; if not IsOk ( i ) then
11292: LD_VAR 0 2
11296: PPUSH
11297: CALL_OW 302
11301: NOT
11302: IFFALSE 11306
// continue ;
11304: GO 11252
// if IsInUnit ( i ) > 0 then
11306: LD_VAR 0 2
11310: PPUSH
11311: CALL_OW 310
11315: PUSH
11316: LD_INT 0
11318: GREATER
11319: IFFALSE 11340
// begin ComExitVehicle ( i ) ;
11321: LD_VAR 0 2
11325: PPUSH
11326: CALL_OW 121
// done = false ;
11330: LD_ADDR_VAR 0 3
11334: PUSH
11335: LD_INT 0
11337: ST_TO_ADDR
// end else
11338: GO 11369
// ComAgressiveMove ( i , GetX ( Burlak ) , GetY ( Burlak ) ) ;
11340: LD_VAR 0 2
11344: PPUSH
11345: LD_EXP 1
11349: PPUSH
11350: CALL_OW 250
11354: PPUSH
11355: LD_EXP 1
11359: PPUSH
11360: CALL_OW 251
11364: PPUSH
11365: CALL_OW 114
// end ;
11369: GO 11252
11371: POP
11372: POP
// until MercHandoverArabsSpawned and done ;
11373: LD_EXP 43
11377: PUSH
11378: LD_VAR 0 3
11382: AND
11383: IFFALSE 11227
// end ; end ;
11385: GO 11155
11387: POP
11388: POP
// if not disabled7 and not MercHandoverDone then
11389: LD_EXP 91
11393: NOT
11394: PUSH
11395: LD_EXP 42
11399: NOT
11400: AND
11401: IFFALSE 11404
// enable ;
11403: ENABLE
// end ;
11404: PPOPN 3
11406: END
// every 0 0$0.5 + 0 0$0.3 marked 8 do
11407: GO 11409
11409: DISABLE
// begin if disabled7 then
11410: LD_EXP 91
11414: IFFALSE 11419
// begin disable ;
11416: DISABLE
// exit ;
11417: GO 12009
// end ; if not MercHandedOver then
11419: LD_EXP 40
11423: NOT
11424: IFFALSE 11428
// exit ;
11426: GO 12009
// if not GetSide ( Kurt ) = arab then
11428: LD_EXP 13
11432: PPUSH
11433: CALL_OW 255
11437: PUSH
11438: LD_EXP 33
11442: EQUAL
11443: NOT
11444: IFFALSE 11464
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
11446: LD_EXP 80
11450: PUSH
11451: LD_INT 1
11453: ARRAY
11454: PPUSH
11455: LD_EXP 13
11459: PPUSH
11460: CALL_OW 115
// if not GetSide ( Mercenary1 ) = arab then
11464: LD_EXP 14
11468: PPUSH
11469: CALL_OW 255
11473: PUSH
11474: LD_EXP 33
11478: EQUAL
11479: NOT
11480: IFFALSE 11500
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11482: LD_EXP 80
11486: PUSH
11487: LD_INT 2
11489: ARRAY
11490: PPUSH
11491: LD_EXP 14
11495: PPUSH
11496: CALL_OW 115
// if not IsLive ( Kurt ) or not IsLive ( Mercenary1 ) then
11500: LD_EXP 13
11504: PPUSH
11505: CALL_OW 300
11509: NOT
11510: PUSH
11511: LD_EXP 14
11515: PPUSH
11516: CALL_OW 300
11520: NOT
11521: OR
11522: IFFALSE 11593
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] ] , [ [ 29 , 57 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11524: LD_INT 1
11526: PPUSH
11527: LD_EXP 80
11531: PUSH
11532: LD_INT 1
11534: ARRAY
11535: PUSH
11536: LD_EXP 80
11540: PUSH
11541: LD_INT 2
11543: ARRAY
11544: PUSH
11545: LD_EXP 80
11549: PUSH
11550: LD_INT 3
11552: ARRAY
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: LIST
11558: PPUSH
11559: LD_INT 29
11561: PUSH
11562: LD_INT 57
11564: PUSH
11565: EMPTY
11566: LIST
11567: LIST
11568: PUSH
11569: EMPTY
11570: LIST
11571: PPUSH
11572: LD_INT 1
11574: PUSH
11575: LD_INT 3
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 5
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PPUSH
11589: CALL_OW 398
// if Attacks ( ar_human [ 1 ] ) = Kurt then
11593: LD_EXP 80
11597: PUSH
11598: LD_INT 1
11600: ARRAY
11601: PPUSH
11602: CALL_OW 320
11606: PUSH
11607: LD_EXP 13
11611: EQUAL
11612: IFFALSE 11726
// begin ComStop ( [ Kurt , Mercenary1 ] ) ;
11614: LD_EXP 13
11618: PUSH
11619: LD_EXP 14
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PPUSH
11628: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11632: LD_EXP 13
11636: PUSH
11637: LD_EXP 14
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PPUSH
11646: LD_EXP 33
11650: PPUSH
11651: CALL_OW 235
// ComStop ( ar_human [ 1 ] ) ;
11655: LD_EXP 80
11659: PUSH
11660: LD_INT 1
11662: ARRAY
11663: PPUSH
11664: CALL_OW 141
// Wait ( 2 ) ;
11668: LD_INT 2
11670: PPUSH
11671: CALL_OW 67
// AddComMoveUnit ( ar_human [ 1 ] , Kurt ) ;
11675: LD_EXP 80
11679: PUSH
11680: LD_INT 1
11682: ARRAY
11683: PPUSH
11684: LD_EXP 13
11688: PPUSH
11689: CALL_OW 172
// if GetLives ( Kurt ) < 300 then
11693: LD_EXP 13
11697: PPUSH
11698: CALL_OW 256
11702: PUSH
11703: LD_INT 300
11705: LESS
11706: IFFALSE 11726
// AddComHeal ( ar_human [ 3 ] , Kurt ) ;
11708: LD_EXP 80
11712: PUSH
11713: LD_INT 3
11715: ARRAY
11716: PPUSH
11717: LD_EXP 13
11721: PPUSH
11722: CALL_OW 188
// end ; if Attacks ( ar_human [ 2 ] ) = Mercenary1 then
11726: LD_EXP 80
11730: PUSH
11731: LD_INT 2
11733: ARRAY
11734: PPUSH
11735: CALL_OW 320
11739: PUSH
11740: LD_EXP 14
11744: EQUAL
11745: IFFALSE 11859
// begin ComStop ( ar_human [ 2 ] ) ;
11747: LD_EXP 80
11751: PUSH
11752: LD_INT 2
11754: ARRAY
11755: PPUSH
11756: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , arab ) ;
11760: LD_EXP 13
11764: PUSH
11765: LD_EXP 14
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: PPUSH
11774: LD_EXP 33
11778: PPUSH
11779: CALL_OW 235
// ComStop ( [ Kurt , Mercenary1 ] ) ;
11783: LD_EXP 13
11787: PUSH
11788: LD_EXP 14
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: PPUSH
11797: CALL_OW 141
// Wait ( 2 ) ;
11801: LD_INT 2
11803: PPUSH
11804: CALL_OW 67
// AddComMoveUnit ( ar_human [ 2 ] , Mercenary1 ) ;
11808: LD_EXP 80
11812: PUSH
11813: LD_INT 2
11815: ARRAY
11816: PPUSH
11817: LD_EXP 14
11821: PPUSH
11822: CALL_OW 172
// if GetLives ( Mercenary1 ) < 300 then
11826: LD_EXP 14
11830: PPUSH
11831: CALL_OW 256
11835: PUSH
11836: LD_INT 300
11838: LESS
11839: IFFALSE 11859
// AddComHeal ( ar_human [ 3 ] , Mercenary1 ) ;
11841: LD_EXP 80
11845: PUSH
11846: LD_INT 3
11848: ARRAY
11849: PPUSH
11850: LD_EXP 14
11854: PPUSH
11855: CALL_OW 188
// end ; if GetSide ( Kurt ) = arab and GetSide ( Mercenary1 ) = arab then
11859: LD_EXP 13
11863: PPUSH
11864: CALL_OW 255
11868: PUSH
11869: LD_EXP 33
11873: EQUAL
11874: PUSH
11875: LD_EXP 14
11879: PPUSH
11880: CALL_OW 255
11884: PUSH
11885: LD_EXP 33
11889: EQUAL
11890: AND
11891: IFFALSE 12001
// begin disabled8 := true ;
11893: LD_ADDR_EXP 92
11897: PUSH
11898: LD_INT 1
11900: ST_TO_ADDR
// disable ( 2 ) ;
11901: LD_INT 2
11903: DISABLE_MARKED
// disable ( 6 ) ;
11904: LD_INT 6
11906: DISABLE_MARKED
// disable ( 12 ) ;
11907: LD_INT 12
11909: DISABLE_MARKED
// Wait ( 0 0$5 ) ;
11910: LD_INT 175
11912: PPUSH
11913: CALL_OW 67
// McMove ( 1 , [ ar_human [ 1 ] , ar_human [ 2 ] , ar_human [ 3 ] , Kurt , Mercenary1 ] , [ [ 115 , 32 ] ] , [ [ mc_move_wait , 3 ] , mc_move_dontcapture ] ) ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 80
11924: PUSH
11925: LD_INT 1
11927: ARRAY
11928: PUSH
11929: LD_EXP 80
11933: PUSH
11934: LD_INT 2
11936: ARRAY
11937: PUSH
11938: LD_EXP 80
11942: PUSH
11943: LD_INT 3
11945: ARRAY
11946: PUSH
11947: LD_EXP 13
11951: PUSH
11952: LD_EXP 14
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: LIST
11961: LIST
11962: LIST
11963: PPUSH
11964: LD_INT 115
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: EMPTY
11975: LIST
11976: PPUSH
11977: LD_INT 1
11979: PUSH
11980: LD_INT 3
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 5
11989: PUSH
11990: EMPTY
11991: LIST
11992: LIST
11993: PPUSH
11994: CALL_OW 398
// enable ( 11 ) ;
11998: LD_INT 11
12000: ENABLE_MARKED
// end ; if not disabled8 then
12001: LD_EXP 92
12005: NOT
12006: IFFALSE 12009
// enable ;
12008: ENABLE
// end ;
12009: END
// every 0 0$1 + 0 0$0.1 marked 8 do
12010: GO 12012
12012: DISABLE
// begin repeat wait ( 0 0$1 ) ;
12013: LD_INT 35
12015: PPUSH
12016: CALL_OW 67
// if GenscherBetrayed then
12020: LD_EXP 36
12024: IFFALSE 12028
// exit ;
12026: GO 12067
// if UnitFilter ( ar_human , [ f_placed ] ) = 0 then
12028: LD_EXP 80
12032: PPUSH
12033: LD_INT 52
12035: PUSH
12036: EMPTY
12037: LIST
12038: PPUSH
12039: CALL_OW 72
12043: PUSH
12044: LD_INT 0
12046: EQUAL
12047: IFFALSE 12063
// begin SA_OnLegionHandoverToUPF ;
12049: CALL 19218 0 0
// MercHandoverDone = true ;
12053: LD_ADDR_EXP 42
12057: PUSH
12058: LD_INT 1
12060: ST_TO_ADDR
// exit ;
12061: GO 12067
// end ; until false ;
12063: LD_INT 0
12065: IFFALSE 12013
// end ;
12067: END
// every 0 0$1 + 0 0$0.9 marked 9 do var un1 , un2 ;
12068: GO 12070
12070: DISABLE
12071: LD_INT 0
12073: PPUSH
12074: PPUSH
// begin if disabled7 then
12075: LD_EXP 91
12079: IFFALSE 12084
// begin disable ;
12081: DISABLE
// exit ;
12082: GO 12310
// end ; if IsInUnit ( ar_human [ 1 ] ) = 0 and IsInUnit ( ar_human [ 2 ] ) = 0 then
12084: LD_EXP 80
12088: PUSH
12089: LD_INT 1
12091: ARRAY
12092: PPUSH
12093: CALL_OW 310
12097: PUSH
12098: LD_INT 0
12100: EQUAL
12101: PUSH
12102: LD_EXP 80
12106: PUSH
12107: LD_INT 2
12109: ARRAY
12110: PPUSH
12111: CALL_OW 310
12115: PUSH
12116: LD_INT 0
12118: EQUAL
12119: AND
12120: IFFALSE 12302
// begin disable ( 601 ) ;
12122: LD_INT 601
12124: DISABLE_MARKED
// D_HandOverCome ;
12125: CALL 5640 0 0
// MercHandedOver := true ;
12129: LD_ADDR_EXP 40
12133: PUSH
12134: LD_INT 1
12136: ST_TO_ADDR
// disable ( 20 ) ;
12137: LD_INT 20
12139: DISABLE_MARKED
// enable ( 23 ) ;
12140: LD_INT 23
12142: ENABLE_MARKED
// enable ( 8 ) ;
12143: LD_INT 8
12145: ENABLE_MARKED
// ComStop ( [ Kurt , Mercenary1 ] ) ;
12146: LD_EXP 13
12150: PUSH
12151: LD_EXP 14
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PPUSH
12160: CALL_OW 141
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
12164: LD_EXP 13
12168: PUSH
12169: LD_EXP 14
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PPUSH
12178: LD_EXP 34
12182: PPUSH
12183: CALL_OW 235
// SetAttitude ( you , merc , att_neutral , true ) ;
12187: LD_EXP 31
12191: PPUSH
12192: LD_EXP 34
12196: PPUSH
12197: LD_INT 0
12199: PPUSH
12200: LD_INT 1
12202: PPUSH
12203: CALL_OW 80
// SetAttitude ( merc , arab , att_friend , true ) ;
12207: LD_EXP 34
12211: PPUSH
12212: LD_EXP 33
12216: PPUSH
12217: LD_INT 1
12219: PPUSH
12220: LD_INT 1
12222: PPUSH
12223: CALL_OW 80
// Wait ( 2 ) ;
12227: LD_INT 2
12229: PPUSH
12230: CALL_OW 67
// enable ( 5 ) ;
12234: LD_INT 5
12236: ENABLE_MARKED
// ComAttackUnit ( ar_human [ 1 ] , Kurt ) ;
12237: LD_EXP 80
12241: PUSH
12242: LD_INT 1
12244: ARRAY
12245: PPUSH
12246: LD_EXP 13
12250: PPUSH
12251: CALL_OW 115
// ComAttackUnit ( ar_human [ 2 ] , Mercenary1 ) ;
12255: LD_EXP 80
12259: PUSH
12260: LD_INT 2
12262: ARRAY
12263: PPUSH
12264: LD_EXP 14
12268: PPUSH
12269: CALL_OW 115
// ComMoveToArea ( [ Kurt , Mercenary1 ] , MercExitArea ) ;
12273: LD_EXP 13
12277: PUSH
12278: LD_EXP 14
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PPUSH
12287: LD_INT 7
12289: PPUSH
12290: CALL_OW 113
// disabled9 := true ;
12294: LD_ADDR_EXP 93
12298: PUSH
12299: LD_INT 1
12301: ST_TO_ADDR
// end ; if not disabled9 then
12302: LD_EXP 93
12306: NOT
12307: IFFALSE 12310
// enable ;
12309: ENABLE
// end ;
12310: PPOPN 2
12312: END
// every 0 0$1 marked 10 do var rnd ;
12313: GO 12315
12315: DISABLE
12316: LD_INT 0
12318: PPUSH
// begin rnd := Rand ( 0 0$30 , 0 0$45 ) ;
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 1050
12326: PPUSH
12327: LD_INT 1575
12329: PPUSH
12330: CALL_OW 12
12334: ST_TO_ADDR
// Wait ( rnd ) ;
12335: LD_VAR 0 1
12339: PPUSH
12340: CALL_OW 67
// if GetAttitude ( you , merc ) = att_neutral and GetSide ( Kurt ) = you then
12344: LD_EXP 31
12348: PPUSH
12349: LD_EXP 34
12353: PPUSH
12354: CALL_OW 81
12358: PUSH
12359: LD_INT 0
12361: EQUAL
12362: PUSH
12363: LD_EXP 13
12367: PPUSH
12368: CALL_OW 255
12372: PUSH
12373: LD_EXP 31
12377: EQUAL
12378: AND
12379: IFFALSE 12385
// D_ArabianRequest ;
12381: CALL 5437 0 0
// end ;
12385: PPOPN 1
12387: END
// every 0 0$1 + 0 0$0.2 marked 11 do var filter , un , disablefilter ;
12388: GO 12390
12390: DISABLE
12391: LD_INT 0
12393: PPUSH
12394: PPUSH
12395: PPUSH
// begin filter := FilterUnitsInArea ( HandOverEnterArea , [ [ f_side , arab ] , [ f_type , unit_human ] ] ) ;
12396: LD_ADDR_VAR 0 1
12400: PUSH
12401: LD_INT 6
12403: PPUSH
12404: LD_INT 22
12406: PUSH
12407: LD_EXP 33
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: PUSH
12416: LD_INT 21
12418: PUSH
12419: LD_INT 1
12421: PUSH
12422: EMPTY
12423: LIST
12424: LIST
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: PPUSH
12430: CALL_OW 70
12434: ST_TO_ADDR
// for un in filter do
12435: LD_ADDR_VAR 0 2
12439: PUSH
12440: LD_VAR 0 1
12444: PUSH
12445: FOR_IN
12446: IFFALSE 12466
// begin RemoveUnit ( un ) ;
12448: LD_VAR 0 2
12452: PPUSH
12453: CALL_OW 64
// Wait ( 1 ) ;
12457: LD_INT 1
12459: PPUSH
12460: CALL_OW 67
// end ;
12464: GO 12445
12466: POP
12467: POP
// disablefilter := FilterAllUnits ( [ f_side , arab ] ) ;
12468: LD_ADDR_VAR 0 3
12472: PUSH
12473: LD_INT 22
12475: PUSH
12476: LD_EXP 33
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: PPUSH
12485: CALL_OW 69
12489: ST_TO_ADDR
// if 0 + disablefilter > 0 then
12490: LD_INT 0
12492: PUSH
12493: LD_VAR 0 3
12497: PLUS
12498: PUSH
12499: LD_INT 0
12501: GREATER
12502: IFFALSE 12507
// enable else
12504: ENABLE
12505: GO 12511
// begin disable ;
12507: DISABLE
// disable ( 7 ) ;
12508: LD_INT 7
12510: DISABLE_MARKED
// end ; end ;
12511: PPOPN 3
12513: END
// var HeikeCratesTime , LegionDone ; every 0 0$1 marked 13 do var un , filter , amount ;
12514: GO 12516
12516: DISABLE
12517: LD_INT 0
12519: PPUSH
12520: PPUSH
12521: PPUSH
// begin if ( not HeikeKilled ) and HeikeDismissed then
12522: LD_EXP 38
12526: NOT
12527: PUSH
12528: LD_EXP 45
12532: AND
12533: IFFALSE 13313
// begin disabled5 := true ;
12535: LD_ADDR_EXP 89
12539: PUSH
12540: LD_INT 1
12542: ST_TO_ADDR
// Wait ( 0 0$5 ) ;
12543: LD_INT 175
12545: PPUSH
12546: CALL_OW 67
// D_LegionFormed ;
12550: CALL 5708 0 0
// case Query ( QLegion ) of 1 :
12554: LD_STRING QLegion
12556: PPUSH
12557: CALL_OW 97
12561: PUSH
12562: LD_INT 1
12564: DOUBLE
12565: EQUAL
12566: IFTRUE 12570
12568: GO 13297
12570: POP
// begin amount := 0 ;
12571: LD_ADDR_VAR 0 3
12575: PUSH
12576: LD_INT 0
12578: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12579: LD_ADDR_VAR 0 2
12583: PUSH
12584: LD_INT 22
12586: PUSH
12587: LD_EXP 31
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: LD_INT 2
12598: PUSH
12599: LD_INT 30
12601: PUSH
12602: LD_INT 0
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: LD_INT 30
12611: PUSH
12612: LD_INT 1
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: LIST
12623: PUSH
12624: EMPTY
12625: LIST
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PPUSH
12631: CALL_OW 69
12635: ST_TO_ADDR
// if filter <> [ ] then
12636: LD_VAR 0 2
12640: PUSH
12641: EMPTY
12642: NONEQUAL
12643: IFFALSE 12691
// for un in filter do
12645: LD_ADDR_VAR 0 1
12649: PUSH
12650: LD_VAR 0 2
12654: PUSH
12655: FOR_IN
12656: IFFALSE 12689
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12658: LD_ADDR_VAR 0 3
12662: PUSH
12663: LD_VAR 0 3
12667: PUSH
12668: LD_VAR 0 1
12672: PPUSH
12673: CALL_OW 274
12677: PPUSH
12678: LD_INT 1
12680: PPUSH
12681: CALL_OW 275
12685: PLUS
12686: ST_TO_ADDR
12687: GO 12655
12689: POP
12690: POP
// if amount < 50 then
12691: LD_VAR 0 3
12695: PUSH
12696: LD_INT 50
12698: LESS
12699: IFFALSE 13123
// begin HeikeCratesTime := 0 0$60 ;
12701: LD_ADDR_LOC 5
12705: PUSH
12706: LD_INT 2100
12708: ST_TO_ADDR
// repeat display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] ;
12709: LD_ADDR_OWVAR 47
12713: PUSH
12714: LD_STRING #Ru08-1
12716: PUSH
12717: LD_INT 0
12719: PUSH
12720: LD_LOC 3
12724: PLUS
12725: PUSH
12726: LD_STRING #Ru08-2
12728: PUSH
12729: LD_INT 0
12731: PUSH
12732: LD_LOC 4
12736: PLUS
12737: PUSH
12738: LD_STRING #Ru08-3
12740: PUSH
12741: LD_INT 0
12743: PUSH
12744: LD_EXP 56
12748: PLUS
12749: PUSH
12750: LD_STRING #Ru08-4
12752: PUSH
12753: LD_LOC 5
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: ST_TO_ADDR
// amount := 0 ;
12768: LD_ADDR_VAR 0 3
12772: PUSH
12773: LD_INT 0
12775: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
12776: LD_ADDR_VAR 0 2
12780: PUSH
12781: LD_INT 22
12783: PUSH
12784: LD_EXP 31
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PUSH
12793: LD_INT 2
12795: PUSH
12796: LD_INT 30
12798: PUSH
12799: LD_INT 0
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 30
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: PPUSH
12828: CALL_OW 69
12832: ST_TO_ADDR
// if filter <> [ ] then
12833: LD_VAR 0 2
12837: PUSH
12838: EMPTY
12839: NONEQUAL
12840: IFFALSE 12888
// for un in filter do
12842: LD_ADDR_VAR 0 1
12846: PUSH
12847: LD_VAR 0 2
12851: PUSH
12852: FOR_IN
12853: IFFALSE 12886
// amount := amount + GetResourceType ( GetBase ( un ) , mat_cans ) ;
12855: LD_ADDR_VAR 0 3
12859: PUSH
12860: LD_VAR 0 3
12864: PUSH
12865: LD_VAR 0 1
12869: PPUSH
12870: CALL_OW 274
12874: PPUSH
12875: LD_INT 1
12877: PPUSH
12878: CALL_OW 275
12882: PLUS
12883: ST_TO_ADDR
12884: GO 12852
12886: POP
12887: POP
// Wait ( 0 0$1 ) ;
12888: LD_INT 35
12890: PPUSH
12891: CALL_OW 67
// HeikeCratesTime := HeikeCratesTime - 0 0$1 ;
12895: LD_ADDR_LOC 5
12899: PUSH
12900: LD_LOC 5
12904: PUSH
12905: LD_INT 35
12907: MINUS
12908: ST_TO_ADDR
// until amount >= 50 or HeikeCratesTime <= 0 ;
12909: LD_VAR 0 3
12913: PUSH
12914: LD_INT 50
12916: GREATEREQUAL
12917: PUSH
12918: LD_LOC 5
12922: PUSH
12923: LD_INT 0
12925: LESSEQUAL
12926: OR
12927: IFFALSE 12709
// if amount >= 50 and HeikeCratesTime > 0 then
12929: LD_VAR 0 3
12933: PUSH
12934: LD_INT 50
12936: GREATEREQUAL
12937: PUSH
12938: LD_LOC 5
12942: PUSH
12943: LD_INT 0
12945: GREATER
12946: AND
12947: IFFALSE 13121
// begin D_QrLegion1 ;
12949: CALL 5784 0 0
// MercPaid := true ;
12953: LD_ADDR_EXP 39
12957: PUSH
12958: LD_INT 1
12960: ST_TO_ADDR
// amount := 50 ;
12961: LD_ADDR_VAR 0 3
12965: PUSH
12966: LD_INT 50
12968: ST_TO_ADDR
// for un in filter do
12969: LD_ADDR_VAR 0 1
12973: PUSH
12974: LD_VAR 0 2
12978: PUSH
12979: FOR_IN
12980: IFFALSE 13119
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
12982: LD_VAR 0 1
12986: PPUSH
12987: CALL_OW 274
12991: PPUSH
12992: LD_INT 1
12994: PPUSH
12995: CALL_OW 275
12999: PUSH
13000: LD_VAR 0 3
13004: LESS
13005: PUSH
13006: LD_VAR 0 3
13010: PUSH
13011: LD_INT 0
13013: NONEQUAL
13014: AND
13015: IFFALSE 13068
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13017: LD_ADDR_VAR 0 3
13021: PUSH
13022: LD_VAR 0 3
13026: PUSH
13027: LD_VAR 0 1
13031: PPUSH
13032: CALL_OW 274
13036: PPUSH
13037: LD_INT 1
13039: PPUSH
13040: CALL_OW 275
13044: MINUS
13045: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13046: LD_VAR 0 1
13050: PPUSH
13051: CALL_OW 274
13055: PPUSH
13056: LD_INT 1
13058: PPUSH
13059: LD_INT 0
13061: PPUSH
13062: CALL_OW 277
// end else
13066: GO 13117
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13068: LD_VAR 0 1
13072: PPUSH
13073: CALL_OW 274
13077: PPUSH
13078: LD_INT 1
13080: PPUSH
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL_OW 274
13090: PPUSH
13091: LD_INT 1
13093: PPUSH
13094: CALL_OW 275
13098: PUSH
13099: LD_VAR 0 3
13103: MINUS
13104: PPUSH
13105: CALL_OW 277
// amount := 0 ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_INT 0
13116: ST_TO_ADDR
// end ;
13117: GO 12979
13119: POP
13120: POP
// end ; end else
13121: GO 13295
// begin D_QrLegion1 ;
13123: CALL 5784 0 0
// MercPaid := true ;
13127: LD_ADDR_EXP 39
13131: PUSH
13132: LD_INT 1
13134: ST_TO_ADDR
// amount := 50 ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 50
13142: ST_TO_ADDR
// for un in filter do
13143: LD_ADDR_VAR 0 1
13147: PUSH
13148: LD_VAR 0 2
13152: PUSH
13153: FOR_IN
13154: IFFALSE 13293
// if GetResourceType ( GetBase ( un ) , mat_cans ) < amount and amount <> 0 then
13156: LD_VAR 0 1
13160: PPUSH
13161: CALL_OW 274
13165: PPUSH
13166: LD_INT 1
13168: PPUSH
13169: CALL_OW 275
13173: PUSH
13174: LD_VAR 0 3
13178: LESS
13179: PUSH
13180: LD_VAR 0 3
13184: PUSH
13185: LD_INT 0
13187: NONEQUAL
13188: AND
13189: IFFALSE 13242
// begin amount := amount - GetResourceType ( GetBase ( un ) , mat_cans ) ;
13191: LD_ADDR_VAR 0 3
13195: PUSH
13196: LD_VAR 0 3
13200: PUSH
13201: LD_VAR 0 1
13205: PPUSH
13206: CALL_OW 274
13210: PPUSH
13211: LD_INT 1
13213: PPUSH
13214: CALL_OW 275
13218: MINUS
13219: ST_TO_ADDR
// SetResourceType ( GetBase ( un ) , mat_cans , 0 ) ;
13220: LD_VAR 0 1
13224: PPUSH
13225: CALL_OW 274
13229: PPUSH
13230: LD_INT 1
13232: PPUSH
13233: LD_INT 0
13235: PPUSH
13236: CALL_OW 277
// end else
13240: GO 13291
// begin SetResourceType ( GetBase ( un ) , mat_cans , GetResourceType ( GetBase ( un ) , mat_cans ) - amount ) ;
13242: LD_VAR 0 1
13246: PPUSH
13247: CALL_OW 274
13251: PPUSH
13252: LD_INT 1
13254: PPUSH
13255: LD_VAR 0 1
13259: PPUSH
13260: CALL_OW 274
13264: PPUSH
13265: LD_INT 1
13267: PPUSH
13268: CALL_OW 275
13272: PUSH
13273: LD_VAR 0 3
13277: MINUS
13278: PPUSH
13279: CALL_OW 277
// amount := 0 ;
13283: LD_ADDR_VAR 0 3
13287: PUSH
13288: LD_INT 0
13290: ST_TO_ADDR
// end ;
13291: GO 13153
13293: POP
13294: POP
// end ; end ; 2 :
13295: GO 13313
13297: LD_INT 2
13299: DOUBLE
13300: EQUAL
13301: IFTRUE 13305
13303: GO 13312
13305: POP
// D_QrLegion2 ; end ;
13306: CALL 5812 0 0
13310: GO 13313
13312: POP
// end ; LegionDone := true ;
13313: LD_ADDR_LOC 6
13317: PUSH
13318: LD_INT 1
13320: ST_TO_ADDR
// end ;
13321: PPOPN 3
13323: END
// every 0 0$1 marked 20 do
13324: GO 13326
13326: DISABLE
// begin if IsSelected ( Heike ) = true then
13327: LD_EXP 11
13331: PPUSH
13332: CALL_OW 306
13336: PUSH
13337: LD_INT 1
13339: EQUAL
13340: IFFALSE 13400
// begin if WasSelected = false then
13342: LD_EXP 83
13346: PUSH
13347: LD_INT 0
13349: EQUAL
13350: IFFALSE 13398
// begin if Query ( QSendHeike ) = 1 then
13352: LD_STRING QSendHeike
13354: PPUSH
13355: CALL_OW 97
13359: PUSH
13360: LD_INT 1
13362: EQUAL
13363: IFFALSE 13390
// begin HeikeSend := true ;
13365: LD_ADDR_EXP 65
13369: PUSH
13370: LD_INT 1
13372: ST_TO_ADDR
// ComMoveXY ( Heike , 39 , 47 ) ;
13373: LD_EXP 11
13377: PPUSH
13378: LD_INT 39
13380: PPUSH
13381: LD_INT 47
13383: PPUSH
13384: CALL_OW 111
// exit ;
13388: GO 13409
// end ; WasSelected := true ;
13390: LD_ADDR_EXP 83
13394: PUSH
13395: LD_INT 1
13397: ST_TO_ADDR
// end ; end else
13398: GO 13408
// WasSelected := false ;
13400: LD_ADDR_EXP 83
13404: PUSH
13405: LD_INT 0
13407: ST_TO_ADDR
// enable ;
13408: ENABLE
// end ;
13409: END
// every 0 0$10 + 0 0$0.4 marked 21 do
13410: GO 13412
13412: DISABLE
// begin if TechnoDone and BuildingsDone and not AmAttackStarted then
13413: LD_EXP 51
13417: PUSH
13418: LD_EXP 48
13422: AND
13423: PUSH
13424: LD_EXP 71
13428: NOT
13429: AND
13430: IFFALSE 13483
// begin enable ( 13 ) ;
13432: LD_INT 13
13434: ENABLE_MARKED
// repeat Wait ( 0 0$1 ) ;
13435: LD_INT 35
13437: PPUSH
13438: CALL_OW 67
// until LegionDone ;
13442: LD_LOC 6
13446: IFFALSE 13435
// if ( not HeikeKilled ) and HeikeDismissed then
13448: LD_EXP 38
13452: NOT
13453: PUSH
13454: LD_EXP 45
13458: AND
13459: IFFALSE 13470
// Wait ( 0 0$35 ) else
13461: LD_INT 1225
13463: PPUSH
13464: CALL_OW 67
13468: GO 13477
// Wait ( 0 0$5 ) ;
13470: LD_INT 175
13472: PPUSH
13473: CALL_OW 67
// enable ( 999 ) ;
13477: LD_INT 999
13479: ENABLE_MARKED
// enable ( 501 ) ;
13480: LD_INT 501
13482: ENABLE_MARKED
// end ; if not AmAttackStarted then
13483: LD_EXP 71
13487: NOT
13488: IFFALSE 13491
// enable ;
13490: ENABLE
// end ;
13491: END
// var ApesRespawned ; every 0 0$1 + 0 0$0.8 marked 22 do var Ape ;
13492: GO 13494
13494: DISABLE
13495: LD_INT 0
13497: PPUSH
// begin Wait ( 350 * ApesRespawned ) ;
13498: LD_INT 350
13500: PUSH
13501: LD_LOC 7
13505: MUL
13506: PPUSH
13507: CALL_OW 67
// if FilterAllUnits ( [ f_class , class_apeman ] ) < 1 then
13511: LD_INT 25
13513: PUSH
13514: LD_INT 12
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: PPUSH
13521: CALL_OW 69
13525: PUSH
13526: LD_INT 1
13528: LESS
13529: IFFALSE 13639
// begin ApesRespawned := ApesRespawned + 1 ;
13531: LD_ADDR_LOC 7
13535: PUSH
13536: LD_LOC 7
13540: PUSH
13541: LD_INT 1
13543: PLUS
13544: ST_TO_ADDR
// uc_side := 0 ;
13545: LD_ADDR_OWVAR 20
13549: PUSH
13550: LD_INT 0
13552: ST_TO_ADDR
// uc_nation := nation_nature ;
13553: LD_ADDR_OWVAR 21
13557: PUSH
13558: LD_INT 0
13560: ST_TO_ADDR
// PrepareHuman ( sex_male , class_apeman , 2 ) ;
13561: LD_INT 1
13563: PPUSH
13564: LD_INT 12
13566: PPUSH
13567: LD_INT 2
13569: PPUSH
13570: CALL_OW 380
// hc_name :=  ;
13574: LD_ADDR_OWVAR 26
13578: PUSH
13579: LD_STRING 
13581: ST_TO_ADDR
// Ape := CreateHuman ;
13582: LD_ADDR_VAR 0 1
13586: PUSH
13587: CALL_OW 44
13591: ST_TO_ADDR
// SetDir ( Ape , Rand ( 0 , 5 ) ) ;
13592: LD_VAR 0 1
13596: PPUSH
13597: LD_INT 0
13599: PPUSH
13600: LD_INT 5
13602: PPUSH
13603: CALL_OW 12
13607: PPUSH
13608: CALL_OW 233
// PlaceUnitArea ( Ape , AnimalsArea , false ) ;
13612: LD_VAR 0 1
13616: PPUSH
13617: LD_INT 22
13619: PPUSH
13620: LD_INT 0
13622: PPUSH
13623: CALL_OW 49
// ComMoveToArea ( Ape , ApeArea ) ;
13627: LD_VAR 0 1
13631: PPUSH
13632: LD_INT 23
13634: PPUSH
13635: CALL_OW 113
// end ; enable ;
13639: ENABLE
// end ;
13640: PPOPN 1
13642: END
// every 0 0$15 marked 23 do var filter , un ;
13643: GO 13645
13645: DISABLE
13646: LD_INT 0
13648: PPUSH
13649: PPUSH
// begin ComAttackUnit ( Heike , Burlak ) ;
13650: LD_EXP 11
13654: PPUSH
13655: LD_EXP 1
13659: PPUSH
13660: CALL_OW 115
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13664: LD_ADDR_VAR 0 1
13668: PUSH
13669: LD_INT 22
13671: PUSH
13672: LD_EXP 31
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 21
13683: PUSH
13684: LD_INT 1
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 69
13699: ST_TO_ADDR
// for un in filter do
13700: LD_ADDR_VAR 0 2
13704: PUSH
13705: LD_VAR 0 1
13709: PUSH
13710: FOR_IN
13711: IFFALSE 13736
// begin AddComAttackUnit ( Heike , un ) ;
13713: LD_EXP 11
13717: PPUSH
13718: LD_VAR 0 2
13722: PPUSH
13723: CALL_OW 175
// Wait ( 10 ) ;
13727: LD_INT 10
13729: PPUSH
13730: CALL_OW 67
// end ;
13734: GO 13710
13736: POP
13737: POP
// enable ;
13738: ENABLE
// end ;
13739: PPOPN 2
13741: END
// on BuildingComplete ( building ) do var rnd , distance , un1 , un2 , pole , budova1 , budova2 , i , filter ;
13742: LD_INT 0
13744: PPUSH
13745: PPUSH
13746: PPUSH
13747: PPUSH
13748: PPUSH
13749: PPUSH
13750: PPUSH
13751: PPUSH
13752: PPUSH
// begin if ( not depot_build ) and ( GetBType ( building ) = b_depot ) and HeikeCaptured then
13753: LD_EXP 28
13757: NOT
13758: PUSH
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 266
13768: PUSH
13769: LD_INT 0
13771: EQUAL
13772: AND
13773: PUSH
13774: LD_EXP 37
13778: AND
13779: IFFALSE 13859
// begin depot_build = true ;
13781: LD_ADDR_EXP 28
13785: PUSH
13786: LD_INT 1
13788: ST_TO_ADDR
// depotX := GetX ( building ) ;
13789: LD_ADDR_EXP 29
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 250
13803: ST_TO_ADDR
// depotY := GetY ( building ) ;
13804: LD_ADDR_EXP 30
13808: PUSH
13809: LD_VAR 0 1
13813: PPUSH
13814: CALL_OW 251
13818: ST_TO_ADDR
// Wait ( 0 0$10 ) ;
13819: LD_INT 350
13821: PPUSH
13822: CALL_OW 67
// D_Heike ;
13826: CALL 5005 0 0
// rnd := Rand ( 1 1$15 , 2 2$0 ) ;
13830: LD_ADDR_VAR 0 2
13834: PUSH
13835: LD_INT 2625
13837: PPUSH
13838: LD_INT 4200
13840: PPUSH
13841: CALL_OW 12
13845: ST_TO_ADDR
// Wait ( rnd ) ;
13846: LD_VAR 0 2
13850: PPUSH
13851: CALL_OW 67
// merc_help ;
13855: CALL 7574 0 0
// end ; end ;
13859: PPOPN 10
13861: END
// on UpgradeComplete ( building ) do begin if ( GetBType ( building ) = b_barracks ) and ( GetNation ( building ) = nation_arabian ) then
13862: LD_VAR 0 1
13866: PPUSH
13867: CALL_OW 266
13871: PUSH
13872: LD_INT 5
13874: EQUAL
13875: PUSH
13876: LD_VAR 0 1
13880: PPUSH
13881: CALL_OW 248
13885: PUSH
13886: LD_INT 2
13888: EQUAL
13889: AND
13890: IFFALSE 13994
// begin MortarDone := true ;
13892: LD_ADDR_EXP 52
13896: PUSH
13897: LD_INT 1
13899: ST_TO_ADDR
// if not MercHandedOver or not MercWillBeHandedOver then
13900: LD_EXP 40
13904: NOT
13905: PUSH
13906: LD_EXP 41
13910: NOT
13911: OR
13912: IFFALSE 13994
// begin Wait ( 0 0$1 ) ;
13914: LD_INT 35
13916: PPUSH
13917: CALL_OW 67
// enable ( 3 ) ;
13921: LD_INT 3
13923: ENABLE_MARKED
// D_MercCompleted ;
13924: CALL 5272 0 0
// enable ( 20 ) ;
13928: LD_INT 20
13930: ENABLE_MARKED
// SetAreaMapShow ( WaitHeikeArea , 1 ) ;
13931: LD_INT 8
13933: PPUSH
13934: LD_INT 1
13936: PPUSH
13937: CALL_OW 424
// SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
13941: LD_EXP 13
13945: PUSH
13946: LD_EXP 14
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: PPUSH
13955: LD_EXP 34
13959: PPUSH
13960: CALL_OW 235
// disable ( 601 ) ;
13964: LD_INT 601
13966: DISABLE_MARKED
// ComMoveXY ( [ Kurt , Mercenary1 ] , 39 , 48 ) ;
13967: LD_EXP 13
13971: PUSH
13972: LD_EXP 14
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: PPUSH
13981: LD_INT 39
13983: PPUSH
13984: LD_INT 48
13986: PPUSH
13987: CALL_OW 111
// enable ( 6 ) ;
13991: LD_INT 6
13993: ENABLE_MARKED
// end ; end ; end ;
13994: PPOPN 1
13996: END
// on UnitGoesToRed ( un ) do begin if LimitTeleportResearched and GetType ( un ) = unit_vehicle then
13997: LD_EXP 62
14001: PUSH
14002: LD_VAR 0 1
14006: PPUSH
14007: CALL_OW 247
14011: PUSH
14012: LD_INT 2
14014: EQUAL
14015: AND
14016: IFFALSE 14033
// begin LimitTeleportTested := true ;
14018: LD_ADDR_EXP 63
14022: PUSH
14023: LD_INT 1
14025: ST_TO_ADDR
// ChangeMissionObjectives ( MTeleDone ) ;
14026: LD_STRING MTeleDone
14028: PPUSH
14029: CALL_OW 337
// end ; if GetSide ( un ) = usa then
14033: LD_VAR 0 1
14037: PPUSH
14038: CALL_OW 255
14042: PUSH
14043: LD_EXP 35
14047: EQUAL
14048: IFFALSE 14066
// amattack := amattack diff un ;
14050: LD_ADDR_EXP 27
14054: PUSH
14055: LD_EXP 27
14059: PUSH
14060: LD_VAR 0 1
14064: DIFF
14065: ST_TO_ADDR
// if un = Heike then
14066: LD_VAR 0 1
14070: PUSH
14071: LD_EXP 11
14075: EQUAL
14076: IFFALSE 14233
// begin if MortarAsked and not MercHandedOver then
14078: LD_EXP 69
14082: PUSH
14083: LD_EXP 40
14087: NOT
14088: AND
14089: IFFALSE 14189
// begin D_MercDeceived ;
14091: CALL 5417 0 0
// if not MortarDone then
14095: LD_EXP 52
14099: NOT
14100: IFFALSE 14163
// begin SetSide ( [ Kurt , Mercenary1 ] , merc ) ;
14102: LD_EXP 13
14106: PUSH
14107: LD_EXP 14
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: PPUSH
14116: LD_EXP 34
14120: PPUSH
14121: CALL_OW 235
// ComAgressiveMove ( [ Kurt , Mercenary1 ] , GetX ( Burlak ) , GetY ( Burlak ) ) ;
14125: LD_EXP 13
14129: PUSH
14130: LD_EXP 14
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: LD_EXP 1
14143: PPUSH
14144: CALL_OW 250
14148: PPUSH
14149: LD_EXP 1
14153: PPUSH
14154: CALL_OW 251
14158: PPUSH
14159: CALL_OW 114
// end ; SetLives ( Heike , 0 ) ;
14163: LD_EXP 11
14167: PPUSH
14168: LD_INT 0
14170: PPUSH
14171: CALL_OW 234
// HeikeKilled := true ;
14175: LD_ADDR_EXP 38
14179: PUSH
14180: LD_INT 1
14182: ST_TO_ADDR
// merc_attack ;
14183: CALL 7775 0 0
// end else
14187: GO 14233
// begin D_HeikeKilled ;
14189: CALL 5036 0 0
// SetLives ( Heike , 0 ) ;
14193: LD_EXP 11
14197: PPUSH
14198: LD_INT 0
14200: PPUSH
14201: CALL_OW 234
// HeikeKilled := true ;
14205: LD_ADDR_EXP 38
14209: PUSH
14210: LD_INT 1
14212: ST_TO_ADDR
// SetAttitude ( you , merc , att_enemy , true ) ;
14213: LD_EXP 31
14217: PPUSH
14218: LD_EXP 34
14222: PPUSH
14223: LD_INT 2
14225: PPUSH
14226: LD_INT 1
14228: PPUSH
14229: CALL_OW 80
// end ; end ; end ;
14233: PPOPN 1
14235: END
// on UnitDestroyed ( human ) do begin if human = Burlak then
14236: LD_VAR 0 1
14240: PUSH
14241: LD_EXP 1
14245: EQUAL
14246: IFFALSE 14255
// YouLost ( Burlak ) ;
14248: LD_STRING Burlak
14250: PPUSH
14251: CALL_OW 104
// end ;
14255: PPOPN 1
14257: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_AdvAI then
14258: LD_VAR 0 1
14262: PUSH
14263: LD_INT 27
14265: EQUAL
14266: IFFALSE 14293
// begin Hint ( AI ) ;
14268: LD_STRING AI
14270: PPUSH
14271: CALL_OW 339
// Wait ( 0 0$10 ) ;
14275: LD_INT 350
14277: PPUSH
14278: CALL_OW 67
// D_AI ;
14282: CALL 6931 0 0
// ChangeMissionObjectives ( MAI ) ;
14286: LD_STRING MAI
14288: PPUSH
14289: CALL_OW 337
// end ; if tech = tech_LimTeleport then
14293: LD_VAR 0 1
14297: PUSH
14298: LD_INT 37
14300: EQUAL
14301: IFFALSE 14336
// begin Hint ( SpontTelep ) ;
14303: LD_STRING SpontTelep
14305: PPUSH
14306: CALL_OW 339
// Wait ( 0 0$10 ) ;
14310: LD_INT 350
14312: PPUSH
14313: CALL_OW 67
// D_SpontTelep ;
14317: CALL 7033 0 0
// ChangeMissionObjectives ( MTele ) ;
14321: LD_STRING MTele
14323: PPUSH
14324: CALL_OW 337
// LimitTeleportResearched := true ;
14328: LD_ADDR_EXP 62
14332: PUSH
14333: LD_INT 1
14335: ST_TO_ADDR
// end ; AvailableTechno := AvailableTechno diff tech ;
14336: LD_ADDR_EXP 56
14340: PUSH
14341: LD_EXP 56
14345: PUSH
14346: LD_VAR 0 1
14350: DIFF
14351: ST_TO_ADDR
// if HeikeCratesTime then
14352: LD_LOC 5
14356: IFFALSE 14419
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) , #Ru08-4 , HeikeCratesTime ] else
14358: LD_ADDR_OWVAR 47
14362: PUSH
14363: LD_STRING #Ru08-1
14365: PUSH
14366: LD_INT 0
14368: PUSH
14369: LD_LOC 3
14373: PLUS
14374: PUSH
14375: LD_STRING #Ru08-2
14377: PUSH
14378: LD_INT 0
14380: PUSH
14381: LD_LOC 4
14385: PLUS
14386: PUSH
14387: LD_STRING #Ru08-3
14389: PUSH
14390: LD_INT 0
14392: PUSH
14393: LD_EXP 56
14397: PLUS
14398: PUSH
14399: LD_STRING #Ru08-4
14401: PUSH
14402: LD_LOC 5
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: ST_TO_ADDR
14417: GO 14468
// display_strings := [ #Ru08-1 , ( 0 + NonBuildBuildings ) , #Ru08-2 , ( 0 + NonBuildWeapons ) , #Ru08-3 , ( 0 + AvailableTechno ) ] ;
14419: LD_ADDR_OWVAR 47
14423: PUSH
14424: LD_STRING #Ru08-1
14426: PUSH
14427: LD_INT 0
14429: PUSH
14430: LD_LOC 3
14434: PLUS
14435: PUSH
14436: LD_STRING #Ru08-2
14438: PUSH
14439: LD_INT 0
14441: PUSH
14442: LD_LOC 4
14446: PLUS
14447: PUSH
14448: LD_STRING #Ru08-3
14450: PUSH
14451: LD_INT 0
14453: PUSH
14454: LD_EXP 56
14458: PLUS
14459: PUSH
14460: EMPTY
14461: LIST
14462: LIST
14463: LIST
14464: LIST
14465: LIST
14466: LIST
14467: ST_TO_ADDR
// if AvailableTechno = [ ] and not TechnoDone then
14468: LD_EXP 56
14472: PUSH
14473: EMPTY
14474: EQUAL
14475: PUSH
14476: LD_EXP 51
14480: NOT
14481: AND
14482: IFFALSE 14499
// begin ChangeMissionObjectives ( MTechnoDone ) ;
14484: LD_STRING MTechnoDone
14486: PPUSH
14487: CALL_OW 337
// TechnoDone := true ;
14491: LD_ADDR_EXP 51
14495: PUSH
14496: LD_INT 1
14498: ST_TO_ADDR
// end ; end ;
14499: PPOPN 2
14501: END
// on VehicleConstructed ( veh , fact ) do begin AvailableWeapons := AvailableWeapons diff GetWeapon ( veh ) ;
14502: LD_ADDR_EXP 54
14506: PUSH
14507: LD_EXP 54
14511: PUSH
14512: LD_VAR 0 1
14516: PPUSH
14517: CALL_OW 264
14521: DIFF
14522: ST_TO_ADDR
// if ( AvailableWeapons + 0 ) = 2 and not MashaAsked then
14523: LD_EXP 54
14527: PUSH
14528: LD_INT 0
14530: PLUS
14531: PUSH
14532: LD_INT 2
14534: EQUAL
14535: PUSH
14536: LD_EXP 70
14540: NOT
14541: AND
14542: IFFALSE 14547
// enable ( 401 ) ;
14544: LD_INT 401
14546: ENABLE_MARKED
// if GetControl ( veh ) = control_computer then
14547: LD_VAR 0 1
14551: PPUSH
14552: CALL_OW 263
14556: PUSH
14557: LD_INT 3
14559: EQUAL
14560: IFFALSE 14577
// begin ChangeMissionObjectives ( MAIDone ) ;
14562: LD_STRING MAIDone
14564: PPUSH
14565: CALL_OW 337
// CompVehConstructed = true ;
14569: LD_ADDR_EXP 61
14573: PUSH
14574: LD_INT 1
14576: ST_TO_ADDR
// end ; end ;
14577: PPOPN 2
14579: END
// on Command ( comm ) marked 601 do var i ;
14580: LD_INT 0
14582: PPUSH
// begin if IsOK ( Kurt ) then
14583: LD_EXP 13
14587: PPUSH
14588: CALL_OW 302
14592: IFFALSE 14792
// if GetTaskList ( Kurt ) <> [ ] then
14594: LD_EXP 13
14598: PPUSH
14599: CALL_OW 437
14603: PUSH
14604: EMPTY
14605: NONEQUAL
14606: IFFALSE 14792
// begin for i := 1 to ( 0 + GetTaskList ( Kurt ) ) do
14608: LD_ADDR_VAR 0 2
14612: PUSH
14613: DOUBLE
14614: LD_INT 1
14616: DEC
14617: ST_TO_ADDR
14618: LD_INT 0
14620: PUSH
14621: LD_EXP 13
14625: PPUSH
14626: CALL_OW 437
14630: PLUS
14631: PUSH
14632: FOR_TO
14633: IFFALSE 14790
// begin if ( GetTaskList ( Kurt ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Kurt ) [ i ] [ 1 ] = B and GetTaskList ( Kurt ) [ i ] [ 5 ] = 36 ) then
14635: LD_EXP 13
14639: PPUSH
14640: CALL_OW 437
14644: PUSH
14645: LD_VAR 0 2
14649: ARRAY
14650: PUSH
14651: LD_INT 1
14653: ARRAY
14654: PUSH
14655: LD_STRING F
14657: PUSH
14658: LD_STRING H
14660: PUSH
14661: LD_STRING M
14663: PUSH
14664: LD_STRING U
14666: PUSH
14667: LD_STRING V
14669: PUSH
14670: LD_STRING a
14672: PUSH
14673: LD_STRING h
14675: PUSH
14676: LD_STRING u
14678: PUSH
14679: LD_STRING v
14681: PUSH
14682: LD_STRING ~
14684: PUSH
14685: LD_STRING ^
14687: PUSH
14688: LD_STRING >
14690: PUSH
14691: LD_STRING +
14693: PUSH
14694: LD_STRING ;
14696: PUSH
14697: LD_STRING 4
14699: PUSH
14700: LD_STRING {
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: IN
14721: PUSH
14722: LD_EXP 13
14726: PPUSH
14727: CALL_OW 437
14731: PUSH
14732: LD_VAR 0 2
14736: ARRAY
14737: PUSH
14738: LD_INT 1
14740: ARRAY
14741: PUSH
14742: LD_STRING B
14744: EQUAL
14745: PUSH
14746: LD_EXP 13
14750: PPUSH
14751: CALL_OW 437
14755: PUSH
14756: LD_VAR 0 2
14760: ARRAY
14761: PUSH
14762: LD_INT 5
14764: ARRAY
14765: PUSH
14766: LD_INT 36
14768: EQUAL
14769: AND
14770: OR
14771: IFFALSE 14775
// else
14773: GO 14788
// begin RemoveTasks ( Kurt ) ;
14775: LD_EXP 13
14779: PPUSH
14780: CALL_OW 493
// D_MercRefuseBuild ;
14784: CALL 5252 0 0
// end ; end ;
14788: GO 14632
14790: POP
14791: POP
// end ; if IsOK ( Mercenary1 ) then
14792: LD_EXP 14
14796: PPUSH
14797: CALL_OW 302
14801: IFFALSE 15001
// if GetTaskList ( Mercenary1 ) <> [ ] then
14803: LD_EXP 14
14807: PPUSH
14808: CALL_OW 437
14812: PUSH
14813: EMPTY
14814: NONEQUAL
14815: IFFALSE 15001
// begin for i := 1 to ( 0 + GetTaskList ( Mercenary1 ) ) do
14817: LD_ADDR_VAR 0 2
14821: PUSH
14822: DOUBLE
14823: LD_INT 1
14825: DEC
14826: ST_TO_ADDR
14827: LD_INT 0
14829: PUSH
14830: LD_EXP 14
14834: PPUSH
14835: CALL_OW 437
14839: PLUS
14840: PUSH
14841: FOR_TO
14842: IFFALSE 14999
// begin if ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] in [ F , H , M , U , V , a , h , u , v , ~ , ^ , > , + , ; , 4 , { ] ) or ( GetTaskList ( Mercenary1 ) [ i ] [ 1 ] = B and GetTaskList ( Mercenary1 ) [ i ] [ 5 ] = 36 ) then
14844: LD_EXP 14
14848: PPUSH
14849: CALL_OW 437
14853: PUSH
14854: LD_VAR 0 2
14858: ARRAY
14859: PUSH
14860: LD_INT 1
14862: ARRAY
14863: PUSH
14864: LD_STRING F
14866: PUSH
14867: LD_STRING H
14869: PUSH
14870: LD_STRING M
14872: PUSH
14873: LD_STRING U
14875: PUSH
14876: LD_STRING V
14878: PUSH
14879: LD_STRING a
14881: PUSH
14882: LD_STRING h
14884: PUSH
14885: LD_STRING u
14887: PUSH
14888: LD_STRING v
14890: PUSH
14891: LD_STRING ~
14893: PUSH
14894: LD_STRING ^
14896: PUSH
14897: LD_STRING >
14899: PUSH
14900: LD_STRING +
14902: PUSH
14903: LD_STRING ;
14905: PUSH
14906: LD_STRING 4
14908: PUSH
14909: LD_STRING {
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: IN
14930: PUSH
14931: LD_EXP 14
14935: PPUSH
14936: CALL_OW 437
14940: PUSH
14941: LD_VAR 0 2
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: PUSH
14951: LD_STRING B
14953: EQUAL
14954: PUSH
14955: LD_EXP 14
14959: PPUSH
14960: CALL_OW 437
14964: PUSH
14965: LD_VAR 0 2
14969: ARRAY
14970: PUSH
14971: LD_INT 5
14973: ARRAY
14974: PUSH
14975: LD_INT 36
14977: EQUAL
14978: AND
14979: OR
14980: IFFALSE 14984
// else
14982: GO 14997
// begin RemoveTasks ( Mercenary1 ) ;
14984: LD_EXP 14
14988: PPUSH
14989: CALL_OW 493
// D_MercRefuseBuild ;
14993: CALL 5252 0 0
// end ; end ;
14997: GO 14841
14999: POP
15000: POP
// end ; end ;
15001: PPOPN 2
15003: END
// every 0 0$1 trigger IsOk ( Kurt ) and GetSide ( Kurt ) = 3 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) >= 2 do
15004: LD_EXP 13
15008: PPUSH
15009: CALL_OW 302
15013: PUSH
15014: LD_EXP 13
15018: PPUSH
15019: CALL_OW 255
15023: PUSH
15024: LD_INT 3
15026: EQUAL
15027: AND
15028: PUSH
15029: LD_INT 22
15031: PUSH
15032: LD_INT 3
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_INT 23
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: LD_INT 30
15051: PUSH
15052: LD_INT 4
15054: PUSH
15055: EMPTY
15056: LIST
15057: LIST
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: LIST
15063: PPUSH
15064: CALL_OW 69
15068: PUSH
15069: LD_INT 2
15071: GREATEREQUAL
15072: AND
15073: IFFALSE 15140
15075: GO 15077
15077: DISABLE
// begin enable ;
15078: ENABLE
// RemoveUnit ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 2 ] , [ f_btype , 4 ] ] ) [ 2 ] ) ;
15079: LD_INT 22
15081: PUSH
15082: LD_INT 3
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_INT 23
15091: PUSH
15092: LD_INT 2
15094: PUSH
15095: EMPTY
15096: LIST
15097: LIST
15098: PUSH
15099: LD_INT 30
15101: PUSH
15102: LD_INT 4
15104: PUSH
15105: EMPTY
15106: LIST
15107: LIST
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: LIST
15113: PPUSH
15114: CALL_OW 69
15118: PUSH
15119: LD_INT 2
15121: ARRAY
15122: PPUSH
15123: CALL_OW 64
// RemoveTasks ( Mercenary1 ) ;
15127: LD_EXP 14
15131: PPUSH
15132: CALL_OW 493
// D_MercRefuseBuild ;
15136: CALL 5252 0 0
// end ; end_of_file
15140: END
// export function hunt ( hunter ) ; var un , animals , animal , kasarna , depot , i , x , y , d , rnd_animal , hunter_x_coordinate , hunter_y_coordinate , range , osoba , min , setridene_animals ; begin
15141: LD_INT 0
15143: PPUSH
15144: PPUSH
15145: PPUSH
15146: PPUSH
15147: PPUSH
15148: PPUSH
15149: PPUSH
15150: PPUSH
15151: PPUSH
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
15157: PPUSH
15158: PPUSH
15159: PPUSH
// kasarna := FilterAllUnits ( [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ) ;
15160: LD_ADDR_VAR 0 6
15164: PUSH
15165: LD_INT 2
15167: PUSH
15168: LD_INT 30
15170: PUSH
15171: LD_INT 5
15173: PUSH
15174: EMPTY
15175: LIST
15176: LIST
15177: PUSH
15178: LD_INT 30
15180: PUSH
15181: LD_INT 4
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL_OW 69
15197: ST_TO_ADDR
// SetSide ( hunter , ally ) ;
15198: LD_VAR 0 1
15202: PPUSH
15203: LD_EXP 32
15207: PPUSH
15208: CALL_OW 235
// if not ( GetClass ( hunter ) = class_soldier ) and ( kasarna > 0 ) then
15212: LD_VAR 0 1
15216: PPUSH
15217: CALL_OW 257
15221: PUSH
15222: LD_INT 1
15224: EQUAL
15225: NOT
15226: PUSH
15227: LD_VAR 0 6
15231: PUSH
15232: LD_INT 0
15234: GREATER
15235: AND
15236: IFFALSE 15424
// begin ComEnterUnit ( hunter , kasarna [ 1 ] ) ;
15238: LD_VAR 0 1
15242: PPUSH
15243: LD_VAR 0 6
15247: PUSH
15248: LD_INT 1
15250: ARRAY
15251: PPUSH
15252: CALL_OW 120
// Wait ( 10 ) ;
15256: LD_INT 10
15258: PPUSH
15259: CALL_OW 67
// while HasTask ( hunter ) do
15263: LD_VAR 0 1
15267: PPUSH
15268: CALL_OW 314
15272: IFFALSE 15283
// begin Wait ( 10 ) ;
15274: LD_INT 10
15276: PPUSH
15277: CALL_OW 67
// end ;
15281: GO 15263
// hunter_x_coordinate := GetX ( hunter ) ;
15283: LD_ADDR_VAR 0 13
15287: PUSH
15288: LD_VAR 0 1
15292: PPUSH
15293: CALL_OW 250
15297: ST_TO_ADDR
// hunter_y_coordinate := GetY ( hunter ) ;
15298: LD_ADDR_VAR 0 14
15302: PUSH
15303: LD_VAR 0 1
15307: PPUSH
15308: CALL_OW 251
15312: ST_TO_ADDR
// RemoveUnit ( hunter ) ;
15313: LD_VAR 0 1
15317: PPUSH
15318: CALL_OW 64
// SetClass ( hunter , class_soldier ) ;
15322: LD_VAR 0 1
15326: PPUSH
15327: LD_INT 1
15329: PPUSH
15330: CALL_OW 336
// Wait ( 0 0$2 ) ;
15334: LD_INT 70
15336: PPUSH
15337: CALL_OW 67
// if not PlaceUnitXY ( hunter , hunter_x_coordinate , hunter_y_coordinate , false ) then
15341: LD_VAR 0 1
15345: PPUSH
15346: LD_VAR 0 13
15350: PPUSH
15351: LD_VAR 0 14
15355: PPUSH
15356: LD_INT 0
15358: PPUSH
15359: CALL_OW 48
15363: NOT
15364: IFFALSE 15424
// begin range := 0 ;
15366: LD_ADDR_VAR 0 15
15370: PUSH
15371: LD_INT 0
15373: ST_TO_ADDR
// repeat Wait ( 2 ) ;
15374: LD_INT 2
15376: PPUSH
15377: CALL_OW 67
// range := range + 1 ;
15381: LD_ADDR_VAR 0 15
15385: PUSH
15386: LD_VAR 0 15
15390: PUSH
15391: LD_INT 1
15393: PLUS
15394: ST_TO_ADDR
// until PlaceUnitXYR ( hunter , hunter_x_coordinate , hunter_y_coordinate , range , false ) end ;
15395: LD_VAR 0 1
15399: PPUSH
15400: LD_VAR 0 13
15404: PPUSH
15405: LD_VAR 0 14
15409: PPUSH
15410: LD_VAR 0 15
15414: PPUSH
15415: LD_INT 0
15417: PPUSH
15418: CALL_OW 50
15422: IFFALSE 15374
// end ; animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15424: LD_ADDR_VAR 0 4
15428: PUSH
15429: LD_INT 2
15431: PUSH
15432: LD_INT 25
15434: PUSH
15435: LD_INT 18
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: PUSH
15442: LD_INT 25
15444: PUSH
15445: LD_INT 14
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: PUSH
15452: EMPTY
15453: LIST
15454: LIST
15455: LIST
15456: PPUSH
15457: CALL_OW 69
15461: ST_TO_ADDR
// if animals = [ ] then
15462: LD_VAR 0 4
15466: PUSH
15467: EMPTY
15468: EQUAL
15469: IFFALSE 15653
// begin Randomize ;
15471: CALL_OW 10
// RandomizeAll ;
15475: CALL_OW 11
// for i := 1 to 6 do
15479: LD_ADDR_VAR 0 8
15483: PUSH
15484: DOUBLE
15485: LD_INT 1
15487: DEC
15488: ST_TO_ADDR
15489: LD_INT 6
15491: PUSH
15492: FOR_TO
15493: IFFALSE 15651
// begin uc_side = 0 ;
15495: LD_ADDR_OWVAR 20
15499: PUSH
15500: LD_INT 0
15502: ST_TO_ADDR
// uc_nation := nation_nature ;
15503: LD_ADDR_OWVAR 21
15507: PUSH
15508: LD_INT 0
15510: ST_TO_ADDR
// PrepareHuman ( 0 , class_phororhacos , 0 ) ;
15511: LD_INT 0
15513: PPUSH
15514: LD_INT 18
15516: PPUSH
15517: LD_INT 0
15519: PPUSH
15520: CALL_OW 380
// hc_name :=  ;
15524: LD_ADDR_OWVAR 26
15528: PUSH
15529: LD_STRING 
15531: ST_TO_ADDR
// Wait ( 1 ) ;
15532: LD_INT 1
15534: PPUSH
15535: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15539: CALL_OW 44
15543: PPUSH
15544: LD_INT 22
15546: PPUSH
15547: LD_INT 0
15549: PPUSH
15550: CALL_OW 49
// Wait ( 1 ) ;
15554: LD_INT 1
15556: PPUSH
15557: CALL_OW 67
// PrepareHuman ( 0 , class_tiger , 0 ) ;
15561: LD_INT 0
15563: PPUSH
15564: LD_INT 14
15566: PPUSH
15567: LD_INT 0
15569: PPUSH
15570: CALL_OW 380
// hc_name :=  ;
15574: LD_ADDR_OWVAR 26
15578: PUSH
15579: LD_STRING 
15581: ST_TO_ADDR
// Wait ( 1 ) ;
15582: LD_INT 1
15584: PPUSH
15585: CALL_OW 67
// PlaceUnitArea ( CreateHuman , AnimalsArea , false ) ;
15589: CALL_OW 44
15593: PPUSH
15594: LD_INT 22
15596: PPUSH
15597: LD_INT 0
15599: PPUSH
15600: CALL_OW 49
// Wait ( 1 ) ;
15604: LD_INT 1
15606: PPUSH
15607: CALL_OW 67
// animals := FilterAllUnits ( [ f_or , [ f_class , class_phororhacos ] , [ f_class , class_tiger ] ] ) ;
15611: LD_ADDR_VAR 0 4
15615: PUSH
15616: LD_INT 2
15618: PUSH
15619: LD_INT 25
15621: PUSH
15622: LD_INT 18
15624: PUSH
15625: EMPTY
15626: LIST
15627: LIST
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 14
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: LIST
15643: PPUSH
15644: CALL_OW 69
15648: ST_TO_ADDR
// end ;
15649: GO 15492
15651: POP
15652: POP
// end ; if GetClass ( hunter ) = class_soldier then
15653: LD_VAR 0 1
15657: PPUSH
15658: CALL_OW 257
15662: PUSH
15663: LD_INT 1
15665: EQUAL
15666: IFFALSE 15686
// rnd_animal := Rand ( 4 , 6 ) else
15668: LD_ADDR_VAR 0 12
15672: PUSH
15673: LD_INT 4
15675: PPUSH
15676: LD_INT 6
15678: PPUSH
15679: CALL_OW 12
15683: ST_TO_ADDR
15684: GO 15702
// rnd_animal := Rand ( 1 , 2 ) ;
15686: LD_ADDR_VAR 0 12
15690: PUSH
15691: LD_INT 1
15693: PPUSH
15694: LD_INT 2
15696: PPUSH
15697: CALL_OW 12
15701: ST_TO_ADDR
// range := 999 ;
15702: LD_ADDR_VAR 0 15
15706: PUSH
15707: LD_INT 999
15709: ST_TO_ADDR
// osoba := hunter ;
15710: LD_ADDR_VAR 0 16
15714: PUSH
15715: LD_VAR 0 1
15719: ST_TO_ADDR
// setridene_animals := [ ] ;
15720: LD_ADDR_VAR 0 18
15724: PUSH
15725: EMPTY
15726: ST_TO_ADDR
// while animals <> [ ] do
15727: LD_VAR 0 4
15731: PUSH
15732: EMPTY
15733: NONEQUAL
15734: IFFALSE 15864
// begin for un in animals do
15736: LD_ADDR_VAR 0 3
15740: PUSH
15741: LD_VAR 0 4
15745: PUSH
15746: FOR_IN
15747: IFFALSE 15810
// begin if GetDistUnits ( osoba , un ) < range then
15749: LD_VAR 0 16
15753: PPUSH
15754: LD_VAR 0 3
15758: PPUSH
15759: CALL_OW 296
15763: PUSH
15764: LD_VAR 0 15
15768: LESS
15769: IFFALSE 15801
// begin range := GetDistUnits ( hunter , un ) ;
15771: LD_ADDR_VAR 0 15
15775: PUSH
15776: LD_VAR 0 1
15780: PPUSH
15781: LD_VAR 0 3
15785: PPUSH
15786: CALL_OW 296
15790: ST_TO_ADDR
// min := un ;
15791: LD_ADDR_VAR 0 17
15795: PUSH
15796: LD_VAR 0 3
15800: ST_TO_ADDR
// end ; Wait ( 1 ) ;
15801: LD_INT 1
15803: PPUSH
15804: CALL_OW 67
// end ;
15808: GO 15746
15810: POP
15811: POP
// setridene_animals := setridene_animals ^ min ;
15812: LD_ADDR_VAR 0 18
15816: PUSH
15817: LD_VAR 0 18
15821: PUSH
15822: LD_VAR 0 17
15826: ADD
15827: ST_TO_ADDR
// animals := animals diff min ;
15828: LD_ADDR_VAR 0 4
15832: PUSH
15833: LD_VAR 0 4
15837: PUSH
15838: LD_VAR 0 17
15842: DIFF
15843: ST_TO_ADDR
// osoba := min ;
15844: LD_ADDR_VAR 0 16
15848: PUSH
15849: LD_VAR 0 17
15853: ST_TO_ADDR
// range := 999 ;
15854: LD_ADDR_VAR 0 15
15858: PUSH
15859: LD_INT 999
15861: ST_TO_ADDR
// end ;
15862: GO 15727
// for i := 1 to rnd_animal do
15864: LD_ADDR_VAR 0 8
15868: PUSH
15869: DOUBLE
15870: LD_INT 1
15872: DEC
15873: ST_TO_ADDR
15874: LD_VAR 0 12
15878: PUSH
15879: FOR_TO
15880: IFFALSE 15911
// begin AddComAttackUnit ( hunter , setridene_animals [ i ] ) ;
15882: LD_VAR 0 1
15886: PPUSH
15887: LD_VAR 0 18
15891: PUSH
15892: LD_VAR 0 8
15896: ARRAY
15897: PPUSH
15898: CALL_OW 175
// Wait ( 10 ) ;
15902: LD_INT 10
15904: PPUSH
15905: CALL_OW 67
// end ;
15909: GO 15879
15911: POP
15912: POP
// if GetClass ( hunter ) = class_soldier then
15913: LD_VAR 0 1
15917: PPUSH
15918: CALL_OW 257
15922: PUSH
15923: LD_INT 1
15925: EQUAL
15926: IFFALSE 15931
// enable ( 102 ) ;
15928: LD_INT 102
15930: ENABLE_MARKED
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
15931: LD_ADDR_VAR 0 7
15935: PUSH
15936: LD_INT 2
15938: PUSH
15939: LD_INT 30
15941: PUSH
15942: LD_INT 0
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PUSH
15949: LD_INT 30
15951: PUSH
15952: LD_INT 1
15954: PUSH
15955: EMPTY
15956: LIST
15957: LIST
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: LIST
15963: PPUSH
15964: CALL_OW 69
15968: ST_TO_ADDR
// if depot + 0 > 0 then
15969: LD_VAR 0 7
15973: PUSH
15974: LD_INT 0
15976: PLUS
15977: PUSH
15978: LD_INT 0
15980: GREATER
15981: IFFALSE 16087
// begin x := GetX ( depot [ 1 ] ) ;
15983: LD_ADDR_VAR 0 9
15987: PUSH
15988: LD_VAR 0 7
15992: PUSH
15993: LD_INT 1
15995: ARRAY
15996: PPUSH
15997: CALL_OW 250
16001: ST_TO_ADDR
// y := GetY ( depot [ 1 ] ) ;
16002: LD_ADDR_VAR 0 10
16006: PUSH
16007: LD_VAR 0 7
16011: PUSH
16012: LD_INT 1
16014: ARRAY
16015: PPUSH
16016: CALL_OW 251
16020: ST_TO_ADDR
// d := GetDir ( depot [ 1 ] ) ;
16021: LD_ADDR_VAR 0 11
16025: PUSH
16026: LD_VAR 0 7
16030: PUSH
16031: LD_INT 1
16033: ARRAY
16034: PPUSH
16035: CALL_OW 254
16039: ST_TO_ADDR
// AddComMoveXY ( hunter , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
16040: LD_VAR 0 1
16044: PPUSH
16045: LD_VAR 0 9
16049: PPUSH
16050: LD_VAR 0 11
16054: PPUSH
16055: LD_INT 7
16057: PPUSH
16058: CALL_OW 272
16062: PPUSH
16063: LD_VAR 0 10
16067: PPUSH
16068: LD_VAR 0 11
16072: PPUSH
16073: LD_INT 7
16075: PPUSH
16076: CALL_OW 273
16080: PPUSH
16081: CALL_OW 171
// end else
16085: GO 16102
// AddComMoveXY ( hunter , 83 , 40 ) ;
16087: LD_VAR 0 1
16091: PPUSH
16092: LD_INT 83
16094: PPUSH
16095: LD_INT 40
16097: PPUSH
16098: CALL_OW 171
// while HasTask ( hunter ) do
16102: LD_VAR 0 1
16106: PPUSH
16107: CALL_OW 314
16111: IFFALSE 16122
// begin Wait ( 0 0$1 ) ;
16113: LD_INT 35
16115: PPUSH
16116: CALL_OW 67
// end ;
16120: GO 16102
// SetSide ( hunter , you ) ;
16122: LD_VAR 0 1
16126: PPUSH
16127: LD_EXP 31
16131: PPUSH
16132: CALL_OW 235
// end ;
16136: LD_VAR 0 2
16140: RET
// every 0 0$1 marked 101 do
16141: GO 16143
16143: DISABLE
// begin HuntingAsked := true ;
16144: LD_ADDR_EXP 67
16148: PUSH
16149: LD_INT 1
16151: ST_TO_ADDR
// Wait ( Rand ( 0 0$30 , 2 2$30 ) ) ;
16152: LD_INT 1050
16154: PPUSH
16155: LD_INT 5250
16157: PPUSH
16158: CALL_OW 12
16162: PPUSH
16163: CALL_OW 67
// if not ( HuntingAccepted ) and ( IsOK ( Belkov ) or IsOK ( Karamazov ) or IsOK ( Kozlov ) ) then
16167: LD_EXP 47
16171: NOT
16172: PUSH
16173: LD_EXP 3
16177: PPUSH
16178: CALL_OW 302
16182: PUSH
16183: LD_EXP 17
16187: PPUSH
16188: CALL_OW 302
16192: OR
16193: PUSH
16194: LD_EXP 20
16198: PPUSH
16199: CALL_OW 302
16203: OR
16204: AND
16205: IFFALSE 16267
// begin D_Hunting ;
16207: CALL 6021 0 0
// case Query ( QHunting ) of 1 :
16211: LD_STRING QHunting
16213: PPUSH
16214: CALL_OW 97
16218: PUSH
16219: LD_INT 1
16221: DOUBLE
16222: EQUAL
16223: IFTRUE 16227
16225: GO 16251
16227: POP
// begin HuntingAccepted := true ;
16228: LD_ADDR_EXP 47
16232: PUSH
16233: LD_INT 1
16235: ST_TO_ADDR
// D_QrHunting1 ;
16236: CALL 6336 0 0
// hunt ( hunter ) ;
16240: LD_EXP 72
16244: PPUSH
16245: CALL 15141 0 1
// end ; 2 :
16249: GO 16267
16251: LD_INT 2
16253: DOUBLE
16254: EQUAL
16255: IFTRUE 16259
16257: GO 16266
16259: POP
// D_QrHunting2 ; end ;
16260: CALL 6356 0 0
16264: GO 16267
16266: POP
// end ; end ;
16267: END
// every 0 0$1 + 0 0$0.3 marked 102 do
16268: GO 16270
16270: DISABLE
// begin if GetDistUnits ( hunter , WantsToAttack ( hunter ) ) < 13 then
16271: LD_EXP 72
16275: PPUSH
16276: LD_EXP 72
16280: PPUSH
16281: CALL_OW 319
16285: PPUSH
16286: CALL_OW 296
16290: PUSH
16291: LD_INT 13
16293: LESS
16294: IFFALSE 16307
// ComCrawl ( hunter ) else
16296: LD_EXP 72
16300: PPUSH
16301: CALL_OW 137
16305: GO 16316
// ComWalk ( hunter ) ;
16307: LD_EXP 72
16311: PPUSH
16312: CALL_OW 138
// if not HasTask ( hunter ) then
16316: LD_EXP 72
16320: PPUSH
16321: CALL_OW 314
16325: NOT
16326: IFFALSE 16331
// disable else
16328: DISABLE
16329: GO 16332
// enable ;
16331: ENABLE
// end ; end_of_file
16332: END
// var ShootAreaNr , BarrelAreas , StandAreas ; every 0 0$1 marked 201 do
16333: GO 16335
16335: DISABLE
// begin GalleryAsked := true ;
16336: LD_ADDR_EXP 66
16340: PUSH
16341: LD_INT 1
16343: ST_TO_ADDR
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
16344: LD_INT 350
16346: PPUSH
16347: LD_INT 700
16349: PPUSH
16350: CALL_OW 12
16354: PPUSH
16355: CALL_OW 67
// D_FiringRange ;
16359: CALL 5840 0 0
// case Query ( QShootingGallery ) of 1 :
16363: LD_STRING QShootingGallery
16365: PPUSH
16366: CALL_OW 97
16370: PUSH
16371: LD_INT 1
16373: DOUBLE
16374: EQUAL
16375: IFTRUE 16379
16377: GO 16476
16379: POP
// begin GalleryBuild := true ;
16380: LD_ADDR_EXP 53
16384: PUSH
16385: LD_INT 1
16387: ST_TO_ADDR
// D_QrShootingGallery1 ;
16388: CALL 5981 0 0
// Wait ( 0 0$2 ) ;
16392: LD_INT 70
16394: PPUSH
16395: CALL_OW 67
// Hint ( ShootingGallery ) ;
16399: LD_STRING ShootingGallery
16401: PPUSH
16402: CALL_OW 339
// ShootAreaNr := 1 ;
16406: LD_ADDR_LOC 8
16410: PUSH
16411: LD_INT 1
16413: ST_TO_ADDR
// BarrelAreas := [ BarrelArea1 , BarrelArea2 , BarrelArea3 , BarrelArea4 , BarrelArea5 ] ;
16414: LD_ADDR_LOC 9
16418: PUSH
16419: LD_INT 12
16421: PUSH
16422: LD_INT 13
16424: PUSH
16425: LD_INT 14
16427: PUSH
16428: LD_INT 15
16430: PUSH
16431: LD_INT 16
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: ST_TO_ADDR
// StandAreas := [ StandArea1 , StandArea2 , StandArea3 , StandArea4 , StandArea5 ] ;
16441: LD_ADDR_LOC 10
16445: PUSH
16446: LD_INT 17
16448: PUSH
16449: LD_INT 18
16451: PUSH
16452: LD_INT 19
16454: PUSH
16455: LD_INT 20
16457: PUSH
16458: LD_INT 21
16460: PUSH
16461: EMPTY
16462: LIST
16463: LIST
16464: LIST
16465: LIST
16466: LIST
16467: ST_TO_ADDR
// enable ( 202 ) ;
16468: LD_INT 202
16470: ENABLE_MARKED
// enable ( 203 ) ;
16471: LD_INT 203
16473: ENABLE_MARKED
// end ; 2 :
16474: GO 16502
16476: LD_INT 2
16478: DOUBLE
16479: EQUAL
16480: IFTRUE 16484
16482: GO 16501
16484: POP
// begin D_QrShootingGallery2 ;
16485: CALL 6001 0 0
// SetAreaMapShow ( ShootArea , 0 ) ;
16489: LD_INT 11
16491: PPUSH
16492: LD_INT 0
16494: PPUSH
16495: CALL_OW 424
// end ; end ;
16499: GO 16502
16501: POP
// end ;
16502: END
// every 0 0$0.5 marked 202 do var shooters , un , buildings ;
16503: GO 16505
16505: DISABLE
16506: LD_INT 0
16508: PPUSH
16509: PPUSH
16510: PPUSH
// begin enable ;
16511: ENABLE
// shooters := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_not , [ f_hastask ] ] , [ f_nation , nation_russian ] ] ) ;
16512: LD_ADDR_VAR 0 1
16516: PUSH
16517: LD_INT 11
16519: PPUSH
16520: LD_INT 21
16522: PUSH
16523: LD_INT 1
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PUSH
16530: LD_INT 3
16532: PUSH
16533: LD_INT 60
16535: PUSH
16536: EMPTY
16537: LIST
16538: PUSH
16539: EMPTY
16540: LIST
16541: LIST
16542: PUSH
16543: LD_INT 23
16545: PUSH
16546: LD_INT 3
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: PUSH
16553: EMPTY
16554: LIST
16555: LIST
16556: LIST
16557: PPUSH
16558: CALL_OW 70
16562: ST_TO_ADDR
// if shooters <> [ ] then
16563: LD_VAR 0 1
16567: PUSH
16568: EMPTY
16569: NONEQUAL
16570: IFFALSE 17112
// begin for un in shooters do
16572: LD_ADDR_VAR 0 2
16576: PUSH
16577: LD_VAR 0 1
16581: PUSH
16582: FOR_IN
16583: IFFALSE 17110
// begin buildings := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
16585: LD_ADDR_VAR 0 3
16589: PUSH
16590: LD_INT 22
16592: PUSH
16593: LD_EXP 31
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: LD_INT 2
16604: PUSH
16605: LD_INT 30
16607: PUSH
16608: LD_INT 0
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: PUSH
16615: LD_INT 30
16617: PUSH
16618: LD_INT 1
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: LIST
16629: PUSH
16630: EMPTY
16631: LIST
16632: PUSH
16633: EMPTY
16634: LIST
16635: LIST
16636: PPUSH
16637: CALL_OW 69
16641: ST_TO_ADDR
// if buildings <> [ ] then
16642: LD_VAR 0 3
16646: PUSH
16647: EMPTY
16648: NONEQUAL
16649: IFFALSE 17108
// begin if not ( GetClass ( un ) = class_engineer ) then
16651: LD_VAR 0 2
16655: PPUSH
16656: CALL_OW 257
16660: PUSH
16661: LD_INT 2
16663: EQUAL
16664: NOT
16665: IFFALSE 16909
// begin ComMoveXY ( un , ShiftX ( GetX ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) , ShiftY ( GetY ( buildings [ 1 ] ) , GetDir ( buildings [ 1 ] ) , 3 ) ) ;
16667: LD_VAR 0 2
16671: PPUSH
16672: LD_VAR 0 3
16676: PUSH
16677: LD_INT 1
16679: ARRAY
16680: PPUSH
16681: CALL_OW 250
16685: PPUSH
16686: LD_VAR 0 3
16690: PUSH
16691: LD_INT 1
16693: ARRAY
16694: PPUSH
16695: CALL_OW 254
16699: PPUSH
16700: LD_INT 3
16702: PPUSH
16703: CALL_OW 272
16707: PPUSH
16708: LD_VAR 0 3
16712: PUSH
16713: LD_INT 1
16715: ARRAY
16716: PPUSH
16717: CALL_OW 251
16721: PPUSH
16722: LD_VAR 0 3
16726: PUSH
16727: LD_INT 1
16729: ARRAY
16730: PPUSH
16731: CALL_OW 254
16735: PPUSH
16736: LD_INT 3
16738: PPUSH
16739: CALL_OW 273
16743: PPUSH
16744: CALL_OW 111
// Wait ( 10 ) ;
16748: LD_INT 10
16750: PPUSH
16751: CALL_OW 67
// while HasTask ( un ) do
16755: LD_VAR 0 2
16759: PPUSH
16760: CALL_OW 314
16764: IFFALSE 16775
// begin Wait ( 10 ) ;
16766: LD_INT 10
16768: PPUSH
16769: CALL_OW 67
// end ;
16773: GO 16755
// if UnitsInside ( buildings [ 1 ] ) = 6 then
16775: LD_VAR 0 3
16779: PUSH
16780: LD_INT 1
16782: ARRAY
16783: PPUSH
16784: CALL_OW 313
16788: PUSH
16789: LD_INT 6
16791: EQUAL
16792: IFFALSE 16849
// begin ComExitBuilding ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) ;
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 1
16801: ARRAY
16802: PPUSH
16803: CALL_OW 313
16807: PUSH
16808: LD_INT 1
16810: ARRAY
16811: PPUSH
16812: CALL_OW 122
// while HasTask ( ( UnitsInside ( buildings [ 1 ] ) ) [ 1 ] ) do
16816: LD_VAR 0 3
16820: PUSH
16821: LD_INT 1
16823: ARRAY
16824: PPUSH
16825: CALL_OW 313
16829: PUSH
16830: LD_INT 1
16832: ARRAY
16833: PPUSH
16834: CALL_OW 314
16838: IFFALSE 16849
// begin Wait ( 10 ) ;
16840: LD_INT 10
16842: PPUSH
16843: CALL_OW 67
// end ;
16847: GO 16816
// end ; ComEnterUnit ( un , buildings [ 1 ] ) ;
16849: LD_VAR 0 2
16853: PPUSH
16854: LD_VAR 0 3
16858: PUSH
16859: LD_INT 1
16861: ARRAY
16862: PPUSH
16863: CALL_OW 120
// Wait ( 1 ) ;
16867: LD_INT 1
16869: PPUSH
16870: CALL_OW 67
// AddComChangeProfession ( un , class_engineer ) ;
16874: LD_VAR 0 2
16878: PPUSH
16879: LD_INT 2
16881: PPUSH
16882: CALL_OW 183
// Wait ( 1 ) ;
16886: LD_INT 1
16888: PPUSH
16889: CALL_OW 67
// AddComExitBuilding ( un ) ;
16893: LD_VAR 0 2
16897: PPUSH
16898: CALL_OW 182
// Wait ( 1 ) ;
16902: LD_INT 1
16904: PPUSH
16905: CALL_OW 67
// end ; if GetCargo ( un , mat_oil ) = 0 then
16909: LD_VAR 0 2
16913: PPUSH
16914: LD_INT 2
16916: PPUSH
16917: CALL_OW 289
16921: PUSH
16922: LD_INT 0
16924: EQUAL
16925: IFFALSE 16948
// AddComTransport ( un , buildings [ 1 ] , mat_oil ) ;
16927: LD_VAR 0 2
16931: PPUSH
16932: LD_VAR 0 3
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: PPUSH
16941: LD_INT 2
16943: PPUSH
16944: CALL_OW 211
// Wait ( 1 ) ;
16948: LD_INT 1
16950: PPUSH
16951: CALL_OW 67
// repeat Wait ( 0 0$1 ) until not HasTask ( un ) ;
16955: LD_INT 35
16957: PPUSH
16958: CALL_OW 67
16962: LD_VAR 0 2
16966: PPUSH
16967: CALL_OW 314
16971: NOT
16972: IFFALSE 16955
// if GetCargo ( un , mat_oil ) <> 0 then
16974: LD_VAR 0 2
16978: PPUSH
16979: LD_INT 2
16981: PPUSH
16982: CALL_OW 289
16986: PUSH
16987: LD_INT 0
16989: NONEQUAL
16990: IFFALSE 17108
// begin AddComMoveToArea ( un , BarrelAreas [ ShootAreaNr ] ) ;
16992: LD_VAR 0 2
16996: PPUSH
16997: LD_LOC 9
17001: PUSH
17002: LD_LOC 8
17006: ARRAY
17007: PPUSH
17008: CALL_OW 173
// Wait ( 1 ) ;
17012: LD_INT 1
17014: PPUSH
17015: CALL_OW 67
// AddComUnload ( un ) ;
17019: LD_VAR 0 2
17023: PPUSH
17024: CALL_OW 219
// Wait ( 1 ) ;
17028: LD_INT 1
17030: PPUSH
17031: CALL_OW 67
// AddComSailEvent ( un , un ) ;
17035: LD_VAR 0 2
17039: PPUSH
17040: LD_VAR 0 2
17044: PPUSH
17045: CALL_OW 224
// AddComMoveToArea ( un , StandAreas [ ShootAreaNr ] ) ;
17049: LD_VAR 0 2
17053: PPUSH
17054: LD_LOC 10
17058: PUSH
17059: LD_LOC 8
17063: ARRAY
17064: PPUSH
17065: CALL_OW 173
// Wait ( 1 ) ;
17069: LD_INT 1
17071: PPUSH
17072: CALL_OW 67
// ShootAreaNr := ShootAreaNr + 1 ;
17076: LD_ADDR_LOC 8
17080: PUSH
17081: LD_LOC 8
17085: PUSH
17086: LD_INT 1
17088: PLUS
17089: ST_TO_ADDR
// if ShootAreaNr = 6 then
17090: LD_LOC 8
17094: PUSH
17095: LD_INT 6
17097: EQUAL
17098: IFFALSE 17108
// ShootAreaNr := 1 ;
17100: LD_ADDR_LOC 8
17104: PUSH
17105: LD_INT 1
17107: ST_TO_ADDR
// end ; end ; end ;
17108: GO 16582
17110: POP
17111: POP
// end ; end ;
17112: PPOPN 3
17114: END
// every 0 0$0.1 + 0 0$0.05 marked 203 do var un , shoot_filter ;
17115: GO 17117
17117: DISABLE
17118: LD_INT 0
17120: PPUSH
17121: PPUSH
// begin shoot_filter := FilterUnitsInArea ( ShootArea , [ [ f_type , unit_human ] , [ f_class , class_engineer ] , [ f_hastask ] , [ f_nation , nation_russian ] ] ) ;
17122: LD_ADDR_VAR 0 2
17126: PUSH
17127: LD_INT 11
17129: PPUSH
17130: LD_INT 21
17132: PUSH
17133: LD_INT 1
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: PUSH
17140: LD_INT 25
17142: PUSH
17143: LD_INT 2
17145: PUSH
17146: EMPTY
17147: LIST
17148: LIST
17149: PUSH
17150: LD_INT 60
17152: PUSH
17153: EMPTY
17154: LIST
17155: PUSH
17156: LD_INT 23
17158: PUSH
17159: LD_INT 3
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: PPUSH
17172: CALL_OW 70
17176: ST_TO_ADDR
// if shoot_filter <> [ ] then
17177: LD_VAR 0 2
17181: PUSH
17182: EMPTY
17183: NONEQUAL
17184: IFFALSE 17300
// for un in shoot_filter do
17186: LD_ADDR_VAR 0 1
17190: PUSH
17191: LD_VAR 0 2
17195: PUSH
17196: FOR_IN
17197: IFFALSE 17298
// if GetTaskList ( un ) <> [ ] then
17199: LD_VAR 0 1
17203: PPUSH
17204: CALL_OW 437
17208: PUSH
17209: EMPTY
17210: NONEQUAL
17211: IFFALSE 17296
// if ( GetTaskList ( un ) [ 1 ] [ 1 ] = A ) and ( InArea ( GetTaskList ( un ) [ 1 ] [ 2 ] , GetTaskList ( un ) [ 1 ] [ 3 ] , ShootArea ) ) then
17213: LD_VAR 0 1
17217: PPUSH
17218: CALL_OW 437
17222: PUSH
17223: LD_INT 1
17225: ARRAY
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PUSH
17231: LD_STRING A
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PPUSH
17240: CALL_OW 437
17244: PUSH
17245: LD_INT 1
17247: ARRAY
17248: PUSH
17249: LD_INT 2
17251: ARRAY
17252: PPUSH
17253: LD_VAR 0 1
17257: PPUSH
17258: CALL_OW 437
17262: PUSH
17263: LD_INT 1
17265: ARRAY
17266: PUSH
17267: LD_INT 3
17269: ARRAY
17270: PPUSH
17271: LD_INT 11
17273: PPUSH
17274: CALL_OW 309
17278: AND
17279: IFFALSE 17296
// AddExperience ( un , skill_combat , 1 ) ;
17281: LD_VAR 0 1
17285: PPUSH
17286: LD_INT 1
17288: PPUSH
17289: LD_INT 1
17291: PPUSH
17292: CALL_OW 492
17296: GO 17196
17298: POP
17299: POP
// enable ;
17300: ENABLE
// end ;
17301: PPOPN 2
17303: END
// on SailEvent ( un ) do var x , y , i ;
17304: LD_INT 0
17306: PPUSH
17307: PPUSH
17308: PPUSH
// begin x := GetX ( un ) ;
17309: LD_ADDR_VAR 0 2
17313: PUSH
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL_OW 250
17323: ST_TO_ADDR
// y := GetY ( un ) ;
17324: LD_ADDR_VAR 0 3
17328: PUSH
17329: LD_VAR 0 1
17333: PPUSH
17334: CALL_OW 251
17338: ST_TO_ADDR
// for i := 0 to 5 do
17339: LD_ADDR_VAR 0 4
17343: PUSH
17344: DOUBLE
17345: LD_INT 0
17347: DEC
17348: ST_TO_ADDR
17349: LD_INT 5
17351: PUSH
17352: FOR_TO
17353: IFFALSE 17449
// if HexInfo ( ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) = - 1 then
17355: LD_VAR 0 2
17359: PPUSH
17360: LD_VAR 0 4
17364: PPUSH
17365: LD_INT 1
17367: PPUSH
17368: CALL_OW 272
17372: PPUSH
17373: LD_VAR 0 3
17377: PPUSH
17378: LD_VAR 0 4
17382: PPUSH
17383: LD_INT 1
17385: PPUSH
17386: CALL_OW 273
17390: PPUSH
17391: CALL_OW 428
17395: PUSH
17396: LD_INT 1
17398: NEG
17399: EQUAL
17400: IFFALSE 17447
// AddComAttackPlace ( un , ShiftX ( x , i , 1 ) , ShiftY ( y , i , 1 ) ) ;
17402: LD_VAR 0 1
17406: PPUSH
17407: LD_VAR 0 2
17411: PPUSH
17412: LD_VAR 0 4
17416: PPUSH
17417: LD_INT 1
17419: PPUSH
17420: CALL_OW 272
17424: PPUSH
17425: LD_VAR 0 3
17429: PPUSH
17430: LD_VAR 0 4
17434: PPUSH
17435: LD_INT 1
17437: PPUSH
17438: CALL_OW 273
17442: PPUSH
17443: CALL_OW 176
17447: GO 17352
17449: POP
17450: POP
// end ; end_of_file
17451: PPOPN 4
17453: END
// every 0 0$1 marked 301 do var filter , x , y , d , lidi , i , tmp ;
17454: GO 17456
17456: DISABLE
17457: LD_INT 0
17459: PPUSH
17460: PPUSH
17461: PPUSH
17462: PPUSH
17463: PPUSH
17464: PPUSH
17465: PPUSH
// begin FreetimeAsked := true ;
17466: LD_ADDR_EXP 68
17470: PUSH
17471: LD_INT 1
17473: ST_TO_ADDR
// if not FreeTimeGranted and ( IsOK ( Petrovova ) or IsOK ( Kirilenkova ) or IsOK ( Kapitsova ) ) and ( IsOK ( Kuzmov ) or IsOK ( Gnyevko ) or IsOK ( Titov ) or IsOK ( Oblukov ) ) then
17474: LD_EXP 59
17478: NOT
17479: PUSH
17480: LD_EXP 21
17484: PPUSH
17485: CALL_OW 302
17489: PUSH
17490: LD_EXP 4
17494: PPUSH
17495: CALL_OW 302
17499: OR
17500: PUSH
17501: LD_EXP 6
17505: PPUSH
17506: CALL_OW 302
17510: OR
17511: AND
17512: PUSH
17513: LD_EXP 10
17517: PPUSH
17518: CALL_OW 302
17522: PUSH
17523: LD_EXP 5
17527: PPUSH
17528: CALL_OW 302
17532: OR
17533: PUSH
17534: LD_EXP 18
17538: PPUSH
17539: CALL_OW 302
17543: OR
17544: PUSH
17545: LD_EXP 19
17549: PPUSH
17550: CALL_OW 302
17554: OR
17555: AND
17556: IFFALSE 18110
// begin D_FreeTime ;
17558: CALL 6376 0 0
// case Query ( QFreeTime ) of 1 :
17562: LD_STRING QFreeTime
17564: PPUSH
17565: CALL_OW 97
17569: PUSH
17570: LD_INT 1
17572: DOUBLE
17573: EQUAL
17574: IFTRUE 17578
17576: GO 18094
17578: POP
// begin FreeTimeGranted := true ;
17579: LD_ADDR_EXP 59
17583: PUSH
17584: LD_INT 1
17586: ST_TO_ADDR
// D_QrFreeTime1 ;
17587: CALL 6843 0 0
// for i in [ FreeMan , FreeWoman ] do
17591: LD_ADDR_VAR 0 6
17595: PUSH
17596: LD_EXP 57
17600: PUSH
17601: LD_EXP 58
17605: PUSH
17606: EMPTY
17607: LIST
17608: LIST
17609: PUSH
17610: FOR_IN
17611: IFFALSE 17690
// begin tmp := IsInUnit ( i ) ;
17613: LD_ADDR_VAR 0 7
17617: PUSH
17618: LD_VAR 0 6
17622: PPUSH
17623: CALL_OW 310
17627: ST_TO_ADDR
// if not tmp then
17628: LD_VAR 0 7
17632: NOT
17633: IFFALSE 17637
// continue ;
17635: GO 17610
// case GetType ( tmp ) of unit_vehicle :
17637: LD_VAR 0 7
17641: PPUSH
17642: CALL_OW 247
17646: PUSH
17647: LD_INT 2
17649: DOUBLE
17650: EQUAL
17651: IFTRUE 17655
17653: GO 17667
17655: POP
// ComExitVehicle ( i ) ; unit_building :
17656: LD_VAR 0 6
17660: PPUSH
17661: CALL_OW 121
17665: GO 17688
17667: LD_INT 3
17669: DOUBLE
17670: EQUAL
17671: IFTRUE 17675
17673: GO 17687
17675: POP
// ComExitBuilding ( i ) ; end ;
17676: LD_VAR 0 6
17680: PPUSH
17681: CALL_OW 122
17685: GO 17688
17687: POP
// end ;
17688: GO 17610
17690: POP
17691: POP
// SetSide ( [ FreeMan , FreeWoman ] , ally ) ;
17692: LD_EXP 57
17696: PUSH
17697: LD_EXP 58
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: PPUSH
17706: LD_EXP 32
17710: PPUSH
17711: CALL_OW 235
// wait ( 0 0$2 ) ;
17715: LD_INT 70
17717: PPUSH
17718: CALL_OW 67
// AddComMoveXY ( [ FreeMan , FreeWoman ] , 115 , 32 ) ;
17722: LD_EXP 57
17726: PUSH
17727: LD_EXP 58
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: PPUSH
17736: LD_INT 115
17738: PPUSH
17739: LD_INT 32
17741: PPUSH
17742: CALL_OW 171
// repeat Wait ( 0 0$1 ) ;
17746: LD_INT 35
17748: PPUSH
17749: CALL_OW 67
// lidi := FilterUnitsInArea ( HandOverEnterArea , [ f_side , ally ] ) ;
17753: LD_ADDR_VAR 0 5
17757: PUSH
17758: LD_INT 6
17760: PPUSH
17761: LD_INT 22
17763: PUSH
17764: LD_EXP 32
17768: PUSH
17769: EMPTY
17770: LIST
17771: LIST
17772: PPUSH
17773: CALL_OW 70
17777: ST_TO_ADDR
// until ( 0 + lidi ) = 2 ;
17778: LD_INT 0
17780: PUSH
17781: LD_VAR 0 5
17785: PLUS
17786: PUSH
17787: LD_INT 2
17789: EQUAL
17790: IFFALSE 17746
// RemoveUnit ( FreeMan ) ;
17792: LD_EXP 57
17796: PPUSH
17797: CALL_OW 64
// RemoveUnit ( FreeWoman ) ;
17801: LD_EXP 58
17805: PPUSH
17806: CALL_OW 64
// Wait ( 3 3$0 ) ;
17810: LD_INT 6300
17812: PPUSH
17813: CALL_OW 67
// PlaceUnitArea ( FreeMan , HandOverEnterArea , false ) ;
17817: LD_EXP 57
17821: PPUSH
17822: LD_INT 6
17824: PPUSH
17825: LD_INT 0
17827: PPUSH
17828: CALL_OW 49
// PlaceUnitArea ( FreeWoman , HandOverEnterArea , false ) ;
17832: LD_EXP 58
17836: PPUSH
17837: LD_INT 6
17839: PPUSH
17840: LD_INT 0
17842: PPUSH
17843: CALL_OW 49
// filter := FilterAllUnits ( [ [ f_side , you ] , [ [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) ;
17847: LD_ADDR_VAR 0 1
17851: PUSH
17852: LD_INT 22
17854: PUSH
17855: LD_EXP 31
17859: PUSH
17860: EMPTY
17861: LIST
17862: LIST
17863: PUSH
17864: LD_INT 2
17866: PUSH
17867: LD_INT 30
17869: PUSH
17870: LD_INT 0
17872: PUSH
17873: EMPTY
17874: LIST
17875: LIST
17876: PUSH
17877: LD_INT 30
17879: PUSH
17880: LD_INT 1
17882: PUSH
17883: EMPTY
17884: LIST
17885: LIST
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: LIST
17891: PUSH
17892: EMPTY
17893: LIST
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: PPUSH
17899: CALL_OW 69
17903: ST_TO_ADDR
// if ( 0 + filter ) <> 0 then
17904: LD_INT 0
17906: PUSH
17907: LD_VAR 0 1
17911: PLUS
17912: PUSH
17913: LD_INT 0
17915: NONEQUAL
17916: IFFALSE 17977
// begin x := GetX ( filter [ 1 ] ) ;
17918: LD_ADDR_VAR 0 2
17922: PUSH
17923: LD_VAR 0 1
17927: PUSH
17928: LD_INT 1
17930: ARRAY
17931: PPUSH
17932: CALL_OW 250
17936: ST_TO_ADDR
// y := GetY ( filter [ 1 ] ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PUSH
17947: LD_INT 1
17949: ARRAY
17950: PPUSH
17951: CALL_OW 251
17955: ST_TO_ADDR
// d := GetDir ( filter [ 1 ] ) ;
17956: LD_ADDR_VAR 0 4
17960: PUSH
17961: LD_VAR 0 1
17965: PUSH
17966: LD_INT 1
17968: ARRAY
17969: PPUSH
17970: CALL_OW 254
17974: ST_TO_ADDR
// end else
17975: GO 18015
// begin x := GetX ( Burlak ) ;
17977: LD_ADDR_VAR 0 2
17981: PUSH
17982: LD_EXP 1
17986: PPUSH
17987: CALL_OW 250
17991: ST_TO_ADDR
// y := GetY ( Burlak ) ;
17992: LD_ADDR_VAR 0 3
17996: PUSH
17997: LD_EXP 1
18001: PPUSH
18002: CALL_OW 251
18006: ST_TO_ADDR
// d := 1 ;
18007: LD_ADDR_VAR 0 4
18011: PUSH
18012: LD_INT 1
18014: ST_TO_ADDR
// end ; ComMoveXY ( [ FreeMan , FreeWoman ] , ShiftX ( x , d , 5 ) , ShiftY ( y , d , 5 ) ) ;
18015: LD_EXP 57
18019: PUSH
18020: LD_EXP 58
18024: PUSH
18025: EMPTY
18026: LIST
18027: LIST
18028: PPUSH
18029: LD_VAR 0 2
18033: PPUSH
18034: LD_VAR 0 4
18038: PPUSH
18039: LD_INT 5
18041: PPUSH
18042: CALL_OW 272
18046: PPUSH
18047: LD_VAR 0 3
18051: PPUSH
18052: LD_VAR 0 4
18056: PPUSH
18057: LD_INT 5
18059: PPUSH
18060: CALL_OW 273
18064: PPUSH
18065: CALL_OW 111
// SetSide ( [ FreeMan , FreeWoman ] , you ) ;
18069: LD_EXP 57
18073: PUSH
18074: LD_EXP 58
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: PPUSH
18083: LD_EXP 31
18087: PPUSH
18088: CALL_OW 235
// end ; 2 :
18092: GO 18110
18094: LD_INT 2
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18109
18102: POP
// D_QrFreeTime2 ; end ;
18103: CALL 6863 0 0
18107: GO 18110
18109: POP
// end ; end ; end_of_file
18110: PPOPN 7
18112: END
// export firstQuery , secondQuery , dec , isShowingQuery ; every 0 0$1 marked 401 do
18113: GO 18115
18115: DISABLE
// begin MashaAsked := true ;
18116: LD_ADDR_EXP 70
18120: PUSH
18121: LD_INT 1
18123: ST_TO_ADDR
// D_Masha ;
18124: CALL 6883 0 0
// Query ( QMasha ) ;
18128: LD_STRING QMasha
18130: PPUSH
18131: CALL_OW 97
// D_Masha2 ;
18135: CALL 6911 0 0
// ChangeMissionObjectives ( MMasha ) ;
18139: LD_STRING MMasha
18141: PPUSH
18142: CALL_OW 337
// enable ( 402 ) ;
18146: LD_INT 402
18148: ENABLE_MARKED
// firstQuery = 1 ;
18149: LD_ADDR_EXP 96
18153: PUSH
18154: LD_INT 1
18156: ST_TO_ADDR
// secondQuery = 0 ;
18157: LD_ADDR_EXP 97
18161: PUSH
18162: LD_INT 0
18164: ST_TO_ADDR
// isShowingQuery = 0 ;
18165: LD_ADDR_EXP 99
18169: PUSH
18170: LD_INT 0
18172: ST_TO_ADDR
// end ;
18173: END
// var BurlakTimeInVehicle , QMashaQueryShown , QMashaQueryRefused , BurlakWasInVehicle , BurlakNewVehicle , BurlakOldVehicle ; every 0 0$3 marked 402 do
18174: GO 18176
18176: DISABLE
// begin if GetType ( IsInUnit ( Burlak ) ) = unit_vehicle and isShowingQuery = 0 then
18177: LD_EXP 1
18181: PPUSH
18182: CALL_OW 310
18186: PPUSH
18187: CALL_OW 247
18191: PUSH
18192: LD_INT 2
18194: EQUAL
18195: PUSH
18196: LD_EXP 99
18200: PUSH
18201: LD_INT 0
18203: EQUAL
18204: AND
18205: IFFALSE 18647
// if GetWeapon ( IsInUnit ( Burlak ) ) = 42 or GetWeapon ( IsInUnit ( Burlak ) ) = 43 or GetWeapon ( IsInUnit ( Burlak ) ) = 44 or GetWeapon ( IsInUnit ( Burlak ) ) = 45 or GetWeapon ( IsInUnit ( Burlak ) ) = 46 then
18207: LD_EXP 1
18211: PPUSH
18212: CALL_OW 310
18216: PPUSH
18217: CALL_OW 264
18221: PUSH
18222: LD_INT 42
18224: EQUAL
18225: PUSH
18226: LD_EXP 1
18230: PPUSH
18231: CALL_OW 310
18235: PPUSH
18236: CALL_OW 264
18240: PUSH
18241: LD_INT 43
18243: EQUAL
18244: OR
18245: PUSH
18246: LD_EXP 1
18250: PPUSH
18251: CALL_OW 310
18255: PPUSH
18256: CALL_OW 264
18260: PUSH
18261: LD_INT 44
18263: EQUAL
18264: OR
18265: PUSH
18266: LD_EXP 1
18270: PPUSH
18271: CALL_OW 310
18275: PPUSH
18276: CALL_OW 264
18280: PUSH
18281: LD_INT 45
18283: EQUAL
18284: OR
18285: PUSH
18286: LD_EXP 1
18290: PPUSH
18291: CALL_OW 310
18295: PPUSH
18296: CALL_OW 264
18300: PUSH
18301: LD_INT 46
18303: EQUAL
18304: OR
18305: IFFALSE 18647
// begin isShowingQuery = 1 ;
18307: LD_ADDR_EXP 99
18311: PUSH
18312: LD_INT 1
18314: ST_TO_ADDR
// if secondQuery = 1 and firstQuery = 0 then
18315: LD_EXP 97
18319: PUSH
18320: LD_INT 1
18322: EQUAL
18323: PUSH
18324: LD_EXP 96
18328: PUSH
18329: LD_INT 0
18331: EQUAL
18332: AND
18333: IFFALSE 18473
// begin dec = Query ( QMashaQuery2 ) ;
18335: LD_ADDR_EXP 98
18339: PUSH
18340: LD_STRING QMashaQuery2
18342: PPUSH
18343: CALL_OW 97
18347: ST_TO_ADDR
// if dec = 1 then
18348: LD_EXP 98
18352: PUSH
18353: LD_INT 1
18355: EQUAL
18356: IFFALSE 18446
// begin disable ;
18358: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18359: LD_ADDR_EXP 60
18363: PUSH
18364: LD_EXP 1
18368: PPUSH
18369: CALL_OW 310
18373: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18374: LD_EXP 60
18378: PPUSH
18379: LD_INT 1
18381: PPUSH
18382: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18386: LD_EXP 60
18390: PPUSH
18391: CALL_OW 265
18395: PUSH
18396: LD_EXP 60
18400: PPUSH
18401: CALL_OW 262
18405: PUSH
18406: LD_EXP 60
18410: PPUSH
18411: CALL_OW 263
18415: PUSH
18416: LD_EXP 60
18420: PPUSH
18421: CALL_OW 264
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: PPUSH
18432: LD_STRING Masha
18434: PPUSH
18435: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18439: LD_STRING MMashaDone
18441: PPUSH
18442: CALL_OW 337
// end ; if dec = 2 then
18446: LD_EXP 98
18450: PUSH
18451: LD_INT 2
18453: EQUAL
18454: IFFALSE 18473
// begin ComExitVehicle ( Burlak ) ;
18456: LD_EXP 1
18460: PPUSH
18461: CALL_OW 121
// isShowingQuery = 0 ;
18465: LD_ADDR_EXP 99
18469: PUSH
18470: LD_INT 0
18472: ST_TO_ADDR
// end ; end ; if firstQuery = 1 and secondQuery = 0 then
18473: LD_EXP 96
18477: PUSH
18478: LD_INT 1
18480: EQUAL
18481: PUSH
18482: LD_EXP 97
18486: PUSH
18487: LD_INT 0
18489: EQUAL
18490: AND
18491: IFFALSE 18647
// begin dec = Query ( QMashaQuery ) ;
18493: LD_ADDR_EXP 98
18497: PUSH
18498: LD_STRING QMashaQuery
18500: PPUSH
18501: CALL_OW 97
18505: ST_TO_ADDR
// if dec = 1 then
18506: LD_EXP 98
18510: PUSH
18511: LD_INT 1
18513: EQUAL
18514: IFFALSE 18604
// begin disable ;
18516: DISABLE
// Masha = IsInUnit ( Burlak ) ;
18517: LD_ADDR_EXP 60
18521: PUSH
18522: LD_EXP 1
18526: PPUSH
18527: CALL_OW 310
18531: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
18532: LD_EXP 60
18536: PPUSH
18537: LD_INT 1
18539: PPUSH
18540: CALL_OW 242
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , Masha ) ;
18544: LD_EXP 60
18548: PPUSH
18549: CALL_OW 265
18553: PUSH
18554: LD_EXP 60
18558: PPUSH
18559: CALL_OW 262
18563: PUSH
18564: LD_EXP 60
18568: PPUSH
18569: CALL_OW 263
18573: PUSH
18574: LD_EXP 60
18578: PPUSH
18579: CALL_OW 264
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: LIST
18588: LIST
18589: PPUSH
18590: LD_STRING Masha
18592: PPUSH
18593: CALL_OW 39
// ChangeMissionObjectives ( MMashaDone ) ;
18597: LD_STRING MMashaDone
18599: PPUSH
18600: CALL_OW 337
// end ; if dec = 2 then
18604: LD_EXP 98
18608: PUSH
18609: LD_INT 2
18611: EQUAL
18612: IFFALSE 18647
// begin ComExitVehicle ( Burlak ) ;
18614: LD_EXP 1
18618: PPUSH
18619: CALL_OW 121
// firstQuery = 0 ;
18623: LD_ADDR_EXP 96
18627: PUSH
18628: LD_INT 0
18630: ST_TO_ADDR
// secondQuery = 1 ;
18631: LD_ADDR_EXP 97
18635: PUSH
18636: LD_INT 1
18638: ST_TO_ADDR
// isShowingQuery = 0 ;
18639: LD_ADDR_EXP 99
18643: PUSH
18644: LD_INT 0
18646: ST_TO_ADDR
// end ; end ; end ; enable ;
18647: ENABLE
// end ; end_of_file
18648: END
// var amcount ; export function prepare_am_attack ; var rndclass , rndlevel , i ; begin
18649: LD_INT 0
18651: PPUSH
18652: PPUSH
18653: PPUSH
18654: PPUSH
// if MercPaid then
18655: LD_EXP 39
18659: IFFALSE 18673
// amcount := weaker else
18661: LD_ADDR_LOC 17
18665: PUSH
18666: LD_EXP 75
18670: ST_TO_ADDR
18671: GO 18683
// amcount := stronger ;
18673: LD_ADDR_LOC 17
18677: PUSH
18678: LD_EXP 76
18682: ST_TO_ADDR
// for i := 1 to amcount do
18683: LD_ADDR_VAR 0 4
18687: PUSH
18688: DOUBLE
18689: LD_INT 1
18691: DEC
18692: ST_TO_ADDR
18693: LD_LOC 17
18697: PUSH
18698: FOR_TO
18699: IFFALSE 18852
// begin uc_side := usa ;
18701: LD_ADDR_OWVAR 20
18705: PUSH
18706: LD_EXP 35
18710: ST_TO_ADDR
// uc_nation := nation_american ;
18711: LD_ADDR_OWVAR 21
18715: PUSH
18716: LD_INT 1
18718: ST_TO_ADDR
// rndclass := Rand ( 1 , 3 ) ;
18719: LD_ADDR_VAR 0 2
18723: PUSH
18724: LD_INT 1
18726: PPUSH
18727: LD_INT 3
18729: PPUSH
18730: CALL_OW 12
18734: ST_TO_ADDR
// case rndclass of 1 :
18735: LD_VAR 0 2
18739: PUSH
18740: LD_INT 1
18742: DOUBLE
18743: EQUAL
18744: IFTRUE 18748
18746: GO 18766
18748: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; 2 :
18749: LD_INT 0
18751: PPUSH
18752: LD_INT 1
18754: PPUSH
18755: LD_EXP 74
18759: PPUSH
18760: CALL_OW 380
18764: GO 18819
18766: LD_INT 2
18768: DOUBLE
18769: EQUAL
18770: IFTRUE 18774
18772: GO 18792
18774: POP
// PrepareHuman ( 0 , class_sniper , am_attack_skill ) ; 3 :
18775: LD_INT 0
18777: PPUSH
18778: LD_INT 5
18780: PPUSH
18781: LD_EXP 74
18785: PPUSH
18786: CALL_OW 380
18790: GO 18819
18792: LD_INT 3
18794: DOUBLE
18795: EQUAL
18796: IFTRUE 18800
18798: GO 18818
18800: POP
// PrepareHuman ( 0 , class_soldier , am_attack_skill ) ; end ;
18801: LD_INT 0
18803: PPUSH
18804: LD_INT 1
18806: PPUSH
18807: LD_EXP 74
18811: PPUSH
18812: CALL_OW 380
18816: GO 18819
18818: POP
// hc_name :=  ;
18819: LD_ADDR_OWVAR 26
18823: PUSH
18824: LD_STRING 
18826: ST_TO_ADDR
// amattack := amattack ^ CreateHuman ;
18827: LD_ADDR_EXP 27
18831: PUSH
18832: LD_EXP 27
18836: PUSH
18837: CALL_OW 44
18841: ADD
18842: ST_TO_ADDR
// Wait ( 1 ) ;
18843: LD_INT 1
18845: PPUSH
18846: CALL_OW 67
// end ;
18850: GO 18698
18852: POP
18853: POP
// end ;
18854: LD_VAR 0 1
18858: RET
// function place_am_attack ; var i , reg_id ; begin
18859: LD_INT 0
18861: PPUSH
18862: PPUSH
18863: PPUSH
// for i := 1 to amcount do
18864: LD_ADDR_VAR 0 2
18868: PUSH
18869: DOUBLE
18870: LD_INT 1
18872: DEC
18873: ST_TO_ADDR
18874: LD_LOC 17
18878: PUSH
18879: FOR_TO
18880: IFFALSE 18912
// begin PlaceUnitArea ( amattack [ i ] , AmEnterArea , false ) ;
18882: LD_EXP 27
18886: PUSH
18887: LD_VAR 0 2
18891: ARRAY
18892: PPUSH
18893: LD_INT 9
18895: PPUSH
18896: LD_INT 0
18898: PPUSH
18899: CALL_OW 49
// Wait ( 1 ) ;
18903: LD_INT 1
18905: PPUSH
18906: CALL_OW 67
// end ;
18910: GO 18879
18912: POP
18913: POP
// reg_id := McRegistry ( usa , [ [ mc_reg_area_to_guard , WholeMapArea ] , - mc_reg_only_important , mc_reg_ignore_fog ] ) ;
18914: LD_ADDR_VAR 0 3
18918: PUSH
18919: LD_EXP 35
18923: PPUSH
18924: LD_INT 2
18926: PUSH
18927: LD_INT 10
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: PUSH
18934: LD_INT 8
18936: NEG
18937: PUSH
18938: LD_INT 7
18940: PUSH
18941: EMPTY
18942: LIST
18943: LIST
18944: LIST
18945: PPUSH
18946: CALL_OW 399
18950: ST_TO_ADDR
// McAttack ( 100 , reg_id , amattack , [ mc_no_stop , mc_pat_aggresive , mc_murder ] ) ;
18951: LD_INT 100
18953: PPUSH
18954: LD_VAR 0 3
18958: PPUSH
18959: LD_EXP 27
18963: PPUSH
18964: LD_INT 10
18966: PUSH
18967: LD_INT 11
18969: PUSH
18970: LD_INT 12
18972: PUSH
18973: EMPTY
18974: LIST
18975: LIST
18976: LIST
18977: PPUSH
18978: CALL_OW 402
// end ;
18982: LD_VAR 0 1
18986: RET
// every 0 0$1 marked 501 do
18987: GO 18989
18989: DISABLE
// begin AmAttackStarted := true ;
18990: LD_ADDR_EXP 71
18994: PUSH
18995: LD_INT 1
18997: ST_TO_ADDR
// D_AmAttackStart ;
18998: CALL 7147 0 0
// Wait ( 0 0$15 ) ;
19002: LD_INT 525
19004: PPUSH
19005: CALL_OW 67
// place_am_attack ;
19009: CALL 18859 0 0
// enable ( 502 ) ;
19013: LD_INT 502
19015: ENABLE_MARKED
// end ;
19016: END
// every 0 0$10 marked 502 do
19017: GO 19019
19019: DISABLE
// begin if amattack = [ ] then
19020: LD_EXP 27
19024: PUSH
19025: EMPTY
19026: EQUAL
19027: IFFALSE 19044
// begin disable ;
19029: DISABLE
// AmAttackDone := true ;
19030: LD_ADDR_EXP 64
19034: PUSH
19035: LD_INT 1
19037: ST_TO_ADDR
// D_AmAttackFin ;
19038: CALL 7236 0 0
// end else
19042: GO 19045
// enable ;
19044: ENABLE
// end ; end_of_file
19045: END
// every 0 0$2 + 0 0$0.1 do
19046: GO 19048
19048: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
19049: LD_INT 22
19051: PUSH
19052: LD_INT 3
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: LD_INT 2
19061: PUSH
19062: LD_INT 25
19064: PUSH
19065: LD_INT 12
19067: PUSH
19068: EMPTY
19069: LIST
19070: LIST
19071: PUSH
19072: LD_INT 25
19074: PUSH
19075: LD_INT 16
19077: PUSH
19078: EMPTY
19079: LIST
19080: LIST
19081: PUSH
19082: LD_INT 25
19084: PUSH
19085: LD_INT 15
19087: PUSH
19088: EMPTY
19089: LIST
19090: LIST
19091: PUSH
19092: LD_INT 25
19094: PUSH
19095: LD_INT 17
19097: PUSH
19098: EMPTY
19099: LIST
19100: LIST
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: LIST
19106: LIST
19107: LIST
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: PPUSH
19113: CALL_OW 69
19117: PUSH
19118: LD_INT 22
19120: PUSH
19121: LD_INT 3
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: PUSH
19128: LD_INT 21
19130: PUSH
19131: LD_INT 1
19133: PUSH
19134: EMPTY
19135: LIST
19136: LIST
19137: PUSH
19138: LD_INT 3
19140: PUSH
19141: LD_INT 2
19143: PUSH
19144: LD_INT 25
19146: PUSH
19147: LD_INT 12
19149: PUSH
19150: EMPTY
19151: LIST
19152: LIST
19153: PUSH
19154: LD_INT 25
19156: PUSH
19157: LD_INT 16
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: PUSH
19164: LD_INT 25
19166: PUSH
19167: LD_INT 15
19169: PUSH
19170: EMPTY
19171: LIST
19172: LIST
19173: PUSH
19174: LD_INT 25
19176: PUSH
19177: LD_INT 17
19179: PUSH
19180: EMPTY
19181: LIST
19182: LIST
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: LIST
19199: PPUSH
19200: CALL_OW 69
19204: GREATER
19205: IFFALSE 19216
// begin SetAchievement ( ACH_POTA ) ;
19207: LD_STRING ACH_POTA
19209: PPUSH
19210: CALL_OW 543
// exit ;
19214: GO 19217
// end ; enable ;
19216: ENABLE
// end ;
19217: END
// export function SA_OnLegionHandoverToUPF ; begin
19218: LD_INT 0
19220: PPUSH
// SetAchievement ( ACH_SC ) ;
19221: LD_STRING ACH_SC
19223: PPUSH
19224: CALL_OW 543
// end ;
19228: LD_VAR 0 1
19232: RET
// export function SA_OnMissionCompleteAndArBarracksBuildAndNotHeikeHandover ; begin
19233: LD_INT 0
19235: PPUSH
// SetAchievement ( ACH_GAME ) ;
19236: LD_STRING ACH_GAME
19238: PPUSH
19239: CALL_OW 543
// end ; end_of_file
19243: LD_VAR 0 1
19247: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
19248: LD_INT 0
19250: PPUSH
19251: PPUSH
// if not missionNumber then
19252: LD_VAR 0 2
19256: NOT
19257: IFFALSE 19261
// exit ;
19259: GO 19391
// achiv := false ;
19261: LD_ADDR_VAR 0 7
19265: PUSH
19266: LD_INT 0
19268: ST_TO_ADDR
// case campaignNumber of 1 :
19269: LD_VAR 0 1
19273: PUSH
19274: LD_INT 1
19276: DOUBLE
19277: EQUAL
19278: IFTRUE 19282
19280: GO 19293
19282: POP
// achiv := ACH_GOTA ; 2 :
19283: LD_ADDR_VAR 0 7
19287: PUSH
19288: LD_STRING ACH_GOTA
19290: ST_TO_ADDR
19291: GO 19343
19293: LD_INT 2
19295: DOUBLE
19296: EQUAL
19297: IFTRUE 19301
19299: GO 19304
19301: POP
// ; 3 :
19302: GO 19343
19304: LD_INT 3
19306: DOUBLE
19307: EQUAL
19308: IFTRUE 19312
19310: GO 19323
19312: POP
// achiv := ACH_MOTSU ; 4 :
19313: LD_ADDR_VAR 0 7
19317: PUSH
19318: LD_STRING ACH_MOTSU
19320: ST_TO_ADDR
19321: GO 19343
19323: LD_INT 4
19325: DOUBLE
19326: EQUAL
19327: IFTRUE 19331
19329: GO 19342
19331: POP
// achiv := ACH_LOP ; end ;
19332: LD_ADDR_VAR 0 7
19336: PUSH
19337: LD_STRING ACH_LOP
19339: ST_TO_ADDR
19340: GO 19343
19342: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
19343: LD_OWVAR 67
19347: PUSH
19348: LD_INT 3
19350: EQUAL
19351: PUSH
19352: LD_VAR 0 7
19356: AND
19357: PUSH
19358: LD_VAR 0 3
19362: AND
19363: PUSH
19364: LD_VAR 0 4
19368: AND
19369: PUSH
19370: LD_VAR 0 5
19374: AND
19375: IFFALSE 19391
// SetAchievementEX ( achiv , missionNumber ) ;
19377: LD_VAR 0 7
19381: PPUSH
19382: LD_VAR 0 2
19386: PPUSH
19387: CALL_OW 564
// end ;
19391: LD_VAR 0 6
19395: RET
// export function SA_BehemothConstructed ; begin
19396: LD_INT 0
19398: PPUSH
// SetAchievement ( ACH_SMC ) ;
19399: LD_STRING ACH_SMC
19401: PPUSH
19402: CALL_OW 543
// end ;
19406: LD_VAR 0 1
19410: RET
