// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 3 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 3
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$45 , 0 0$40 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1575
 345: PUSH
 346: LD_INT 1400
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 4200
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// if scientists > 5 then
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1304
// for i := 6 to scientists do
1260: LD_ADDR_VAR 0 3
1264: PUSH
1265: DOUBLE
1266: LD_INT 6
1268: DEC
1269: ST_TO_ADDR
1270: LD_EXP 40
1274: PUSH
1275: FOR_TO
1276: IFFALSE 1302
// scientists := scientists diff scientists [ i ] ;
1278: LD_ADDR_EXP 40
1282: PUSH
1283: LD_EXP 40
1287: PUSH
1288: LD_EXP 40
1292: PUSH
1293: LD_VAR 0 3
1297: ARRAY
1298: DIFF
1299: ST_TO_ADDR
1300: GO 1275
1302: POP
1303: POP
// survivors3 = survivors3 diff scientists ;
1304: LD_ADDR_EXP 22
1308: PUSH
1309: LD_EXP 22
1313: PUSH
1314: LD_EXP 40
1318: DIFF
1319: ST_TO_ADDR
// if scientists < 5 then
1320: LD_EXP 40
1324: PUSH
1325: LD_INT 5
1327: LESS
1328: IFFALSE 1419
// for i := 1 to 5 - scientists do
1330: LD_ADDR_VAR 0 3
1334: PUSH
1335: DOUBLE
1336: LD_INT 1
1338: DEC
1339: ST_TO_ADDR
1340: LD_INT 5
1342: PUSH
1343: LD_EXP 40
1347: MINUS
1348: PUSH
1349: FOR_TO
1350: IFFALSE 1417
// begin uc_side = ally ;
1352: LD_ADDR_OWVAR 20
1356: PUSH
1357: LD_EXP 25
1361: ST_TO_ADDR
// uc_nation := nation_russian ;
1362: LD_ADDR_OWVAR 21
1366: PUSH
1367: LD_INT 3
1369: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1370: LD_INT 0
1372: PPUSH
1373: LD_INT 4
1375: PPUSH
1376: LD_INT 5
1378: PPUSH
1379: LD_INT 7
1381: PPUSH
1382: CALL_OW 12
1386: PPUSH
1387: CALL_OW 380
// hc_name :=  ;
1391: LD_ADDR_OWVAR 26
1395: PUSH
1396: LD_STRING 
1398: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1399: LD_ADDR_EXP 40
1403: PUSH
1404: LD_EXP 40
1408: PUSH
1409: CALL_OW 44
1413: ADD
1414: ST_TO_ADDR
// end ;
1415: GO 1349
1417: POP
1418: POP
// for un in scientists do
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_EXP 40
1428: PUSH
1429: FOR_IN
1430: IFFALSE 1448
// SetSide ( un , ally ) ;
1432: LD_VAR 0 2
1436: PPUSH
1437: LD_EXP 25
1441: PPUSH
1442: CALL_OW 235
1446: GO 1429
1448: POP
1449: POP
// possible := all_possible diff scientists ;
1450: LD_ADDR_EXP 38
1454: PUSH
1455: LD_EXP 39
1459: PUSH
1460: LD_EXP 40
1464: DIFF
1465: ST_TO_ADDR
// if scientists > 5 then
1466: LD_EXP 40
1470: PUSH
1471: LD_INT 5
1473: GREATER
1474: IFFALSE 1518
// for i = scientists downto 5 do
1476: LD_ADDR_VAR 0 3
1480: PUSH
1481: DOUBLE
1482: LD_EXP 40
1486: INC
1487: ST_TO_ADDR
1488: LD_INT 5
1490: PUSH
1491: FOR_DOWNTO
1492: IFFALSE 1516
// scientists := Delete ( scientists , i ) ;
1494: LD_ADDR_EXP 40
1498: PUSH
1499: LD_EXP 40
1503: PPUSH
1504: LD_VAR 0 3
1508: PPUSH
1509: CALL_OW 3
1513: ST_TO_ADDR
1514: GO 1491
1516: POP
1517: POP
// for un in scientists do
1518: LD_ADDR_VAR 0 2
1522: PUSH
1523: LD_EXP 40
1527: PUSH
1528: FOR_IN
1529: IFFALSE 1545
// PlaceHumanInUnit ( un , 2 ) ;
1531: LD_VAR 0 2
1535: PPUSH
1536: LD_INT 2
1538: PPUSH
1539: CALL_OW 52
1543: GO 1528
1545: POP
1546: POP
// new := [ ] ;
1547: LD_ADDR_EXP 36
1551: PUSH
1552: EMPTY
1553: ST_TO_ADDR
// if possible < 10 then
1554: LD_EXP 38
1558: PUSH
1559: LD_INT 10
1561: LESS
1562: IFFALSE 1645
// for i := 1 to 10 - possible do
1564: LD_ADDR_VAR 0 3
1568: PUSH
1569: DOUBLE
1570: LD_INT 1
1572: DEC
1573: ST_TO_ADDR
1574: LD_INT 10
1576: PUSH
1577: LD_EXP 38
1581: MINUS
1582: PUSH
1583: FOR_TO
1584: IFFALSE 1643
// begin uc_side = rus ;
1586: LD_ADDR_OWVAR 20
1590: PUSH
1591: LD_EXP 24
1595: ST_TO_ADDR
// uc_nation := nation_russian ;
1596: LD_ADDR_OWVAR 21
1600: PUSH
1601: LD_INT 3
1603: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1604: LD_INT 0
1606: PPUSH
1607: LD_INT 0
1609: PPUSH
1610: LD_INT 5
1612: PPUSH
1613: CALL_OW 380
// hc_name :=  ;
1617: LD_ADDR_OWVAR 26
1621: PUSH
1622: LD_STRING 
1624: ST_TO_ADDR
// new := new ^ CreateHuman ;
1625: LD_ADDR_EXP 36
1629: PUSH
1630: LD_EXP 36
1634: PUSH
1635: CALL_OW 44
1639: ADD
1640: ST_TO_ADDR
// end ;
1641: GO 1583
1643: POP
1644: POP
// uc_side = rus ;
1645: LD_ADDR_OWVAR 20
1649: PUSH
1650: LD_EXP 24
1654: ST_TO_ADDR
// uc_nation := nation_russian ;
1655: LD_ADDR_OWVAR 21
1659: PUSH
1660: LD_INT 3
1662: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1663: LD_ADDR_EXP 1
1667: PUSH
1668: LD_STRING Burlak
1670: PPUSH
1671: CALL 565 0 1
1675: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1676: LD_EXP 1
1680: PPUSH
1681: LD_INT 3
1683: PPUSH
1684: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1688: LD_ADDR_EXP 20
1692: PUSH
1693: LD_STRING Platonov
1695: PPUSH
1696: CALL_OW 25
1700: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1701: LD_INT 1
1703: PPUSH
1704: LD_INT 1
1706: PPUSH
1707: LD_INT 4
1709: PPUSH
1710: CALL_OW 380
// hc_name :=  ;
1714: LD_ADDR_OWVAR 26
1718: PUSH
1719: LD_STRING 
1721: ST_TO_ADDR
// RSoldier := CreateHuman ;
1722: LD_ADDR_EXP 21
1726: PUSH
1727: CALL_OW 44
1731: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1732: LD_ADDR_VAR 0 3
1736: PUSH
1737: DOUBLE
1738: LD_INT 1
1740: DEC
1741: ST_TO_ADDR
1742: LD_EXP 31
1746: PUSH
1747: LD_INT 3
1749: PUSH
1750: LD_EXP 30
1754: MUL
1755: PLUS
1756: PUSH
1757: FOR_TO
1758: IFFALSE 1850
// begin case Rand ( 1 , 2 ) of 1 :
1760: LD_INT 1
1762: PPUSH
1763: LD_INT 2
1765: PPUSH
1766: CALL_OW 12
1770: PUSH
1771: LD_INT 1
1773: DOUBLE
1774: EQUAL
1775: IFTRUE 1779
1777: GO 1797
1779: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1780: LD_INT 1
1782: PPUSH
1783: LD_INT 1
1785: PPUSH
1786: LD_EXP 32
1790: PPUSH
1791: CALL_OW 380
1795: GO 1824
1797: LD_INT 2
1799: DOUBLE
1800: EQUAL
1801: IFTRUE 1805
1803: GO 1823
1805: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 9
1811: PPUSH
1812: LD_EXP 32
1816: PPUSH
1817: CALL_OW 380
1821: GO 1824
1823: POP
// hc_name :=  ;
1824: LD_ADDR_OWVAR 26
1828: PUSH
1829: LD_STRING 
1831: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1832: LD_ADDR_EXP 29
1836: PUSH
1837: LD_EXP 29
1841: PUSH
1842: CALL_OW 44
1846: ADD
1847: ST_TO_ADDR
// end ;
1848: GO 1757
1850: POP
1851: POP
// end ;
1852: LD_VAR 0 1
1856: RET
// function select_people ; var units , un ; begin
1857: LD_INT 0
1859: PPUSH
1860: PPUSH
1861: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING 
1869: PPUSH
1870: LD_INT 5
1872: PPUSH
1873: LD_INT 5
1875: PPUSH
1876: LD_INT -1
1878: PUSH
1879: LD_INT -4
1881: PUSH
1882: LD_INT -6
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: PUSH
1890: LD_EXP 1
1894: ADD
1895: PUSH
1896: LD_INT -2
1898: PUSH
1899: LD_INT -4
1901: PUSH
1902: LD_INT -6
1904: PUSH
1905: EMPTY
1906: LIST
1907: LIST
1908: LIST
1909: ADD
1910: PUSH
1911: LD_EXP 20
1915: ADD
1916: PUSH
1917: LD_INT -2
1919: PUSH
1920: LD_INT -5
1922: PUSH
1923: LD_INT -3
1925: PUSH
1926: EMPTY
1927: LIST
1928: LIST
1929: LIST
1930: ADD
1931: PUSH
1932: LD_EXP 38
1936: ADD
1937: PUSH
1938: LD_EXP 22
1942: ADD
1943: PUSH
1944: LD_EXP 36
1948: ADD
1949: PPUSH
1950: LD_INT 1
1952: PUSH
1953: LD_INT 3
1955: PUSH
1956: LD_INT 2
1958: PUSH
1959: LD_INT 4
1961: PUSH
1962: LD_INT 9
1964: PUSH
1965: LD_INT 0
1967: PUSH
1968: LD_INT 2
1970: PUSH
1971: EMPTY
1972: LIST
1973: LIST
1974: LIST
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: PPUSH
1983: CALL_OW 42
1987: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1988: LD_EXP 41
1992: PUSH
1993: LD_EXP 1
1997: DIFF
1998: PPUSH
1999: LD_EXP 27
2003: PPUSH
2004: CALL_OW 235
// for un in ( player_units diff Burlak ) do
2008: LD_ADDR_VAR 0 3
2012: PUSH
2013: LD_EXP 41
2017: PUSH
2018: LD_EXP 1
2022: DIFF
2023: PUSH
2024: FOR_IN
2025: IFFALSE 2044
// PlaceUnitArea ( un , BaseArea , false ) ;
2027: LD_VAR 0 3
2031: PPUSH
2032: LD_INT 2
2034: PPUSH
2035: LD_INT 0
2037: PPUSH
2038: CALL_OW 49
2042: GO 2024
2044: POP
2045: POP
// end ;
2046: LD_VAR 0 1
2050: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
2051: LD_INT 0
2053: PPUSH
2054: PPUSH
2055: PPUSH
2056: PPUSH
2057: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
2058: LD_ADDR_VAR 0 3
2062: PUSH
2063: LD_STRING EscapeVehicle_12a
2065: PPUSH
2066: LD_INT 1
2068: PUSH
2069: LD_INT 0
2071: PUSH
2072: LD_INT 0
2074: PUSH
2075: EMPTY
2076: LIST
2077: LIST
2078: LIST
2079: PPUSH
2080: CALL_OW 30
2084: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2085: LD_ADDR_LOC 1
2089: PUSH
2090: LD_VAR 0 3
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2099: LD_ADDR_VAR 0 4
2103: PUSH
2104: LD_VAR 0 3
2108: PUSH
2109: LD_INT 2
2111: ARRAY
2112: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2113: LD_ADDR_VAR 0 5
2117: PUSH
2118: LD_VAR 0 3
2122: PUSH
2123: LD_INT 3
2125: ARRAY
2126: ST_TO_ADDR
// if MashaWanted then
2127: LD_LOC 1
2131: IFFALSE 2335
// begin veh := LoadVariable ( Masha , false ) ;
2133: LD_ADDR_VAR 0 2
2137: PUSH
2138: LD_STRING Masha
2140: PPUSH
2141: LD_INT 0
2143: PPUSH
2144: CALL_OW 30
2148: ST_TO_ADDR
// if veh then
2149: LD_VAR 0 2
2153: IFFALSE 2257
// begin uc_side := rus ;
2155: LD_ADDR_OWVAR 20
2159: PUSH
2160: LD_EXP 24
2164: ST_TO_ADDR
// uc_nation := nation_russian ;
2165: LD_ADDR_OWVAR 21
2169: PUSH
2170: LD_INT 3
2172: ST_TO_ADDR
// uc_direction := 2 ;
2173: LD_ADDR_OWVAR 24
2177: PUSH
2178: LD_INT 2
2180: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2181: LD_ADDR_OWVAR 37
2185: PUSH
2186: LD_VAR 0 2
2190: PUSH
2191: LD_INT 1
2193: ARRAY
2194: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2195: LD_ADDR_OWVAR 39
2199: PUSH
2200: LD_VAR 0 2
2204: PUSH
2205: LD_INT 2
2207: ARRAY
2208: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2209: LD_ADDR_OWVAR 38
2213: PUSH
2214: LD_VAR 0 2
2218: PUSH
2219: LD_INT 3
2221: ARRAY
2222: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2223: LD_ADDR_OWVAR 40
2227: PUSH
2228: LD_VAR 0 2
2232: PUSH
2233: LD_INT 4
2235: ARRAY
2236: ST_TO_ADDR
// RealMasha := true ;
2237: LD_ADDR_EXP 42
2241: PUSH
2242: LD_INT 1
2244: ST_TO_ADDR
// Masha := CreateVehicle ;
2245: LD_ADDR_EXP 43
2249: PUSH
2250: CALL_OW 45
2254: ST_TO_ADDR
// end else
2255: GO 2333
// begin uc_side := rus ;
2257: LD_ADDR_OWVAR 20
2261: PUSH
2262: LD_EXP 24
2266: ST_TO_ADDR
// uc_nation := nation_russian ;
2267: LD_ADDR_OWVAR 21
2271: PUSH
2272: LD_INT 3
2274: ST_TO_ADDR
// uc_direction := 2 ;
2275: LD_ADDR_OWVAR 24
2279: PUSH
2280: LD_INT 2
2282: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2283: LD_ADDR_OWVAR 37
2287: PUSH
2288: LD_INT 22
2290: ST_TO_ADDR
// vc_engine := engine_siberite ;
2291: LD_ADDR_OWVAR 39
2295: PUSH
2296: LD_INT 3
2298: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2299: LD_ADDR_OWVAR 40
2303: PUSH
2304: LD_INT 43
2306: ST_TO_ADDR
// vc_control := control_manual ;
2307: LD_ADDR_OWVAR 38
2311: PUSH
2312: LD_INT 1
2314: ST_TO_ADDR
// RealMasha := false ;
2315: LD_ADDR_EXP 42
2319: PUSH
2320: LD_INT 0
2322: ST_TO_ADDR
// Masha := CreateVehicle ;
2323: LD_ADDR_EXP 43
2327: PUSH
2328: CALL_OW 45
2332: ST_TO_ADDR
// end ; end else
2333: GO 2415
// begin uc_side := rus ;
2335: LD_ADDR_OWVAR 20
2339: PUSH
2340: LD_EXP 24
2344: ST_TO_ADDR
// uc_nation := nation_russian ;
2345: LD_ADDR_OWVAR 21
2349: PUSH
2350: LD_INT 3
2352: ST_TO_ADDR
// uc_direction := 2 ;
2353: LD_ADDR_OWVAR 24
2357: PUSH
2358: LD_INT 2
2360: ST_TO_ADDR
// vc_chassis := Chassis ;
2361: LD_ADDR_OWVAR 37
2365: PUSH
2366: LD_VAR 0 4
2370: ST_TO_ADDR
// vc_engine := engine_siberite ;
2371: LD_ADDR_OWVAR 39
2375: PUSH
2376: LD_INT 3
2378: ST_TO_ADDR
// vc_weapon := Weapon ;
2379: LD_ADDR_OWVAR 40
2383: PUSH
2384: LD_VAR 0 5
2388: ST_TO_ADDR
// vc_control := control_manual ;
2389: LD_ADDR_OWVAR 38
2393: PUSH
2394: LD_INT 1
2396: ST_TO_ADDR
// RealMasha := false ;
2397: LD_ADDR_EXP 42
2401: PUSH
2402: LD_INT 0
2404: ST_TO_ADDR
// Masha := CreateVehicle ;
2405: LD_ADDR_EXP 43
2409: PUSH
2410: CALL_OW 45
2414: ST_TO_ADDR
// end ; SetMark ( Masha , 1 ) ;
2415: LD_EXP 43
2419: PPUSH
2420: LD_INT 1
2422: PPUSH
2423: CALL_OW 242
// if GetEngine ( Masha ) <> engine_siberite then
2427: LD_EXP 43
2431: PPUSH
2432: CALL_OW 262
2436: PUSH
2437: LD_INT 3
2439: NONEQUAL
2440: IFFALSE 2462
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2442: LD_EXP 43
2446: PPUSH
2447: LD_INT 70
2449: PPUSH
2450: LD_INT 95
2452: PPUSH
2453: CALL_OW 12
2457: PPUSH
2458: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2462: LD_EXP 43
2466: PPUSH
2467: LD_INT 47
2469: PPUSH
2470: LD_INT 87
2472: PPUSH
2473: LD_INT 0
2475: PPUSH
2476: CALL_OW 48
// end ;
2480: LD_VAR 0 1
2484: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2485: LD_INT 1
2487: PPUSH
2488: LD_STRING bluekher
2490: PPUSH
2491: CALL_OW 500
// IngameOn ;
2495: CALL_OW 8
// Randomize ;
2499: CALL_OW 10
// RandomizeAll ;
2503: CALL_OW 11
// InitBc ;
2507: CALL_OW 21
// InitHc ;
2511: CALL_OW 19
// InitUc ;
2515: CALL_OW 18
// InitVc ;
2519: CALL_OW 20
// disable ( 1 ) ;
2523: LD_INT 1
2525: DISABLE_MARKED
// disable ( 2 ) ;
2526: LD_INT 2
2528: DISABLE_MARKED
// disable ( 3 ) ;
2529: LD_INT 3
2531: DISABLE_MARKED
// disable ( 4 ) ;
2532: LD_INT 4
2534: DISABLE_MARKED
// disable ( 6 ) ;
2535: LD_INT 6
2537: DISABLE_MARKED
// disable ( 7 ) ;
2538: LD_INT 7
2540: DISABLE_MARKED
// disable ( 8 ) ;
2541: LD_INT 8
2543: DISABLE_MARKED
// disable ( 9 ) ;
2544: LD_INT 9
2546: DISABLE_MARKED
// disable ( 333 ) ;
2547: LD_INT 333
2549: DISABLE_MARKED
// disable ( 337 ) ;
2550: LD_INT 337
2552: DISABLE_MARKED
// disable ( 401 ) ;
2553: LD_INT 401
2555: DISABLE_MARKED
// read_parameters ;
2556: CALL 0 0 0
// set_difficulty ;
2560: CALL 257 0 0
// create_people ;
2564: CALL 609 0 0
// select_people ;
2568: CALL 1857 0 0
// place_masha ;
2572: CALL 2051 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2576: LD_INT 53
2578: PPUSH
2579: LD_INT 90
2581: PPUSH
2582: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2586: LD_EXP 1
2590: PPUSH
2591: LD_INT 51
2593: PPUSH
2594: LD_INT 88
2596: PPUSH
2597: LD_INT 0
2599: PPUSH
2600: CALL_OW 48
// ComHold ( Burlak ) ;
2604: LD_EXP 1
2608: PPUSH
2609: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2613: LD_EXP 21
2617: PPUSH
2618: LD_INT 54
2620: PPUSH
2621: LD_INT 90
2623: PPUSH
2624: LD_INT 0
2626: PPUSH
2627: CALL_OW 48
// ComHold ( RSoldier ) ;
2631: LD_EXP 21
2635: PPUSH
2636: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2640: LD_EXP 1
2644: PPUSH
2645: LD_EXP 21
2649: PPUSH
2650: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2654: LD_EXP 21
2658: PPUSH
2659: LD_EXP 1
2663: PPUSH
2664: CALL_OW 119
// D_Platonov ;
2668: CALL 5318 0 0
// IngameOff ;
2672: CALL_OW 9
// SaveForQuickRestart ;
2676: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2680: LD_STRING MRun
2682: PPUSH
2683: CALL_OW 337
// ComMoveXY ( Burlak , 39 , 67 ) ;
2687: LD_EXP 1
2691: PPUSH
2692: LD_INT 39
2694: PPUSH
2695: LD_INT 67
2697: PPUSH
2698: CALL_OW 111
// ChangeSideFog ( you , you ) ;
2702: LD_EXP 23
2706: PPUSH
2707: LD_EXP 23
2711: PPUSH
2712: CALL_OW 343
// SetSide ( Burlak , you ) ;
2716: LD_EXP 1
2720: PPUSH
2721: LD_EXP 23
2725: PPUSH
2726: CALL_OW 235
// SetSide ( Masha , you ) ;
2730: LD_EXP 43
2734: PPUSH
2735: LD_EXP 23
2739: PPUSH
2740: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PUSH
2755: LD_INT 1
2757: DOUBLE
2758: EQUAL
2759: IFTRUE 2763
2761: GO 2821
2763: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2764: LD_ADDR_LOC 2
2768: PUSH
2769: DOUBLE
2770: LD_EXP 31
2774: PUSH
2775: LD_INT 1
2777: PLUS
2778: DEC
2779: ST_TO_ADDR
2780: LD_EXP 31
2784: PUSH
2785: LD_EXP 30
2789: PLUS
2790: PUSH
2791: FOR_TO
2792: IFFALSE 2817
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2794: LD_EXP 29
2798: PUSH
2799: LD_LOC 2
2803: ARRAY
2804: PPUSH
2805: LD_INT 4
2807: PPUSH
2808: LD_INT 0
2810: PPUSH
2811: CALL_OW 49
2815: GO 2791
2817: POP
2818: POP
// end ; 2 :
2819: GO 2888
2821: LD_INT 2
2823: DOUBLE
2824: EQUAL
2825: IFTRUE 2829
2827: GO 2887
2829: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2830: LD_ADDR_LOC 2
2834: PUSH
2835: DOUBLE
2836: LD_EXP 31
2840: PUSH
2841: LD_INT 1
2843: PLUS
2844: DEC
2845: ST_TO_ADDR
2846: LD_EXP 31
2850: PUSH
2851: LD_EXP 30
2855: PLUS
2856: PUSH
2857: FOR_TO
2858: IFFALSE 2883
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2860: LD_EXP 29
2864: PUSH
2865: LD_LOC 2
2869: ARRAY
2870: PPUSH
2871: LD_INT 5
2873: PPUSH
2874: LD_INT 0
2876: PPUSH
2877: CALL_OW 49
2881: GO 2857
2883: POP
2884: POP
// end ; end ;
2885: GO 2888
2887: POP
// case Rand ( 1 , 2 ) of 1 :
2888: LD_INT 1
2890: PPUSH
2891: LD_INT 2
2893: PPUSH
2894: CALL_OW 12
2898: PUSH
2899: LD_INT 1
2901: DOUBLE
2902: EQUAL
2903: IFTRUE 2907
2905: GO 2975
2907: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2908: LD_ADDR_LOC 2
2912: PUSH
2913: DOUBLE
2914: LD_EXP 31
2918: PUSH
2919: LD_INT 1
2921: PLUS
2922: PUSH
2923: LD_EXP 30
2927: PLUS
2928: DEC
2929: ST_TO_ADDR
2930: LD_EXP 31
2934: PUSH
2935: LD_INT 2
2937: PUSH
2938: LD_EXP 30
2942: MUL
2943: PLUS
2944: PUSH
2945: FOR_TO
2946: IFFALSE 2971
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2948: LD_EXP 29
2952: PUSH
2953: LD_LOC 2
2957: ARRAY
2958: PPUSH
2959: LD_INT 8
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 49
2969: GO 2945
2971: POP
2972: POP
// end ; 2 :
2973: GO 3052
2975: LD_INT 2
2977: DOUBLE
2978: EQUAL
2979: IFTRUE 2983
2981: GO 3051
2983: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2984: LD_ADDR_LOC 2
2988: PUSH
2989: DOUBLE
2990: LD_EXP 31
2994: PUSH
2995: LD_INT 1
2997: PLUS
2998: PUSH
2999: LD_EXP 30
3003: PLUS
3004: DEC
3005: ST_TO_ADDR
3006: LD_EXP 31
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_EXP 30
3018: MUL
3019: PLUS
3020: PUSH
3021: FOR_TO
3022: IFFALSE 3047
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
3024: LD_EXP 29
3028: PUSH
3029: LD_LOC 2
3033: ARRAY
3034: PPUSH
3035: LD_INT 7
3037: PPUSH
3038: LD_INT 0
3040: PPUSH
3041: CALL_OW 49
3045: GO 3021
3047: POP
3048: POP
// end ; end ;
3049: GO 3052
3051: POP
// case Rand ( 1 , 2 ) of 1 :
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 2
3057: PPUSH
3058: CALL_OW 12
3062: PUSH
3063: LD_INT 1
3065: DOUBLE
3066: EQUAL
3067: IFTRUE 3071
3069: GO 3143
3071: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3072: LD_ADDR_LOC 2
3076: PUSH
3077: DOUBLE
3078: LD_EXP 31
3082: PUSH
3083: LD_INT 1
3085: PLUS
3086: PUSH
3087: LD_INT 2
3089: PUSH
3090: LD_EXP 30
3094: MUL
3095: PLUS
3096: DEC
3097: ST_TO_ADDR
3098: LD_EXP 31
3102: PUSH
3103: LD_INT 3
3105: PUSH
3106: LD_EXP 30
3110: MUL
3111: PLUS
3112: PUSH
3113: FOR_TO
3114: IFFALSE 3139
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3116: LD_EXP 29
3120: PUSH
3121: LD_LOC 2
3125: ARRAY
3126: PPUSH
3127: LD_INT 6
3129: PPUSH
3130: LD_INT 0
3132: PPUSH
3133: CALL_OW 49
3137: GO 3113
3139: POP
3140: POP
// end ; 2 :
3141: GO 3224
3143: LD_INT 2
3145: DOUBLE
3146: EQUAL
3147: IFTRUE 3151
3149: GO 3223
3151: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3152: LD_ADDR_LOC 2
3156: PUSH
3157: DOUBLE
3158: LD_EXP 31
3162: PUSH
3163: LD_INT 1
3165: PLUS
3166: PUSH
3167: LD_INT 2
3169: PUSH
3170: LD_EXP 30
3174: MUL
3175: PLUS
3176: DEC
3177: ST_TO_ADDR
3178: LD_EXP 31
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_EXP 30
3190: MUL
3191: PLUS
3192: PUSH
3193: FOR_TO
3194: IFFALSE 3219
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3196: LD_EXP 29
3200: PUSH
3201: LD_LOC 2
3205: ARRAY
3206: PPUSH
3207: LD_INT 16
3209: PPUSH
3210: LD_INT 0
3212: PPUSH
3213: CALL_OW 49
3217: GO 3193
3219: POP
3220: POP
// end ; end ;
3221: GO 3224
3223: POP
// Wait ( 1 1$20 ) ;
3224: LD_INT 2800
3226: PPUSH
3227: CALL_OW 67
// for i := 1 to pursuers_base do
3231: LD_ADDR_LOC 2
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_EXP 31
3245: PUSH
3246: FOR_TO
3247: IFFALSE 3316
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3249: LD_EXP 29
3253: PUSH
3254: LD_LOC 2
3258: ARRAY
3259: PPUSH
3260: LD_INT 9
3262: PPUSH
3263: LD_INT 0
3265: PPUSH
3266: CALL_OW 49
3270: NOT
3271: IFFALSE 3294
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3273: LD_EXP 29
3277: PUSH
3278: LD_LOC 2
3282: ARRAY
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: LD_INT 0
3289: PPUSH
3290: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3294: LD_EXP 29
3298: PUSH
3299: LD_LOC 2
3303: ARRAY
3304: PPUSH
3305: LD_EXP 1
3309: PPUSH
3310: CALL_OW 115
// end ;
3314: GO 3246
3316: POP
3317: POP
// Wait ( straz_start ) ;
3318: LD_EXP 35
3322: PPUSH
3323: CALL_OW 67
// enable ( 1 ) ;
3327: LD_INT 1
3329: ENABLE_MARKED
// enable ( 2 ) ;
3330: LD_INT 2
3332: ENABLE_MARKED
// end ;
3333: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3334: LD_INT 0
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
3341: PPUSH
3342: PPUSH
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
3348: PPUSH
3349: PPUSH
3350: PPUSH
3351: PPUSH
3352: PPUSH
3353: PPUSH
3354: PPUSH
3355: PPUSH
3356: PPUSH
3357: PPUSH
3358: PPUSH
3359: PPUSH
// gained_medals := [ ] ;
3360: LD_ADDR_OWVAR 61
3364: PUSH
3365: EMPTY
3366: ST_TO_ADDR
// missing_medals := [ ] ;
3367: LD_ADDR_OWVAR 62
3371: PUSH
3372: EMPTY
3373: ST_TO_ADDR
// reward_units := [ ] ;
3374: LD_ADDR_VAR 0 5
3378: PUSH
3379: EMPTY
3380: ST_TO_ADDR
// if scientists_dead = 0 then
3381: LD_EXP 49
3385: PUSH
3386: LD_INT 0
3388: EQUAL
3389: IFFALSE 3403
// AddMedal ( Science , 1 ) else
3391: LD_STRING Science
3393: PPUSH
3394: LD_INT 1
3396: PPUSH
3397: CALL_OW 101
3401: GO 3414
// AddMedal ( Science , - 1 ) ;
3403: LD_STRING Science
3405: PPUSH
3406: LD_INT 1
3408: NEG
3409: PPUSH
3410: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3414: LD_ADDR_VAR 0 4
3418: PUSH
3419: LD_INT 22
3421: PUSH
3422: LD_EXP 23
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: PUSH
3431: LD_INT 2
3433: PUSH
3434: LD_INT 30
3436: PUSH
3437: LD_INT 0
3439: PUSH
3440: EMPTY
3441: LIST
3442: LIST
3443: PUSH
3444: LD_INT 30
3446: PUSH
3447: LD_INT 1
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: PUSH
3459: EMPTY
3460: LIST
3461: LIST
3462: PPUSH
3463: CALL_OW 69
3467: ST_TO_ADDR
// matros := 0 ;
3468: LD_ADDR_VAR 0 2
3472: PUSH
3473: LD_INT 0
3475: ST_TO_ADDR
// if 0 + filter <> 0 then
3476: LD_INT 0
3478: PUSH
3479: LD_VAR 0 4
3483: PLUS
3484: PUSH
3485: LD_INT 0
3487: NONEQUAL
3488: IFFALSE 3536
// for un in filter do
3490: LD_ADDR_VAR 0 3
3494: PUSH
3495: LD_VAR 0 4
3499: PUSH
3500: FOR_IN
3501: IFFALSE 3534
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3503: LD_ADDR_VAR 0 2
3507: PUSH
3508: LD_VAR 0 2
3512: PUSH
3513: LD_VAR 0 3
3517: PPUSH
3518: CALL_OW 274
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: CALL_OW 275
3530: PLUS
3531: ST_TO_ADDR
3532: GO 3500
3534: POP
3535: POP
// if matros > 100 then
3536: LD_VAR 0 2
3540: PUSH
3541: LD_INT 100
3543: GREATER
3544: IFFALSE 3558
// AddMedal ( Effectivity , 1 ) else
3546: LD_STRING Effectivity
3548: PPUSH
3549: LD_INT 1
3551: PPUSH
3552: CALL_OW 101
3556: GO 3569
// AddMedal ( Effectivity , - 1 ) ;
3558: LD_STRING Effectivity
3560: PPUSH
3561: LD_INT 1
3563: NEG
3564: PPUSH
3565: CALL_OW 101
// rus_building_destroyed := false ;
3569: LD_ADDR_VAR 0 7
3573: PUSH
3574: LD_INT 0
3576: ST_TO_ADDR
// for un in rus_mcrep_bui do
3577: LD_ADDR_VAR 0 3
3581: PUSH
3582: LD_EXP 64
3586: PUSH
3587: FOR_IN
3588: IFFALSE 3618
// if not IsLive ( un ) then
3590: LD_VAR 0 3
3594: PPUSH
3595: CALL_OW 300
3599: NOT
3600: IFFALSE 3616
// rus_building_destroyed := rus_building_destroyed + 1 ;
3602: LD_ADDR_VAR 0 7
3606: PUSH
3607: LD_VAR 0 7
3611: PUSH
3612: LD_INT 1
3614: PLUS
3615: ST_TO_ADDR
3616: GO 3587
3618: POP
3619: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3620: LD_EXP 53
3624: PUSH
3625: LD_INT 5
3627: GREATEREQUAL
3628: PUSH
3629: LD_VAR 0 7
3633: PUSH
3634: LD_INT 2
3636: GREATEREQUAL
3637: OR
3638: IFFALSE 3653
// AddMedal ( LittleLosses , - 1 ) else
3640: LD_STRING LittleLosses
3642: PPUSH
3643: LD_INT 1
3645: NEG
3646: PPUSH
3647: CALL_OW 101
3651: GO 3663
// AddMedal ( LittleLosses , 1 ) ;
3653: LD_STRING LittleLosses
3655: PPUSH
3656: LD_INT 1
3658: PPUSH
3659: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , killed_russians >= 5 or rus_building_destroyed >= 2 ) ;
3663: LD_INT 4
3665: PPUSH
3666: LD_INT 5
3668: PPUSH
3669: LD_EXP 49
3673: PUSH
3674: LD_INT 0
3676: EQUAL
3677: PPUSH
3678: LD_VAR 0 2
3682: PUSH
3683: LD_INT 100
3685: GREATER
3686: PPUSH
3687: LD_EXP 53
3691: PUSH
3692: LD_INT 5
3694: GREATEREQUAL
3695: PUSH
3696: LD_VAR 0 7
3700: PUSH
3701: LD_INT 2
3703: GREATEREQUAL
3704: OR
3705: PPUSH
3706: CALL 14227 0 5
// GiveMedals ( Main ) ;
3710: LD_STRING Main
3712: PPUSH
3713: CALL_OW 102
// for un in player_units do
3717: LD_ADDR_VAR 0 3
3721: PUSH
3722: LD_EXP 41
3726: PUSH
3727: FOR_IN
3728: IFFALSE 3760
// if not IsDead ( un ) then
3730: LD_VAR 0 3
3734: PPUSH
3735: CALL_OW 301
3739: NOT
3740: IFFALSE 3758
// reward_units := reward_units ^ un ;
3742: LD_ADDR_VAR 0 5
3746: PUSH
3747: LD_VAR 0 5
3751: PUSH
3752: LD_VAR 0 3
3756: ADD
3757: ST_TO_ADDR
3758: GO 3727
3760: POP
3761: POP
// RewardPeople ( reward_units ) ;
3762: LD_VAR 0 5
3766: PPUSH
3767: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3771: LD_EXP 40
3775: PUSH
3776: LD_EXP 39
3780: PUSH
3781: LD_EXP 8
3785: ADD
3786: DIFF
3787: PPUSH
3788: LD_STRING scientists
3790: PPUSH
3791: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3795: LD_ADDR_VAR 0 6
3799: PUSH
3800: LD_EXP 41
3804: PUSH
3805: LD_EXP 39
3809: PUSH
3810: LD_EXP 40
3814: ADD
3815: PUSH
3816: LD_EXP 1
3820: ADD
3821: PUSH
3822: LD_EXP 8
3826: ADD
3827: DIFF
3828: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3829: LD_VAR 0 6
3833: PPUSH
3834: LD_STRING survivors5
3836: PPUSH
3837: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3841: LD_EXP 1
3845: PPUSH
3846: LD_STRING Burlak
3848: PPUSH
3849: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3853: LD_EXP 2
3857: PPUSH
3858: LD_STRING Belkov
3860: PPUSH
3861: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3865: LD_EXP 3
3869: PPUSH
3870: LD_STRING Gnyevko
3872: PPUSH
3873: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3877: LD_EXP 4
3881: PPUSH
3882: LD_STRING Kirilenkova
3884: PPUSH
3885: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3889: LD_EXP 5
3893: PPUSH
3894: LD_STRING Gleb
3896: PPUSH
3897: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3901: LD_EXP 6
3905: PPUSH
3906: LD_STRING Petrosyan
3908: PPUSH
3909: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3913: LD_EXP 7
3917: PPUSH
3918: LD_STRING Titov
3920: PPUSH
3921: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3925: LD_EXP 8
3929: PPUSH
3930: LD_STRING Gossudarov
3932: PPUSH
3933: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3937: LD_EXP 9
3941: PPUSH
3942: LD_STRING Kovalyuk
3944: PPUSH
3945: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3949: LD_EXP 10
3953: PPUSH
3954: LD_STRING Scholtze
3956: PPUSH
3957: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3961: LD_EXP 11
3965: PPUSH
3966: LD_STRING Kuzmov
3968: PPUSH
3969: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3973: LD_EXP 12
3977: PPUSH
3978: LD_STRING Karamazov
3980: PPUSH
3981: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3985: LD_EXP 13
3989: PPUSH
3990: LD_STRING Petrovova
3992: PPUSH
3993: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3997: LD_EXP 14
4001: PPUSH
4002: LD_STRING Lipshchin
4004: PPUSH
4005: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
4009: LD_EXP 15
4013: PPUSH
4014: LD_STRING Dolgov
4016: PPUSH
4017: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4021: LD_EXP 16
4025: PPUSH
4026: LD_STRING Xavier
4028: PPUSH
4029: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4033: LD_EXP 17
4037: PPUSH
4038: LD_STRING Oblukov
4040: PPUSH
4041: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4045: LD_EXP 18
4049: PPUSH
4050: LD_STRING Kozlov
4052: PPUSH
4053: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4057: LD_EXP 19
4061: PPUSH
4062: LD_STRING Kapitsova
4064: PPUSH
4065: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
4069: LD_EXP 42
4073: PUSH
4074: LD_EXP 52
4078: AND
4079: PUSH
4080: LD_LOC 1
4084: NOT
4085: OR
4086: IFFALSE 4095
// DeleteVariable ( Masha ) ;
4088: LD_STRING Masha
4090: PPUSH
4091: CALL_OW 41
// if Belkov in scientists then
4095: LD_EXP 2
4099: PUSH
4100: LD_EXP 40
4104: IN
4105: IFFALSE 4117
// belkov_side := 2 else
4107: LD_ADDR_VAR 0 8
4111: PUSH
4112: LD_INT 2
4114: ST_TO_ADDR
4115: GO 4147
// if Belkov in player_units then
4117: LD_EXP 2
4121: PUSH
4122: LD_EXP 41
4126: IN
4127: IFFALSE 4139
// belkov_side := 1 else
4129: LD_ADDR_VAR 0 8
4133: PUSH
4134: LD_INT 1
4136: ST_TO_ADDR
4137: GO 4147
// belkov_side := 0 ;
4139: LD_ADDR_VAR 0 8
4143: PUSH
4144: LD_INT 0
4146: ST_TO_ADDR
// if Gnyevko in scientists then
4147: LD_EXP 3
4151: PUSH
4152: LD_EXP 40
4156: IN
4157: IFFALSE 4169
// gnyevko_side := 2 else
4159: LD_ADDR_VAR 0 9
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
4167: GO 4199
// if Gnyevko in player_units then
4169: LD_EXP 3
4173: PUSH
4174: LD_EXP 41
4178: IN
4179: IFFALSE 4191
// gnyevko_side := 1 else
4181: LD_ADDR_VAR 0 9
4185: PUSH
4186: LD_INT 1
4188: ST_TO_ADDR
4189: GO 4199
// gnyevko_side := 0 ;
4191: LD_ADDR_VAR 0 9
4195: PUSH
4196: LD_INT 0
4198: ST_TO_ADDR
// if Kirilenkova in scientists then
4199: LD_EXP 4
4203: PUSH
4204: LD_EXP 40
4208: IN
4209: IFFALSE 4221
// kiril_side := 2 else
4211: LD_ADDR_VAR 0 10
4215: PUSH
4216: LD_INT 2
4218: ST_TO_ADDR
4219: GO 4251
// if Kirilenkova in player_units then
4221: LD_EXP 4
4225: PUSH
4226: LD_EXP 41
4230: IN
4231: IFFALSE 4243
// kiril_side := 1 else
4233: LD_ADDR_VAR 0 10
4237: PUSH
4238: LD_INT 1
4240: ST_TO_ADDR
4241: GO 4251
// kiril_side := 0 ;
4243: LD_ADDR_VAR 0 10
4247: PUSH
4248: LD_INT 0
4250: ST_TO_ADDR
// if Gleb in scientists then
4251: LD_EXP 5
4255: PUSH
4256: LD_EXP 40
4260: IN
4261: IFFALSE 4273
// gleb_side := 2 else
4263: LD_ADDR_VAR 0 16
4267: PUSH
4268: LD_INT 2
4270: ST_TO_ADDR
4271: GO 4303
// if Gleb in player_units then
4273: LD_EXP 5
4277: PUSH
4278: LD_EXP 41
4282: IN
4283: IFFALSE 4295
// gleb_side := 1 else
4285: LD_ADDR_VAR 0 16
4289: PUSH
4290: LD_INT 1
4292: ST_TO_ADDR
4293: GO 4303
// gleb_side := 0 ;
4295: LD_ADDR_VAR 0 16
4299: PUSH
4300: LD_INT 0
4302: ST_TO_ADDR
// if Petrosyan in scientists then
4303: LD_EXP 6
4307: PUSH
4308: LD_EXP 40
4312: IN
4313: IFFALSE 4325
// petros_side := 2 else
4315: LD_ADDR_VAR 0 15
4319: PUSH
4320: LD_INT 2
4322: ST_TO_ADDR
4323: GO 4355
// if Petrosyan in player_units then
4325: LD_EXP 6
4329: PUSH
4330: LD_EXP 41
4334: IN
4335: IFFALSE 4347
// petros_side := 1 else
4337: LD_ADDR_VAR 0 15
4341: PUSH
4342: LD_INT 1
4344: ST_TO_ADDR
4345: GO 4355
// petros_side := 0 ;
4347: LD_ADDR_VAR 0 15
4351: PUSH
4352: LD_INT 0
4354: ST_TO_ADDR
// if Titov in scientists then
4355: LD_EXP 7
4359: PUSH
4360: LD_EXP 40
4364: IN
4365: IFFALSE 4377
// titov_side := 2 else
4367: LD_ADDR_VAR 0 19
4371: PUSH
4372: LD_INT 2
4374: ST_TO_ADDR
4375: GO 4407
// if Titov in player_units then
4377: LD_EXP 7
4381: PUSH
4382: LD_EXP 41
4386: IN
4387: IFFALSE 4399
// titov_side := 1 else
4389: LD_ADDR_VAR 0 19
4393: PUSH
4394: LD_INT 1
4396: ST_TO_ADDR
4397: GO 4407
// titov_side := 0 ;
4399: LD_ADDR_VAR 0 19
4403: PUSH
4404: LD_INT 0
4406: ST_TO_ADDR
// if Kovalyuk in scientists then
4407: LD_EXP 9
4411: PUSH
4412: LD_EXP 40
4416: IN
4417: IFFALSE 4429
// kovalyuk_side := 2 else
4419: LD_ADDR_VAR 0 11
4423: PUSH
4424: LD_INT 2
4426: ST_TO_ADDR
4427: GO 4459
// if Kovalyuk in player_units then
4429: LD_EXP 9
4433: PUSH
4434: LD_EXP 41
4438: IN
4439: IFFALSE 4451
// kovalyuk_side := 1 else
4441: LD_ADDR_VAR 0 11
4445: PUSH
4446: LD_INT 1
4448: ST_TO_ADDR
4449: GO 4459
// kovalyuk_side := 0 ;
4451: LD_ADDR_VAR 0 11
4455: PUSH
4456: LD_INT 0
4458: ST_TO_ADDR
// if Scholtze in scientists then
4459: LD_EXP 10
4463: PUSH
4464: LD_EXP 40
4468: IN
4469: IFFALSE 4481
// scholtze_side := 2 else
4471: LD_ADDR_VAR 0 12
4475: PUSH
4476: LD_INT 2
4478: ST_TO_ADDR
4479: GO 4511
// if Scholtze in player_units then
4481: LD_EXP 10
4485: PUSH
4486: LD_EXP 41
4490: IN
4491: IFFALSE 4503
// scholtze_side := 1 else
4493: LD_ADDR_VAR 0 12
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
4501: GO 4511
// scholtze_side := 0 ;
4503: LD_ADDR_VAR 0 12
4507: PUSH
4508: LD_INT 0
4510: ST_TO_ADDR
// if Kuzmov in scientists then
4511: LD_EXP 11
4515: PUSH
4516: LD_EXP 40
4520: IN
4521: IFFALSE 4533
// kuzmov_side := 2 else
4523: LD_ADDR_VAR 0 13
4527: PUSH
4528: LD_INT 2
4530: ST_TO_ADDR
4531: GO 4563
// if Kuzmov in player_units then
4533: LD_EXP 11
4537: PUSH
4538: LD_EXP 41
4542: IN
4543: IFFALSE 4555
// kuzmov_side := 1 else
4545: LD_ADDR_VAR 0 13
4549: PUSH
4550: LD_INT 1
4552: ST_TO_ADDR
4553: GO 4563
// kuzmov_side := 0 ;
4555: LD_ADDR_VAR 0 13
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// if Karamazov in scientists then
4563: LD_EXP 12
4567: PUSH
4568: LD_EXP 40
4572: IN
4573: IFFALSE 4585
// karam_side := 2 else
4575: LD_ADDR_VAR 0 14
4579: PUSH
4580: LD_INT 2
4582: ST_TO_ADDR
4583: GO 4615
// if Karamazov in player_units then
4585: LD_EXP 12
4589: PUSH
4590: LD_EXP 41
4594: IN
4595: IFFALSE 4607
// karam_side := 1 else
4597: LD_ADDR_VAR 0 14
4601: PUSH
4602: LD_INT 1
4604: ST_TO_ADDR
4605: GO 4615
// karam_side := 0 ;
4607: LD_ADDR_VAR 0 14
4611: PUSH
4612: LD_INT 0
4614: ST_TO_ADDR
// if Petrovova in scientists then
4615: LD_EXP 13
4619: PUSH
4620: LD_EXP 40
4624: IN
4625: IFFALSE 4637
// petrov_side := 2 else
4627: LD_ADDR_VAR 0 17
4631: PUSH
4632: LD_INT 2
4634: ST_TO_ADDR
4635: GO 4667
// if Petrovova in player_units then
4637: LD_EXP 13
4641: PUSH
4642: LD_EXP 41
4646: IN
4647: IFFALSE 4659
// petrov_side := 1 else
4649: LD_ADDR_VAR 0 17
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
4657: GO 4667
// petrov_side := 0 ;
4659: LD_ADDR_VAR 0 17
4663: PUSH
4664: LD_INT 0
4666: ST_TO_ADDR
// if Lipshchin in scientists then
4667: LD_EXP 14
4671: PUSH
4672: LD_EXP 40
4676: IN
4677: IFFALSE 4689
// lipshchin_side := 2 else
4679: LD_ADDR_VAR 0 18
4683: PUSH
4684: LD_INT 2
4686: ST_TO_ADDR
4687: GO 4719
// if Lipshchin in player_units then
4689: LD_EXP 14
4693: PUSH
4694: LD_EXP 41
4698: IN
4699: IFFALSE 4711
// lipshchin_side := 1 else
4701: LD_ADDR_VAR 0 18
4705: PUSH
4706: LD_INT 1
4708: ST_TO_ADDR
4709: GO 4719
// lipshchin_side := 0 ;
4711: LD_ADDR_VAR 0 18
4715: PUSH
4716: LD_INT 0
4718: ST_TO_ADDR
// if Dolgov in scientists then
4719: LD_EXP 15
4723: PUSH
4724: LD_EXP 40
4728: IN
4729: IFFALSE 4741
// dolgov_side := 2 else
4731: LD_ADDR_VAR 0 20
4735: PUSH
4736: LD_INT 2
4738: ST_TO_ADDR
4739: GO 4771
// if Dolgov in player_units then
4741: LD_EXP 15
4745: PUSH
4746: LD_EXP 41
4750: IN
4751: IFFALSE 4763
// dolgov_side := 1 else
4753: LD_ADDR_VAR 0 20
4757: PUSH
4758: LD_INT 1
4760: ST_TO_ADDR
4761: GO 4771
// dolgov_side := 0 ;
4763: LD_ADDR_VAR 0 20
4767: PUSH
4768: LD_INT 0
4770: ST_TO_ADDR
// if Xavier in scientists then
4771: LD_EXP 16
4775: PUSH
4776: LD_EXP 40
4780: IN
4781: IFFALSE 4793
// xavier_side := 2 else
4783: LD_ADDR_VAR 0 21
4787: PUSH
4788: LD_INT 2
4790: ST_TO_ADDR
4791: GO 4823
// if Xavier in player_units then
4793: LD_EXP 16
4797: PUSH
4798: LD_EXP 41
4802: IN
4803: IFFALSE 4815
// xavier_side := 1 else
4805: LD_ADDR_VAR 0 21
4809: PUSH
4810: LD_INT 1
4812: ST_TO_ADDR
4813: GO 4823
// xavier_side := 0 ;
4815: LD_ADDR_VAR 0 21
4819: PUSH
4820: LD_INT 0
4822: ST_TO_ADDR
// if Oblukov in scientists then
4823: LD_EXP 17
4827: PUSH
4828: LD_EXP 40
4832: IN
4833: IFFALSE 4845
// oblukov_side := 2 else
4835: LD_ADDR_VAR 0 22
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
4843: GO 4875
// if Oblukov in player_units then
4845: LD_EXP 17
4849: PUSH
4850: LD_EXP 41
4854: IN
4855: IFFALSE 4867
// oblukov_side := 1 else
4857: LD_ADDR_VAR 0 22
4861: PUSH
4862: LD_INT 1
4864: ST_TO_ADDR
4865: GO 4875
// oblukov_side := 0 ;
4867: LD_ADDR_VAR 0 22
4871: PUSH
4872: LD_INT 0
4874: ST_TO_ADDR
// if Kozlov in scientists then
4875: LD_EXP 18
4879: PUSH
4880: LD_EXP 40
4884: IN
4885: IFFALSE 4897
// kozlov_side := 2 else
4887: LD_ADDR_VAR 0 23
4891: PUSH
4892: LD_INT 2
4894: ST_TO_ADDR
4895: GO 4927
// if Kozlov in player_units then
4897: LD_EXP 18
4901: PUSH
4902: LD_EXP 41
4906: IN
4907: IFFALSE 4919
// kozlov_side := 1 else
4909: LD_ADDR_VAR 0 23
4913: PUSH
4914: LD_INT 1
4916: ST_TO_ADDR
4917: GO 4927
// kozlov_side := 0 ;
4919: LD_ADDR_VAR 0 23
4923: PUSH
4924: LD_INT 0
4926: ST_TO_ADDR
// if Kapitsova in scientists then
4927: LD_EXP 19
4931: PUSH
4932: LD_EXP 40
4936: IN
4937: IFFALSE 4949
// kapitsova_side := 2 else
4939: LD_ADDR_VAR 0 24
4943: PUSH
4944: LD_INT 2
4946: ST_TO_ADDR
4947: GO 4979
// if Kapitsova in player_units then
4949: LD_EXP 19
4953: PUSH
4954: LD_EXP 41
4958: IN
4959: IFFALSE 4971
// kapitsova_side := 1 else
4961: LD_ADDR_VAR 0 24
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
4969: GO 4979
// kapitsova_side := 0 ;
4971: LD_ADDR_VAR 0 24
4975: PUSH
4976: LD_INT 0
4978: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4979: LD_VAR 0 8
4983: PPUSH
4984: LD_STRING belkov_side
4986: PPUSH
4987: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4991: LD_VAR 0 9
4995: PPUSH
4996: LD_STRING gnyevko_side
4998: PPUSH
4999: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
5003: LD_VAR 0 10
5007: PPUSH
5008: LD_STRING kiril_side
5010: PPUSH
5011: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
5015: LD_VAR 0 16
5019: PPUSH
5020: LD_STRING gleb_side
5022: PPUSH
5023: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
5027: LD_VAR 0 15
5031: PPUSH
5032: LD_STRING petros_side
5034: PPUSH
5035: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
5039: LD_VAR 0 19
5043: PPUSH
5044: LD_STRING titov_side
5046: PPUSH
5047: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
5051: LD_VAR 0 11
5055: PPUSH
5056: LD_STRING kovalyuk_side
5058: PPUSH
5059: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
5063: LD_VAR 0 12
5067: PPUSH
5068: LD_STRING scholtze_side
5070: PPUSH
5071: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5075: LD_VAR 0 13
5079: PPUSH
5080: LD_STRING kuzmov_side
5082: PPUSH
5083: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5087: LD_VAR 0 14
5091: PPUSH
5092: LD_STRING karam_side
5094: PPUSH
5095: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5099: LD_VAR 0 17
5103: PPUSH
5104: LD_STRING petrov_side
5106: PPUSH
5107: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5111: LD_VAR 0 18
5115: PPUSH
5116: LD_STRING lipshchin_side
5118: PPUSH
5119: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5123: LD_VAR 0 20
5127: PPUSH
5128: LD_STRING dolgov_side
5130: PPUSH
5131: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5135: LD_VAR 0 21
5139: PPUSH
5140: LD_STRING xavier_side
5142: PPUSH
5143: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5147: LD_VAR 0 22
5151: PPUSH
5152: LD_STRING oblukov_side
5154: PPUSH
5155: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5159: LD_VAR 0 23
5163: PPUSH
5164: LD_STRING kozlov_side
5166: PPUSH
5167: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5171: LD_VAR 0 24
5175: PPUSH
5176: LD_STRING kapitsova_side
5178: PPUSH
5179: CALL_OW 39
// YouWin ;
5183: CALL_OW 103
// exit ;
5187: GO 5189
// end ; end_of_file
5189: LD_VAR 0 1
5193: RET
// export function D_Start ; begin
5194: LD_INT 0
5196: PPUSH
// DisableExclamations ;
5197: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5201: LD_EXP 8
5205: PPUSH
5206: LD_STRING DStart-Gos-1
5208: PPUSH
5209: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5213: LD_EXP 1
5217: PPUSH
5218: LD_STRING DStart-Bur-1
5220: PPUSH
5221: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5225: LD_EXP 8
5229: PPUSH
5230: LD_STRING DStart-Gos-2
5232: PPUSH
5233: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5237: LD_EXP 1
5241: PPUSH
5242: LD_STRING DStart-Bur-2
5244: PPUSH
5245: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5249: LD_EXP 8
5253: PPUSH
5254: LD_STRING DStart-Gos-3
5256: PPUSH
5257: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5261: LD_EXP 1
5265: PPUSH
5266: LD_STRING DStart-Bur-3
5268: PPUSH
5269: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5273: LD_EXP 8
5277: PPUSH
5278: LD_STRING DStart-Gos-4
5280: PPUSH
5281: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5285: LD_EXP 1
5289: PPUSH
5290: LD_STRING DStart-Bur-4
5292: PPUSH
5293: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5297: LD_EXP 8
5301: PPUSH
5302: LD_STRING DStart-Gos-5
5304: PPUSH
5305: CALL_OW 88
// EnableExclamations ;
5309: CALL_OW 473
// end ;
5313: LD_VAR 0 1
5317: RET
// export function D_Platonov ; begin
5318: LD_INT 0
5320: PPUSH
// DisableExclamations ;
5321: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5325: LD_EXP 21
5329: PPUSH
5330: LD_STRING DPlatonov-Rsol1-1
5332: PPUSH
5333: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5337: LD_EXP 1
5341: PPUSH
5342: LD_STRING DPlatonov-Bur-1
5344: PPUSH
5345: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5349: LD_EXP 21
5353: PPUSH
5354: LD_STRING DPlatonov-Rsol1-2
5356: PPUSH
5357: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5361: LD_EXP 1
5365: PPUSH
5366: LD_STRING DPlatonov-Bur-2
5368: PPUSH
5369: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5373: LD_EXP 1
5377: PPUSH
5378: LD_EXP 43
5382: PPUSH
5383: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5387: LD_EXP 21
5391: PPUSH
5392: LD_STRING DPlatonov-Rsol1-3
5394: PPUSH
5395: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5399: LD_INT 7
5401: PPUSH
5402: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5406: LD_EXP 43
5410: PPUSH
5411: CALL_OW 311
5415: PUSH
5416: LD_EXP 1
5420: EQUAL
5421: IFFALSE 5399
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5423: LD_EXP 1
5427: PPUSH
5428: LD_STRING DPlatonov-Bur-3
5430: PPUSH
5431: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5435: LD_EXP 1
5439: PPUSH
5440: LD_EXP 21
5444: PPUSH
5445: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5449: LD_INT 7
5451: PPUSH
5452: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5456: LD_EXP 43
5460: PPUSH
5461: CALL_OW 320
5465: PUSH
5466: LD_EXP 21
5470: EQUAL
5471: IFFALSE 5449
// Wait ( 0 0$0.5 ) ;
5473: LD_INT 18
5475: PPUSH
5476: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5480: LD_EXP 21
5484: PPUSH
5485: LD_STRING DPlatonov-Rsol1-4
5487: PPUSH
5488: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5492: LD_EXP 21
5496: PPUSH
5497: LD_EXP 43
5501: PPUSH
5502: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5506: LD_EXP 1
5510: PPUSH
5511: LD_EXP 21
5515: PPUSH
5516: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5520: LD_EXP 20
5524: PPUSH
5525: LD_STRING DPlatonov-Pla-4
5527: PPUSH
5528: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5532: LD_EXP 20
5536: PPUSH
5537: LD_STRING DPlatonov-Pla-4a
5539: PPUSH
5540: CALL_OW 88
// EnableExclamations ;
5544: CALL_OW 473
// end ;
5548: LD_VAR 0 1
5552: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5553: LD_INT 0
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
// DisableExclamations ;
5559: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5563: LD_EXP 2
5567: PPUSH
5568: CALL_OW 302
5572: PUSH
5573: LD_EXP 2
5577: PPUSH
5578: CALL_OW 255
5582: PUSH
5583: LD_EXP 23
5587: EQUAL
5588: AND
5589: IFFALSE 5603
// Say ( Belkov , DGosStart-Bel-1 ) ;
5591: LD_EXP 2
5595: PPUSH
5596: LD_STRING DGosStart-Bel-1
5598: PPUSH
5599: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5603: LD_EXP 3
5607: PPUSH
5608: CALL_OW 302
5612: PUSH
5613: LD_EXP 3
5617: PPUSH
5618: CALL_OW 255
5622: PUSH
5623: LD_EXP 23
5627: EQUAL
5628: AND
5629: IFFALSE 5643
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5631: LD_EXP 3
5635: PPUSH
5636: LD_STRING DGosStart-Gny-1
5638: PPUSH
5639: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5643: LD_EXP 5
5647: PPUSH
5648: CALL_OW 302
5652: PUSH
5653: LD_EXP 5
5657: PPUSH
5658: CALL_OW 255
5662: PUSH
5663: LD_EXP 23
5667: EQUAL
5668: AND
5669: IFFALSE 5683
// Say ( Gleb , DGosStart-Glb-1 ) ;
5671: LD_EXP 5
5675: PPUSH
5676: LD_STRING DGosStart-Glb-1
5678: PPUSH
5679: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5683: LD_EXP 6
5687: PPUSH
5688: CALL_OW 302
5692: PUSH
5693: LD_EXP 6
5697: PPUSH
5698: CALL_OW 255
5702: PUSH
5703: LD_EXP 23
5707: EQUAL
5708: AND
5709: IFFALSE 5723
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5711: LD_EXP 6
5715: PPUSH
5716: LD_STRING DGosStart-Pty-1
5718: PPUSH
5719: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5723: LD_EXP 7
5727: PPUSH
5728: CALL_OW 302
5732: PUSH
5733: LD_EXP 7
5737: PPUSH
5738: CALL_OW 255
5742: PUSH
5743: LD_EXP 23
5747: EQUAL
5748: AND
5749: IFFALSE 5763
// Say ( Titov , DGosStart-Tit-1 ) ;
5751: LD_EXP 7
5755: PPUSH
5756: LD_STRING DGosStart-Tit-1
5758: PPUSH
5759: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5763: LD_EXP 4
5767: PPUSH
5768: CALL_OW 302
5772: PUSH
5773: LD_EXP 4
5777: PPUSH
5778: CALL_OW 255
5782: PUSH
5783: LD_EXP 23
5787: EQUAL
5788: AND
5789: IFFALSE 5803
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5791: LD_EXP 4
5795: PPUSH
5796: LD_STRING DGosStart-Kir-1
5798: PPUSH
5799: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5803: LD_EXP 2
5807: PPUSH
5808: CALL_OW 302
5812: PUSH
5813: LD_EXP 2
5817: PPUSH
5818: CALL_OW 255
5822: PUSH
5823: LD_EXP 23
5827: EQUAL
5828: AND
5829: PUSH
5830: LD_EXP 3
5834: PPUSH
5835: CALL_OW 302
5839: PUSH
5840: LD_EXP 3
5844: PPUSH
5845: CALL_OW 255
5849: PUSH
5850: LD_EXP 23
5854: EQUAL
5855: AND
5856: OR
5857: PUSH
5858: LD_EXP 5
5862: PPUSH
5863: CALL_OW 302
5867: PUSH
5868: LD_EXP 5
5872: PPUSH
5873: CALL_OW 255
5877: PUSH
5878: LD_EXP 23
5882: EQUAL
5883: AND
5884: OR
5885: PUSH
5886: LD_EXP 6
5890: PPUSH
5891: CALL_OW 302
5895: PUSH
5896: LD_EXP 6
5900: PPUSH
5901: CALL_OW 255
5905: PUSH
5906: LD_EXP 23
5910: EQUAL
5911: AND
5912: OR
5913: PUSH
5914: LD_EXP 7
5918: PPUSH
5919: CALL_OW 302
5923: PUSH
5924: LD_EXP 7
5928: PPUSH
5929: CALL_OW 255
5933: PUSH
5934: LD_EXP 23
5938: EQUAL
5939: AND
5940: OR
5941: PUSH
5942: LD_EXP 4
5946: PPUSH
5947: CALL_OW 302
5951: PUSH
5952: LD_EXP 4
5956: PPUSH
5957: CALL_OW 255
5961: PUSH
5962: LD_EXP 23
5966: EQUAL
5967: AND
5968: OR
5969: NOT
5970: IFFALSE 6334
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5972: LD_ADDR_VAR 0 4
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_EXP 23
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PUSH
5989: LD_INT 26
5991: PUSH
5992: LD_INT 1
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 50
6001: PUSH
6002: EMPTY
6003: LIST
6004: PUSH
6005: LD_INT 3
6007: PUSH
6008: LD_INT 23
6010: PUSH
6011: LD_INT 0
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: LIST
6027: PPUSH
6028: CALL_OW 69
6032: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6033: LD_ADDR_VAR 0 4
6037: PUSH
6038: LD_VAR 0 4
6042: PUSH
6043: LD_EXP 1
6047: DIFF
6048: ST_TO_ADDR
// if 0 + filter_all > 0 then
6049: LD_INT 0
6051: PUSH
6052: LD_VAR 0 4
6056: PLUS
6057: PUSH
6058: LD_INT 0
6060: GREATER
6061: IFFALSE 6162
// begin filter := [ ] ;
6063: LD_ADDR_VAR 0 3
6067: PUSH
6068: EMPTY
6069: ST_TO_ADDR
// for un in filter_all do
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_VAR 0 4
6079: PUSH
6080: FOR_IN
6081: IFFALSE 6114
// if not ( un in all_possible ) then
6083: LD_VAR 0 2
6087: PUSH
6088: LD_EXP 39
6092: IN
6093: NOT
6094: IFFALSE 6112
// filter := filter union un ;
6096: LD_ADDR_VAR 0 3
6100: PUSH
6101: LD_VAR 0 3
6105: PUSH
6106: LD_VAR 0 2
6110: UNION
6111: ST_TO_ADDR
6112: GO 6080
6114: POP
6115: POP
// if filter > 0 then
6116: LD_VAR 0 3
6120: PUSH
6121: LD_INT 0
6123: GREATER
6124: IFFALSE 6144
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6126: LD_VAR 0 3
6130: PUSH
6131: LD_INT 1
6133: ARRAY
6134: PPUSH
6135: LD_STRING DGosStart-Sol1-1
6137: PPUSH
6138: CALL_OW 88
6142: GO 6160
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6144: LD_VAR 0 4
6148: PUSH
6149: LD_INT 1
6151: ARRAY
6152: PPUSH
6153: LD_STRING DGosStart-Sol1-1
6155: PPUSH
6156: CALL_OW 88
// end else
6160: GO 6334
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6162: LD_ADDR_VAR 0 4
6166: PUSH
6167: LD_INT 22
6169: PUSH
6170: LD_EXP 23
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 26
6181: PUSH
6182: LD_INT 2
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: PUSH
6189: LD_INT 50
6191: PUSH
6192: EMPTY
6193: LIST
6194: PUSH
6195: LD_INT 3
6197: PUSH
6198: LD_INT 23
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: PPUSH
6218: CALL_OW 69
6222: ST_TO_ADDR
// if 0 + filter_all > 0 then
6223: LD_INT 0
6225: PUSH
6226: LD_VAR 0 4
6230: PLUS
6231: PUSH
6232: LD_INT 0
6234: GREATER
6235: IFFALSE 6334
// begin filter := [ ] ;
6237: LD_ADDR_VAR 0 3
6241: PUSH
6242: EMPTY
6243: ST_TO_ADDR
// for un in filter_all do
6244: LD_ADDR_VAR 0 2
6248: PUSH
6249: LD_VAR 0 4
6253: PUSH
6254: FOR_IN
6255: IFFALSE 6288
// if not ( un in all_possible ) then
6257: LD_VAR 0 2
6261: PUSH
6262: LD_EXP 39
6266: IN
6267: NOT
6268: IFFALSE 6286
// filter := filter union un ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PUSH
6280: LD_VAR 0 2
6284: UNION
6285: ST_TO_ADDR
6286: GO 6254
6288: POP
6289: POP
// if filter > 0 then
6290: LD_VAR 0 3
6294: PUSH
6295: LD_INT 0
6297: GREATER
6298: IFFALSE 6318
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6300: LD_VAR 0 3
6304: PUSH
6305: LD_INT 1
6307: ARRAY
6308: PPUSH
6309: LD_STRING DGosStart-FSol1-1
6311: PPUSH
6312: CALL_OW 88
6316: GO 6334
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6318: LD_VAR 0 4
6322: PUSH
6323: LD_INT 1
6325: ARRAY
6326: PPUSH
6327: LD_STRING DGosStart-FSol1-1
6329: PPUSH
6330: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6334: LD_EXP 1
6338: PPUSH
6339: LD_STRING DGosStart-Bur-1
6341: PPUSH
6342: CALL_OW 88
// Wait ( 0 0$20 ) ;
6346: LD_INT 700
6348: PPUSH
6349: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6353: LD_EXP 1
6357: PPUSH
6358: LD_STRING DGosStart-Bur-1a
6360: PPUSH
6361: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6365: LD_EXP 8
6369: PPUSH
6370: LD_STRING DGosStart-Gos-1
6372: PPUSH
6373: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6377: LD_EXP 1
6381: PPUSH
6382: LD_STRING DGosStart-Bur-2
6384: PPUSH
6385: CALL_OW 88
// Hint ( Signal ) ;
6389: LD_STRING Signal
6391: PPUSH
6392: CALL_OW 339
// attackAvalaible = 1 ;
6396: LD_ADDR_EXP 61
6400: PUSH
6401: LD_INT 1
6403: ST_TO_ADDR
// enable ( 6 ) ;
6404: LD_INT 6
6406: ENABLE_MARKED
// EnableExclamations ;
6407: CALL_OW 473
// end ;
6411: LD_VAR 0 1
6415: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6416: LD_INT 0
6418: PPUSH
6419: PPUSH
6420: PPUSH
6421: PPUSH
// DisableExclamations ;
6422: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6426: LD_EXP 1
6430: PPUSH
6431: LD_STRING DSituation-Bur-1
6433: PPUSH
6434: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6438: LD_ADDR_VAR 0 4
6442: PUSH
6443: LD_INT 22
6445: PUSH
6446: LD_EXP 23
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 2
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 50
6467: PUSH
6468: EMPTY
6469: LIST
6470: PUSH
6471: LD_INT 3
6473: PUSH
6474: LD_INT 23
6476: PUSH
6477: LD_INT 0
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: PPUSH
6494: CALL_OW 69
6498: ST_TO_ADDR
// if 0 + filter_all > 0 then
6499: LD_INT 0
6501: PUSH
6502: LD_VAR 0 4
6506: PLUS
6507: PUSH
6508: LD_INT 0
6510: GREATER
6511: IFFALSE 6612
// begin filter := [ ] ;
6513: LD_ADDR_VAR 0 3
6517: PUSH
6518: EMPTY
6519: ST_TO_ADDR
// for un in filter_all do
6520: LD_ADDR_VAR 0 2
6524: PUSH
6525: LD_VAR 0 4
6529: PUSH
6530: FOR_IN
6531: IFFALSE 6564
// if not ( un in all_possible ) then
6533: LD_VAR 0 2
6537: PUSH
6538: LD_EXP 39
6542: IN
6543: NOT
6544: IFFALSE 6562
// filter := filter union un ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_VAR 0 2
6560: UNION
6561: ST_TO_ADDR
6562: GO 6530
6564: POP
6565: POP
// if filter > 0 then
6566: LD_VAR 0 3
6570: PUSH
6571: LD_INT 0
6573: GREATER
6574: IFFALSE 6594
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6576: LD_VAR 0 3
6580: PUSH
6581: LD_INT 1
6583: ARRAY
6584: PPUSH
6585: LD_STRING DSituation-RFSol1-1
6587: PPUSH
6588: CALL_OW 88
6592: GO 6610
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6594: LD_VAR 0 4
6598: PUSH
6599: LD_INT 1
6601: ARRAY
6602: PPUSH
6603: LD_STRING DSituation-RFSol1-1
6605: PPUSH
6606: CALL_OW 88
// end else
6610: GO 6800
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6612: LD_ADDR_VAR 0 4
6616: PUSH
6617: LD_INT 22
6619: PUSH
6620: LD_EXP 23
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 26
6631: PUSH
6632: LD_INT 1
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: LD_INT 50
6641: PUSH
6642: EMPTY
6643: LIST
6644: PUSH
6645: LD_INT 3
6647: PUSH
6648: LD_INT 23
6650: PUSH
6651: LD_INT 0
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: EMPTY
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: PPUSH
6668: CALL_OW 69
6672: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: LD_VAR 0 4
6682: PUSH
6683: LD_EXP 1
6687: DIFF
6688: ST_TO_ADDR
// if 0 + filter_all > 0 then
6689: LD_INT 0
6691: PUSH
6692: LD_VAR 0 4
6696: PLUS
6697: PUSH
6698: LD_INT 0
6700: GREATER
6701: IFFALSE 6800
// begin filter := [ ] ;
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: EMPTY
6709: ST_TO_ADDR
// for un in filter_all do
6710: LD_ADDR_VAR 0 2
6714: PUSH
6715: LD_VAR 0 4
6719: PUSH
6720: FOR_IN
6721: IFFALSE 6754
// if not ( un in all_possible ) then
6723: LD_VAR 0 2
6727: PUSH
6728: LD_EXP 39
6732: IN
6733: NOT
6734: IFFALSE 6752
// filter := filter union un ;
6736: LD_ADDR_VAR 0 3
6740: PUSH
6741: LD_VAR 0 3
6745: PUSH
6746: LD_VAR 0 2
6750: UNION
6751: ST_TO_ADDR
6752: GO 6720
6754: POP
6755: POP
// if filter > 0 then
6756: LD_VAR 0 3
6760: PUSH
6761: LD_INT 0
6763: GREATER
6764: IFFALSE 6784
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6766: LD_VAR 0 3
6770: PUSH
6771: LD_INT 1
6773: ARRAY
6774: PPUSH
6775: LD_STRING DSituation-RSol1-1
6777: PPUSH
6778: CALL_OW 88
6782: GO 6800
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6784: LD_VAR 0 4
6788: PUSH
6789: LD_INT 1
6791: ARRAY
6792: PPUSH
6793: LD_STRING DSituation-RSol1-1
6795: PPUSH
6796: CALL_OW 88
// end ; end ; EnableExclamations ;
6800: CALL_OW 473
// end ;
6804: LD_VAR 0 1
6808: RET
// export function D_GO1 ; begin
6809: LD_INT 0
6811: PPUSH
// DisableExclamations ;
6812: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6816: LD_EXP 1
6820: PPUSH
6821: LD_STRING DGO#1-Bur-1
6823: PPUSH
6824: CALL_OW 88
// EnableExclamations ;
6828: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6832: LD_INT 11
6834: PPUSH
6835: LD_INT 1
6837: PPUSH
6838: CALL_OW 424
// end ;
6842: LD_VAR 0 1
6846: RET
// export function D_SeeYou ; begin
6847: LD_INT 0
6849: PPUSH
// DisableExclamations ;
6850: CALL_OW 474
// DialogueOn ;
6854: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6858: LD_EXP 8
6862: PPUSH
6863: LD_STRING DSeeYou-Gos-1
6865: PPUSH
6866: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6870: LD_EXP 1
6874: PPUSH
6875: LD_STRING DSeeYou-Bur-1
6877: PPUSH
6878: CALL_OW 88
// DialogueOff ;
6882: CALL_OW 7
// EnableExclamations ;
6886: CALL_OW 473
// end ; end_of_file
6890: LD_VAR 0 1
6894: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6895: GO 6897
6897: DISABLE
6898: LD_INT 0
6900: PPUSH
6901: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6902: LD_EXP 1
6906: PPUSH
6907: LD_INT 1
6909: PPUSH
6910: CALL_OW 308
6914: IFFALSE 6980
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: LD_INT 22
6923: PUSH
6924: LD_EXP 27
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PPUSH
6933: CALL_OW 69
6937: ST_TO_ADDR
// for un in filter do
6938: LD_ADDR_VAR 0 2
6942: PUSH
6943: LD_VAR 0 1
6947: PUSH
6948: FOR_IN
6949: IFFALSE 6967
// setside ( un , you ) ;
6951: LD_VAR 0 2
6955: PPUSH
6956: LD_EXP 23
6960: PPUSH
6961: CALL_OW 235
6965: GO 6948
6967: POP
6968: POP
// BurlakReachedBase := true ;
6969: LD_ADDR_EXP 28
6973: PUSH
6974: LD_INT 1
6976: ST_TO_ADDR
// disable ;
6977: DISABLE
// end else
6978: GO 6981
// enable ;
6980: ENABLE
// end ;
6981: PPOPN 2
6983: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6984: GO 6986
6986: DISABLE
6987: LD_INT 0
6989: PPUSH
6990: PPUSH
6991: PPUSH
6992: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6993: LD_EXP 1
6997: PPUSH
6998: LD_INT 10
7000: PPUSH
7001: CALL_OW 308
7005: IFFALSE 7236
// begin DisableExclamations ;
7007: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
7011: LD_ADDR_VAR 0 1
7015: PUSH
7016: LD_INT 22
7018: PUSH
7019: LD_EXP 27
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 69
7032: ST_TO_ADDR
// skill := 0 ;
7033: LD_ADDR_VAR 0 3
7037: PUSH
7038: LD_INT 0
7040: ST_TO_ADDR
// for un in filter do
7041: LD_ADDR_VAR 0 2
7045: PUSH
7046: LD_VAR 0 1
7050: PUSH
7051: FOR_IN
7052: IFFALSE 7086
// if GetSkill ( un , skill_engineering ) >= skill then
7054: LD_VAR 0 2
7058: PPUSH
7059: LD_INT 2
7061: PPUSH
7062: CALL_OW 259
7066: PUSH
7067: LD_VAR 0 3
7071: GREATEREQUAL
7072: IFFALSE 7084
// inzenyr := un ;
7074: LD_ADDR_VAR 0 4
7078: PUSH
7079: LD_VAR 0 2
7083: ST_TO_ADDR
7084: GO 7051
7086: POP
7087: POP
// ComStop ( inzenyr ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7097: LD_VAR 0 4
7101: PPUSH
7102: CALL_OW 257
7106: PUSH
7107: LD_INT 2
7109: NONEQUAL
7110: IFFALSE 7201
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7112: LD_ADDR_VAR 0 1
7116: PUSH
7117: LD_INT 30
7119: PUSH
7120: LD_INT 1
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 22
7129: PUSH
7130: LD_EXP 27
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PUSH
7139: EMPTY
7140: LIST
7141: LIST
7142: PPUSH
7143: CALL_OW 69
7147: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7148: LD_VAR 0 4
7152: PPUSH
7153: LD_VAR 0 1
7157: PUSH
7158: LD_INT 1
7160: ARRAY
7161: PPUSH
7162: CALL_OW 120
// Wait ( 10 ) ;
7166: LD_INT 10
7168: PPUSH
7169: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7173: LD_VAR 0 4
7177: PPUSH
7178: LD_INT 2
7180: PPUSH
7181: CALL_OW 183
// Wait ( 10 ) ;
7185: LD_INT 10
7187: PPUSH
7188: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7192: LD_VAR 0 4
7196: PPUSH
7197: CALL_OW 182
// end ; Wait ( 10 ) ;
7201: LD_INT 10
7203: PPUSH
7204: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7208: LD_VAR 0 4
7212: PPUSH
7213: LD_INT 26
7215: PPUSH
7216: LD_INT 126
7218: PPUSH
7219: LD_INT 17
7221: PPUSH
7222: LD_INT 5
7224: PPUSH
7225: CALL_OW 205
// EnableExclamations ;
7229: CALL_OW 473
// disable ;
7233: DISABLE
// end else
7234: GO 7237
// enable ;
7236: ENABLE
// end ;
7237: PPOPN 4
7239: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7240: GO 7242
7242: DISABLE
7243: LD_INT 0
7245: PPUSH
7246: PPUSH
// begin if straz < bazooker then
7247: LD_EXP 45
7251: PUSH
7252: LD_EXP 51
7256: LESS
7257: IFFALSE 7405
// begin bazooker := bazooker + 1 ;
7259: LD_ADDR_EXP 51
7263: PUSH
7264: LD_EXP 51
7268: PUSH
7269: LD_INT 1
7271: PLUS
7272: ST_TO_ADDR
// while straz < bazooker do
7273: LD_EXP 45
7277: PUSH
7278: LD_EXP 51
7282: LESS
7283: IFFALSE 7405
// begin uc_side := rus ;
7285: LD_ADDR_OWVAR 20
7289: PUSH
7290: LD_EXP 24
7294: ST_TO_ADDR
// uc_nation := nation_russian ;
7295: LD_ADDR_OWVAR 21
7299: PUSH
7300: LD_INT 3
7302: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 4 + difficulty ) ;
7303: LD_INT 1
7305: PPUSH
7306: LD_INT 9
7308: PPUSH
7309: LD_INT 4
7311: PUSH
7312: LD_OWVAR 67
7316: PLUS
7317: PPUSH
7318: CALL_OW 380
// hc_name :=  ;
7322: LD_ADDR_OWVAR 26
7326: PUSH
7327: LD_STRING 
7329: ST_TO_ADDR
// bazukr := CreateHuman ;
7330: LD_ADDR_VAR 0 2
7334: PUSH
7335: CALL_OW 44
7339: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7340: LD_EXP 62
7344: PPUSH
7345: LD_VAR 0 2
7349: PPUSH
7350: LD_INT 1
7352: PPUSH
7353: CALL_OW 394
// straz := straz ^ bazukr ;
7357: LD_ADDR_EXP 45
7361: PUSH
7362: LD_EXP 45
7366: PUSH
7367: LD_VAR 0 2
7371: ADD
7372: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7373: LD_VAR 0 2
7377: PPUSH
7378: LD_INT 9
7380: PPUSH
7381: LD_INT 0
7383: PPUSH
7384: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7388: LD_VAR 0 2
7392: PPUSH
7393: LD_INT 66
7395: PPUSH
7396: LD_INT 48
7398: PPUSH
7399: CALL_OW 114
// end ;
7403: GO 7273
// end ; end ;
7405: PPOPN 2
7407: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7408: GO 7410
7410: DISABLE
7411: LD_INT 0
7413: PPUSH
// begin if ( 0 + straz ) <> 0 then
7414: LD_INT 0
7416: PUSH
7417: LD_EXP 45
7421: PLUS
7422: PUSH
7423: LD_INT 0
7425: NONEQUAL
7426: IFFALSE 7669
// begin for un in straz do
7428: LD_ADDR_VAR 0 1
7432: PUSH
7433: LD_EXP 45
7437: PUSH
7438: FOR_IN
7439: IFFALSE 7667
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7441: LD_VAR 0 1
7445: PPUSH
7446: CALL_OW 314
7450: NOT
7451: PUSH
7452: LD_VAR 0 1
7456: PPUSH
7457: CALL_OW 256
7461: PUSH
7462: LD_INT 601
7464: GREATER
7465: AND
7466: IFFALSE 7665
// begin if GetY ( un ) > 60 then
7468: LD_VAR 0 1
7472: PPUSH
7473: CALL_OW 251
7477: PUSH
7478: LD_INT 60
7480: GREATER
7481: IFFALSE 7575
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 66
7490: PPUSH
7491: LD_INT 48
7493: PPUSH
7494: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7498: LD_VAR 0 1
7502: PPUSH
7503: LD_INT 63
7505: PPUSH
7506: LD_INT 74
7508: PPUSH
7509: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7513: LD_VAR 0 1
7517: PPUSH
7518: LD_INT 73
7520: PPUSH
7521: LD_INT 90
7523: PPUSH
7524: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7528: LD_VAR 0 1
7532: PPUSH
7533: LD_INT 76
7535: PPUSH
7536: LD_INT 95
7538: PPUSH
7539: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7543: LD_VAR 0 1
7547: PPUSH
7548: LD_INT 72
7550: PPUSH
7551: LD_INT 95
7553: PPUSH
7554: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: LD_INT 50
7565: PPUSH
7566: LD_INT 73
7568: PPUSH
7569: CALL_OW 174
// end else
7573: GO 7665
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7575: LD_VAR 0 1
7579: PPUSH
7580: LD_INT 73
7582: PPUSH
7583: LD_INT 90
7585: PPUSH
7586: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7590: LD_VAR 0 1
7594: PPUSH
7595: LD_INT 76
7597: PPUSH
7598: LD_INT 95
7600: PPUSH
7601: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7605: LD_VAR 0 1
7609: PPUSH
7610: LD_INT 72
7612: PPUSH
7613: LD_INT 95
7615: PPUSH
7616: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7620: LD_VAR 0 1
7624: PPUSH
7625: LD_INT 50
7627: PPUSH
7628: LD_INT 73
7630: PPUSH
7631: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7635: LD_VAR 0 1
7639: PPUSH
7640: LD_INT 63
7642: PPUSH
7643: LD_INT 74
7645: PPUSH
7646: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7650: LD_VAR 0 1
7654: PPUSH
7655: LD_INT 66
7657: PPUSH
7658: LD_INT 48
7660: PPUSH
7661: CALL_OW 174
// end ; end ; end ;
7665: GO 7438
7667: POP
7668: POP
// end ; enable ;
7669: ENABLE
// end ;
7670: PPOPN 1
7672: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7673: GO 7675
7675: DISABLE
7676: LD_INT 0
7678: PPUSH
7679: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7680: LD_EXP 1
7684: PPUSH
7685: LD_INT 2
7687: PPUSH
7688: CALL_OW 308
7692: IFFALSE 7736
// begin disabled5 := true ;
7694: LD_ADDR_LOC 4
7698: PUSH
7699: LD_INT 1
7701: ST_TO_ADDR
// D_GosStart ;
7702: CALL 5553 0 0
// Wait ( 0 0$5 ) ;
7706: LD_INT 175
7708: PPUSH
7709: CALL_OW 67
// D_Situation ;
7713: CALL 6416 0 0
// ChangeMissionObjectives ( MHold ) ;
7717: LD_STRING MHold
7719: PPUSH
7720: CALL_OW 337
// disable ;
7724: DISABLE
// enable ( 333 ) ;
7725: LD_INT 333
7727: ENABLE_MARKED
// enable ( 334 ) ;
7728: LD_INT 334
7730: ENABLE_MARKED
// enable ( 337 ) ;
7731: LD_INT 337
7733: ENABLE_MARKED
// end else
7734: GO 7737
// enable ;
7736: ENABLE
// end ;
7737: PPOPN 2
7739: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7740: GO 7742
7742: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7743: LD_EXP 8
7747: PPUSH
7748: CALL_OW 306
7752: PUSH
7753: LD_INT 1
7755: EQUAL
7756: IFFALSE 7782
// begin if WasSelected = false then
7758: LD_EXP 46
7762: PUSH
7763: LD_INT 0
7765: EQUAL
7766: IFFALSE 7780
// begin QueryQGO ;
7768: CALL 7799 0 0
// WasSelected := true ;
7772: LD_ADDR_EXP 46
7776: PUSH
7777: LD_INT 1
7779: ST_TO_ADDR
// end ; end else
7780: GO 7790
// WasSelected := false ;
7782: LD_ADDR_EXP 46
7786: PUSH
7787: LD_INT 0
7789: ST_TO_ADDR
// if not disabled3 then
7790: LD_LOC 3
7794: NOT
7795: IFFALSE 7798
// enable ;
7797: ENABLE
// end ;
7798: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7799: LD_INT 0
7801: PPUSH
7802: PPUSH
7803: PPUSH
7804: PPUSH
7805: PPUSH
7806: PPUSH
// res := Query ( QGO ) ;
7807: LD_ADDR_VAR 0 2
7811: PUSH
7812: LD_STRING QGO
7814: PPUSH
7815: CALL_OW 97
7819: ST_TO_ADDR
// if res = 1 then
7820: LD_VAR 0 2
7824: PUSH
7825: LD_INT 1
7827: EQUAL
7828: IFFALSE 8204
// begin disabled3 := true ;
7830: LD_ADDR_LOC 3
7834: PUSH
7835: LD_INT 1
7837: ST_TO_ADDR
// D_GO1 ;
7838: CALL 6809 0 0
// ChangeMissionObjectives ( MGuide ) ;
7842: LD_STRING MGuide
7844: PPUSH
7845: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7849: LD_ADDR_VAR 0 3
7853: PUSH
7854: LD_INT 3
7856: PPUSH
7857: LD_INT 21
7859: PUSH
7860: LD_INT 2
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: PUSH
7867: LD_INT 34
7869: PUSH
7870: LD_INT 51
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PUSH
7877: EMPTY
7878: LIST
7879: LIST
7880: PPUSH
7881: CALL_OW 70
7885: ST_TO_ADDR
// if filter = 0 then
7886: LD_VAR 0 3
7890: PUSH
7891: LD_INT 0
7893: EQUAL
7894: IFFALSE 8045
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7896: LD_EXP 8
7900: PPUSH
7901: LD_INT 57
7903: PPUSH
7904: LD_INT 98
7906: PPUSH
7907: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7911: LD_INT 35
7913: PPUSH
7914: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7918: LD_EXP 8
7922: PPUSH
7923: CALL_OW 314
7927: NOT
7928: IFFALSE 7911
// RemoveUnit ( Gossudarov ) ;
7930: LD_EXP 8
7934: PPUSH
7935: CALL_OW 64
// uc_side := ally ;
7939: LD_ADDR_OWVAR 20
7943: PUSH
7944: LD_EXP 25
7948: ST_TO_ADDR
// uc_nation := nation_russian ;
7949: LD_ADDR_OWVAR 21
7953: PUSH
7954: LD_INT 3
7956: ST_TO_ADDR
// uc_direction := 5 ;
7957: LD_ADDR_OWVAR 24
7961: PUSH
7962: LD_INT 5
7964: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7965: LD_ADDR_OWVAR 37
7969: PUSH
7970: LD_INT 21
7972: ST_TO_ADDR
// vc_engine := engine_combustion ;
7973: LD_ADDR_OWVAR 39
7977: PUSH
7978: LD_INT 1
7980: ST_TO_ADDR
// vc_control := control_manual ;
7981: LD_ADDR_OWVAR 38
7985: PUSH
7986: LD_INT 1
7988: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7989: LD_ADDR_OWVAR 40
7993: PUSH
7994: LD_INT 51
7996: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7997: LD_ADDR_VAR 0 4
8001: PUSH
8002: CALL_OW 45
8006: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
8007: LD_EXP 8
8011: PPUSH
8012: LD_VAR 0 4
8016: PPUSH
8017: CALL_OW 52
// Wait ( 0 0$5 ) ;
8021: LD_INT 175
8023: PPUSH
8024: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
8028: LD_VAR 0 4
8032: PPUSH
8033: LD_INT 9
8035: PPUSH
8036: LD_INT 0
8038: PPUSH
8039: CALL_OW 49
// end else
8043: GO 8063
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
8045: LD_EXP 8
8049: PPUSH
8050: LD_VAR 0 3
8054: PUSH
8055: LD_INT 1
8057: ARRAY
8058: PPUSH
8059: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8063: LD_EXP 8
8067: PPUSH
8068: LD_INT 4
8070: PPUSH
8071: CALL_OW 469
8075: PUSH
8076: LD_INT 1
8078: ARRAY
8079: PPUSH
8080: LD_INT 4
8082: PPUSH
8083: CALL_OW 469
8087: PUSH
8088: LD_INT 2
8090: ARRAY
8091: PPUSH
8092: CALL_OW 220
// Wait ( 0 0$5 ) ;
8096: LD_INT 175
8098: PPUSH
8099: CALL_OW 67
// ComExitBuilding ( scientists ) ;
8103: LD_EXP 40
8107: PPUSH
8108: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
8112: LD_EXP 40
8116: PUSH
8117: LD_EXP 8
8121: ADD
8122: PPUSH
8123: LD_INT 50
8125: PPUSH
8126: LD_INT 58
8128: PPUSH
8129: CALL_OW 171
// for un in scientists ^ Gossudarov do
8133: LD_ADDR_VAR 0 6
8137: PUSH
8138: LD_EXP 40
8142: PUSH
8143: LD_EXP 8
8147: ADD
8148: PUSH
8149: FOR_IN
8150: IFFALSE 8168
// AddComSailEvent ( un , un ) ;
8152: LD_VAR 0 6
8156: PPUSH
8157: LD_VAR 0 6
8161: PPUSH
8162: CALL_OW 224
8166: GO 8149
8168: POP
8169: POP
// player_units := player_units union scientists union Gossudarov ;
8170: LD_ADDR_EXP 41
8174: PUSH
8175: LD_EXP 41
8179: PUSH
8180: LD_EXP 40
8184: UNION
8185: PUSH
8186: LD_EXP 8
8190: UNION
8191: ST_TO_ADDR
// enable ( 4 ) ;
8192: LD_INT 4
8194: ENABLE_MARKED
// enable ( 7 ) ;
8195: LD_INT 7
8197: ENABLE_MARKED
// enable ( 8 ) ;
8198: LD_INT 8
8200: ENABLE_MARKED
// enable ( 9 ) ;
8201: LD_INT 9
8203: ENABLE_MARKED
// end ; end ;
8204: LD_VAR 0 1
8208: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8209: GO 8211
8211: DISABLE
8212: LD_INT 0
8214: PPUSH
// begin for un in scientists do
8215: LD_ADDR_VAR 0 1
8219: PUSH
8220: LD_EXP 40
8224: PUSH
8225: FOR_IN
8226: IFFALSE 8296
// begin if IsInArea ( un , ExitArea ) then
8228: LD_VAR 0 1
8232: PPUSH
8233: LD_INT 11
8235: PPUSH
8236: CALL_OW 308
8240: IFFALSE 8267
// begin scientists_saved := scientists_saved union un ;
8242: LD_ADDR_EXP 48
8246: PUSH
8247: LD_EXP 48
8251: PUSH
8252: LD_VAR 0 1
8256: UNION
8257: ST_TO_ADDR
// RemoveUnit ( un ) ;
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 64
// end ; if IsDead ( un ) then
8267: LD_VAR 0 1
8271: PPUSH
8272: CALL_OW 301
8276: IFFALSE 8294
// scientists_dead := scientists_dead union un ;
8278: LD_ADDR_EXP 49
8282: PUSH
8283: LD_EXP 49
8287: PUSH
8288: LD_VAR 0 1
8292: UNION
8293: ST_TO_ADDR
// end ;
8294: GO 8225
8296: POP
8297: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8298: LD_EXP 8
8302: PPUSH
8303: LD_INT 11
8305: PPUSH
8306: CALL_OW 308
8310: PUSH
8311: LD_EXP 8
8315: PPUSH
8316: CALL_OW 310
8320: PPUSH
8321: LD_INT 11
8323: PPUSH
8324: CALL_OW 308
8328: OR
8329: PUSH
8330: LD_EXP 48
8334: PUSH
8335: LD_EXP 49
8339: PLUS
8340: PUSH
8341: LD_EXP 40
8345: EQUAL
8346: AND
8347: PUSH
8348: LD_EXP 50
8352: PPUSH
8353: CALL_OW 255
8357: PUSH
8358: LD_EXP 23
8362: EQUAL
8363: AND
8364: PUSH
8365: LD_EXP 50
8369: PPUSH
8370: LD_INT 11
8372: PPUSH
8373: CALL_OW 308
8377: AND
8378: PUSH
8379: LD_EXP 50
8383: PPUSH
8384: LD_INT 4
8386: PPUSH
8387: CALL_OW 289
8391: PUSH
8392: LD_INT 40
8394: EQUAL
8395: AND
8396: IFFALSE 8408
// begin D_SeeYou ;
8398: CALL 6847 0 0
// TheEnd ;
8402: CALL 3334 0 0
// end else
8406: GO 8409
// enable ;
8408: ENABLE
// end ;
8409: PPOPN 1
8411: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8412: GO 8414
8414: DISABLE
8415: LD_INT 0
8417: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8418: LD_EXP 1
8422: PPUSH
8423: LD_INT 18
8425: PPUSH
8426: CALL_OW 308
8430: PUSH
8431: LD_EXP 43
8435: PPUSH
8436: LD_INT 18
8438: PPUSH
8439: CALL_OW 308
8443: OR
8444: IFFALSE 8461
// begin Wait ( 0 0$3 ) ;
8446: LD_INT 105
8448: PPUSH
8449: CALL_OW 67
// Attack1 := true ;
8453: LD_ADDR_LOC 5
8457: PUSH
8458: LD_INT 1
8460: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8461: LD_EXP 1
8465: PPUSH
8466: LD_INT 19
8468: PPUSH
8469: CALL_OW 308
8473: PUSH
8474: LD_EXP 43
8478: PPUSH
8479: LD_INT 19
8481: PPUSH
8482: CALL_OW 308
8486: OR
8487: IFFALSE 8504
// begin Wait ( 0 0$3 ) ;
8489: LD_INT 105
8491: PPUSH
8492: CALL_OW 67
// Attack2 := true ;
8496: LD_ADDR_LOC 6
8500: PUSH
8501: LD_INT 1
8503: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8504: LD_EXP 1
8508: PPUSH
8509: LD_INT 20
8511: PPUSH
8512: CALL_OW 308
8516: PUSH
8517: LD_EXP 43
8521: PPUSH
8522: LD_INT 20
8524: PPUSH
8525: CALL_OW 308
8529: OR
8530: IFFALSE 8547
// begin Wait ( 0 0$3 ) ;
8532: LD_INT 105
8534: PPUSH
8535: CALL_OW 67
// Attack3 := true ;
8539: LD_ADDR_LOC 7
8543: PUSH
8544: LD_INT 1
8546: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8547: LD_LOC 5
8551: PUSH
8552: LD_LOC 6
8556: NOT
8557: AND
8558: PUSH
8559: LD_LOC 7
8563: NOT
8564: AND
8565: IFFALSE 8628
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8567: LD_ADDR_VAR 0 1
8571: PUSH
8572: DOUBLE
8573: LD_EXP 31
8577: PUSH
8578: LD_INT 1
8580: PLUS
8581: DEC
8582: ST_TO_ADDR
8583: LD_EXP 31
8587: PUSH
8588: LD_EXP 30
8592: PLUS
8593: PUSH
8594: FOR_TO
8595: IFFALSE 8626
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8597: LD_EXP 29
8601: PUSH
8602: LD_VAR 0 1
8606: ARRAY
8607: PPUSH
8608: LD_EXP 1
8612: PPUSH
8613: CALL_OW 115
// Wait ( 2 ) ;
8617: LD_INT 2
8619: PPUSH
8620: CALL_OW 67
// end ;
8624: GO 8594
8626: POP
8627: POP
// if Attack1 and Attack2 and not Attack3 then
8628: LD_LOC 5
8632: PUSH
8633: LD_LOC 6
8637: AND
8638: PUSH
8639: LD_LOC 7
8643: NOT
8644: AND
8645: IFFALSE 8712
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8647: LD_ADDR_VAR 0 1
8651: PUSH
8652: DOUBLE
8653: LD_EXP 31
8657: PUSH
8658: LD_INT 1
8660: PLUS
8661: DEC
8662: ST_TO_ADDR
8663: LD_EXP 31
8667: PUSH
8668: LD_INT 2
8670: PUSH
8671: LD_EXP 30
8675: MUL
8676: PLUS
8677: PUSH
8678: FOR_TO
8679: IFFALSE 8710
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8681: LD_EXP 29
8685: PUSH
8686: LD_VAR 0 1
8690: ARRAY
8691: PPUSH
8692: LD_EXP 1
8696: PPUSH
8697: CALL_OW 115
// Wait ( 2 ) ;
8701: LD_INT 2
8703: PPUSH
8704: CALL_OW 67
// end ;
8708: GO 8678
8710: POP
8711: POP
// if Attack1 and Attack2 and Attack3 then
8712: LD_LOC 5
8716: PUSH
8717: LD_LOC 6
8721: AND
8722: PUSH
8723: LD_LOC 7
8727: AND
8728: IFFALSE 8795
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8730: LD_ADDR_VAR 0 1
8734: PUSH
8735: DOUBLE
8736: LD_EXP 31
8740: PUSH
8741: LD_INT 1
8743: PLUS
8744: DEC
8745: ST_TO_ADDR
8746: LD_EXP 31
8750: PUSH
8751: LD_INT 3
8753: PUSH
8754: LD_EXP 30
8758: MUL
8759: PLUS
8760: PUSH
8761: FOR_TO
8762: IFFALSE 8793
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8764: LD_EXP 29
8768: PUSH
8769: LD_VAR 0 1
8773: ARRAY
8774: PPUSH
8775: LD_EXP 1
8779: PPUSH
8780: CALL_OW 115
// Wait ( 2 ) ;
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 67
// end ;
8791: GO 8761
8793: POP
8794: POP
// for i := 1 to pursuers_base do
8795: LD_ADDR_VAR 0 1
8799: PUSH
8800: DOUBLE
8801: LD_INT 1
8803: DEC
8804: ST_TO_ADDR
8805: LD_EXP 31
8809: PUSH
8810: FOR_TO
8811: IFFALSE 8842
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8813: LD_EXP 29
8817: PUSH
8818: LD_VAR 0 1
8822: ARRAY
8823: PPUSH
8824: LD_EXP 1
8828: PPUSH
8829: CALL_OW 115
// Wait ( 2 ) ;
8833: LD_INT 2
8835: PPUSH
8836: CALL_OW 67
// end ;
8840: GO 8810
8842: POP
8843: POP
// if not disabled5 then
8844: LD_LOC 4
8848: NOT
8849: IFFALSE 8852
// enable ;
8851: ENABLE
// end ;
8852: PPOPN 1
8854: END
// every 0 0$1 marked 6 do
8855: GO 8857
8857: DISABLE
// begin if Goss_time > 0 then
8858: LD_EXP 47
8862: PUSH
8863: LD_INT 0
8865: GREATER
8866: IFFALSE 8902
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8868: LD_ADDR_OWVAR 47
8872: PUSH
8873: LD_STRING #Ru12a-1
8875: PUSH
8876: LD_EXP 47
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8885: LD_ADDR_EXP 47
8889: PUSH
8890: LD_EXP 47
8894: PUSH
8895: LD_INT 35
8897: MINUS
8898: ST_TO_ADDR
// enable ;
8899: ENABLE
// end else
8900: GO 8913
// begin display_strings :=  ;
8902: LD_ADDR_OWVAR 47
8906: PUSH
8907: LD_STRING 
8909: ST_TO_ADDR
// enable ( 3 ) ;
8910: LD_INT 3
8912: ENABLE_MARKED
// end ; end ;
8913: END
// every 0 0$1 marked 7 do
8914: GO 8916
8916: DISABLE
// begin if FindArtifact ( 4 ) then
8917: LD_INT 4
8919: PPUSH
8920: CALL_OW 469
8924: IFFALSE 8978
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8926: LD_LOC 8
8930: PPUSH
8931: LD_INT 4
8933: PPUSH
8934: CALL_OW 469
8938: PUSH
8939: LD_INT 1
8941: ARRAY
8942: PPUSH
8943: LD_INT 4
8945: PPUSH
8946: CALL_OW 469
8950: PUSH
8951: LD_INT 2
8953: ARRAY
8954: PPUSH
8955: CALL_OW 160
// Wait ( 3 ) ;
8959: LD_INT 3
8961: PPUSH
8962: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8966: LD_LOC 8
8970: PPUSH
8971: LD_INT 9
8973: PPUSH
8974: CALL_OW 173
// end ; enable ;
8978: ENABLE
// end ;
8979: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8980: GO 8982
8982: DISABLE
8983: LD_INT 0
8985: PPUSH
8986: PPUSH
8987: PPUSH
8988: PPUSH
// begin Wait ( pausa ) ;
8989: LD_EXP 37
8993: PPUSH
8994: CALL_OW 67
// sc_utok := [ ] ;
8998: LD_ADDR_VAR 0 3
9002: PUSH
9003: EMPTY
9004: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
9005: LD_ADDR_VAR 0 1
9009: PUSH
9010: DOUBLE
9011: LD_INT 1
9013: DEC
9014: ST_TO_ADDR
9015: LD_INT 2
9017: PUSH
9018: LD_OWVAR 67
9022: PLUS
9023: PUSH
9024: FOR_TO
9025: IFFALSE 9229
// begin uc_side := rus ;
9027: LD_ADDR_OWVAR 20
9031: PUSH
9032: LD_EXP 24
9036: ST_TO_ADDR
// uc_nation := nation_russian ;
9037: LD_ADDR_OWVAR 21
9041: PUSH
9042: LD_INT 3
9044: ST_TO_ADDR
// uc_direction := 5 ;
9045: LD_ADDR_OWVAR 24
9049: PUSH
9050: LD_INT 5
9052: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
9053: LD_INT 1
9055: PPUSH
9056: LD_INT 3
9058: PPUSH
9059: CALL_OW 12
9063: PUSH
9064: LD_INT 1
9066: DOUBLE
9067: EQUAL
9068: IFTRUE 9072
9070: GO 9096
9072: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9073: LD_INT 1
9075: PPUSH
9076: LD_INT 1
9078: PPUSH
9079: LD_INT 4
9081: PPUSH
9082: LD_INT 8
9084: PPUSH
9085: CALL_OW 12
9089: PPUSH
9090: CALL_OW 380
9094: GO 9135
9096: LD_INT 2
9098: DOUBLE
9099: GREATEREQUAL
9100: IFFALSE 9108
9102: LD_INT 3
9104: DOUBLE
9105: LESSEQUAL
9106: IFTRUE 9110
9108: GO 9134
9110: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9111: LD_INT 1
9113: PPUSH
9114: LD_INT 9
9116: PPUSH
9117: LD_INT 3
9119: PPUSH
9120: LD_INT 7
9122: PPUSH
9123: CALL_OW 12
9127: PPUSH
9128: CALL_OW 380
9132: GO 9135
9134: POP
// hc_name :=  ;
9135: LD_ADDR_OWVAR 26
9139: PUSH
9140: LD_STRING 
9142: ST_TO_ADDR
// clovek := CreateHuman ;
9143: LD_ADDR_VAR 0 2
9147: PUSH
9148: CALL_OW 44
9152: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9153: LD_VAR 0 2
9157: PPUSH
9158: LD_INT 9
9160: PPUSH
9161: LD_INT 0
9163: PPUSH
9164: CALL_OW 49
// Wait ( 0 0$2 ) ;
9168: LD_INT 70
9170: PPUSH
9171: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9175: LD_VAR 0 2
9179: PPUSH
9180: LD_INT 50
9182: PPUSH
9183: LD_INT 84
9185: PPUSH
9186: CALL_OW 111
// Wait ( 2 ) ;
9190: LD_INT 2
9192: PPUSH
9193: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9197: LD_VAR 0 2
9201: PPUSH
9202: LD_EXP 50
9206: PPUSH
9207: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9211: LD_ADDR_VAR 0 3
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 2
9225: ADD
9226: ST_TO_ADDR
// end ;
9227: GO 9024
9229: POP
9230: POP
// Wait ( 0 0$10 ) ;
9231: LD_INT 350
9233: PPUSH
9234: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9238: LD_LOC 8
9242: PPUSH
9243: CALL_OW 302
9247: NOT
9248: IFFALSE 9355
// begin uc_side := rus ;
9250: LD_ADDR_OWVAR 20
9254: PUSH
9255: LD_EXP 24
9259: ST_TO_ADDR
// uc_nation := nation_russian ;
9260: LD_ADDR_OWVAR 21
9264: PUSH
9265: LD_INT 3
9267: ST_TO_ADDR
// uc_direction := 5 ;
9268: LD_ADDR_OWVAR 24
9272: PUSH
9273: LD_INT 5
9275: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9276: LD_ADDR_OWVAR 37
9280: PUSH
9281: LD_INT 22
9283: ST_TO_ADDR
// vc_control := control_computer ;
9284: LD_ADDR_OWVAR 38
9288: PUSH
9289: LD_INT 3
9291: ST_TO_ADDR
// vc_engine := engine_siberite ;
9292: LD_ADDR_OWVAR 39
9296: PUSH
9297: LD_INT 3
9299: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9300: LD_ADDR_OWVAR 40
9304: PUSH
9305: LD_INT 51
9307: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9308: LD_ADDR_LOC 8
9312: PUSH
9313: CALL_OW 45
9317: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9318: LD_LOC 8
9322: PPUSH
9323: LD_INT 9
9325: PPUSH
9326: LD_INT 0
9328: PPUSH
9329: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9333: LD_INT 18
9335: PPUSH
9336: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9340: LD_LOC 8
9344: PPUSH
9345: LD_INT 55
9347: PPUSH
9348: LD_INT 84
9350: PPUSH
9351: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9355: LD_VAR 0 3
9359: PUSH
9360: LD_LOC 8
9364: PPUSH
9365: CALL_OW 302
9369: AND
9370: IFFALSE 9440
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9372: LD_VAR 0 3
9376: PPUSH
9377: LD_EXP 50
9381: PPUSH
9382: CALL_OW 115
// Wait ( 0 0$2 ) ;
9386: LD_INT 70
9388: PPUSH
9389: CALL_OW 67
// for un in sc_utok do
9393: LD_ADDR_VAR 0 4
9397: PUSH
9398: LD_VAR 0 3
9402: PUSH
9403: FOR_IN
9404: IFFALSE 9436
// if not IsOK ( un ) then
9406: LD_VAR 0 4
9410: PPUSH
9411: CALL_OW 302
9415: NOT
9416: IFFALSE 9434
// sc_utok := sc_utok diff un ;
9418: LD_ADDR_VAR 0 3
9422: PUSH
9423: LD_VAR 0 3
9427: PUSH
9428: LD_VAR 0 4
9432: DIFF
9433: ST_TO_ADDR
9434: GO 9403
9436: POP
9437: POP
// end ;
9438: GO 9355
// Wait ( 0 0$5 ) ;
9440: LD_INT 175
9442: PPUSH
9443: CALL_OW 67
// enable ;
9447: ENABLE
// end ;
9448: PPOPN 4
9450: END
// every 0 0$3 marked 9 do
9451: GO 9453
9453: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9454: LD_LOC 8
9458: PPUSH
9459: LD_INT 3
9461: PPUSH
9462: CALL_OW 308
9466: PUSH
9467: LD_LOC 8
9471: PPUSH
9472: LD_INT 4
9474: PPUSH
9475: CALL_OW 289
9479: PUSH
9480: LD_INT 40
9482: EQUAL
9483: AND
9484: IFFALSE 9493
// YouLost ( Artefact ) ;
9486: LD_STRING Artefact
9488: PPUSH
9489: CALL_OW 104
// enable ;
9493: ENABLE
// end ;
9494: END
// on UnitDestroyed ( human ) do var i , un ;
9495: LD_INT 0
9497: PPUSH
9498: PPUSH
// begin if human = Burlak then
9499: LD_VAR 0 1
9503: PUSH
9504: LD_EXP 1
9508: EQUAL
9509: IFFALSE 9518
// YouLost ( Burlak ) ;
9511: LD_STRING Burlak
9513: PPUSH
9514: CALL_OW 104
// if human = Gossudarov then
9518: LD_VAR 0 1
9522: PUSH
9523: LD_EXP 8
9527: EQUAL
9528: IFFALSE 9537
// YouLost ( Gossudarov ) ;
9530: LD_STRING Gossudarov
9532: PPUSH
9533: CALL_OW 104
// if human = Masha then
9537: LD_VAR 0 1
9541: PUSH
9542: LD_EXP 43
9546: EQUAL
9547: IFFALSE 9557
// lost_masha := true ;
9549: LD_ADDR_EXP 52
9553: PUSH
9554: LD_INT 1
9556: ST_TO_ADDR
// if human in straz then
9557: LD_VAR 0 1
9561: PUSH
9562: LD_EXP 45
9566: IN
9567: IFFALSE 9616
// begin straz := straz diff human ;
9569: LD_ADDR_EXP 45
9573: PUSH
9574: LD_EXP 45
9578: PUSH
9579: LD_VAR 0 1
9583: DIFF
9584: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9585: LD_EXP 62
9589: PPUSH
9590: LD_VAR 0 1
9594: PPUSH
9595: LD_INT 1
9597: PPUSH
9598: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9602: LD_ADDR_EXP 53
9606: PUSH
9607: LD_EXP 53
9611: PUSH
9612: LD_INT 1
9614: PLUS
9615: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9616: LD_VAR 0 1
9620: PPUSH
9621: CALL_OW 255
9625: PUSH
9626: LD_INT 3
9628: EQUAL
9629: PUSH
9630: LD_VAR 0 1
9634: PUSH
9635: LD_EXP 60
9639: IN
9640: AND
9641: IFFALSE 9688
// begin for i in attackGroup do
9643: LD_ADDR_VAR 0 2
9647: PUSH
9648: LD_EXP 60
9652: PUSH
9653: FOR_IN
9654: IFFALSE 9686
// if i = human then
9656: LD_VAR 0 2
9660: PUSH
9661: LD_VAR 0 1
9665: EQUAL
9666: IFFALSE 9684
// attackGroup = attackGroup diff i ;
9668: LD_ADDR_EXP 60
9672: PUSH
9673: LD_EXP 60
9677: PUSH
9678: LD_VAR 0 2
9682: DIFF
9683: ST_TO_ADDR
9684: GO 9653
9686: POP
9687: POP
// end ; end ;
9688: PPOPN 3
9690: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9691: LD_VAR 0 1
9695: PUSH
9696: LD_EXP 8
9700: EQUAL
9701: IFFALSE 9722
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9703: LD_EXP 8
9707: PPUSH
9708: CALL_OW 310
9712: PPUSH
9713: LD_EXP 23
9717: PPUSH
9718: CALL_OW 235
// SetSide ( num , you ) ;
9722: LD_VAR 0 1
9726: PPUSH
9727: LD_EXP 23
9731: PPUSH
9732: CALL_OW 235
// end ;
9736: PPOPN 1
9738: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 255
9748: PUSH
9749: LD_EXP 24
9753: NONEQUAL
9754: IFFALSE 9766
// Artifact_cargo := un ;
9756: LD_ADDR_EXP 50
9760: PUSH
9761: LD_VAR 0 1
9765: ST_TO_ADDR
// end ; end_of_file
9766: PPOPN 2
9768: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9769: GO 9771
9771: DISABLE
9772: LD_INT 0
9774: PPUSH
9775: PPUSH
9776: PPUSH
9777: PPUSH
9778: PPUSH
9779: PPUSH
9780: PPUSH
// begin case tick of 0 .. 30000 :
9781: LD_OWVAR 1
9785: PUSH
9786: LD_INT 0
9788: DOUBLE
9789: GREATEREQUAL
9790: IFFALSE 9798
9792: LD_INT 30000
9794: DOUBLE
9795: LESSEQUAL
9796: IFTRUE 9800
9798: GO 9810
9800: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9801: LD_INT 1050
9803: PPUSH
9804: CALL_OW 67
9808: GO 9986
9810: LD_INT 30001
9812: DOUBLE
9813: GREATEREQUAL
9814: IFFALSE 9822
9816: LD_INT 50000
9818: DOUBLE
9819: LESSEQUAL
9820: IFTRUE 9824
9822: GO 9834
9824: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9825: LD_INT 1575
9827: PPUSH
9828: CALL_OW 67
9832: GO 9986
9834: LD_INT 50001
9836: DOUBLE
9837: GREATEREQUAL
9838: IFFALSE 9846
9840: LD_INT 70000
9842: DOUBLE
9843: LESSEQUAL
9844: IFTRUE 9848
9846: GO 9858
9848: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9849: LD_INT 2100
9851: PPUSH
9852: CALL_OW 67
9856: GO 9986
9858: LD_INT 70001
9860: DOUBLE
9861: GREATEREQUAL
9862: IFFALSE 9870
9864: LD_INT 90000
9866: DOUBLE
9867: LESSEQUAL
9868: IFTRUE 9872
9870: GO 9882
9872: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9873: LD_INT 2625
9875: PPUSH
9876: CALL_OW 67
9880: GO 9986
9882: LD_INT 70001
9884: DOUBLE
9885: GREATEREQUAL
9886: IFFALSE 9894
9888: LD_INT 90000
9890: DOUBLE
9891: LESSEQUAL
9892: IFTRUE 9896
9894: GO 9906
9896: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9897: LD_INT 3150
9899: PPUSH
9900: CALL_OW 67
9904: GO 9986
9906: LD_INT 90001
9908: DOUBLE
9909: GREATEREQUAL
9910: IFFALSE 9918
9912: LD_INT 110000
9914: DOUBLE
9915: LESSEQUAL
9916: IFTRUE 9920
9918: GO 9930
9920: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9921: LD_INT 3675
9923: PPUSH
9924: CALL_OW 67
9928: GO 9986
9930: LD_INT 110001
9932: DOUBLE
9933: GREATEREQUAL
9934: IFFALSE 9942
9936: LD_INT 130000
9938: DOUBLE
9939: LESSEQUAL
9940: IFTRUE 9944
9942: GO 9954
9944: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9945: LD_INT 4200
9947: PPUSH
9948: CALL_OW 67
9952: GO 9986
9954: LD_INT 130001
9956: DOUBLE
9957: GREATEREQUAL
9958: IFFALSE 9966
9960: LD_INT 150000
9962: DOUBLE
9963: LESSEQUAL
9964: IFTRUE 9968
9966: GO 9978
9968: POP
// Wait ( 2 2$15 ) ; else
9969: LD_INT 4725
9971: PPUSH
9972: CALL_OW 67
9976: GO 9986
9978: POP
// Wait ( 2 2$30 ) ; end ;
9979: LD_INT 5250
9981: PPUSH
9982: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9986: LD_ADDR_LOC 9
9990: PUSH
9991: LD_INT 22
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 1
9999: PUSH
10000: LD_INT 43
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: PUSH
10009: LD_INT 23
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 1
10017: PUSH
10018: LD_INT 45
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 21
10029: PUSH
10030: LD_INT 3
10032: PUSH
10033: LD_INT 1
10035: PUSH
10036: LD_INT 43
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: LIST
10043: LIST
10044: PUSH
10045: LD_INT 24
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 1
10053: PUSH
10054: LD_INT 45
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: PUSH
10063: LD_INT 21
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 1
10071: PUSH
10072: LD_INT 45
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: PUSH
10081: LD_INT 22
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 1
10089: PUSH
10090: LD_INT 44
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: PUSH
10099: LD_INT 24
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 3
10107: PUSH
10108: LD_INT 46
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: PUSH
10117: LD_INT 23
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 46
10128: PUSH
10129: EMPTY
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 24
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 46
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: PUSH
10153: LD_INT 23
10155: PUSH
10156: LD_INT 3
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 47
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 24
10173: PUSH
10174: LD_INT 3
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 49
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_INT 23
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 1
10197: PUSH
10198: LD_INT 49
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: LIST
10211: LIST
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10221: LD_ADDR_VAR 0 1
10225: PUSH
10226: LD_INT 22
10228: PUSH
10229: LD_EXP 23
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 21
10240: PUSH
10241: LD_INT 2
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PUSH
10248: EMPTY
10249: LIST
10250: LIST
10251: PPUSH
10252: CALL_OW 69
10256: ST_TO_ADDR
// if filter < 3 then
10257: LD_VAR 0 1
10261: PUSH
10262: LD_INT 3
10264: LESS
10265: IFFALSE 10275
// filter := 3 ;
10267: LD_ADDR_VAR 0 1
10271: PUSH
10272: LD_INT 3
10274: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10275: LD_INT 22
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: LD_INT 21
10287: PUSH
10288: LD_INT 2
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PUSH
10295: LD_INT 50
10297: PUSH
10298: EMPTY
10299: LIST
10300: PUSH
10301: LD_INT 2
10303: PUSH
10304: LD_INT 34
10306: PUSH
10307: LD_INT 43
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PUSH
10314: LD_INT 34
10316: PUSH
10317: LD_INT 45
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 34
10326: PUSH
10327: LD_INT 44
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: LD_INT 34
10336: PUSH
10337: LD_INT 46
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PUSH
10344: LD_INT 34
10346: PUSH
10347: LD_INT 47
10349: PUSH
10350: EMPTY
10351: LIST
10352: LIST
10353: PUSH
10354: LD_INT 34
10356: PUSH
10357: LD_INT 49
10359: PUSH
10360: EMPTY
10361: LIST
10362: LIST
10363: PUSH
10364: EMPTY
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: PPUSH
10379: CALL_OW 69
10383: PUSH
10384: LD_INT 6
10386: LESSEQUAL
10387: IFFALSE 10918
// for i := 1 to ( filter div 3 ) do
10389: LD_ADDR_VAR 0 2
10393: PUSH
10394: DOUBLE
10395: LD_INT 1
10397: DEC
10398: ST_TO_ADDR
10399: LD_VAR 0 1
10403: PUSH
10404: LD_INT 3
10406: DIV
10407: PUSH
10408: FOR_TO
10409: IFFALSE 10916
// begin uc_side := rus ;
10411: LD_ADDR_OWVAR 20
10415: PUSH
10416: LD_EXP 24
10420: ST_TO_ADDR
// uc_nation := nation_russian ;
10421: LD_ADDR_OWVAR 21
10425: PUSH
10426: LD_INT 3
10428: ST_TO_ADDR
// uc_direction := 5 ;
10429: LD_ADDR_OWVAR 24
10433: PUSH
10434: LD_INT 5
10436: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10437: LD_OWVAR 1
10441: PUSH
10442: LD_INT 60000
10444: LESS
10445: PUSH
10446: LD_INT 28
10448: PPUSH
10449: LD_EXP 23
10453: PPUSH
10454: CALL_OW 321
10458: PUSH
10459: LD_INT 2
10461: EQUAL
10462: OR
10463: IFFALSE 10489
// typ := rand ( 1 , vehicles - 2 ) else
10465: LD_ADDR_VAR 0 4
10469: PUSH
10470: LD_INT 1
10472: PPUSH
10473: LD_LOC 9
10477: PUSH
10478: LD_INT 2
10480: MINUS
10481: PPUSH
10482: CALL_OW 12
10486: ST_TO_ADDR
10487: GO 10507
// typ := rand ( 1 , vehicles ) ;
10489: LD_ADDR_VAR 0 4
10493: PUSH
10494: LD_INT 1
10496: PPUSH
10497: LD_LOC 9
10501: PPUSH
10502: CALL_OW 12
10506: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10507: LD_ADDR_OWVAR 37
10511: PUSH
10512: LD_LOC 9
10516: PUSH
10517: LD_VAR 0 4
10521: ARRAY
10522: PUSH
10523: LD_INT 1
10525: ARRAY
10526: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10527: LD_ADDR_OWVAR 38
10531: PUSH
10532: LD_LOC 9
10536: PUSH
10537: LD_VAR 0 4
10541: ARRAY
10542: PUSH
10543: LD_INT 2
10545: ARRAY
10546: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10547: LD_ADDR_OWVAR 39
10551: PUSH
10552: LD_LOC 9
10556: PUSH
10557: LD_VAR 0 4
10561: ARRAY
10562: PUSH
10563: LD_INT 3
10565: ARRAY
10566: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10567: LD_ADDR_OWVAR 40
10571: PUSH
10572: LD_LOC 9
10576: PUSH
10577: LD_VAR 0 4
10581: ARRAY
10582: PUSH
10583: LD_INT 4
10585: ARRAY
10586: ST_TO_ADDR
// auto := CreateVehicle ;
10587: LD_ADDR_VAR 0 5
10591: PUSH
10592: CALL_OW 45
10596: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10597: LD_VAR 0 5
10601: PPUSH
10602: LD_INT 9
10604: PPUSH
10605: LD_INT 0
10607: PPUSH
10608: CALL_OW 49
// attack := attack ^ auto ;
10612: LD_ADDR_LOC 10
10616: PUSH
10617: LD_LOC 10
10621: PUSH
10622: LD_VAR 0 5
10626: ADD
10627: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10628: LD_VAR 0 5
10632: PPUSH
10633: LD_INT 52
10635: PPUSH
10636: LD_INT 61
10638: PPUSH
10639: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10643: LD_VAR 0 5
10647: PPUSH
10648: LD_INT 52
10650: PPUSH
10651: LD_INT 61
10653: PPUSH
10654: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10658: LD_INT 1
10660: PPUSH
10661: LD_INT 2
10663: PPUSH
10664: CALL_OW 12
10668: PUSH
10669: LD_INT 1
10671: DOUBLE
10672: EQUAL
10673: IFTRUE 10677
10675: GO 10695
10677: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10678: LD_VAR 0 5
10682: PPUSH
10683: LD_INT 35
10685: PPUSH
10686: LD_INT 30
10688: PPUSH
10689: CALL_OW 174
10693: GO 10722
10695: LD_INT 2
10697: DOUBLE
10698: EQUAL
10699: IFTRUE 10703
10701: GO 10721
10703: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10704: LD_VAR 0 5
10708: PPUSH
10709: LD_INT 17
10711: PPUSH
10712: LD_INT 29
10714: PPUSH
10715: CALL_OW 174
10719: GO 10722
10721: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10722: LD_VAR 0 5
10726: PPUSH
10727: LD_INT 29
10729: PPUSH
10730: LD_INT 5
10732: PPUSH
10733: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10737: LD_INT 1
10739: PPUSH
10740: LD_INT 2
10742: PPUSH
10743: CALL_OW 12
10747: PUSH
10748: LD_INT 1
10750: DOUBLE
10751: EQUAL
10752: IFTRUE 10756
10754: GO 10774
10756: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10757: LD_VAR 0 5
10761: PPUSH
10762: LD_INT 60
10764: PPUSH
10765: LD_INT 30
10767: PPUSH
10768: CALL_OW 174
10772: GO 10801
10774: LD_INT 2
10776: DOUBLE
10777: EQUAL
10778: IFTRUE 10782
10780: GO 10800
10782: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10783: LD_VAR 0 5
10787: PPUSH
10788: LD_INT 84
10790: PPUSH
10791: LD_INT 30
10793: PPUSH
10794: CALL_OW 174
10798: GO 10801
10800: POP
// case Rand ( 1 , 2 ) of 1 :
10801: LD_INT 1
10803: PPUSH
10804: LD_INT 2
10806: PPUSH
10807: CALL_OW 12
10811: PUSH
10812: LD_INT 1
10814: DOUBLE
10815: EQUAL
10816: IFTRUE 10820
10818: GO 10838
10820: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10821: LD_VAR 0 5
10825: PPUSH
10826: LD_INT 71
10828: PPUSH
10829: LD_INT 59
10831: PPUSH
10832: CALL_OW 174
10836: GO 10865
10838: LD_INT 2
10840: DOUBLE
10841: EQUAL
10842: IFTRUE 10846
10844: GO 10864
10846: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10847: LD_VAR 0 5
10851: PPUSH
10852: LD_INT 92
10854: PPUSH
10855: LD_INT 66
10857: PPUSH
10858: CALL_OW 174
10862: GO 10865
10864: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10865: LD_VAR 0 5
10869: PPUSH
10870: LD_INT 78
10872: PPUSH
10873: LD_INT 88
10875: PPUSH
10876: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10880: LD_VAR 0 5
10884: PPUSH
10885: LD_INT 117
10887: PPUSH
10888: LD_INT 90
10890: PPUSH
10891: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10895: LD_VAR 0 5
10899: PPUSH
10900: LD_INT 15
10902: PPUSH
10903: CALL_OW 173
// Wait ( 0 0$4 ) ;
10907: LD_INT 140
10909: PPUSH
10910: CALL_OW 67
// end ;
10914: GO 10408
10916: POP
10917: POP
// enable ;
10918: ENABLE
// end ;
10919: PPOPN 7
10921: END
// export function PrepareInfantry ; var i , clovek ; begin
10922: LD_INT 0
10924: PPUSH
10925: PPUSH
10926: PPUSH
// for i = 1 to 6 do
10927: LD_ADDR_VAR 0 2
10931: PUSH
10932: DOUBLE
10933: LD_INT 1
10935: DEC
10936: ST_TO_ADDR
10937: LD_INT 6
10939: PUSH
10940: FOR_TO
10941: IFFALSE 11118
// begin uc_side = 3 ;
10943: LD_ADDR_OWVAR 20
10947: PUSH
10948: LD_INT 3
10950: ST_TO_ADDR
// uc_nation = 3 ;
10951: LD_ADDR_OWVAR 21
10955: PUSH
10956: LD_INT 3
10958: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10959: LD_INT 1
10961: PPUSH
10962: LD_INT 3
10964: PPUSH
10965: CALL_OW 12
10969: PUSH
10970: LD_INT 1
10972: DOUBLE
10973: EQUAL
10974: IFTRUE 10978
10976: GO 11008
10978: POP
// PrepareHuman ( sex_male , class_soldier , rand ( 3 , 5 + Difficulty ) ) ; 2 .. 3 :
10979: LD_INT 1
10981: PPUSH
10982: LD_INT 1
10984: PPUSH
10985: LD_INT 3
10987: PPUSH
10988: LD_INT 5
10990: PUSH
10991: LD_OWVAR 67
10995: PLUS
10996: PPUSH
10997: CALL_OW 12
11001: PPUSH
11002: CALL_OW 380
11006: GO 11053
11008: LD_INT 2
11010: DOUBLE
11011: GREATEREQUAL
11012: IFFALSE 11020
11014: LD_INT 3
11016: DOUBLE
11017: LESSEQUAL
11018: IFTRUE 11022
11020: GO 11052
11022: POP
// PrepareHuman ( sex_male , class_bazooker , rand ( 3 , 4 + Difficulty ) ) ; end ;
11023: LD_INT 1
11025: PPUSH
11026: LD_INT 9
11028: PPUSH
11029: LD_INT 3
11031: PPUSH
11032: LD_INT 4
11034: PUSH
11035: LD_OWVAR 67
11039: PLUS
11040: PPUSH
11041: CALL_OW 12
11045: PPUSH
11046: CALL_OW 380
11050: GO 11053
11052: POP
// hc_name :=  ;
11053: LD_ADDR_OWVAR 26
11057: PUSH
11058: LD_STRING 
11060: ST_TO_ADDR
// clovek := CreateHuman ;
11061: LD_ADDR_VAR 0 3
11065: PUSH
11066: CALL_OW 44
11070: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
11071: LD_VAR 0 3
11075: PPUSH
11076: LD_INT 9
11078: PPUSH
11079: LD_INT 0
11081: PPUSH
11082: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11086: LD_ADDR_EXP 59
11090: PUSH
11091: LD_EXP 59
11095: PUSH
11096: LD_INT 1
11098: MINUS
11099: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11100: LD_ADDR_EXP 60
11104: PUSH
11105: LD_EXP 60
11109: PUSH
11110: LD_VAR 0 3
11114: ADD
11115: ST_TO_ADDR
// end ;
11116: GO 10940
11118: POP
11119: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11120: LD_EXP 60
11124: PPUSH
11125: LD_INT 52
11127: PPUSH
11128: LD_INT 61
11130: PPUSH
11131: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11135: LD_INT 1
11137: PPUSH
11138: LD_INT 2
11140: PPUSH
11141: CALL_OW 12
11145: PUSH
11146: LD_INT 1
11148: DOUBLE
11149: EQUAL
11150: IFTRUE 11154
11152: GO 11172
11154: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11155: LD_EXP 60
11159: PPUSH
11160: LD_INT 35
11162: PPUSH
11163: LD_INT 30
11165: PPUSH
11166: CALL_OW 174
11170: GO 11199
11172: LD_INT 2
11174: DOUBLE
11175: EQUAL
11176: IFTRUE 11180
11178: GO 11198
11180: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11181: LD_EXP 60
11185: PPUSH
11186: LD_INT 17
11188: PPUSH
11189: LD_INT 29
11191: PPUSH
11192: CALL_OW 174
11196: GO 11199
11198: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11199: LD_EXP 60
11203: PPUSH
11204: LD_INT 29
11206: PPUSH
11207: LD_INT 5
11209: PPUSH
11210: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11214: LD_INT 1
11216: PPUSH
11217: LD_INT 2
11219: PPUSH
11220: CALL_OW 12
11224: PUSH
11225: LD_INT 1
11227: DOUBLE
11228: EQUAL
11229: IFTRUE 11233
11231: GO 11251
11233: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11234: LD_EXP 60
11238: PPUSH
11239: LD_INT 60
11241: PPUSH
11242: LD_INT 30
11244: PPUSH
11245: CALL_OW 174
11249: GO 11278
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11277
11259: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11260: LD_EXP 60
11264: PPUSH
11265: LD_INT 84
11267: PPUSH
11268: LD_INT 30
11270: PPUSH
11271: CALL_OW 174
11275: GO 11278
11277: POP
// case Rand ( 1 , 2 ) of 1 :
11278: LD_INT 1
11280: PPUSH
11281: LD_INT 2
11283: PPUSH
11284: CALL_OW 12
11288: PUSH
11289: LD_INT 1
11291: DOUBLE
11292: EQUAL
11293: IFTRUE 11297
11295: GO 11315
11297: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11298: LD_EXP 60
11302: PPUSH
11303: LD_INT 71
11305: PPUSH
11306: LD_INT 59
11308: PPUSH
11309: CALL_OW 174
11313: GO 11342
11315: LD_INT 2
11317: DOUBLE
11318: EQUAL
11319: IFTRUE 11323
11321: GO 11341
11323: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11324: LD_EXP 60
11328: PPUSH
11329: LD_INT 92
11331: PPUSH
11332: LD_INT 66
11334: PPUSH
11335: CALL_OW 174
11339: GO 11342
11341: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11342: LD_EXP 60
11346: PPUSH
11347: LD_INT 78
11349: PPUSH
11350: LD_INT 88
11352: PPUSH
11353: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11357: LD_EXP 60
11361: PPUSH
11362: LD_INT 117
11364: PPUSH
11365: LD_INT 90
11367: PPUSH
11368: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11372: LD_EXP 60
11376: PPUSH
11377: LD_INT 15
11379: PPUSH
11380: CALL_OW 173
// end ;
11384: LD_VAR 0 1
11388: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11389: LD_EXP 60
11393: PUSH
11394: EMPTY
11395: EQUAL
11396: PUSH
11397: LD_EXP 61
11401: PUSH
11402: LD_INT 1
11404: EQUAL
11405: AND
11406: IFFALSE 11416
11408: GO 11410
11410: DISABLE
// begin enable ;
11411: ENABLE
// PrepareInfantry ;
11412: CALL 10922 0 0
// end ;
11416: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11417: GO 11419
11419: DISABLE
11420: LD_INT 0
11422: PPUSH
11423: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11424: LD_ADDR_VAR 0 1
11428: PUSH
11429: LD_INT 15
11431: PPUSH
11432: LD_INT 22
11434: PUSH
11435: LD_EXP 24
11439: PUSH
11440: EMPTY
11441: LIST
11442: LIST
11443: PUSH
11444: LD_INT 50
11446: PUSH
11447: EMPTY
11448: LIST
11449: PUSH
11450: LD_INT 2
11452: PUSH
11453: LD_INT 21
11455: PUSH
11456: LD_INT 2
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 21
11465: PUSH
11466: LD_INT 1
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: LIST
11482: PPUSH
11483: CALL_OW 70
11487: ST_TO_ADDR
// case tick of 0 .. 30000 :
11488: LD_OWVAR 1
11492: PUSH
11493: LD_INT 0
11495: DOUBLE
11496: GREATEREQUAL
11497: IFFALSE 11505
11499: LD_INT 30000
11501: DOUBLE
11502: LESSEQUAL
11503: IFTRUE 11507
11505: GO 11524
11507: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11508: LD_ADDR_VAR 0 2
11512: PUSH
11513: LD_EXP 34
11517: PUSH
11518: LD_INT 4
11520: MINUS
11521: ST_TO_ADDR
11522: GO 11628
11524: LD_INT 30001
11526: DOUBLE
11527: GREATEREQUAL
11528: IFFALSE 11536
11530: LD_INT 50000
11532: DOUBLE
11533: LESSEQUAL
11534: IFTRUE 11538
11536: GO 11555
11538: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11539: LD_ADDR_VAR 0 2
11543: PUSH
11544: LD_EXP 34
11548: PUSH
11549: LD_INT 3
11551: MINUS
11552: ST_TO_ADDR
11553: GO 11628
11555: LD_INT 50001
11557: DOUBLE
11558: GREATEREQUAL
11559: IFFALSE 11567
11561: LD_INT 70000
11563: DOUBLE
11564: LESSEQUAL
11565: IFTRUE 11569
11567: GO 11586
11569: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11570: LD_ADDR_VAR 0 2
11574: PUSH
11575: LD_EXP 34
11579: PUSH
11580: LD_INT 2
11582: MINUS
11583: ST_TO_ADDR
11584: GO 11628
11586: LD_INT 70001
11588: DOUBLE
11589: GREATEREQUAL
11590: IFFALSE 11598
11592: LD_INT 90000
11594: DOUBLE
11595: LESSEQUAL
11596: IFTRUE 11600
11598: GO 11617
11600: POP
// mnozstvi := maxaut - 1 ; else
11601: LD_ADDR_VAR 0 2
11605: PUSH
11606: LD_EXP 34
11610: PUSH
11611: LD_INT 1
11613: MINUS
11614: ST_TO_ADDR
11615: GO 11628
11617: POP
// mnozstvi := maxaut ; end ;
11618: LD_ADDR_VAR 0 2
11622: PUSH
11623: LD_EXP 34
11627: ST_TO_ADDR
// if filter >= mnozstvi then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_VAR 0 2
11637: GREATEREQUAL
11638: IFFALSE 11655
// ComMoveXY ( filter , 138 , 69 ) ;
11640: LD_VAR 0 1
11644: PPUSH
11645: LD_INT 138
11647: PPUSH
11648: LD_INT 69
11650: PPUSH
11651: CALL_OW 111
// enable ;
11655: ENABLE
// end ;
11656: PPOPN 2
11658: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11659: GO 11661
11661: DISABLE
11662: LD_INT 0
11664: PPUSH
11665: PPUSH
11666: PPUSH
11667: PPUSH
11668: PPUSH
11669: PPUSH
// begin enable ;
11670: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11671: LD_ADDR_VAR 0 1
11675: PUSH
11676: LD_INT 12
11678: PPUSH
11679: LD_INT 22
11681: PUSH
11682: LD_EXP 24
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 50
11693: PUSH
11694: EMPTY
11695: LIST
11696: PUSH
11697: LD_INT 3
11699: PUSH
11700: LD_INT 34
11702: PUSH
11703: LD_INT 49
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: EMPTY
11715: LIST
11716: LIST
11717: LIST
11718: PPUSH
11719: CALL_OW 70
11723: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11724: LD_INT 33
11726: PPUSH
11727: LD_EXP 23
11731: PPUSH
11732: CALL_OW 321
11736: PUSH
11737: LD_INT 2
11739: EQUAL
11740: IFFALSE 11794
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11742: LD_ADDR_VAR 0 2
11746: PUSH
11747: LD_INT 12
11749: PPUSH
11750: LD_INT 22
11752: PUSH
11753: LD_EXP 23
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 25
11764: PUSH
11765: LD_INT 4
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 101
11774: PUSH
11775: LD_EXP 24
11779: PUSH
11780: EMPTY
11781: LIST
11782: LIST
11783: PUSH
11784: EMPTY
11785: LIST
11786: LIST
11787: LIST
11788: PPUSH
11789: CALL_OW 70
11793: ST_TO_ADDR
// if filter_you = 0 then
11794: LD_VAR 0 2
11798: PUSH
11799: LD_INT 0
11801: EQUAL
11802: IFFALSE 11911
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11804: LD_ADDR_VAR 0 2
11808: PUSH
11809: LD_INT 22
11811: PUSH
11812: LD_EXP 23
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 50
11823: PUSH
11824: EMPTY
11825: LIST
11826: PUSH
11827: LD_INT 2
11829: PUSH
11830: LD_INT 21
11832: PUSH
11833: LD_INT 1
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 2
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 3
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: LIST
11870: PPUSH
11871: CALL_OW 69
11875: ST_TO_ADDR
// if filter_you = 0 then
11876: LD_VAR 0 2
11880: PUSH
11881: LD_INT 0
11883: EQUAL
11884: IFFALSE 11911
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11886: LD_ADDR_VAR 0 2
11890: PUSH
11891: LD_INT 12
11893: PPUSH
11894: LD_INT 22
11896: PUSH
11897: LD_EXP 23
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PPUSH
11906: CALL_OW 70
11910: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11911: LD_VAR 0 1
11915: PUSH
11916: LD_INT 0
11918: GREATER
11919: PUSH
11920: LD_VAR 0 2
11924: PUSH
11925: LD_INT 0
11927: GREATER
11928: AND
11929: IFFALSE 12320
// begin for un_rus in filter_rus do
11931: LD_ADDR_VAR 0 3
11935: PUSH
11936: LD_VAR 0 1
11940: PUSH
11941: FOR_IN
11942: IFFALSE 12318
// begin Wait ( 5 ) ;
11944: LD_INT 5
11946: PPUSH
11947: CALL_OW 67
// min := 99999 ;
11951: LD_ADDR_VAR 0 5
11955: PUSH
11956: LD_INT 99999
11958: ST_TO_ADDR
// cil := 0 ;
11959: LD_ADDR_VAR 0 6
11963: PUSH
11964: LD_INT 0
11966: ST_TO_ADDR
// for un_you in filter_you do
11967: LD_ADDR_VAR 0 4
11971: PUSH
11972: LD_VAR 0 2
11976: PUSH
11977: FOR_IN
11978: IFFALSE 12174
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11980: LD_VAR 0 4
11984: PPUSH
11985: CALL_OW 320
11989: PUSH
11990: LD_VAR 0 4
11994: PPUSH
11995: CALL_OW 256
11999: PUSH
12000: LD_VAR 0 5
12004: LESS
12005: AND
12006: PUSH
12007: LD_VAR 0 3
12011: PPUSH
12012: LD_VAR 0 4
12016: PPUSH
12017: CALL_OW 296
12021: PUSH
12022: LD_INT 2
12024: PUSH
12025: LD_INT 2
12027: PUSH
12028: LD_INT 4
12030: PUSH
12031: LD_INT 6
12033: PUSH
12034: LD_INT 5
12036: PUSH
12037: LD_INT 9
12039: PUSH
12040: LD_INT 0
12042: PUSH
12043: LD_INT 2
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: LIST
12055: PUSH
12056: LD_VAR 0 3
12060: PPUSH
12061: CALL_OW 264
12065: PUSH
12066: LD_INT 41
12068: MINUS
12069: ARRAY
12070: GREATEREQUAL
12071: AND
12072: PUSH
12073: LD_VAR 0 3
12077: PPUSH
12078: LD_VAR 0 4
12082: PPUSH
12083: CALL_OW 296
12087: PUSH
12088: LD_INT 15
12090: PUSH
12091: LD_INT 16
12093: PUSH
12094: LD_INT 17
12096: PUSH
12097: LD_INT 22
12099: PUSH
12100: LD_INT 20
12102: PUSH
12103: LD_INT 28
12105: PUSH
12106: LD_INT 0
12108: PUSH
12109: LD_INT 51
12111: PUSH
12112: EMPTY
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: PUSH
12122: LD_VAR 0 3
12126: PPUSH
12127: CALL_OW 264
12131: PUSH
12132: LD_INT 41
12134: MINUS
12135: ARRAY
12136: LESSEQUAL
12137: AND
12138: IFFALSE 12165
// begin min := GetLives ( un_you ) ;
12140: LD_ADDR_VAR 0 5
12144: PUSH
12145: LD_VAR 0 4
12149: PPUSH
12150: CALL_OW 256
12154: ST_TO_ADDR
// cil := un_you ;
12155: LD_ADDR_VAR 0 6
12159: PUSH
12160: LD_VAR 0 4
12164: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12165: LD_INT 5
12167: PPUSH
12168: CALL_OW 67
// end ;
12172: GO 11977
12174: POP
12175: POP
// if cil <> 0 then
12176: LD_VAR 0 6
12180: PUSH
12181: LD_INT 0
12183: NONEQUAL
12184: IFFALSE 12202
// ComAttackUnit ( un_rus , cil ) else
12186: LD_VAR 0 3
12190: PPUSH
12191: LD_VAR 0 6
12195: PPUSH
12196: CALL_OW 115
12200: GO 12316
// begin for un_you in filter_you do
12202: LD_ADDR_VAR 0 4
12206: PUSH
12207: LD_VAR 0 2
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12300
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12215: LD_VAR 0 4
12219: PPUSH
12220: CALL_OW 266
12224: PUSH
12225: LD_INT 0
12227: PUSH
12228: LD_INT 1
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: IN
12235: IFFALSE 12249
// cil := un_you else
12237: LD_ADDR_VAR 0 6
12241: PUSH
12242: LD_VAR 0 4
12246: ST_TO_ADDR
12247: GO 12291
// if GetLives ( un_you ) < min then
12249: LD_VAR 0 4
12253: PPUSH
12254: CALL_OW 256
12258: PUSH
12259: LD_VAR 0 5
12263: LESS
12264: IFFALSE 12291
// begin min := GetLives ( un_you ) ;
12266: LD_ADDR_VAR 0 5
12270: PUSH
12271: LD_VAR 0 4
12275: PPUSH
12276: CALL_OW 256
12280: ST_TO_ADDR
// cil := un_you ;
12281: LD_ADDR_VAR 0 6
12285: PUSH
12286: LD_VAR 0 4
12290: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12291: LD_INT 5
12293: PPUSH
12294: CALL_OW 67
// end ;
12298: GO 12212
12300: POP
12301: POP
// ComAttackUnit ( un_rus , cil ) end ;
12302: LD_VAR 0 3
12306: PPUSH
12307: LD_VAR 0 6
12311: PPUSH
12312: CALL_OW 115
// end ;
12316: GO 11941
12318: POP
12319: POP
// end ; end ;
12320: PPOPN 6
12322: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12323: GO 12325
12325: DISABLE
12326: LD_INT 0
12328: PPUSH
12329: PPUSH
12330: PPUSH
12331: PPUSH
12332: PPUSH
12333: PPUSH
// begin enable ;
12334: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12335: LD_ADDR_VAR 0 1
12339: PUSH
12340: LD_INT 21
12342: PPUSH
12343: LD_INT 22
12345: PUSH
12346: LD_EXP 24
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: PUSH
12355: LD_INT 3
12357: PUSH
12358: LD_INT 2
12360: PUSH
12361: LD_INT 21
12363: PUSH
12364: LD_INT 3
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: PUSH
12371: LD_INT 34
12373: PUSH
12374: LD_INT 49
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PUSH
12381: LD_INT 34
12383: PUSH
12384: LD_INT 51
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PUSH
12391: LD_INT 25
12393: PUSH
12394: LD_INT 4
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: PUSH
12401: LD_INT 25
12403: PUSH
12404: LD_INT 2
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: PUSH
12411: LD_INT 54
12413: PUSH
12414: EMPTY
12415: LIST
12416: PUSH
12417: EMPTY
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: PUSH
12426: EMPTY
12427: LIST
12428: LIST
12429: LIST
12430: PPUSH
12431: CALL_OW 70
12435: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12436: LD_ADDR_VAR 0 1
12440: PUSH
12441: LD_VAR 0 1
12445: PUSH
12446: LD_EXP 45
12450: DIFF
12451: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12452: LD_ADDR_VAR 0 2
12456: PUSH
12457: LD_INT 21
12459: PPUSH
12460: LD_INT 22
12462: PUSH
12463: LD_EXP 23
12467: PUSH
12468: EMPTY
12469: LIST
12470: LIST
12471: PUSH
12472: LD_INT 21
12474: PUSH
12475: LD_INT 2
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PPUSH
12486: CALL_OW 70
12490: ST_TO_ADDR
// if not filter_you then
12491: LD_VAR 0 2
12495: NOT
12496: IFFALSE 12569
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12498: LD_ADDR_VAR 0 2
12502: PUSH
12503: LD_INT 21
12505: PPUSH
12506: LD_INT 22
12508: PUSH
12509: LD_EXP 23
12513: PUSH
12514: EMPTY
12515: LIST
12516: LIST
12517: PUSH
12518: LD_INT 25
12520: PUSH
12521: LD_INT 4
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: PUSH
12528: EMPTY
12529: LIST
12530: LIST
12531: PPUSH
12532: CALL_OW 70
12536: ST_TO_ADDR
// if not filter_you then
12537: LD_VAR 0 2
12541: NOT
12542: IFFALSE 12569
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12544: LD_ADDR_VAR 0 2
12548: PUSH
12549: LD_INT 21
12551: PPUSH
12552: LD_INT 22
12554: PUSH
12555: LD_EXP 23
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PPUSH
12564: CALL_OW 70
12568: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12569: LD_VAR 0 1
12573: PUSH
12574: LD_INT 0
12576: GREATER
12577: PUSH
12578: LD_VAR 0 2
12582: PUSH
12583: LD_INT 0
12585: GREATER
12586: AND
12587: IFFALSE 12978
// begin for un_rus in filter_rus do
12589: LD_ADDR_VAR 0 3
12593: PUSH
12594: LD_VAR 0 1
12598: PUSH
12599: FOR_IN
12600: IFFALSE 12976
// begin Wait ( 5 ) ;
12602: LD_INT 5
12604: PPUSH
12605: CALL_OW 67
// min := 99999 ;
12609: LD_ADDR_VAR 0 5
12613: PUSH
12614: LD_INT 99999
12616: ST_TO_ADDR
// cil := 0 ;
12617: LD_ADDR_VAR 0 6
12621: PUSH
12622: LD_INT 0
12624: ST_TO_ADDR
// for un_you in filter_you do
12625: LD_ADDR_VAR 0 4
12629: PUSH
12630: LD_VAR 0 2
12634: PUSH
12635: FOR_IN
12636: IFFALSE 12832
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12638: LD_VAR 0 4
12642: PPUSH
12643: CALL_OW 302
12647: PUSH
12648: LD_VAR 0 4
12652: PPUSH
12653: CALL_OW 256
12657: PUSH
12658: LD_VAR 0 5
12662: LESS
12663: AND
12664: PUSH
12665: LD_VAR 0 3
12669: PPUSH
12670: LD_VAR 0 4
12674: PPUSH
12675: CALL_OW 296
12679: PUSH
12680: LD_INT 2
12682: PUSH
12683: LD_INT 2
12685: PUSH
12686: LD_INT 4
12688: PUSH
12689: LD_INT 6
12691: PUSH
12692: LD_INT 5
12694: PUSH
12695: LD_INT 9
12697: PUSH
12698: LD_INT 0
12700: PUSH
12701: LD_INT 2
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: PUSH
12714: LD_VAR 0 3
12718: PPUSH
12719: CALL_OW 264
12723: PUSH
12724: LD_INT 41
12726: MINUS
12727: ARRAY
12728: GREATEREQUAL
12729: AND
12730: PUSH
12731: LD_VAR 0 3
12735: PPUSH
12736: LD_VAR 0 4
12740: PPUSH
12741: CALL_OW 296
12745: PUSH
12746: LD_INT 15
12748: PUSH
12749: LD_INT 16
12751: PUSH
12752: LD_INT 17
12754: PUSH
12755: LD_INT 22
12757: PUSH
12758: LD_INT 20
12760: PUSH
12761: LD_INT 28
12763: PUSH
12764: LD_INT 0
12766: PUSH
12767: LD_INT 51
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: PUSH
12780: LD_VAR 0 3
12784: PPUSH
12785: CALL_OW 264
12789: PUSH
12790: LD_INT 41
12792: MINUS
12793: ARRAY
12794: LESSEQUAL
12795: AND
12796: IFFALSE 12823
// begin min := GetLives ( un_you ) ;
12798: LD_ADDR_VAR 0 5
12802: PUSH
12803: LD_VAR 0 4
12807: PPUSH
12808: CALL_OW 256
12812: ST_TO_ADDR
// cil := un_you ;
12813: LD_ADDR_VAR 0 6
12817: PUSH
12818: LD_VAR 0 4
12822: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12823: LD_INT 5
12825: PPUSH
12826: CALL_OW 67
// end ;
12830: GO 12635
12832: POP
12833: POP
// if cil <> 0 then
12834: LD_VAR 0 6
12838: PUSH
12839: LD_INT 0
12841: NONEQUAL
12842: IFFALSE 12860
// ComAttackUnit ( un_rus , cil ) else
12844: LD_VAR 0 3
12848: PPUSH
12849: LD_VAR 0 6
12853: PPUSH
12854: CALL_OW 115
12858: GO 12974
// begin for un_you in filter_you do
12860: LD_ADDR_VAR 0 4
12864: PUSH
12865: LD_VAR 0 2
12869: PUSH
12870: FOR_IN
12871: IFFALSE 12958
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12873: LD_VAR 0 4
12877: PPUSH
12878: CALL_OW 266
12882: PUSH
12883: LD_INT 0
12885: PUSH
12886: LD_INT 1
12888: PUSH
12889: EMPTY
12890: LIST
12891: LIST
12892: IN
12893: IFFALSE 12907
// cil := un_you else
12895: LD_ADDR_VAR 0 6
12899: PUSH
12900: LD_VAR 0 4
12904: ST_TO_ADDR
12905: GO 12949
// if GetLives ( un_you ) < min then
12907: LD_VAR 0 4
12911: PPUSH
12912: CALL_OW 256
12916: PUSH
12917: LD_VAR 0 5
12921: LESS
12922: IFFALSE 12949
// begin min := GetLives ( un_you ) ;
12924: LD_ADDR_VAR 0 5
12928: PUSH
12929: LD_VAR 0 4
12933: PPUSH
12934: CALL_OW 256
12938: ST_TO_ADDR
// cil := un_you ;
12939: LD_ADDR_VAR 0 6
12943: PUSH
12944: LD_VAR 0 4
12948: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12949: LD_INT 5
12951: PPUSH
12952: CALL_OW 67
// end ;
12956: GO 12870
12958: POP
12959: POP
// ComAttackUnit ( un_rus , cil ) end ;
12960: LD_VAR 0 3
12964: PPUSH
12965: LD_VAR 0 6
12969: PPUSH
12970: CALL_OW 115
// end ;
12974: GO 12599
12976: POP
12977: POP
// end ; end ;
12978: PPOPN 6
12980: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12981: GO 12983
12983: DISABLE
12984: LD_INT 0
12986: PPUSH
12987: PPUSH
12988: PPUSH
12989: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12990: LD_INT 28
12992: PPUSH
12993: LD_EXP 23
12997: PPUSH
12998: CALL_OW 321
13002: PUSH
13003: LD_INT 2
13005: EQUAL
13006: NOT
13007: IFFALSE 13010
// enable ;
13009: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
13010: LD_ADDR_VAR 0 1
13014: PUSH
13015: LD_INT 12
13017: PPUSH
13018: LD_INT 22
13020: PUSH
13021: LD_EXP 24
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PUSH
13030: LD_INT 50
13032: PUSH
13033: EMPTY
13034: LIST
13035: PUSH
13036: LD_INT 34
13038: PUSH
13039: LD_INT 49
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: LIST
13050: PPUSH
13051: CALL_OW 70
13055: ST_TO_ADDR
// if filter_rus > 0 then
13056: LD_VAR 0 1
13060: PUSH
13061: LD_INT 0
13063: GREATER
13064: IFFALSE 13105
// for un_rus in filter_rus do
13066: LD_ADDR_VAR 0 3
13070: PUSH
13071: LD_VAR 0 1
13075: PUSH
13076: FOR_IN
13077: IFFALSE 13103
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
13079: LD_VAR 0 3
13083: PPUSH
13084: LD_INT 122
13086: PPUSH
13087: LD_INT 27
13089: PPUSH
13090: CALL_OW 111
// Wait ( 5 ) ;
13094: LD_INT 5
13096: PPUSH
13097: CALL_OW 67
// end ;
13101: GO 13076
13103: POP
13104: POP
// end ;
13105: PPOPN 4
13107: END
// every 1 1$0 + 0 0$5.5 do
13108: GO 13110
13110: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13111: LD_INT 59
13113: PPUSH
13114: LD_EXP 24
13118: PPUSH
13119: CALL_OW 321
13123: PUSH
13124: LD_INT 2
13126: EQUAL
13127: NOT
13128: PUSH
13129: LD_OWVAR 1
13133: PUSH
13134: LD_EXP 54
13138: GREATEREQUAL
13139: AND
13140: IFFALSE 13157
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13142: LD_INT 59
13144: PPUSH
13145: LD_EXP 24
13149: PPUSH
13150: LD_INT 2
13152: PPUSH
13153: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13157: LD_INT 50
13159: PPUSH
13160: LD_EXP 24
13164: PPUSH
13165: CALL_OW 321
13169: PUSH
13170: LD_INT 2
13172: EQUAL
13173: NOT
13174: PUSH
13175: LD_OWVAR 1
13179: PUSH
13180: LD_EXP 55
13184: GREATEREQUAL
13185: AND
13186: IFFALSE 13203
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13188: LD_INT 50
13190: PPUSH
13191: LD_EXP 24
13195: PPUSH
13196: LD_INT 2
13198: PPUSH
13199: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13203: LD_INT 53
13205: PPUSH
13206: LD_EXP 24
13210: PPUSH
13211: CALL_OW 321
13215: PUSH
13216: LD_INT 2
13218: EQUAL
13219: NOT
13220: PUSH
13221: LD_OWVAR 1
13225: PUSH
13226: LD_EXP 56
13230: GREATEREQUAL
13231: AND
13232: IFFALSE 13249
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13234: LD_INT 53
13236: PPUSH
13237: LD_EXP 24
13241: PPUSH
13242: LD_INT 2
13244: PPUSH
13245: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13249: LD_INT 56
13251: PPUSH
13252: LD_EXP 24
13256: PPUSH
13257: CALL_OW 321
13261: PUSH
13262: LD_INT 2
13264: EQUAL
13265: NOT
13266: PUSH
13267: LD_OWVAR 1
13271: PUSH
13272: LD_EXP 57
13276: GREATEREQUAL
13277: AND
13278: IFFALSE 13295
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13280: LD_INT 56
13282: PPUSH
13283: LD_EXP 24
13287: PPUSH
13288: LD_INT 2
13290: PPUSH
13291: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13295: LD_INT 65
13297: PPUSH
13298: LD_EXP 24
13302: PPUSH
13303: CALL_OW 321
13307: PUSH
13308: LD_INT 2
13310: EQUAL
13311: NOT
13312: PUSH
13313: LD_OWVAR 1
13317: PUSH
13318: LD_EXP 58
13322: GREATEREQUAL
13323: AND
13324: IFFALSE 13341
// SetTech ( tech_ST3 , rus , state_researched ) ;
13326: LD_INT 65
13328: PPUSH
13329: LD_EXP 24
13333: PPUSH
13334: LD_INT 2
13336: PPUSH
13337: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13341: LD_INT 59
13343: PPUSH
13344: LD_EXP 24
13348: PPUSH
13349: CALL_OW 321
13353: PUSH
13354: LD_INT 2
13356: EQUAL
13357: PUSH
13358: LD_INT 50
13360: PPUSH
13361: LD_EXP 24
13365: PPUSH
13366: CALL_OW 321
13370: PUSH
13371: LD_INT 2
13373: EQUAL
13374: AND
13375: PUSH
13376: LD_INT 53
13378: PPUSH
13379: LD_EXP 24
13383: PPUSH
13384: CALL_OW 321
13388: PUSH
13389: LD_INT 2
13391: EQUAL
13392: AND
13393: PUSH
13394: LD_INT 56
13396: PPUSH
13397: LD_EXP 24
13401: PPUSH
13402: CALL_OW 321
13406: PUSH
13407: LD_INT 2
13409: EQUAL
13410: AND
13411: PUSH
13412: LD_INT 65
13414: PPUSH
13415: LD_EXP 24
13419: PPUSH
13420: CALL_OW 321
13424: PUSH
13425: LD_INT 2
13427: EQUAL
13428: AND
13429: NOT
13430: IFFALSE 13433
// enable ;
13432: ENABLE
// end ; end_of_file
13433: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13434: GO 13436
13436: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13437: LD_ADDR_EXP 63
13441: PUSH
13442: LD_INT 14
13444: PUSH
13445: LD_INT 18
13447: PUSH
13448: LD_INT 19
13450: PUSH
13451: LD_INT 20
13453: PUSH
13454: LD_INT 21
13456: PUSH
13457: LD_INT 22
13459: PUSH
13460: LD_INT 23
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13472: LD_ADDR_EXP 64
13476: PUSH
13477: LD_INT 22
13479: PUSH
13480: LD_EXP 24
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 21
13491: PUSH
13492: LD_INT 3
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: PPUSH
13503: CALL_OW 69
13507: PUSH
13508: LD_INT 14
13510: PUSH
13511: LD_INT 15
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: ADD
13518: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13519: LD_ADDR_EXP 65
13523: PUSH
13524: LD_INT 22
13526: PUSH
13527: LD_EXP 24
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 30
13538: PUSH
13539: LD_INT 1
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PPUSH
13550: CALL_OW 69
13554: PUSH
13555: LD_INT 1
13557: ARRAY
13558: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13559: LD_ADDR_EXP 66
13563: PUSH
13564: LD_INT 22
13566: PUSH
13567: LD_EXP 24
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 30
13578: PUSH
13579: LD_INT 8
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PPUSH
13590: CALL_OW 69
13594: PUSH
13595: LD_INT 1
13597: ARRAY
13598: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13599: LD_ADDR_EXP 67
13603: PUSH
13604: LD_INT 22
13606: PUSH
13607: LD_EXP 24
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: LD_INT 30
13618: PUSH
13619: LD_INT 31
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 69
13634: PUSH
13635: LD_INT 1
13637: ARRAY
13638: ST_TO_ADDR
// enable ( 401 ) ;
13639: LD_INT 401
13641: ENABLE_MARKED
// end ;
13642: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13643: GO 13645
13645: DISABLE
13646: LD_INT 0
13648: PPUSH
13649: PPUSH
13650: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13651: LD_EXP 62
13655: PPUSH
13656: CALL_OW 386
13660: NOT
13661: IFFALSE 13716
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13663: LD_ADDR_EXP 62
13667: PUSH
13668: LD_INT 100
13670: PPUSH
13671: LD_EXP 63
13675: PPUSH
13676: LD_EXP 64
13680: PUSH
13681: LD_EXP 63
13685: ADD
13686: PPUSH
13687: LD_INT 1
13689: PUSH
13690: LD_INT 23
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PUSH
13697: LD_INT 10
13699: PUSH
13700: LD_INT 22
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PUSH
13707: EMPTY
13708: LIST
13709: LIST
13710: PPUSH
13711: CALL_OW 414
13715: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13716: LD_EXP 65
13720: PPUSH
13721: CALL_OW 300
13725: PUSH
13726: LD_EXP 66
13730: PPUSH
13731: CALL_OW 300
13735: OR
13736: PUSH
13737: LD_EXP 67
13741: PPUSH
13742: CALL_OW 300
13746: OR
13747: IFFALSE 13973
// begin for un in rus_mcrep_units do
13749: LD_ADDR_VAR 0 1
13753: PUSH
13754: LD_EXP 63
13758: PUSH
13759: FOR_IN
13760: IFFALSE 13971
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13762: LD_VAR 0 1
13766: PPUSH
13767: CALL_OW 388
13771: PUSH
13772: LD_INT 0
13774: EQUAL
13775: PUSH
13776: LD_VAR 0 1
13780: PPUSH
13781: CALL_OW 256
13785: PUSH
13786: LD_INT 1000
13788: EQUAL
13789: AND
13790: IFFALSE 13957
// case GetClass ( un ) of class_engineer :
13792: LD_VAR 0 1
13796: PPUSH
13797: CALL_OW 257
13801: PUSH
13802: LD_INT 2
13804: DOUBLE
13805: EQUAL
13806: IFTRUE 13810
13808: GO 13854
13810: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13811: LD_EXP 65
13815: PPUSH
13816: CALL_OW 300
13820: PUSH
13821: LD_EXP 65
13825: PPUSH
13826: CALL_OW 313
13830: PUSH
13831: LD_INT 6
13833: EQUAL
13834: NOT
13835: AND
13836: IFFALSE 13852
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13838: LD_VAR 0 1
13842: PPUSH
13843: LD_EXP 65
13847: PPUSH
13848: CALL_OW 120
13852: GO 13955
13854: LD_INT 4
13856: DOUBLE
13857: EQUAL
13858: IFTRUE 13862
13860: GO 13906
13862: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13863: LD_EXP 66
13867: PPUSH
13868: CALL_OW 300
13872: PUSH
13873: LD_EXP 66
13877: PPUSH
13878: CALL_OW 313
13882: PUSH
13883: LD_INT 6
13885: EQUAL
13886: NOT
13887: AND
13888: IFFALSE 13904
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13890: LD_VAR 0 1
13894: PPUSH
13895: LD_EXP 66
13899: PPUSH
13900: CALL_OW 120
13904: GO 13955
13906: LD_INT 1
13908: DOUBLE
13909: EQUAL
13910: IFTRUE 13914
13912: GO 13954
13914: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13915: LD_EXP 67
13919: PPUSH
13920: CALL_OW 300
13924: PUSH
13925: LD_EXP 67
13929: PPUSH
13930: CALL_OW 313
13934: NOT
13935: AND
13936: IFFALSE 13952
// ComEnterUnit ( un , rus_breastwork ) ; end else
13938: LD_VAR 0 1
13942: PPUSH
13943: LD_EXP 67
13947: PPUSH
13948: CALL_OW 120
13952: GO 13955
13954: POP
13955: GO 13969
// ComMoveToArea ( un , BluekherRepairArea ) ;
13957: LD_VAR 0 1
13961: PPUSH
13962: LD_INT 23
13964: PPUSH
13965: CALL_OW 113
13969: GO 13759
13971: POP
13972: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13973: LD_ADDR_VAR 0 3
13977: PUSH
13978: LD_INT 22
13980: PPUSH
13981: LD_INT 22
13983: PUSH
13984: LD_EXP 24
13988: PUSH
13989: EMPTY
13990: LIST
13991: LIST
13992: PUSH
13993: LD_INT 2
13995: PUSH
13996: LD_INT 25
13998: PUSH
13999: LD_INT 2
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: PUSH
14006: LD_INT 25
14008: PUSH
14009: LD_INT 4
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: LIST
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: PPUSH
14025: CALL_OW 71
14029: ST_TO_ADDR
// if filter then
14030: LD_VAR 0 3
14034: IFFALSE 14051
// ComMoveXY ( filter , 48 , 88 ) ;
14036: LD_VAR 0 3
14040: PPUSH
14041: LD_INT 48
14043: PPUSH
14044: LD_INT 88
14046: PPUSH
14047: CALL_OW 111
// enable ;
14051: ENABLE
// end ; end_of_file
14052: PPOPN 3
14054: END
// every 0 0$2 + 0 0$0.1 do
14055: GO 14057
14057: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
14058: LD_INT 22
14060: PUSH
14061: LD_INT 7
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: PUSH
14068: LD_INT 2
14070: PUSH
14071: LD_INT 25
14073: PUSH
14074: LD_INT 12
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: PUSH
14081: LD_INT 25
14083: PUSH
14084: LD_INT 16
14086: PUSH
14087: EMPTY
14088: LIST
14089: LIST
14090: PUSH
14091: LD_INT 25
14093: PUSH
14094: LD_INT 15
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: PUSH
14101: LD_INT 25
14103: PUSH
14104: LD_INT 17
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: PUSH
14111: EMPTY
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PPUSH
14122: CALL_OW 69
14126: PUSH
14127: LD_INT 22
14129: PUSH
14130: LD_INT 7
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: PUSH
14137: LD_INT 21
14139: PUSH
14140: LD_INT 1
14142: PUSH
14143: EMPTY
14144: LIST
14145: LIST
14146: PUSH
14147: LD_INT 3
14149: PUSH
14150: LD_INT 2
14152: PUSH
14153: LD_INT 25
14155: PUSH
14156: LD_INT 12
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_INT 25
14165: PUSH
14166: LD_INT 16
14168: PUSH
14169: EMPTY
14170: LIST
14171: LIST
14172: PUSH
14173: LD_INT 25
14175: PUSH
14176: LD_INT 15
14178: PUSH
14179: EMPTY
14180: LIST
14181: LIST
14182: PUSH
14183: LD_INT 25
14185: PUSH
14186: LD_INT 17
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: LIST
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: LIST
14208: PPUSH
14209: CALL_OW 69
14213: GREATER
14214: IFFALSE 14225
// begin SetAchievement ( ACH_POTA ) ;
14216: LD_STRING ACH_POTA
14218: PPUSH
14219: CALL_OW 543
// exit ;
14223: GO 14226
// end ; enable ;
14225: ENABLE
// end ; end_of_file
14226: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14227: LD_INT 0
14229: PPUSH
14230: PPUSH
// if not missionNumber then
14231: LD_VAR 0 2
14235: NOT
14236: IFFALSE 14240
// exit ;
14238: GO 14370
// achiv := false ;
14240: LD_ADDR_VAR 0 7
14244: PUSH
14245: LD_INT 0
14247: ST_TO_ADDR
// case campaignNumber of 1 :
14248: LD_VAR 0 1
14252: PUSH
14253: LD_INT 1
14255: DOUBLE
14256: EQUAL
14257: IFTRUE 14261
14259: GO 14272
14261: POP
// achiv := ACH_GOTA ; 2 :
14262: LD_ADDR_VAR 0 7
14266: PUSH
14267: LD_STRING ACH_GOTA
14269: ST_TO_ADDR
14270: GO 14322
14272: LD_INT 2
14274: DOUBLE
14275: EQUAL
14276: IFTRUE 14280
14278: GO 14283
14280: POP
// ; 3 :
14281: GO 14322
14283: LD_INT 3
14285: DOUBLE
14286: EQUAL
14287: IFTRUE 14291
14289: GO 14302
14291: POP
// achiv := ACH_MOTSU ; 4 :
14292: LD_ADDR_VAR 0 7
14296: PUSH
14297: LD_STRING ACH_MOTSU
14299: ST_TO_ADDR
14300: GO 14322
14302: LD_INT 4
14304: DOUBLE
14305: EQUAL
14306: IFTRUE 14310
14308: GO 14321
14310: POP
// achiv := ACH_LOP ; end ;
14311: LD_ADDR_VAR 0 7
14315: PUSH
14316: LD_STRING ACH_LOP
14318: ST_TO_ADDR
14319: GO 14322
14321: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14322: LD_OWVAR 67
14326: PUSH
14327: LD_INT 3
14329: EQUAL
14330: PUSH
14331: LD_VAR 0 7
14335: AND
14336: PUSH
14337: LD_VAR 0 3
14341: AND
14342: PUSH
14343: LD_VAR 0 4
14347: AND
14348: PUSH
14349: LD_VAR 0 5
14353: AND
14354: IFFALSE 14370
// SetAchievementEX ( achiv , missionNumber ) ;
14356: LD_VAR 0 7
14360: PPUSH
14361: LD_VAR 0 2
14365: PPUSH
14366: CALL_OW 564
// end ;
14370: LD_VAR 0 6
14374: RET
// export function SA_BehemothConstructed ; begin
14375: LD_INT 0
14377: PPUSH
// SetAchievement ( ACH_SMC ) ;
14378: LD_STRING ACH_SMC
14380: PPUSH
14381: CALL_OW 543
// end ;
14385: LD_VAR 0 1
14389: RET
