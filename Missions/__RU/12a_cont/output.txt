// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 3 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 3
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$45 , 0 0$40 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1575
 345: PUSH
 346: LD_INT 1400
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 4200
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// while scientists > 5 do
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1286
// scientists = Delete ( scientists , scientists + 0 ) ;
1260: LD_ADDR_EXP 40
1264: PUSH
1265: LD_EXP 40
1269: PPUSH
1270: LD_EXP 40
1274: PUSH
1275: LD_INT 0
1277: PLUS
1278: PPUSH
1279: CALL_OW 3
1283: ST_TO_ADDR
1284: GO 1250
// survivors3 = survivors3 diff scientists ;
1286: LD_ADDR_EXP 22
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 40
1300: DIFF
1301: ST_TO_ADDR
// if scientists < 5 then
1302: LD_EXP 40
1306: PUSH
1307: LD_INT 5
1309: LESS
1310: IFFALSE 1401
// for i := 1 to 5 - scientists do
1312: LD_ADDR_VAR 0 3
1316: PUSH
1317: DOUBLE
1318: LD_INT 1
1320: DEC
1321: ST_TO_ADDR
1322: LD_INT 5
1324: PUSH
1325: LD_EXP 40
1329: MINUS
1330: PUSH
1331: FOR_TO
1332: IFFALSE 1399
// begin uc_side = ally ;
1334: LD_ADDR_OWVAR 20
1338: PUSH
1339: LD_EXP 25
1343: ST_TO_ADDR
// uc_nation := nation_russian ;
1344: LD_ADDR_OWVAR 21
1348: PUSH
1349: LD_INT 3
1351: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1352: LD_INT 0
1354: PPUSH
1355: LD_INT 4
1357: PPUSH
1358: LD_INT 5
1360: PPUSH
1361: LD_INT 7
1363: PPUSH
1364: CALL_OW 12
1368: PPUSH
1369: CALL_OW 380
// hc_name :=  ;
1373: LD_ADDR_OWVAR 26
1377: PUSH
1378: LD_STRING 
1380: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1381: LD_ADDR_EXP 40
1385: PUSH
1386: LD_EXP 40
1390: PUSH
1391: CALL_OW 44
1395: ADD
1396: ST_TO_ADDR
// end ;
1397: GO 1331
1399: POP
1400: POP
// for un in scientists do
1401: LD_ADDR_VAR 0 2
1405: PUSH
1406: LD_EXP 40
1410: PUSH
1411: FOR_IN
1412: IFFALSE 1430
// SetSide ( un , ally ) ;
1414: LD_VAR 0 2
1418: PPUSH
1419: LD_EXP 25
1423: PPUSH
1424: CALL_OW 235
1428: GO 1411
1430: POP
1431: POP
// possible := all_possible diff scientists ;
1432: LD_ADDR_EXP 38
1436: PUSH
1437: LD_EXP 39
1441: PUSH
1442: LD_EXP 40
1446: DIFF
1447: ST_TO_ADDR
// if scientists > 5 then
1448: LD_EXP 40
1452: PUSH
1453: LD_INT 5
1455: GREATER
1456: IFFALSE 1500
// for i = scientists downto 5 do
1458: LD_ADDR_VAR 0 3
1462: PUSH
1463: DOUBLE
1464: LD_EXP 40
1468: INC
1469: ST_TO_ADDR
1470: LD_INT 5
1472: PUSH
1473: FOR_DOWNTO
1474: IFFALSE 1498
// scientists := Delete ( scientists , i ) ;
1476: LD_ADDR_EXP 40
1480: PUSH
1481: LD_EXP 40
1485: PPUSH
1486: LD_VAR 0 3
1490: PPUSH
1491: CALL_OW 3
1495: ST_TO_ADDR
1496: GO 1473
1498: POP
1499: POP
// for un in scientists do
1500: LD_ADDR_VAR 0 2
1504: PUSH
1505: LD_EXP 40
1509: PUSH
1510: FOR_IN
1511: IFFALSE 1527
// PlaceHumanInUnit ( un , 2 ) ;
1513: LD_VAR 0 2
1517: PPUSH
1518: LD_INT 2
1520: PPUSH
1521: CALL_OW 52
1525: GO 1510
1527: POP
1528: POP
// new := [ ] ;
1529: LD_ADDR_EXP 36
1533: PUSH
1534: EMPTY
1535: ST_TO_ADDR
// if possible < 10 then
1536: LD_EXP 38
1540: PUSH
1541: LD_INT 10
1543: LESS
1544: IFFALSE 1627
// for i := 1 to 10 - possible do
1546: LD_ADDR_VAR 0 3
1550: PUSH
1551: DOUBLE
1552: LD_INT 1
1554: DEC
1555: ST_TO_ADDR
1556: LD_INT 10
1558: PUSH
1559: LD_EXP 38
1563: MINUS
1564: PUSH
1565: FOR_TO
1566: IFFALSE 1625
// begin uc_side = rus ;
1568: LD_ADDR_OWVAR 20
1572: PUSH
1573: LD_EXP 24
1577: ST_TO_ADDR
// uc_nation := nation_russian ;
1578: LD_ADDR_OWVAR 21
1582: PUSH
1583: LD_INT 3
1585: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1586: LD_INT 0
1588: PPUSH
1589: LD_INT 0
1591: PPUSH
1592: LD_INT 5
1594: PPUSH
1595: CALL_OW 380
// hc_name :=  ;
1599: LD_ADDR_OWVAR 26
1603: PUSH
1604: LD_STRING 
1606: ST_TO_ADDR
// new := new ^ CreateHuman ;
1607: LD_ADDR_EXP 36
1611: PUSH
1612: LD_EXP 36
1616: PUSH
1617: CALL_OW 44
1621: ADD
1622: ST_TO_ADDR
// end ;
1623: GO 1565
1625: POP
1626: POP
// uc_side = rus ;
1627: LD_ADDR_OWVAR 20
1631: PUSH
1632: LD_EXP 24
1636: ST_TO_ADDR
// uc_nation := nation_russian ;
1637: LD_ADDR_OWVAR 21
1641: PUSH
1642: LD_INT 3
1644: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1645: LD_ADDR_EXP 1
1649: PUSH
1650: LD_STRING Burlak
1652: PPUSH
1653: CALL 565 0 1
1657: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1658: LD_EXP 1
1662: PPUSH
1663: LD_INT 3
1665: PPUSH
1666: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1670: LD_ADDR_EXP 20
1674: PUSH
1675: LD_STRING Platonov
1677: PPUSH
1678: CALL_OW 25
1682: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1683: LD_INT 1
1685: PPUSH
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 4
1691: PPUSH
1692: CALL_OW 380
// hc_name :=  ;
1696: LD_ADDR_OWVAR 26
1700: PUSH
1701: LD_STRING 
1703: ST_TO_ADDR
// RSoldier := CreateHuman ;
1704: LD_ADDR_EXP 21
1708: PUSH
1709: CALL_OW 44
1713: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1714: LD_ADDR_VAR 0 3
1718: PUSH
1719: DOUBLE
1720: LD_INT 1
1722: DEC
1723: ST_TO_ADDR
1724: LD_EXP 31
1728: PUSH
1729: LD_INT 3
1731: PUSH
1732: LD_EXP 30
1736: MUL
1737: PLUS
1738: PUSH
1739: FOR_TO
1740: IFFALSE 1832
// begin case Rand ( 1 , 2 ) of 1 :
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: CALL_OW 12
1752: PUSH
1753: LD_INT 1
1755: DOUBLE
1756: EQUAL
1757: IFTRUE 1761
1759: GO 1779
1761: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1762: LD_INT 1
1764: PPUSH
1765: LD_INT 1
1767: PPUSH
1768: LD_EXP 32
1772: PPUSH
1773: CALL_OW 380
1777: GO 1806
1779: LD_INT 2
1781: DOUBLE
1782: EQUAL
1783: IFTRUE 1787
1785: GO 1805
1787: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_EXP 32
1798: PPUSH
1799: CALL_OW 380
1803: GO 1806
1805: POP
// hc_name :=  ;
1806: LD_ADDR_OWVAR 26
1810: PUSH
1811: LD_STRING 
1813: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1814: LD_ADDR_EXP 29
1818: PUSH
1819: LD_EXP 29
1823: PUSH
1824: CALL_OW 44
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1739
1832: POP
1833: POP
// end ;
1834: LD_VAR 0 1
1838: RET
// function select_people ; var units , un ; begin
1839: LD_INT 0
1841: PPUSH
1842: PPUSH
1843: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1844: LD_ADDR_EXP 41
1848: PUSH
1849: LD_STRING 
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 5
1857: PPUSH
1858: LD_INT -1
1860: PUSH
1861: LD_INT -4
1863: PUSH
1864: LD_INT -6
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: PUSH
1872: LD_EXP 1
1876: ADD
1877: PUSH
1878: LD_INT -2
1880: PUSH
1881: LD_INT -4
1883: PUSH
1884: LD_INT -6
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: ADD
1892: PUSH
1893: LD_EXP 20
1897: ADD
1898: PUSH
1899: LD_INT -2
1901: PUSH
1902: LD_INT -5
1904: PUSH
1905: LD_INT -3
1907: PUSH
1908: EMPTY
1909: LIST
1910: LIST
1911: LIST
1912: ADD
1913: PUSH
1914: LD_EXP 38
1918: ADD
1919: PUSH
1920: LD_EXP 22
1924: ADD
1925: PUSH
1926: LD_EXP 36
1930: ADD
1931: PPUSH
1932: LD_INT 1
1934: PUSH
1935: LD_INT 3
1937: PUSH
1938: LD_INT 2
1940: PUSH
1941: LD_INT 4
1943: PUSH
1944: LD_INT 9
1946: PUSH
1947: LD_INT 0
1949: PUSH
1950: LD_INT 2
1952: PUSH
1953: EMPTY
1954: LIST
1955: LIST
1956: LIST
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: LIST
1964: PPUSH
1965: CALL_OW 42
1969: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1970: LD_EXP 41
1974: PUSH
1975: LD_EXP 1
1979: DIFF
1980: PPUSH
1981: LD_EXP 27
1985: PPUSH
1986: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1990: LD_ADDR_VAR 0 3
1994: PUSH
1995: LD_EXP 41
1999: PUSH
2000: LD_EXP 1
2004: DIFF
2005: PUSH
2006: FOR_IN
2007: IFFALSE 2026
// PlaceUnitArea ( un , BaseArea , false ) ;
2009: LD_VAR 0 3
2013: PPUSH
2014: LD_INT 2
2016: PPUSH
2017: LD_INT 0
2019: PPUSH
2020: CALL_OW 49
2024: GO 2006
2026: POP
2027: POP
// end ;
2028: LD_VAR 0 1
2032: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
2033: LD_INT 0
2035: PPUSH
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
2040: LD_ADDR_VAR 0 3
2044: PUSH
2045: LD_STRING EscapeVehicle_12a
2047: PPUSH
2048: LD_INT 1
2050: PUSH
2051: LD_INT 0
2053: PUSH
2054: LD_INT 0
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: LIST
2061: PPUSH
2062: CALL_OW 30
2066: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2067: LD_ADDR_LOC 1
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 1
2079: ARRAY
2080: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 3
2090: PUSH
2091: LD_INT 2
2093: ARRAY
2094: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 3
2104: PUSH
2105: LD_INT 3
2107: ARRAY
2108: ST_TO_ADDR
// if MashaWanted then
2109: LD_LOC 1
2113: IFFALSE 2317
// begin veh := LoadVariable ( Masha , false ) ;
2115: LD_ADDR_VAR 0 2
2119: PUSH
2120: LD_STRING Masha
2122: PPUSH
2123: LD_INT 0
2125: PPUSH
2126: CALL_OW 30
2130: ST_TO_ADDR
// if veh then
2131: LD_VAR 0 2
2135: IFFALSE 2239
// begin uc_side := rus ;
2137: LD_ADDR_OWVAR 20
2141: PUSH
2142: LD_EXP 24
2146: ST_TO_ADDR
// uc_nation := nation_russian ;
2147: LD_ADDR_OWVAR 21
2151: PUSH
2152: LD_INT 3
2154: ST_TO_ADDR
// uc_direction := 2 ;
2155: LD_ADDR_OWVAR 24
2159: PUSH
2160: LD_INT 2
2162: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2163: LD_ADDR_OWVAR 37
2167: PUSH
2168: LD_VAR 0 2
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_VAR 0 2
2186: PUSH
2187: LD_INT 2
2189: ARRAY
2190: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2191: LD_ADDR_OWVAR 38
2195: PUSH
2196: LD_VAR 0 2
2200: PUSH
2201: LD_INT 3
2203: ARRAY
2204: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2205: LD_ADDR_OWVAR 40
2209: PUSH
2210: LD_VAR 0 2
2214: PUSH
2215: LD_INT 4
2217: ARRAY
2218: ST_TO_ADDR
// RealMasha := true ;
2219: LD_ADDR_EXP 42
2223: PUSH
2224: LD_INT 1
2226: ST_TO_ADDR
// Masha := CreateVehicle ;
2227: LD_ADDR_EXP 43
2231: PUSH
2232: CALL_OW 45
2236: ST_TO_ADDR
// end else
2237: GO 2315
// begin uc_side := rus ;
2239: LD_ADDR_OWVAR 20
2243: PUSH
2244: LD_EXP 24
2248: ST_TO_ADDR
// uc_nation := nation_russian ;
2249: LD_ADDR_OWVAR 21
2253: PUSH
2254: LD_INT 3
2256: ST_TO_ADDR
// uc_direction := 2 ;
2257: LD_ADDR_OWVAR 24
2261: PUSH
2262: LD_INT 2
2264: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2265: LD_ADDR_OWVAR 37
2269: PUSH
2270: LD_INT 22
2272: ST_TO_ADDR
// vc_engine := engine_siberite ;
2273: LD_ADDR_OWVAR 39
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2281: LD_ADDR_OWVAR 40
2285: PUSH
2286: LD_INT 43
2288: ST_TO_ADDR
// vc_control := control_manual ;
2289: LD_ADDR_OWVAR 38
2293: PUSH
2294: LD_INT 1
2296: ST_TO_ADDR
// RealMasha := false ;
2297: LD_ADDR_EXP 42
2301: PUSH
2302: LD_INT 0
2304: ST_TO_ADDR
// Masha := CreateVehicle ;
2305: LD_ADDR_EXP 43
2309: PUSH
2310: CALL_OW 45
2314: ST_TO_ADDR
// end ; end else
2315: GO 2397
// begin uc_side := rus ;
2317: LD_ADDR_OWVAR 20
2321: PUSH
2322: LD_EXP 24
2326: ST_TO_ADDR
// uc_nation := nation_russian ;
2327: LD_ADDR_OWVAR 21
2331: PUSH
2332: LD_INT 3
2334: ST_TO_ADDR
// uc_direction := 2 ;
2335: LD_ADDR_OWVAR 24
2339: PUSH
2340: LD_INT 2
2342: ST_TO_ADDR
// vc_chassis := Chassis ;
2343: LD_ADDR_OWVAR 37
2347: PUSH
2348: LD_VAR 0 4
2352: ST_TO_ADDR
// vc_engine := engine_siberite ;
2353: LD_ADDR_OWVAR 39
2357: PUSH
2358: LD_INT 3
2360: ST_TO_ADDR
// vc_weapon := Weapon ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_VAR 0 5
2370: ST_TO_ADDR
// vc_control := control_manual ;
2371: LD_ADDR_OWVAR 38
2375: PUSH
2376: LD_INT 1
2378: ST_TO_ADDR
// RealMasha := false ;
2379: LD_ADDR_EXP 42
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// Masha := CreateVehicle ;
2387: LD_ADDR_EXP 43
2391: PUSH
2392: CALL_OW 45
2396: ST_TO_ADDR
// end ; SetMark ( Masha , 1 ) ;
2397: LD_EXP 43
2401: PPUSH
2402: LD_INT 1
2404: PPUSH
2405: CALL_OW 242
// if GetEngine ( Masha ) <> engine_siberite then
2409: LD_EXP 43
2413: PPUSH
2414: CALL_OW 262
2418: PUSH
2419: LD_INT 3
2421: NONEQUAL
2422: IFFALSE 2444
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2424: LD_EXP 43
2428: PPUSH
2429: LD_INT 70
2431: PPUSH
2432: LD_INT 95
2434: PPUSH
2435: CALL_OW 12
2439: PPUSH
2440: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2444: LD_EXP 43
2448: PPUSH
2449: LD_INT 47
2451: PPUSH
2452: LD_INT 87
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL_OW 48
// end ;
2462: LD_VAR 0 1
2466: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2467: LD_INT 1
2469: PPUSH
2470: LD_STRING bluekher
2472: PPUSH
2473: CALL_OW 500
// IngameOn ;
2477: CALL_OW 8
// Randomize ;
2481: CALL_OW 10
// RandomizeAll ;
2485: CALL_OW 11
// InitBc ;
2489: CALL_OW 21
// InitHc ;
2493: CALL_OW 19
// InitUc ;
2497: CALL_OW 18
// InitVc ;
2501: CALL_OW 20
// disable ( 1 ) ;
2505: LD_INT 1
2507: DISABLE_MARKED
// disable ( 2 ) ;
2508: LD_INT 2
2510: DISABLE_MARKED
// disable ( 3 ) ;
2511: LD_INT 3
2513: DISABLE_MARKED
// disable ( 4 ) ;
2514: LD_INT 4
2516: DISABLE_MARKED
// disable ( 6 ) ;
2517: LD_INT 6
2519: DISABLE_MARKED
// disable ( 7 ) ;
2520: LD_INT 7
2522: DISABLE_MARKED
// disable ( 8 ) ;
2523: LD_INT 8
2525: DISABLE_MARKED
// disable ( 9 ) ;
2526: LD_INT 9
2528: DISABLE_MARKED
// disable ( 333 ) ;
2529: LD_INT 333
2531: DISABLE_MARKED
// disable ( 337 ) ;
2532: LD_INT 337
2534: DISABLE_MARKED
// disable ( 401 ) ;
2535: LD_INT 401
2537: DISABLE_MARKED
// read_parameters ;
2538: CALL 0 0 0
// set_difficulty ;
2542: CALL 257 0 0
// create_people ;
2546: CALL 609 0 0
// select_people ;
2550: CALL 1839 0 0
// place_masha ;
2554: CALL 2033 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2558: LD_INT 53
2560: PPUSH
2561: LD_INT 90
2563: PPUSH
2564: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2568: LD_EXP 1
2572: PPUSH
2573: LD_INT 51
2575: PPUSH
2576: LD_INT 88
2578: PPUSH
2579: LD_INT 0
2581: PPUSH
2582: CALL_OW 48
// ComHold ( Burlak ) ;
2586: LD_EXP 1
2590: PPUSH
2591: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2595: LD_EXP 21
2599: PPUSH
2600: LD_INT 54
2602: PPUSH
2603: LD_INT 90
2605: PPUSH
2606: LD_INT 0
2608: PPUSH
2609: CALL_OW 48
// ComHold ( RSoldier ) ;
2613: LD_EXP 21
2617: PPUSH
2618: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2622: LD_EXP 1
2626: PPUSH
2627: LD_EXP 21
2631: PPUSH
2632: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2636: LD_EXP 21
2640: PPUSH
2641: LD_EXP 1
2645: PPUSH
2646: CALL_OW 119
// D_Platonov ;
2650: CALL 5301 0 0
// IngameOff ;
2654: CALL_OW 9
// SaveForQuickRestart ;
2658: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2662: LD_STRING MRun
2664: PPUSH
2665: CALL_OW 337
// ComMoveXY ( Burlak , 39 , 67 ) ;
2669: LD_EXP 1
2673: PPUSH
2674: LD_INT 39
2676: PPUSH
2677: LD_INT 67
2679: PPUSH
2680: CALL_OW 111
// ChangeSideFog ( you , you ) ;
2684: LD_EXP 23
2688: PPUSH
2689: LD_EXP 23
2693: PPUSH
2694: CALL_OW 343
// SetSide ( Burlak , you ) ;
2698: LD_EXP 1
2702: PPUSH
2703: LD_EXP 23
2707: PPUSH
2708: CALL_OW 235
// SetSide ( Masha , you ) ;
2712: LD_EXP 43
2716: PPUSH
2717: LD_EXP 23
2721: PPUSH
2722: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2726: LD_INT 1
2728: PPUSH
2729: LD_INT 2
2731: PPUSH
2732: CALL_OW 12
2736: PUSH
2737: LD_INT 1
2739: DOUBLE
2740: EQUAL
2741: IFTRUE 2745
2743: GO 2803
2745: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2746: LD_ADDR_LOC 2
2750: PUSH
2751: DOUBLE
2752: LD_EXP 31
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: DEC
2761: ST_TO_ADDR
2762: LD_EXP 31
2766: PUSH
2767: LD_EXP 30
2771: PLUS
2772: PUSH
2773: FOR_TO
2774: IFFALSE 2799
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2776: LD_EXP 29
2780: PUSH
2781: LD_LOC 2
2785: ARRAY
2786: PPUSH
2787: LD_INT 4
2789: PPUSH
2790: LD_INT 0
2792: PPUSH
2793: CALL_OW 49
2797: GO 2773
2799: POP
2800: POP
// end ; 2 :
2801: GO 2870
2803: LD_INT 2
2805: DOUBLE
2806: EQUAL
2807: IFTRUE 2811
2809: GO 2869
2811: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2812: LD_ADDR_LOC 2
2816: PUSH
2817: DOUBLE
2818: LD_EXP 31
2822: PUSH
2823: LD_INT 1
2825: PLUS
2826: DEC
2827: ST_TO_ADDR
2828: LD_EXP 31
2832: PUSH
2833: LD_EXP 30
2837: PLUS
2838: PUSH
2839: FOR_TO
2840: IFFALSE 2865
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2842: LD_EXP 29
2846: PUSH
2847: LD_LOC 2
2851: ARRAY
2852: PPUSH
2853: LD_INT 5
2855: PPUSH
2856: LD_INT 0
2858: PPUSH
2859: CALL_OW 49
2863: GO 2839
2865: POP
2866: POP
// end ; end ;
2867: GO 2870
2869: POP
// case Rand ( 1 , 2 ) of 1 :
2870: LD_INT 1
2872: PPUSH
2873: LD_INT 2
2875: PPUSH
2876: CALL_OW 12
2880: PUSH
2881: LD_INT 1
2883: DOUBLE
2884: EQUAL
2885: IFTRUE 2889
2887: GO 2957
2889: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2890: LD_ADDR_LOC 2
2894: PUSH
2895: DOUBLE
2896: LD_EXP 31
2900: PUSH
2901: LD_INT 1
2903: PLUS
2904: PUSH
2905: LD_EXP 30
2909: PLUS
2910: DEC
2911: ST_TO_ADDR
2912: LD_EXP 31
2916: PUSH
2917: LD_INT 2
2919: PUSH
2920: LD_EXP 30
2924: MUL
2925: PLUS
2926: PUSH
2927: FOR_TO
2928: IFFALSE 2953
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2930: LD_EXP 29
2934: PUSH
2935: LD_LOC 2
2939: ARRAY
2940: PPUSH
2941: LD_INT 8
2943: PPUSH
2944: LD_INT 0
2946: PPUSH
2947: CALL_OW 49
2951: GO 2927
2953: POP
2954: POP
// end ; 2 :
2955: GO 3034
2957: LD_INT 2
2959: DOUBLE
2960: EQUAL
2961: IFTRUE 2965
2963: GO 3033
2965: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2966: LD_ADDR_LOC 2
2970: PUSH
2971: DOUBLE
2972: LD_EXP 31
2976: PUSH
2977: LD_INT 1
2979: PLUS
2980: PUSH
2981: LD_EXP 30
2985: PLUS
2986: DEC
2987: ST_TO_ADDR
2988: LD_EXP 31
2992: PUSH
2993: LD_INT 2
2995: PUSH
2996: LD_EXP 30
3000: MUL
3001: PLUS
3002: PUSH
3003: FOR_TO
3004: IFFALSE 3029
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
3006: LD_EXP 29
3010: PUSH
3011: LD_LOC 2
3015: ARRAY
3016: PPUSH
3017: LD_INT 7
3019: PPUSH
3020: LD_INT 0
3022: PPUSH
3023: CALL_OW 49
3027: GO 3003
3029: POP
3030: POP
// end ; end ;
3031: GO 3034
3033: POP
// case Rand ( 1 , 2 ) of 1 :
3034: LD_INT 1
3036: PPUSH
3037: LD_INT 2
3039: PPUSH
3040: CALL_OW 12
3044: PUSH
3045: LD_INT 1
3047: DOUBLE
3048: EQUAL
3049: IFTRUE 3053
3051: GO 3125
3053: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3054: LD_ADDR_LOC 2
3058: PUSH
3059: DOUBLE
3060: LD_EXP 31
3064: PUSH
3065: LD_INT 1
3067: PLUS
3068: PUSH
3069: LD_INT 2
3071: PUSH
3072: LD_EXP 30
3076: MUL
3077: PLUS
3078: DEC
3079: ST_TO_ADDR
3080: LD_EXP 31
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_EXP 30
3092: MUL
3093: PLUS
3094: PUSH
3095: FOR_TO
3096: IFFALSE 3121
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3098: LD_EXP 29
3102: PUSH
3103: LD_LOC 2
3107: ARRAY
3108: PPUSH
3109: LD_INT 6
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 49
3119: GO 3095
3121: POP
3122: POP
// end ; 2 :
3123: GO 3206
3125: LD_INT 2
3127: DOUBLE
3128: EQUAL
3129: IFTRUE 3133
3131: GO 3205
3133: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3134: LD_ADDR_LOC 2
3138: PUSH
3139: DOUBLE
3140: LD_EXP 31
3144: PUSH
3145: LD_INT 1
3147: PLUS
3148: PUSH
3149: LD_INT 2
3151: PUSH
3152: LD_EXP 30
3156: MUL
3157: PLUS
3158: DEC
3159: ST_TO_ADDR
3160: LD_EXP 31
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_EXP 30
3172: MUL
3173: PLUS
3174: PUSH
3175: FOR_TO
3176: IFFALSE 3201
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3178: LD_EXP 29
3182: PUSH
3183: LD_LOC 2
3187: ARRAY
3188: PPUSH
3189: LD_INT 16
3191: PPUSH
3192: LD_INT 0
3194: PPUSH
3195: CALL_OW 49
3199: GO 3175
3201: POP
3202: POP
// end ; end ;
3203: GO 3206
3205: POP
// Wait ( 1 1$20 ) ;
3206: LD_INT 2800
3208: PPUSH
3209: CALL_OW 67
// for i := 1 to pursuers_base do
3213: LD_ADDR_LOC 2
3217: PUSH
3218: DOUBLE
3219: LD_INT 1
3221: DEC
3222: ST_TO_ADDR
3223: LD_EXP 31
3227: PUSH
3228: FOR_TO
3229: IFFALSE 3298
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3231: LD_EXP 29
3235: PUSH
3236: LD_LOC 2
3240: ARRAY
3241: PPUSH
3242: LD_INT 9
3244: PPUSH
3245: LD_INT 0
3247: PPUSH
3248: CALL_OW 49
3252: NOT
3253: IFFALSE 3276
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3255: LD_EXP 29
3259: PUSH
3260: LD_LOC 2
3264: ARRAY
3265: PPUSH
3266: LD_INT 3
3268: PPUSH
3269: LD_INT 0
3271: PPUSH
3272: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3276: LD_EXP 29
3280: PUSH
3281: LD_LOC 2
3285: ARRAY
3286: PPUSH
3287: LD_EXP 1
3291: PPUSH
3292: CALL_OW 115
// end ;
3296: GO 3228
3298: POP
3299: POP
// Wait ( straz_start ) ;
3300: LD_EXP 35
3304: PPUSH
3305: CALL_OW 67
// enable ( 1 ) ;
3309: LD_INT 1
3311: ENABLE_MARKED
// enable ( 2 ) ;
3312: LD_INT 2
3314: ENABLE_MARKED
// end ;
3315: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3316: LD_INT 0
3318: PPUSH
3319: PPUSH
3320: PPUSH
3321: PPUSH
3322: PPUSH
3323: PPUSH
3324: PPUSH
3325: PPUSH
3326: PPUSH
3327: PPUSH
3328: PPUSH
3329: PPUSH
3330: PPUSH
3331: PPUSH
3332: PPUSH
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
3341: PPUSH
// gained_medals := [ ] ;
3342: LD_ADDR_OWVAR 61
3346: PUSH
3347: EMPTY
3348: ST_TO_ADDR
// missing_medals := [ ] ;
3349: LD_ADDR_OWVAR 62
3353: PUSH
3354: EMPTY
3355: ST_TO_ADDR
// reward_units := [ ] ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: EMPTY
3362: ST_TO_ADDR
// if scientists_dead = 0 then
3363: LD_EXP 49
3367: PUSH
3368: LD_INT 0
3370: EQUAL
3371: IFFALSE 3385
// AddMedal ( Science , 1 ) else
3373: LD_STRING Science
3375: PPUSH
3376: LD_INT 1
3378: PPUSH
3379: CALL_OW 101
3383: GO 3396
// AddMedal ( Science , - 1 ) ;
3385: LD_STRING Science
3387: PPUSH
3388: LD_INT 1
3390: NEG
3391: PPUSH
3392: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3396: LD_ADDR_VAR 0 4
3400: PUSH
3401: LD_INT 22
3403: PUSH
3404: LD_EXP 23
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 30
3418: PUSH
3419: LD_INT 0
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 30
3428: PUSH
3429: LD_INT 1
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: ST_TO_ADDR
// matros := 0 ;
3450: LD_ADDR_VAR 0 2
3454: PUSH
3455: LD_INT 0
3457: ST_TO_ADDR
// if 0 + filter <> 0 then
3458: LD_INT 0
3460: PUSH
3461: LD_VAR 0 4
3465: PLUS
3466: PUSH
3467: LD_INT 0
3469: NONEQUAL
3470: IFFALSE 3518
// for un in filter do
3472: LD_ADDR_VAR 0 3
3476: PUSH
3477: LD_VAR 0 4
3481: PUSH
3482: FOR_IN
3483: IFFALSE 3516
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3485: LD_ADDR_VAR 0 2
3489: PUSH
3490: LD_VAR 0 2
3494: PUSH
3495: LD_VAR 0 3
3499: PPUSH
3500: CALL_OW 274
3504: PPUSH
3505: LD_INT 1
3507: PPUSH
3508: CALL_OW 275
3512: PLUS
3513: ST_TO_ADDR
3514: GO 3482
3516: POP
3517: POP
// if matros > 100 then
3518: LD_VAR 0 2
3522: PUSH
3523: LD_INT 100
3525: GREATER
3526: IFFALSE 3540
// AddMedal ( Effectivity , 1 ) else
3528: LD_STRING Effectivity
3530: PPUSH
3531: LD_INT 1
3533: PPUSH
3534: CALL_OW 101
3538: GO 3551
// AddMedal ( Effectivity , - 1 ) ;
3540: LD_STRING Effectivity
3542: PPUSH
3543: LD_INT 1
3545: NEG
3546: PPUSH
3547: CALL_OW 101
// rus_building_destroyed := false ;
3551: LD_ADDR_VAR 0 7
3555: PUSH
3556: LD_INT 0
3558: ST_TO_ADDR
// for un in rus_mcrep_bui do
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: LD_EXP 64
3568: PUSH
3569: FOR_IN
3570: IFFALSE 3600
// if not IsLive ( un ) then
3572: LD_VAR 0 3
3576: PPUSH
3577: CALL_OW 300
3581: NOT
3582: IFFALSE 3598
// rus_building_destroyed := rus_building_destroyed + 1 ;
3584: LD_ADDR_VAR 0 7
3588: PUSH
3589: LD_VAR 0 7
3593: PUSH
3594: LD_INT 1
3596: PLUS
3597: ST_TO_ADDR
3598: GO 3569
3600: POP
3601: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3602: LD_EXP 53
3606: PUSH
3607: LD_INT 5
3609: GREATEREQUAL
3610: PUSH
3611: LD_VAR 0 7
3615: PUSH
3616: LD_INT 2
3618: GREATEREQUAL
3619: OR
3620: IFFALSE 3635
// AddMedal ( LittleLosses , - 1 ) else
3622: LD_STRING LittleLosses
3624: PPUSH
3625: LD_INT 1
3627: NEG
3628: PPUSH
3629: CALL_OW 101
3633: GO 3645
// AddMedal ( LittleLosses , 1 ) ;
3635: LD_STRING LittleLosses
3637: PPUSH
3638: LD_INT 1
3640: PPUSH
3641: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , not ( killed_russians >= 5 or rus_building_destroyed >= 2 ) ) ;
3645: LD_INT 4
3647: PPUSH
3648: LD_INT 5
3650: PPUSH
3651: LD_EXP 49
3655: PUSH
3656: LD_INT 0
3658: EQUAL
3659: PPUSH
3660: LD_VAR 0 2
3664: PUSH
3665: LD_INT 100
3667: GREATER
3668: PPUSH
3669: LD_EXP 53
3673: PUSH
3674: LD_INT 5
3676: GREATEREQUAL
3677: PUSH
3678: LD_VAR 0 7
3682: PUSH
3683: LD_INT 2
3685: GREATEREQUAL
3686: OR
3687: NOT
3688: PPUSH
3689: CALL 14210 0 5
// GiveMedals ( Main ) ;
3693: LD_STRING Main
3695: PPUSH
3696: CALL_OW 102
// for un in player_units do
3700: LD_ADDR_VAR 0 3
3704: PUSH
3705: LD_EXP 41
3709: PUSH
3710: FOR_IN
3711: IFFALSE 3743
// if not IsDead ( un ) then
3713: LD_VAR 0 3
3717: PPUSH
3718: CALL_OW 301
3722: NOT
3723: IFFALSE 3741
// reward_units := reward_units ^ un ;
3725: LD_ADDR_VAR 0 5
3729: PUSH
3730: LD_VAR 0 5
3734: PUSH
3735: LD_VAR 0 3
3739: ADD
3740: ST_TO_ADDR
3741: GO 3710
3743: POP
3744: POP
// RewardPeople ( reward_units ) ;
3745: LD_VAR 0 5
3749: PPUSH
3750: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3754: LD_EXP 40
3758: PUSH
3759: LD_EXP 39
3763: PUSH
3764: LD_EXP 8
3768: ADD
3769: DIFF
3770: PPUSH
3771: LD_STRING scientists
3773: PPUSH
3774: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3778: LD_ADDR_VAR 0 6
3782: PUSH
3783: LD_EXP 41
3787: PUSH
3788: LD_EXP 39
3792: PUSH
3793: LD_EXP 40
3797: ADD
3798: PUSH
3799: LD_EXP 1
3803: ADD
3804: PUSH
3805: LD_EXP 8
3809: ADD
3810: DIFF
3811: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3812: LD_VAR 0 6
3816: PPUSH
3817: LD_STRING survivors5
3819: PPUSH
3820: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3824: LD_EXP 1
3828: PPUSH
3829: LD_STRING Burlak
3831: PPUSH
3832: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3836: LD_EXP 2
3840: PPUSH
3841: LD_STRING Belkov
3843: PPUSH
3844: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3848: LD_EXP 3
3852: PPUSH
3853: LD_STRING Gnyevko
3855: PPUSH
3856: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3860: LD_EXP 4
3864: PPUSH
3865: LD_STRING Kirilenkova
3867: PPUSH
3868: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3872: LD_EXP 5
3876: PPUSH
3877: LD_STRING Gleb
3879: PPUSH
3880: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3884: LD_EXP 6
3888: PPUSH
3889: LD_STRING Petrosyan
3891: PPUSH
3892: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3896: LD_EXP 7
3900: PPUSH
3901: LD_STRING Titov
3903: PPUSH
3904: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3908: LD_EXP 8
3912: PPUSH
3913: LD_STRING Gossudarov
3915: PPUSH
3916: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3920: LD_EXP 9
3924: PPUSH
3925: LD_STRING Kovalyuk
3927: PPUSH
3928: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3932: LD_EXP 10
3936: PPUSH
3937: LD_STRING Scholtze
3939: PPUSH
3940: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3944: LD_EXP 11
3948: PPUSH
3949: LD_STRING Kuzmov
3951: PPUSH
3952: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3956: LD_EXP 12
3960: PPUSH
3961: LD_STRING Karamazov
3963: PPUSH
3964: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3968: LD_EXP 13
3972: PPUSH
3973: LD_STRING Petrovova
3975: PPUSH
3976: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3980: LD_EXP 14
3984: PPUSH
3985: LD_STRING Lipshchin
3987: PPUSH
3988: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3992: LD_EXP 15
3996: PPUSH
3997: LD_STRING Dolgov
3999: PPUSH
4000: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4004: LD_EXP 16
4008: PPUSH
4009: LD_STRING Xavier
4011: PPUSH
4012: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4016: LD_EXP 17
4020: PPUSH
4021: LD_STRING Oblukov
4023: PPUSH
4024: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4028: LD_EXP 18
4032: PPUSH
4033: LD_STRING Kozlov
4035: PPUSH
4036: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4040: LD_EXP 19
4044: PPUSH
4045: LD_STRING Kapitsova
4047: PPUSH
4048: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
4052: LD_EXP 42
4056: PUSH
4057: LD_EXP 52
4061: AND
4062: PUSH
4063: LD_LOC 1
4067: NOT
4068: OR
4069: IFFALSE 4078
// DeleteVariable ( Masha ) ;
4071: LD_STRING Masha
4073: PPUSH
4074: CALL_OW 41
// if Belkov in scientists then
4078: LD_EXP 2
4082: PUSH
4083: LD_EXP 40
4087: IN
4088: IFFALSE 4100
// belkov_side := 2 else
4090: LD_ADDR_VAR 0 8
4094: PUSH
4095: LD_INT 2
4097: ST_TO_ADDR
4098: GO 4130
// if Belkov in player_units then
4100: LD_EXP 2
4104: PUSH
4105: LD_EXP 41
4109: IN
4110: IFFALSE 4122
// belkov_side := 1 else
4112: LD_ADDR_VAR 0 8
4116: PUSH
4117: LD_INT 1
4119: ST_TO_ADDR
4120: GO 4130
// belkov_side := 0 ;
4122: LD_ADDR_VAR 0 8
4126: PUSH
4127: LD_INT 0
4129: ST_TO_ADDR
// if Gnyevko in scientists then
4130: LD_EXP 3
4134: PUSH
4135: LD_EXP 40
4139: IN
4140: IFFALSE 4152
// gnyevko_side := 2 else
4142: LD_ADDR_VAR 0 9
4146: PUSH
4147: LD_INT 2
4149: ST_TO_ADDR
4150: GO 4182
// if Gnyevko in player_units then
4152: LD_EXP 3
4156: PUSH
4157: LD_EXP 41
4161: IN
4162: IFFALSE 4174
// gnyevko_side := 1 else
4164: LD_ADDR_VAR 0 9
4168: PUSH
4169: LD_INT 1
4171: ST_TO_ADDR
4172: GO 4182
// gnyevko_side := 0 ;
4174: LD_ADDR_VAR 0 9
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// if Kirilenkova in scientists then
4182: LD_EXP 4
4186: PUSH
4187: LD_EXP 40
4191: IN
4192: IFFALSE 4204
// kiril_side := 2 else
4194: LD_ADDR_VAR 0 10
4198: PUSH
4199: LD_INT 2
4201: ST_TO_ADDR
4202: GO 4234
// if Kirilenkova in player_units then
4204: LD_EXP 4
4208: PUSH
4209: LD_EXP 41
4213: IN
4214: IFFALSE 4226
// kiril_side := 1 else
4216: LD_ADDR_VAR 0 10
4220: PUSH
4221: LD_INT 1
4223: ST_TO_ADDR
4224: GO 4234
// kiril_side := 0 ;
4226: LD_ADDR_VAR 0 10
4230: PUSH
4231: LD_INT 0
4233: ST_TO_ADDR
// if Gleb in scientists then
4234: LD_EXP 5
4238: PUSH
4239: LD_EXP 40
4243: IN
4244: IFFALSE 4256
// gleb_side := 2 else
4246: LD_ADDR_VAR 0 16
4250: PUSH
4251: LD_INT 2
4253: ST_TO_ADDR
4254: GO 4286
// if Gleb in player_units then
4256: LD_EXP 5
4260: PUSH
4261: LD_EXP 41
4265: IN
4266: IFFALSE 4278
// gleb_side := 1 else
4268: LD_ADDR_VAR 0 16
4272: PUSH
4273: LD_INT 1
4275: ST_TO_ADDR
4276: GO 4286
// gleb_side := 0 ;
4278: LD_ADDR_VAR 0 16
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// if Petrosyan in scientists then
4286: LD_EXP 6
4290: PUSH
4291: LD_EXP 40
4295: IN
4296: IFFALSE 4308
// petros_side := 2 else
4298: LD_ADDR_VAR 0 15
4302: PUSH
4303: LD_INT 2
4305: ST_TO_ADDR
4306: GO 4338
// if Petrosyan in player_units then
4308: LD_EXP 6
4312: PUSH
4313: LD_EXP 41
4317: IN
4318: IFFALSE 4330
// petros_side := 1 else
4320: LD_ADDR_VAR 0 15
4324: PUSH
4325: LD_INT 1
4327: ST_TO_ADDR
4328: GO 4338
// petros_side := 0 ;
4330: LD_ADDR_VAR 0 15
4334: PUSH
4335: LD_INT 0
4337: ST_TO_ADDR
// if Titov in scientists then
4338: LD_EXP 7
4342: PUSH
4343: LD_EXP 40
4347: IN
4348: IFFALSE 4360
// titov_side := 2 else
4350: LD_ADDR_VAR 0 19
4354: PUSH
4355: LD_INT 2
4357: ST_TO_ADDR
4358: GO 4390
// if Titov in player_units then
4360: LD_EXP 7
4364: PUSH
4365: LD_EXP 41
4369: IN
4370: IFFALSE 4382
// titov_side := 1 else
4372: LD_ADDR_VAR 0 19
4376: PUSH
4377: LD_INT 1
4379: ST_TO_ADDR
4380: GO 4390
// titov_side := 0 ;
4382: LD_ADDR_VAR 0 19
4386: PUSH
4387: LD_INT 0
4389: ST_TO_ADDR
// if Kovalyuk in scientists then
4390: LD_EXP 9
4394: PUSH
4395: LD_EXP 40
4399: IN
4400: IFFALSE 4412
// kovalyuk_side := 2 else
4402: LD_ADDR_VAR 0 11
4406: PUSH
4407: LD_INT 2
4409: ST_TO_ADDR
4410: GO 4442
// if Kovalyuk in player_units then
4412: LD_EXP 9
4416: PUSH
4417: LD_EXP 41
4421: IN
4422: IFFALSE 4434
// kovalyuk_side := 1 else
4424: LD_ADDR_VAR 0 11
4428: PUSH
4429: LD_INT 1
4431: ST_TO_ADDR
4432: GO 4442
// kovalyuk_side := 0 ;
4434: LD_ADDR_VAR 0 11
4438: PUSH
4439: LD_INT 0
4441: ST_TO_ADDR
// if Scholtze in scientists then
4442: LD_EXP 10
4446: PUSH
4447: LD_EXP 40
4451: IN
4452: IFFALSE 4464
// scholtze_side := 2 else
4454: LD_ADDR_VAR 0 12
4458: PUSH
4459: LD_INT 2
4461: ST_TO_ADDR
4462: GO 4494
// if Scholtze in player_units then
4464: LD_EXP 10
4468: PUSH
4469: LD_EXP 41
4473: IN
4474: IFFALSE 4486
// scholtze_side := 1 else
4476: LD_ADDR_VAR 0 12
4480: PUSH
4481: LD_INT 1
4483: ST_TO_ADDR
4484: GO 4494
// scholtze_side := 0 ;
4486: LD_ADDR_VAR 0 12
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// if Kuzmov in scientists then
4494: LD_EXP 11
4498: PUSH
4499: LD_EXP 40
4503: IN
4504: IFFALSE 4516
// kuzmov_side := 2 else
4506: LD_ADDR_VAR 0 13
4510: PUSH
4511: LD_INT 2
4513: ST_TO_ADDR
4514: GO 4546
// if Kuzmov in player_units then
4516: LD_EXP 11
4520: PUSH
4521: LD_EXP 41
4525: IN
4526: IFFALSE 4538
// kuzmov_side := 1 else
4528: LD_ADDR_VAR 0 13
4532: PUSH
4533: LD_INT 1
4535: ST_TO_ADDR
4536: GO 4546
// kuzmov_side := 0 ;
4538: LD_ADDR_VAR 0 13
4542: PUSH
4543: LD_INT 0
4545: ST_TO_ADDR
// if Karamazov in scientists then
4546: LD_EXP 12
4550: PUSH
4551: LD_EXP 40
4555: IN
4556: IFFALSE 4568
// karam_side := 2 else
4558: LD_ADDR_VAR 0 14
4562: PUSH
4563: LD_INT 2
4565: ST_TO_ADDR
4566: GO 4598
// if Karamazov in player_units then
4568: LD_EXP 12
4572: PUSH
4573: LD_EXP 41
4577: IN
4578: IFFALSE 4590
// karam_side := 1 else
4580: LD_ADDR_VAR 0 14
4584: PUSH
4585: LD_INT 1
4587: ST_TO_ADDR
4588: GO 4598
// karam_side := 0 ;
4590: LD_ADDR_VAR 0 14
4594: PUSH
4595: LD_INT 0
4597: ST_TO_ADDR
// if Petrovova in scientists then
4598: LD_EXP 13
4602: PUSH
4603: LD_EXP 40
4607: IN
4608: IFFALSE 4620
// petrov_side := 2 else
4610: LD_ADDR_VAR 0 17
4614: PUSH
4615: LD_INT 2
4617: ST_TO_ADDR
4618: GO 4650
// if Petrovova in player_units then
4620: LD_EXP 13
4624: PUSH
4625: LD_EXP 41
4629: IN
4630: IFFALSE 4642
// petrov_side := 1 else
4632: LD_ADDR_VAR 0 17
4636: PUSH
4637: LD_INT 1
4639: ST_TO_ADDR
4640: GO 4650
// petrov_side := 0 ;
4642: LD_ADDR_VAR 0 17
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// if Lipshchin in scientists then
4650: LD_EXP 14
4654: PUSH
4655: LD_EXP 40
4659: IN
4660: IFFALSE 4672
// lipshchin_side := 2 else
4662: LD_ADDR_VAR 0 18
4666: PUSH
4667: LD_INT 2
4669: ST_TO_ADDR
4670: GO 4702
// if Lipshchin in player_units then
4672: LD_EXP 14
4676: PUSH
4677: LD_EXP 41
4681: IN
4682: IFFALSE 4694
// lipshchin_side := 1 else
4684: LD_ADDR_VAR 0 18
4688: PUSH
4689: LD_INT 1
4691: ST_TO_ADDR
4692: GO 4702
// lipshchin_side := 0 ;
4694: LD_ADDR_VAR 0 18
4698: PUSH
4699: LD_INT 0
4701: ST_TO_ADDR
// if Dolgov in scientists then
4702: LD_EXP 15
4706: PUSH
4707: LD_EXP 40
4711: IN
4712: IFFALSE 4724
// dolgov_side := 2 else
4714: LD_ADDR_VAR 0 20
4718: PUSH
4719: LD_INT 2
4721: ST_TO_ADDR
4722: GO 4754
// if Dolgov in player_units then
4724: LD_EXP 15
4728: PUSH
4729: LD_EXP 41
4733: IN
4734: IFFALSE 4746
// dolgov_side := 1 else
4736: LD_ADDR_VAR 0 20
4740: PUSH
4741: LD_INT 1
4743: ST_TO_ADDR
4744: GO 4754
// dolgov_side := 0 ;
4746: LD_ADDR_VAR 0 20
4750: PUSH
4751: LD_INT 0
4753: ST_TO_ADDR
// if Xavier in scientists then
4754: LD_EXP 16
4758: PUSH
4759: LD_EXP 40
4763: IN
4764: IFFALSE 4776
// xavier_side := 2 else
4766: LD_ADDR_VAR 0 21
4770: PUSH
4771: LD_INT 2
4773: ST_TO_ADDR
4774: GO 4806
// if Xavier in player_units then
4776: LD_EXP 16
4780: PUSH
4781: LD_EXP 41
4785: IN
4786: IFFALSE 4798
// xavier_side := 1 else
4788: LD_ADDR_VAR 0 21
4792: PUSH
4793: LD_INT 1
4795: ST_TO_ADDR
4796: GO 4806
// xavier_side := 0 ;
4798: LD_ADDR_VAR 0 21
4802: PUSH
4803: LD_INT 0
4805: ST_TO_ADDR
// if Oblukov in scientists then
4806: LD_EXP 17
4810: PUSH
4811: LD_EXP 40
4815: IN
4816: IFFALSE 4828
// oblukov_side := 2 else
4818: LD_ADDR_VAR 0 22
4822: PUSH
4823: LD_INT 2
4825: ST_TO_ADDR
4826: GO 4858
// if Oblukov in player_units then
4828: LD_EXP 17
4832: PUSH
4833: LD_EXP 41
4837: IN
4838: IFFALSE 4850
// oblukov_side := 1 else
4840: LD_ADDR_VAR 0 22
4844: PUSH
4845: LD_INT 1
4847: ST_TO_ADDR
4848: GO 4858
// oblukov_side := 0 ;
4850: LD_ADDR_VAR 0 22
4854: PUSH
4855: LD_INT 0
4857: ST_TO_ADDR
// if Kozlov in scientists then
4858: LD_EXP 18
4862: PUSH
4863: LD_EXP 40
4867: IN
4868: IFFALSE 4880
// kozlov_side := 2 else
4870: LD_ADDR_VAR 0 23
4874: PUSH
4875: LD_INT 2
4877: ST_TO_ADDR
4878: GO 4910
// if Kozlov in player_units then
4880: LD_EXP 18
4884: PUSH
4885: LD_EXP 41
4889: IN
4890: IFFALSE 4902
// kozlov_side := 1 else
4892: LD_ADDR_VAR 0 23
4896: PUSH
4897: LD_INT 1
4899: ST_TO_ADDR
4900: GO 4910
// kozlov_side := 0 ;
4902: LD_ADDR_VAR 0 23
4906: PUSH
4907: LD_INT 0
4909: ST_TO_ADDR
// if Kapitsova in scientists then
4910: LD_EXP 19
4914: PUSH
4915: LD_EXP 40
4919: IN
4920: IFFALSE 4932
// kapitsova_side := 2 else
4922: LD_ADDR_VAR 0 24
4926: PUSH
4927: LD_INT 2
4929: ST_TO_ADDR
4930: GO 4962
// if Kapitsova in player_units then
4932: LD_EXP 19
4936: PUSH
4937: LD_EXP 41
4941: IN
4942: IFFALSE 4954
// kapitsova_side := 1 else
4944: LD_ADDR_VAR 0 24
4948: PUSH
4949: LD_INT 1
4951: ST_TO_ADDR
4952: GO 4962
// kapitsova_side := 0 ;
4954: LD_ADDR_VAR 0 24
4958: PUSH
4959: LD_INT 0
4961: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4962: LD_VAR 0 8
4966: PPUSH
4967: LD_STRING belkov_side
4969: PPUSH
4970: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4974: LD_VAR 0 9
4978: PPUSH
4979: LD_STRING gnyevko_side
4981: PPUSH
4982: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4986: LD_VAR 0 10
4990: PPUSH
4991: LD_STRING kiril_side
4993: PPUSH
4994: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4998: LD_VAR 0 16
5002: PPUSH
5003: LD_STRING gleb_side
5005: PPUSH
5006: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
5010: LD_VAR 0 15
5014: PPUSH
5015: LD_STRING petros_side
5017: PPUSH
5018: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
5022: LD_VAR 0 19
5026: PPUSH
5027: LD_STRING titov_side
5029: PPUSH
5030: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
5034: LD_VAR 0 11
5038: PPUSH
5039: LD_STRING kovalyuk_side
5041: PPUSH
5042: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
5046: LD_VAR 0 12
5050: PPUSH
5051: LD_STRING scholtze_side
5053: PPUSH
5054: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5058: LD_VAR 0 13
5062: PPUSH
5063: LD_STRING kuzmov_side
5065: PPUSH
5066: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5070: LD_VAR 0 14
5074: PPUSH
5075: LD_STRING karam_side
5077: PPUSH
5078: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5082: LD_VAR 0 17
5086: PPUSH
5087: LD_STRING petrov_side
5089: PPUSH
5090: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5094: LD_VAR 0 18
5098: PPUSH
5099: LD_STRING lipshchin_side
5101: PPUSH
5102: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5106: LD_VAR 0 20
5110: PPUSH
5111: LD_STRING dolgov_side
5113: PPUSH
5114: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5118: LD_VAR 0 21
5122: PPUSH
5123: LD_STRING xavier_side
5125: PPUSH
5126: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5130: LD_VAR 0 22
5134: PPUSH
5135: LD_STRING oblukov_side
5137: PPUSH
5138: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5142: LD_VAR 0 23
5146: PPUSH
5147: LD_STRING kozlov_side
5149: PPUSH
5150: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5154: LD_VAR 0 24
5158: PPUSH
5159: LD_STRING kapitsova_side
5161: PPUSH
5162: CALL_OW 39
// YouWin ;
5166: CALL_OW 103
// exit ;
5170: GO 5172
// end ; end_of_file
5172: LD_VAR 0 1
5176: RET
// export function D_Start ; begin
5177: LD_INT 0
5179: PPUSH
// DisableExclamations ;
5180: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5184: LD_EXP 8
5188: PPUSH
5189: LD_STRING DStart-Gos-1
5191: PPUSH
5192: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5196: LD_EXP 1
5200: PPUSH
5201: LD_STRING DStart-Bur-1
5203: PPUSH
5204: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5208: LD_EXP 8
5212: PPUSH
5213: LD_STRING DStart-Gos-2
5215: PPUSH
5216: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5220: LD_EXP 1
5224: PPUSH
5225: LD_STRING DStart-Bur-2
5227: PPUSH
5228: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5232: LD_EXP 8
5236: PPUSH
5237: LD_STRING DStart-Gos-3
5239: PPUSH
5240: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5244: LD_EXP 1
5248: PPUSH
5249: LD_STRING DStart-Bur-3
5251: PPUSH
5252: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5256: LD_EXP 8
5260: PPUSH
5261: LD_STRING DStart-Gos-4
5263: PPUSH
5264: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5268: LD_EXP 1
5272: PPUSH
5273: LD_STRING DStart-Bur-4
5275: PPUSH
5276: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5280: LD_EXP 8
5284: PPUSH
5285: LD_STRING DStart-Gos-5
5287: PPUSH
5288: CALL_OW 88
// EnableExclamations ;
5292: CALL_OW 473
// end ;
5296: LD_VAR 0 1
5300: RET
// export function D_Platonov ; begin
5301: LD_INT 0
5303: PPUSH
// DisableExclamations ;
5304: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5308: LD_EXP 21
5312: PPUSH
5313: LD_STRING DPlatonov-Rsol1-1
5315: PPUSH
5316: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5320: LD_EXP 1
5324: PPUSH
5325: LD_STRING DPlatonov-Bur-1
5327: PPUSH
5328: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5332: LD_EXP 21
5336: PPUSH
5337: LD_STRING DPlatonov-Rsol1-2
5339: PPUSH
5340: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5344: LD_EXP 1
5348: PPUSH
5349: LD_STRING DPlatonov-Bur-2
5351: PPUSH
5352: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5356: LD_EXP 1
5360: PPUSH
5361: LD_EXP 43
5365: PPUSH
5366: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5370: LD_EXP 21
5374: PPUSH
5375: LD_STRING DPlatonov-Rsol1-3
5377: PPUSH
5378: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5382: LD_INT 7
5384: PPUSH
5385: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5389: LD_EXP 43
5393: PPUSH
5394: CALL_OW 311
5398: PUSH
5399: LD_EXP 1
5403: EQUAL
5404: IFFALSE 5382
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5406: LD_EXP 1
5410: PPUSH
5411: LD_STRING DPlatonov-Bur-3
5413: PPUSH
5414: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5418: LD_EXP 1
5422: PPUSH
5423: LD_EXP 21
5427: PPUSH
5428: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5432: LD_INT 7
5434: PPUSH
5435: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5439: LD_EXP 43
5443: PPUSH
5444: CALL_OW 320
5448: PUSH
5449: LD_EXP 21
5453: EQUAL
5454: IFFALSE 5432
// Wait ( 0 0$0.5 ) ;
5456: LD_INT 18
5458: PPUSH
5459: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5463: LD_EXP 21
5467: PPUSH
5468: LD_STRING DPlatonov-Rsol1-4
5470: PPUSH
5471: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5475: LD_EXP 21
5479: PPUSH
5480: LD_EXP 43
5484: PPUSH
5485: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5489: LD_EXP 1
5493: PPUSH
5494: LD_EXP 21
5498: PPUSH
5499: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5503: LD_EXP 20
5507: PPUSH
5508: LD_STRING DPlatonov-Pla-4
5510: PPUSH
5511: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5515: LD_EXP 20
5519: PPUSH
5520: LD_STRING DPlatonov-Pla-4a
5522: PPUSH
5523: CALL_OW 88
// EnableExclamations ;
5527: CALL_OW 473
// end ;
5531: LD_VAR 0 1
5535: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5536: LD_INT 0
5538: PPUSH
5539: PPUSH
5540: PPUSH
5541: PPUSH
// DisableExclamations ;
5542: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5546: LD_EXP 2
5550: PPUSH
5551: CALL_OW 302
5555: PUSH
5556: LD_EXP 2
5560: PPUSH
5561: CALL_OW 255
5565: PUSH
5566: LD_EXP 23
5570: EQUAL
5571: AND
5572: IFFALSE 5586
// Say ( Belkov , DGosStart-Bel-1 ) ;
5574: LD_EXP 2
5578: PPUSH
5579: LD_STRING DGosStart-Bel-1
5581: PPUSH
5582: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5586: LD_EXP 3
5590: PPUSH
5591: CALL_OW 302
5595: PUSH
5596: LD_EXP 3
5600: PPUSH
5601: CALL_OW 255
5605: PUSH
5606: LD_EXP 23
5610: EQUAL
5611: AND
5612: IFFALSE 5626
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5614: LD_EXP 3
5618: PPUSH
5619: LD_STRING DGosStart-Gny-1
5621: PPUSH
5622: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5626: LD_EXP 5
5630: PPUSH
5631: CALL_OW 302
5635: PUSH
5636: LD_EXP 5
5640: PPUSH
5641: CALL_OW 255
5645: PUSH
5646: LD_EXP 23
5650: EQUAL
5651: AND
5652: IFFALSE 5666
// Say ( Gleb , DGosStart-Glb-1 ) ;
5654: LD_EXP 5
5658: PPUSH
5659: LD_STRING DGosStart-Glb-1
5661: PPUSH
5662: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5666: LD_EXP 6
5670: PPUSH
5671: CALL_OW 302
5675: PUSH
5676: LD_EXP 6
5680: PPUSH
5681: CALL_OW 255
5685: PUSH
5686: LD_EXP 23
5690: EQUAL
5691: AND
5692: IFFALSE 5706
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5694: LD_EXP 6
5698: PPUSH
5699: LD_STRING DGosStart-Pty-1
5701: PPUSH
5702: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5706: LD_EXP 7
5710: PPUSH
5711: CALL_OW 302
5715: PUSH
5716: LD_EXP 7
5720: PPUSH
5721: CALL_OW 255
5725: PUSH
5726: LD_EXP 23
5730: EQUAL
5731: AND
5732: IFFALSE 5746
// Say ( Titov , DGosStart-Tit-1 ) ;
5734: LD_EXP 7
5738: PPUSH
5739: LD_STRING DGosStart-Tit-1
5741: PPUSH
5742: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5746: LD_EXP 4
5750: PPUSH
5751: CALL_OW 302
5755: PUSH
5756: LD_EXP 4
5760: PPUSH
5761: CALL_OW 255
5765: PUSH
5766: LD_EXP 23
5770: EQUAL
5771: AND
5772: IFFALSE 5786
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5774: LD_EXP 4
5778: PPUSH
5779: LD_STRING DGosStart-Kir-1
5781: PPUSH
5782: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5786: LD_EXP 2
5790: PPUSH
5791: CALL_OW 302
5795: PUSH
5796: LD_EXP 2
5800: PPUSH
5801: CALL_OW 255
5805: PUSH
5806: LD_EXP 23
5810: EQUAL
5811: AND
5812: PUSH
5813: LD_EXP 3
5817: PPUSH
5818: CALL_OW 302
5822: PUSH
5823: LD_EXP 3
5827: PPUSH
5828: CALL_OW 255
5832: PUSH
5833: LD_EXP 23
5837: EQUAL
5838: AND
5839: OR
5840: PUSH
5841: LD_EXP 5
5845: PPUSH
5846: CALL_OW 302
5850: PUSH
5851: LD_EXP 5
5855: PPUSH
5856: CALL_OW 255
5860: PUSH
5861: LD_EXP 23
5865: EQUAL
5866: AND
5867: OR
5868: PUSH
5869: LD_EXP 6
5873: PPUSH
5874: CALL_OW 302
5878: PUSH
5879: LD_EXP 6
5883: PPUSH
5884: CALL_OW 255
5888: PUSH
5889: LD_EXP 23
5893: EQUAL
5894: AND
5895: OR
5896: PUSH
5897: LD_EXP 7
5901: PPUSH
5902: CALL_OW 302
5906: PUSH
5907: LD_EXP 7
5911: PPUSH
5912: CALL_OW 255
5916: PUSH
5917: LD_EXP 23
5921: EQUAL
5922: AND
5923: OR
5924: PUSH
5925: LD_EXP 4
5929: PPUSH
5930: CALL_OW 302
5934: PUSH
5935: LD_EXP 4
5939: PPUSH
5940: CALL_OW 255
5944: PUSH
5945: LD_EXP 23
5949: EQUAL
5950: AND
5951: OR
5952: NOT
5953: IFFALSE 6317
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5955: LD_ADDR_VAR 0 4
5959: PUSH
5960: LD_INT 22
5962: PUSH
5963: LD_EXP 23
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PUSH
5972: LD_INT 26
5974: PUSH
5975: LD_INT 1
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: PUSH
5982: LD_INT 50
5984: PUSH
5985: EMPTY
5986: LIST
5987: PUSH
5988: LD_INT 3
5990: PUSH
5991: LD_INT 23
5993: PUSH
5994: LD_INT 0
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: LIST
6010: PPUSH
6011: CALL_OW 69
6015: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6016: LD_ADDR_VAR 0 4
6020: PUSH
6021: LD_VAR 0 4
6025: PUSH
6026: LD_EXP 1
6030: DIFF
6031: ST_TO_ADDR
// if 0 + filter_all > 0 then
6032: LD_INT 0
6034: PUSH
6035: LD_VAR 0 4
6039: PLUS
6040: PUSH
6041: LD_INT 0
6043: GREATER
6044: IFFALSE 6145
// begin filter := [ ] ;
6046: LD_ADDR_VAR 0 3
6050: PUSH
6051: EMPTY
6052: ST_TO_ADDR
// for un in filter_all do
6053: LD_ADDR_VAR 0 2
6057: PUSH
6058: LD_VAR 0 4
6062: PUSH
6063: FOR_IN
6064: IFFALSE 6097
// if not ( un in all_possible ) then
6066: LD_VAR 0 2
6070: PUSH
6071: LD_EXP 39
6075: IN
6076: NOT
6077: IFFALSE 6095
// filter := filter union un ;
6079: LD_ADDR_VAR 0 3
6083: PUSH
6084: LD_VAR 0 3
6088: PUSH
6089: LD_VAR 0 2
6093: UNION
6094: ST_TO_ADDR
6095: GO 6063
6097: POP
6098: POP
// if filter > 0 then
6099: LD_VAR 0 3
6103: PUSH
6104: LD_INT 0
6106: GREATER
6107: IFFALSE 6127
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6109: LD_VAR 0 3
6113: PUSH
6114: LD_INT 1
6116: ARRAY
6117: PPUSH
6118: LD_STRING DGosStart-Sol1-1
6120: PPUSH
6121: CALL_OW 88
6125: GO 6143
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: ARRAY
6135: PPUSH
6136: LD_STRING DGosStart-Sol1-1
6138: PPUSH
6139: CALL_OW 88
// end else
6143: GO 6317
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6145: LD_ADDR_VAR 0 4
6149: PUSH
6150: LD_INT 22
6152: PUSH
6153: LD_EXP 23
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 26
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: LD_INT 50
6174: PUSH
6175: EMPTY
6176: LIST
6177: PUSH
6178: LD_INT 3
6180: PUSH
6181: LD_INT 23
6183: PUSH
6184: LD_INT 0
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 69
6205: ST_TO_ADDR
// if 0 + filter_all > 0 then
6206: LD_INT 0
6208: PUSH
6209: LD_VAR 0 4
6213: PLUS
6214: PUSH
6215: LD_INT 0
6217: GREATER
6218: IFFALSE 6317
// begin filter := [ ] ;
6220: LD_ADDR_VAR 0 3
6224: PUSH
6225: EMPTY
6226: ST_TO_ADDR
// for un in filter_all do
6227: LD_ADDR_VAR 0 2
6231: PUSH
6232: LD_VAR 0 4
6236: PUSH
6237: FOR_IN
6238: IFFALSE 6271
// if not ( un in all_possible ) then
6240: LD_VAR 0 2
6244: PUSH
6245: LD_EXP 39
6249: IN
6250: NOT
6251: IFFALSE 6269
// filter := filter union un ;
6253: LD_ADDR_VAR 0 3
6257: PUSH
6258: LD_VAR 0 3
6262: PUSH
6263: LD_VAR 0 2
6267: UNION
6268: ST_TO_ADDR
6269: GO 6237
6271: POP
6272: POP
// if filter > 0 then
6273: LD_VAR 0 3
6277: PUSH
6278: LD_INT 0
6280: GREATER
6281: IFFALSE 6301
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 1
6290: ARRAY
6291: PPUSH
6292: LD_STRING DGosStart-FSol1-1
6294: PPUSH
6295: CALL_OW 88
6299: GO 6317
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6301: LD_VAR 0 4
6305: PUSH
6306: LD_INT 1
6308: ARRAY
6309: PPUSH
6310: LD_STRING DGosStart-FSol1-1
6312: PPUSH
6313: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6317: LD_EXP 1
6321: PPUSH
6322: LD_STRING DGosStart-Bur-1
6324: PPUSH
6325: CALL_OW 88
// Wait ( 0 0$20 ) ;
6329: LD_INT 700
6331: PPUSH
6332: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6336: LD_EXP 1
6340: PPUSH
6341: LD_STRING DGosStart-Bur-1a
6343: PPUSH
6344: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6348: LD_EXP 8
6352: PPUSH
6353: LD_STRING DGosStart-Gos-1
6355: PPUSH
6356: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6360: LD_EXP 1
6364: PPUSH
6365: LD_STRING DGosStart-Bur-2
6367: PPUSH
6368: CALL_OW 88
// Hint ( Signal ) ;
6372: LD_STRING Signal
6374: PPUSH
6375: CALL_OW 339
// attackAvalaible = 1 ;
6379: LD_ADDR_EXP 61
6383: PUSH
6384: LD_INT 1
6386: ST_TO_ADDR
// enable ( 6 ) ;
6387: LD_INT 6
6389: ENABLE_MARKED
// EnableExclamations ;
6390: CALL_OW 473
// end ;
6394: LD_VAR 0 1
6398: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6399: LD_INT 0
6401: PPUSH
6402: PPUSH
6403: PPUSH
6404: PPUSH
// DisableExclamations ;
6405: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6409: LD_EXP 1
6413: PPUSH
6414: LD_STRING DSituation-Bur-1
6416: PPUSH
6417: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6421: LD_ADDR_VAR 0 4
6425: PUSH
6426: LD_INT 22
6428: PUSH
6429: LD_EXP 23
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PUSH
6438: LD_INT 26
6440: PUSH
6441: LD_INT 2
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 50
6450: PUSH
6451: EMPTY
6452: LIST
6453: PUSH
6454: LD_INT 3
6456: PUSH
6457: LD_INT 23
6459: PUSH
6460: LD_INT 0
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: PPUSH
6477: CALL_OW 69
6481: ST_TO_ADDR
// if 0 + filter_all > 0 then
6482: LD_INT 0
6484: PUSH
6485: LD_VAR 0 4
6489: PLUS
6490: PUSH
6491: LD_INT 0
6493: GREATER
6494: IFFALSE 6595
// begin filter := [ ] ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: EMPTY
6502: ST_TO_ADDR
// for un in filter_all do
6503: LD_ADDR_VAR 0 2
6507: PUSH
6508: LD_VAR 0 4
6512: PUSH
6513: FOR_IN
6514: IFFALSE 6547
// if not ( un in all_possible ) then
6516: LD_VAR 0 2
6520: PUSH
6521: LD_EXP 39
6525: IN
6526: NOT
6527: IFFALSE 6545
// filter := filter union un ;
6529: LD_ADDR_VAR 0 3
6533: PUSH
6534: LD_VAR 0 3
6538: PUSH
6539: LD_VAR 0 2
6543: UNION
6544: ST_TO_ADDR
6545: GO 6513
6547: POP
6548: POP
// if filter > 0 then
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 0
6556: GREATER
6557: IFFALSE 6577
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6559: LD_VAR 0 3
6563: PUSH
6564: LD_INT 1
6566: ARRAY
6567: PPUSH
6568: LD_STRING DSituation-RFSol1-1
6570: PPUSH
6571: CALL_OW 88
6575: GO 6593
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6577: LD_VAR 0 4
6581: PUSH
6582: LD_INT 1
6584: ARRAY
6585: PPUSH
6586: LD_STRING DSituation-RFSol1-1
6588: PPUSH
6589: CALL_OW 88
// end else
6593: GO 6783
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6595: LD_ADDR_VAR 0 4
6599: PUSH
6600: LD_INT 22
6602: PUSH
6603: LD_EXP 23
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 26
6614: PUSH
6615: LD_INT 1
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PUSH
6622: LD_INT 50
6624: PUSH
6625: EMPTY
6626: LIST
6627: PUSH
6628: LD_INT 3
6630: PUSH
6631: LD_INT 23
6633: PUSH
6634: LD_INT 0
6636: PUSH
6637: EMPTY
6638: LIST
6639: LIST
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PPUSH
6651: CALL_OW 69
6655: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6656: LD_ADDR_VAR 0 4
6660: PUSH
6661: LD_VAR 0 4
6665: PUSH
6666: LD_EXP 1
6670: DIFF
6671: ST_TO_ADDR
// if 0 + filter_all > 0 then
6672: LD_INT 0
6674: PUSH
6675: LD_VAR 0 4
6679: PLUS
6680: PUSH
6681: LD_INT 0
6683: GREATER
6684: IFFALSE 6783
// begin filter := [ ] ;
6686: LD_ADDR_VAR 0 3
6690: PUSH
6691: EMPTY
6692: ST_TO_ADDR
// for un in filter_all do
6693: LD_ADDR_VAR 0 2
6697: PUSH
6698: LD_VAR 0 4
6702: PUSH
6703: FOR_IN
6704: IFFALSE 6737
// if not ( un in all_possible ) then
6706: LD_VAR 0 2
6710: PUSH
6711: LD_EXP 39
6715: IN
6716: NOT
6717: IFFALSE 6735
// filter := filter union un ;
6719: LD_ADDR_VAR 0 3
6723: PUSH
6724: LD_VAR 0 3
6728: PUSH
6729: LD_VAR 0 2
6733: UNION
6734: ST_TO_ADDR
6735: GO 6703
6737: POP
6738: POP
// if filter > 0 then
6739: LD_VAR 0 3
6743: PUSH
6744: LD_INT 0
6746: GREATER
6747: IFFALSE 6767
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6749: LD_VAR 0 3
6753: PUSH
6754: LD_INT 1
6756: ARRAY
6757: PPUSH
6758: LD_STRING DSituation-RSol1-1
6760: PPUSH
6761: CALL_OW 88
6765: GO 6783
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 1
6774: ARRAY
6775: PPUSH
6776: LD_STRING DSituation-RSol1-1
6778: PPUSH
6779: CALL_OW 88
// end ; end ; EnableExclamations ;
6783: CALL_OW 473
// end ;
6787: LD_VAR 0 1
6791: RET
// export function D_GO1 ; begin
6792: LD_INT 0
6794: PPUSH
// DisableExclamations ;
6795: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6799: LD_EXP 1
6803: PPUSH
6804: LD_STRING DGO#1-Bur-1
6806: PPUSH
6807: CALL_OW 88
// EnableExclamations ;
6811: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6815: LD_INT 11
6817: PPUSH
6818: LD_INT 1
6820: PPUSH
6821: CALL_OW 424
// end ;
6825: LD_VAR 0 1
6829: RET
// export function D_SeeYou ; begin
6830: LD_INT 0
6832: PPUSH
// DisableExclamations ;
6833: CALL_OW 474
// DialogueOn ;
6837: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6841: LD_EXP 8
6845: PPUSH
6846: LD_STRING DSeeYou-Gos-1
6848: PPUSH
6849: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6853: LD_EXP 1
6857: PPUSH
6858: LD_STRING DSeeYou-Bur-1
6860: PPUSH
6861: CALL_OW 88
// DialogueOff ;
6865: CALL_OW 7
// EnableExclamations ;
6869: CALL_OW 473
// end ; end_of_file
6873: LD_VAR 0 1
6877: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6878: GO 6880
6880: DISABLE
6881: LD_INT 0
6883: PPUSH
6884: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6885: LD_EXP 1
6889: PPUSH
6890: LD_INT 1
6892: PPUSH
6893: CALL_OW 308
6897: IFFALSE 6963
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_INT 22
6906: PUSH
6907: LD_EXP 27
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for un in filter do
6921: LD_ADDR_VAR 0 2
6925: PUSH
6926: LD_VAR 0 1
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6950
// setside ( un , you ) ;
6934: LD_VAR 0 2
6938: PPUSH
6939: LD_EXP 23
6943: PPUSH
6944: CALL_OW 235
6948: GO 6931
6950: POP
6951: POP
// BurlakReachedBase := true ;
6952: LD_ADDR_EXP 28
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// disable ;
6960: DISABLE
// end else
6961: GO 6964
// enable ;
6963: ENABLE
// end ;
6964: PPOPN 2
6966: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6967: GO 6969
6969: DISABLE
6970: LD_INT 0
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6976: LD_EXP 1
6980: PPUSH
6981: LD_INT 10
6983: PPUSH
6984: CALL_OW 308
6988: IFFALSE 7219
// begin DisableExclamations ;
6990: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6994: LD_ADDR_VAR 0 1
6998: PUSH
6999: LD_INT 22
7001: PUSH
7002: LD_EXP 27
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PPUSH
7011: CALL_OW 69
7015: ST_TO_ADDR
// skill := 0 ;
7016: LD_ADDR_VAR 0 3
7020: PUSH
7021: LD_INT 0
7023: ST_TO_ADDR
// for un in filter do
7024: LD_ADDR_VAR 0 2
7028: PUSH
7029: LD_VAR 0 1
7033: PUSH
7034: FOR_IN
7035: IFFALSE 7069
// if GetSkill ( un , skill_engineering ) >= skill then
7037: LD_VAR 0 2
7041: PPUSH
7042: LD_INT 2
7044: PPUSH
7045: CALL_OW 259
7049: PUSH
7050: LD_VAR 0 3
7054: GREATEREQUAL
7055: IFFALSE 7067
// inzenyr := un ;
7057: LD_ADDR_VAR 0 4
7061: PUSH
7062: LD_VAR 0 2
7066: ST_TO_ADDR
7067: GO 7034
7069: POP
7070: POP
// ComStop ( inzenyr ) ;
7071: LD_VAR 0 4
7075: PPUSH
7076: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7080: LD_VAR 0 4
7084: PPUSH
7085: CALL_OW 257
7089: PUSH
7090: LD_INT 2
7092: NONEQUAL
7093: IFFALSE 7184
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7095: LD_ADDR_VAR 0 1
7099: PUSH
7100: LD_INT 30
7102: PUSH
7103: LD_INT 1
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: PUSH
7110: LD_INT 22
7112: PUSH
7113: LD_EXP 27
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: PPUSH
7126: CALL_OW 69
7130: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7131: LD_VAR 0 4
7135: PPUSH
7136: LD_VAR 0 1
7140: PUSH
7141: LD_INT 1
7143: ARRAY
7144: PPUSH
7145: CALL_OW 120
// Wait ( 10 ) ;
7149: LD_INT 10
7151: PPUSH
7152: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 183
// Wait ( 10 ) ;
7168: LD_INT 10
7170: PPUSH
7171: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7175: LD_VAR 0 4
7179: PPUSH
7180: CALL_OW 182
// end ; Wait ( 10 ) ;
7184: LD_INT 10
7186: PPUSH
7187: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7191: LD_VAR 0 4
7195: PPUSH
7196: LD_INT 26
7198: PPUSH
7199: LD_INT 126
7201: PPUSH
7202: LD_INT 17
7204: PPUSH
7205: LD_INT 5
7207: PPUSH
7208: CALL_OW 205
// EnableExclamations ;
7212: CALL_OW 473
// disable ;
7216: DISABLE
// end else
7217: GO 7220
// enable ;
7219: ENABLE
// end ;
7220: PPOPN 4
7222: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7223: GO 7225
7225: DISABLE
7226: LD_INT 0
7228: PPUSH
7229: PPUSH
// begin if straz < bazooker then
7230: LD_EXP 45
7234: PUSH
7235: LD_EXP 51
7239: LESS
7240: IFFALSE 7388
// begin bazooker := bazooker + 1 ;
7242: LD_ADDR_EXP 51
7246: PUSH
7247: LD_EXP 51
7251: PUSH
7252: LD_INT 1
7254: PLUS
7255: ST_TO_ADDR
// while straz < bazooker do
7256: LD_EXP 45
7260: PUSH
7261: LD_EXP 51
7265: LESS
7266: IFFALSE 7388
// begin uc_side := rus ;
7268: LD_ADDR_OWVAR 20
7272: PUSH
7273: LD_EXP 24
7277: ST_TO_ADDR
// uc_nation := nation_russian ;
7278: LD_ADDR_OWVAR 21
7282: PUSH
7283: LD_INT 3
7285: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 4 + difficulty ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_INT 9
7291: PPUSH
7292: LD_INT 4
7294: PUSH
7295: LD_OWVAR 67
7299: PLUS
7300: PPUSH
7301: CALL_OW 380
// hc_name :=  ;
7305: LD_ADDR_OWVAR 26
7309: PUSH
7310: LD_STRING 
7312: ST_TO_ADDR
// bazukr := CreateHuman ;
7313: LD_ADDR_VAR 0 2
7317: PUSH
7318: CALL_OW 44
7322: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7323: LD_EXP 62
7327: PPUSH
7328: LD_VAR 0 2
7332: PPUSH
7333: LD_INT 1
7335: PPUSH
7336: CALL_OW 394
// straz := straz ^ bazukr ;
7340: LD_ADDR_EXP 45
7344: PUSH
7345: LD_EXP 45
7349: PUSH
7350: LD_VAR 0 2
7354: ADD
7355: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7356: LD_VAR 0 2
7360: PPUSH
7361: LD_INT 9
7363: PPUSH
7364: LD_INT 0
7366: PPUSH
7367: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7371: LD_VAR 0 2
7375: PPUSH
7376: LD_INT 66
7378: PPUSH
7379: LD_INT 48
7381: PPUSH
7382: CALL_OW 114
// end ;
7386: GO 7256
// end ; end ;
7388: PPOPN 2
7390: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7391: GO 7393
7393: DISABLE
7394: LD_INT 0
7396: PPUSH
// begin if ( 0 + straz ) <> 0 then
7397: LD_INT 0
7399: PUSH
7400: LD_EXP 45
7404: PLUS
7405: PUSH
7406: LD_INT 0
7408: NONEQUAL
7409: IFFALSE 7652
// begin for un in straz do
7411: LD_ADDR_VAR 0 1
7415: PUSH
7416: LD_EXP 45
7420: PUSH
7421: FOR_IN
7422: IFFALSE 7650
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7424: LD_VAR 0 1
7428: PPUSH
7429: CALL_OW 314
7433: NOT
7434: PUSH
7435: LD_VAR 0 1
7439: PPUSH
7440: CALL_OW 256
7444: PUSH
7445: LD_INT 601
7447: GREATER
7448: AND
7449: IFFALSE 7648
// begin if GetY ( un ) > 60 then
7451: LD_VAR 0 1
7455: PPUSH
7456: CALL_OW 251
7460: PUSH
7461: LD_INT 60
7463: GREATER
7464: IFFALSE 7558
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7466: LD_VAR 0 1
7470: PPUSH
7471: LD_INT 66
7473: PPUSH
7474: LD_INT 48
7476: PPUSH
7477: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7481: LD_VAR 0 1
7485: PPUSH
7486: LD_INT 63
7488: PPUSH
7489: LD_INT 74
7491: PPUSH
7492: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7496: LD_VAR 0 1
7500: PPUSH
7501: LD_INT 73
7503: PPUSH
7504: LD_INT 90
7506: PPUSH
7507: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7511: LD_VAR 0 1
7515: PPUSH
7516: LD_INT 76
7518: PPUSH
7519: LD_INT 95
7521: PPUSH
7522: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7526: LD_VAR 0 1
7530: PPUSH
7531: LD_INT 72
7533: PPUSH
7534: LD_INT 95
7536: PPUSH
7537: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7541: LD_VAR 0 1
7545: PPUSH
7546: LD_INT 50
7548: PPUSH
7549: LD_INT 73
7551: PPUSH
7552: CALL_OW 174
// end else
7556: GO 7648
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: LD_INT 73
7565: PPUSH
7566: LD_INT 90
7568: PPUSH
7569: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 76
7580: PPUSH
7581: LD_INT 95
7583: PPUSH
7584: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7588: LD_VAR 0 1
7592: PPUSH
7593: LD_INT 72
7595: PPUSH
7596: LD_INT 95
7598: PPUSH
7599: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_INT 50
7610: PPUSH
7611: LD_INT 73
7613: PPUSH
7614: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7618: LD_VAR 0 1
7622: PPUSH
7623: LD_INT 63
7625: PPUSH
7626: LD_INT 74
7628: PPUSH
7629: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7633: LD_VAR 0 1
7637: PPUSH
7638: LD_INT 66
7640: PPUSH
7641: LD_INT 48
7643: PPUSH
7644: CALL_OW 174
// end ; end ; end ;
7648: GO 7421
7650: POP
7651: POP
// end ; enable ;
7652: ENABLE
// end ;
7653: PPOPN 1
7655: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7656: GO 7658
7658: DISABLE
7659: LD_INT 0
7661: PPUSH
7662: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7663: LD_EXP 1
7667: PPUSH
7668: LD_INT 2
7670: PPUSH
7671: CALL_OW 308
7675: IFFALSE 7719
// begin disabled5 := true ;
7677: LD_ADDR_LOC 4
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// D_GosStart ;
7685: CALL 5536 0 0
// Wait ( 0 0$5 ) ;
7689: LD_INT 175
7691: PPUSH
7692: CALL_OW 67
// D_Situation ;
7696: CALL 6399 0 0
// ChangeMissionObjectives ( MHold ) ;
7700: LD_STRING MHold
7702: PPUSH
7703: CALL_OW 337
// disable ;
7707: DISABLE
// enable ( 333 ) ;
7708: LD_INT 333
7710: ENABLE_MARKED
// enable ( 334 ) ;
7711: LD_INT 334
7713: ENABLE_MARKED
// enable ( 337 ) ;
7714: LD_INT 337
7716: ENABLE_MARKED
// end else
7717: GO 7720
// enable ;
7719: ENABLE
// end ;
7720: PPOPN 2
7722: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7723: GO 7725
7725: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7726: LD_EXP 8
7730: PPUSH
7731: CALL_OW 306
7735: PUSH
7736: LD_INT 1
7738: EQUAL
7739: IFFALSE 7765
// begin if WasSelected = false then
7741: LD_EXP 46
7745: PUSH
7746: LD_INT 0
7748: EQUAL
7749: IFFALSE 7763
// begin QueryQGO ;
7751: CALL 7782 0 0
// WasSelected := true ;
7755: LD_ADDR_EXP 46
7759: PUSH
7760: LD_INT 1
7762: ST_TO_ADDR
// end ; end else
7763: GO 7773
// WasSelected := false ;
7765: LD_ADDR_EXP 46
7769: PUSH
7770: LD_INT 0
7772: ST_TO_ADDR
// if not disabled3 then
7773: LD_LOC 3
7777: NOT
7778: IFFALSE 7781
// enable ;
7780: ENABLE
// end ;
7781: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
7787: PPUSH
7788: PPUSH
7789: PPUSH
// res := Query ( QGO ) ;
7790: LD_ADDR_VAR 0 2
7794: PUSH
7795: LD_STRING QGO
7797: PPUSH
7798: CALL_OW 97
7802: ST_TO_ADDR
// if res = 1 then
7803: LD_VAR 0 2
7807: PUSH
7808: LD_INT 1
7810: EQUAL
7811: IFFALSE 8187
// begin disabled3 := true ;
7813: LD_ADDR_LOC 3
7817: PUSH
7818: LD_INT 1
7820: ST_TO_ADDR
// D_GO1 ;
7821: CALL 6792 0 0
// ChangeMissionObjectives ( MGuide ) ;
7825: LD_STRING MGuide
7827: PPUSH
7828: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7832: LD_ADDR_VAR 0 3
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: LD_INT 21
7842: PUSH
7843: LD_INT 2
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: PUSH
7850: LD_INT 34
7852: PUSH
7853: LD_INT 51
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PPUSH
7864: CALL_OW 70
7868: ST_TO_ADDR
// if filter = 0 then
7869: LD_VAR 0 3
7873: PUSH
7874: LD_INT 0
7876: EQUAL
7877: IFFALSE 8028
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7879: LD_EXP 8
7883: PPUSH
7884: LD_INT 57
7886: PPUSH
7887: LD_INT 98
7889: PPUSH
7890: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7894: LD_INT 35
7896: PPUSH
7897: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7901: LD_EXP 8
7905: PPUSH
7906: CALL_OW 314
7910: NOT
7911: IFFALSE 7894
// RemoveUnit ( Gossudarov ) ;
7913: LD_EXP 8
7917: PPUSH
7918: CALL_OW 64
// uc_side := ally ;
7922: LD_ADDR_OWVAR 20
7926: PUSH
7927: LD_EXP 25
7931: ST_TO_ADDR
// uc_nation := nation_russian ;
7932: LD_ADDR_OWVAR 21
7936: PUSH
7937: LD_INT 3
7939: ST_TO_ADDR
// uc_direction := 5 ;
7940: LD_ADDR_OWVAR 24
7944: PUSH
7945: LD_INT 5
7947: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7948: LD_ADDR_OWVAR 37
7952: PUSH
7953: LD_INT 21
7955: ST_TO_ADDR
// vc_engine := engine_combustion ;
7956: LD_ADDR_OWVAR 39
7960: PUSH
7961: LD_INT 1
7963: ST_TO_ADDR
// vc_control := control_manual ;
7964: LD_ADDR_OWVAR 38
7968: PUSH
7969: LD_INT 1
7971: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7972: LD_ADDR_OWVAR 40
7976: PUSH
7977: LD_INT 51
7979: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7980: LD_ADDR_VAR 0 4
7984: PUSH
7985: CALL_OW 45
7989: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7990: LD_EXP 8
7994: PPUSH
7995: LD_VAR 0 4
7999: PPUSH
8000: CALL_OW 52
// Wait ( 0 0$5 ) ;
8004: LD_INT 175
8006: PPUSH
8007: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
8011: LD_VAR 0 4
8015: PPUSH
8016: LD_INT 9
8018: PPUSH
8019: LD_INT 0
8021: PPUSH
8022: CALL_OW 49
// end else
8026: GO 8046
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
8028: LD_EXP 8
8032: PPUSH
8033: LD_VAR 0 3
8037: PUSH
8038: LD_INT 1
8040: ARRAY
8041: PPUSH
8042: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8046: LD_EXP 8
8050: PPUSH
8051: LD_INT 4
8053: PPUSH
8054: CALL_OW 469
8058: PUSH
8059: LD_INT 1
8061: ARRAY
8062: PPUSH
8063: LD_INT 4
8065: PPUSH
8066: CALL_OW 469
8070: PUSH
8071: LD_INT 2
8073: ARRAY
8074: PPUSH
8075: CALL_OW 220
// Wait ( 0 0$5 ) ;
8079: LD_INT 175
8081: PPUSH
8082: CALL_OW 67
// ComExitBuilding ( scientists ) ;
8086: LD_EXP 40
8090: PPUSH
8091: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
8095: LD_EXP 40
8099: PUSH
8100: LD_EXP 8
8104: ADD
8105: PPUSH
8106: LD_INT 50
8108: PPUSH
8109: LD_INT 58
8111: PPUSH
8112: CALL_OW 171
// for un in scientists ^ Gossudarov do
8116: LD_ADDR_VAR 0 6
8120: PUSH
8121: LD_EXP 40
8125: PUSH
8126: LD_EXP 8
8130: ADD
8131: PUSH
8132: FOR_IN
8133: IFFALSE 8151
// AddComSailEvent ( un , un ) ;
8135: LD_VAR 0 6
8139: PPUSH
8140: LD_VAR 0 6
8144: PPUSH
8145: CALL_OW 224
8149: GO 8132
8151: POP
8152: POP
// player_units := player_units union scientists union Gossudarov ;
8153: LD_ADDR_EXP 41
8157: PUSH
8158: LD_EXP 41
8162: PUSH
8163: LD_EXP 40
8167: UNION
8168: PUSH
8169: LD_EXP 8
8173: UNION
8174: ST_TO_ADDR
// enable ( 4 ) ;
8175: LD_INT 4
8177: ENABLE_MARKED
// enable ( 7 ) ;
8178: LD_INT 7
8180: ENABLE_MARKED
// enable ( 8 ) ;
8181: LD_INT 8
8183: ENABLE_MARKED
// enable ( 9 ) ;
8184: LD_INT 9
8186: ENABLE_MARKED
// end ; end ;
8187: LD_VAR 0 1
8191: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8192: GO 8194
8194: DISABLE
8195: LD_INT 0
8197: PPUSH
// begin for un in scientists do
8198: LD_ADDR_VAR 0 1
8202: PUSH
8203: LD_EXP 40
8207: PUSH
8208: FOR_IN
8209: IFFALSE 8279
// begin if IsInArea ( un , ExitArea ) then
8211: LD_VAR 0 1
8215: PPUSH
8216: LD_INT 11
8218: PPUSH
8219: CALL_OW 308
8223: IFFALSE 8250
// begin scientists_saved := scientists_saved union un ;
8225: LD_ADDR_EXP 48
8229: PUSH
8230: LD_EXP 48
8234: PUSH
8235: LD_VAR 0 1
8239: UNION
8240: ST_TO_ADDR
// RemoveUnit ( un ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: CALL_OW 64
// end ; if IsDead ( un ) then
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 301
8259: IFFALSE 8277
// scientists_dead := scientists_dead union un ;
8261: LD_ADDR_EXP 49
8265: PUSH
8266: LD_EXP 49
8270: PUSH
8271: LD_VAR 0 1
8275: UNION
8276: ST_TO_ADDR
// end ;
8277: GO 8208
8279: POP
8280: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8281: LD_EXP 8
8285: PPUSH
8286: LD_INT 11
8288: PPUSH
8289: CALL_OW 308
8293: PUSH
8294: LD_EXP 8
8298: PPUSH
8299: CALL_OW 310
8303: PPUSH
8304: LD_INT 11
8306: PPUSH
8307: CALL_OW 308
8311: OR
8312: PUSH
8313: LD_EXP 48
8317: PUSH
8318: LD_EXP 49
8322: PLUS
8323: PUSH
8324: LD_EXP 40
8328: EQUAL
8329: AND
8330: PUSH
8331: LD_EXP 50
8335: PPUSH
8336: CALL_OW 255
8340: PUSH
8341: LD_EXP 23
8345: EQUAL
8346: AND
8347: PUSH
8348: LD_EXP 50
8352: PPUSH
8353: LD_INT 11
8355: PPUSH
8356: CALL_OW 308
8360: AND
8361: PUSH
8362: LD_EXP 50
8366: PPUSH
8367: LD_INT 4
8369: PPUSH
8370: CALL_OW 289
8374: PUSH
8375: LD_INT 40
8377: EQUAL
8378: AND
8379: IFFALSE 8391
// begin D_SeeYou ;
8381: CALL 6830 0 0
// TheEnd ;
8385: CALL 3316 0 0
// end else
8389: GO 8392
// enable ;
8391: ENABLE
// end ;
8392: PPOPN 1
8394: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8395: GO 8397
8397: DISABLE
8398: LD_INT 0
8400: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8401: LD_EXP 1
8405: PPUSH
8406: LD_INT 18
8408: PPUSH
8409: CALL_OW 308
8413: PUSH
8414: LD_EXP 43
8418: PPUSH
8419: LD_INT 18
8421: PPUSH
8422: CALL_OW 308
8426: OR
8427: IFFALSE 8444
// begin Wait ( 0 0$3 ) ;
8429: LD_INT 105
8431: PPUSH
8432: CALL_OW 67
// Attack1 := true ;
8436: LD_ADDR_LOC 5
8440: PUSH
8441: LD_INT 1
8443: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8444: LD_EXP 1
8448: PPUSH
8449: LD_INT 19
8451: PPUSH
8452: CALL_OW 308
8456: PUSH
8457: LD_EXP 43
8461: PPUSH
8462: LD_INT 19
8464: PPUSH
8465: CALL_OW 308
8469: OR
8470: IFFALSE 8487
// begin Wait ( 0 0$3 ) ;
8472: LD_INT 105
8474: PPUSH
8475: CALL_OW 67
// Attack2 := true ;
8479: LD_ADDR_LOC 6
8483: PUSH
8484: LD_INT 1
8486: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8487: LD_EXP 1
8491: PPUSH
8492: LD_INT 20
8494: PPUSH
8495: CALL_OW 308
8499: PUSH
8500: LD_EXP 43
8504: PPUSH
8505: LD_INT 20
8507: PPUSH
8508: CALL_OW 308
8512: OR
8513: IFFALSE 8530
// begin Wait ( 0 0$3 ) ;
8515: LD_INT 105
8517: PPUSH
8518: CALL_OW 67
// Attack3 := true ;
8522: LD_ADDR_LOC 7
8526: PUSH
8527: LD_INT 1
8529: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8530: LD_LOC 5
8534: PUSH
8535: LD_LOC 6
8539: NOT
8540: AND
8541: PUSH
8542: LD_LOC 7
8546: NOT
8547: AND
8548: IFFALSE 8611
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8550: LD_ADDR_VAR 0 1
8554: PUSH
8555: DOUBLE
8556: LD_EXP 31
8560: PUSH
8561: LD_INT 1
8563: PLUS
8564: DEC
8565: ST_TO_ADDR
8566: LD_EXP 31
8570: PUSH
8571: LD_EXP 30
8575: PLUS
8576: PUSH
8577: FOR_TO
8578: IFFALSE 8609
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8580: LD_EXP 29
8584: PUSH
8585: LD_VAR 0 1
8589: ARRAY
8590: PPUSH
8591: LD_EXP 1
8595: PPUSH
8596: CALL_OW 115
// Wait ( 2 ) ;
8600: LD_INT 2
8602: PPUSH
8603: CALL_OW 67
// end ;
8607: GO 8577
8609: POP
8610: POP
// if Attack1 and Attack2 and not Attack3 then
8611: LD_LOC 5
8615: PUSH
8616: LD_LOC 6
8620: AND
8621: PUSH
8622: LD_LOC 7
8626: NOT
8627: AND
8628: IFFALSE 8695
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8630: LD_ADDR_VAR 0 1
8634: PUSH
8635: DOUBLE
8636: LD_EXP 31
8640: PUSH
8641: LD_INT 1
8643: PLUS
8644: DEC
8645: ST_TO_ADDR
8646: LD_EXP 31
8650: PUSH
8651: LD_INT 2
8653: PUSH
8654: LD_EXP 30
8658: MUL
8659: PLUS
8660: PUSH
8661: FOR_TO
8662: IFFALSE 8693
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8664: LD_EXP 29
8668: PUSH
8669: LD_VAR 0 1
8673: ARRAY
8674: PPUSH
8675: LD_EXP 1
8679: PPUSH
8680: CALL_OW 115
// Wait ( 2 ) ;
8684: LD_INT 2
8686: PPUSH
8687: CALL_OW 67
// end ;
8691: GO 8661
8693: POP
8694: POP
// if Attack1 and Attack2 and Attack3 then
8695: LD_LOC 5
8699: PUSH
8700: LD_LOC 6
8704: AND
8705: PUSH
8706: LD_LOC 7
8710: AND
8711: IFFALSE 8778
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8713: LD_ADDR_VAR 0 1
8717: PUSH
8718: DOUBLE
8719: LD_EXP 31
8723: PUSH
8724: LD_INT 1
8726: PLUS
8727: DEC
8728: ST_TO_ADDR
8729: LD_EXP 31
8733: PUSH
8734: LD_INT 3
8736: PUSH
8737: LD_EXP 30
8741: MUL
8742: PLUS
8743: PUSH
8744: FOR_TO
8745: IFFALSE 8776
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8747: LD_EXP 29
8751: PUSH
8752: LD_VAR 0 1
8756: ARRAY
8757: PPUSH
8758: LD_EXP 1
8762: PPUSH
8763: CALL_OW 115
// Wait ( 2 ) ;
8767: LD_INT 2
8769: PPUSH
8770: CALL_OW 67
// end ;
8774: GO 8744
8776: POP
8777: POP
// for i := 1 to pursuers_base do
8778: LD_ADDR_VAR 0 1
8782: PUSH
8783: DOUBLE
8784: LD_INT 1
8786: DEC
8787: ST_TO_ADDR
8788: LD_EXP 31
8792: PUSH
8793: FOR_TO
8794: IFFALSE 8825
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8796: LD_EXP 29
8800: PUSH
8801: LD_VAR 0 1
8805: ARRAY
8806: PPUSH
8807: LD_EXP 1
8811: PPUSH
8812: CALL_OW 115
// Wait ( 2 ) ;
8816: LD_INT 2
8818: PPUSH
8819: CALL_OW 67
// end ;
8823: GO 8793
8825: POP
8826: POP
// if not disabled5 then
8827: LD_LOC 4
8831: NOT
8832: IFFALSE 8835
// enable ;
8834: ENABLE
// end ;
8835: PPOPN 1
8837: END
// every 0 0$1 marked 6 do
8838: GO 8840
8840: DISABLE
// begin if Goss_time > 0 then
8841: LD_EXP 47
8845: PUSH
8846: LD_INT 0
8848: GREATER
8849: IFFALSE 8885
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8851: LD_ADDR_OWVAR 47
8855: PUSH
8856: LD_STRING #Ru12a-1
8858: PUSH
8859: LD_EXP 47
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8868: LD_ADDR_EXP 47
8872: PUSH
8873: LD_EXP 47
8877: PUSH
8878: LD_INT 35
8880: MINUS
8881: ST_TO_ADDR
// enable ;
8882: ENABLE
// end else
8883: GO 8896
// begin display_strings :=  ;
8885: LD_ADDR_OWVAR 47
8889: PUSH
8890: LD_STRING 
8892: ST_TO_ADDR
// enable ( 3 ) ;
8893: LD_INT 3
8895: ENABLE_MARKED
// end ; end ;
8896: END
// every 0 0$1 marked 7 do
8897: GO 8899
8899: DISABLE
// begin if FindArtifact ( 4 ) then
8900: LD_INT 4
8902: PPUSH
8903: CALL_OW 469
8907: IFFALSE 8961
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8909: LD_LOC 8
8913: PPUSH
8914: LD_INT 4
8916: PPUSH
8917: CALL_OW 469
8921: PUSH
8922: LD_INT 1
8924: ARRAY
8925: PPUSH
8926: LD_INT 4
8928: PPUSH
8929: CALL_OW 469
8933: PUSH
8934: LD_INT 2
8936: ARRAY
8937: PPUSH
8938: CALL_OW 160
// Wait ( 3 ) ;
8942: LD_INT 3
8944: PPUSH
8945: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8949: LD_LOC 8
8953: PPUSH
8954: LD_INT 9
8956: PPUSH
8957: CALL_OW 173
// end ; enable ;
8961: ENABLE
// end ;
8962: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8963: GO 8965
8965: DISABLE
8966: LD_INT 0
8968: PPUSH
8969: PPUSH
8970: PPUSH
8971: PPUSH
// begin Wait ( pausa ) ;
8972: LD_EXP 37
8976: PPUSH
8977: CALL_OW 67
// sc_utok := [ ] ;
8981: LD_ADDR_VAR 0 3
8985: PUSH
8986: EMPTY
8987: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
8988: LD_ADDR_VAR 0 1
8992: PUSH
8993: DOUBLE
8994: LD_INT 1
8996: DEC
8997: ST_TO_ADDR
8998: LD_INT 2
9000: PUSH
9001: LD_OWVAR 67
9005: PLUS
9006: PUSH
9007: FOR_TO
9008: IFFALSE 9212
// begin uc_side := rus ;
9010: LD_ADDR_OWVAR 20
9014: PUSH
9015: LD_EXP 24
9019: ST_TO_ADDR
// uc_nation := nation_russian ;
9020: LD_ADDR_OWVAR 21
9024: PUSH
9025: LD_INT 3
9027: ST_TO_ADDR
// uc_direction := 5 ;
9028: LD_ADDR_OWVAR 24
9032: PUSH
9033: LD_INT 5
9035: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
9036: LD_INT 1
9038: PPUSH
9039: LD_INT 3
9041: PPUSH
9042: CALL_OW 12
9046: PUSH
9047: LD_INT 1
9049: DOUBLE
9050: EQUAL
9051: IFTRUE 9055
9053: GO 9079
9055: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9056: LD_INT 1
9058: PPUSH
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 4
9064: PPUSH
9065: LD_INT 8
9067: PPUSH
9068: CALL_OW 12
9072: PPUSH
9073: CALL_OW 380
9077: GO 9118
9079: LD_INT 2
9081: DOUBLE
9082: GREATEREQUAL
9083: IFFALSE 9091
9085: LD_INT 3
9087: DOUBLE
9088: LESSEQUAL
9089: IFTRUE 9093
9091: GO 9117
9093: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9094: LD_INT 1
9096: PPUSH
9097: LD_INT 9
9099: PPUSH
9100: LD_INT 3
9102: PPUSH
9103: LD_INT 7
9105: PPUSH
9106: CALL_OW 12
9110: PPUSH
9111: CALL_OW 380
9115: GO 9118
9117: POP
// hc_name :=  ;
9118: LD_ADDR_OWVAR 26
9122: PUSH
9123: LD_STRING 
9125: ST_TO_ADDR
// clovek := CreateHuman ;
9126: LD_ADDR_VAR 0 2
9130: PUSH
9131: CALL_OW 44
9135: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9136: LD_VAR 0 2
9140: PPUSH
9141: LD_INT 9
9143: PPUSH
9144: LD_INT 0
9146: PPUSH
9147: CALL_OW 49
// Wait ( 0 0$2 ) ;
9151: LD_INT 70
9153: PPUSH
9154: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9158: LD_VAR 0 2
9162: PPUSH
9163: LD_INT 50
9165: PPUSH
9166: LD_INT 84
9168: PPUSH
9169: CALL_OW 111
// Wait ( 2 ) ;
9173: LD_INT 2
9175: PPUSH
9176: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9180: LD_VAR 0 2
9184: PPUSH
9185: LD_EXP 50
9189: PPUSH
9190: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9194: LD_ADDR_VAR 0 3
9198: PUSH
9199: LD_VAR 0 3
9203: PUSH
9204: LD_VAR 0 2
9208: ADD
9209: ST_TO_ADDR
// end ;
9210: GO 9007
9212: POP
9213: POP
// Wait ( 0 0$10 ) ;
9214: LD_INT 350
9216: PPUSH
9217: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9221: LD_LOC 8
9225: PPUSH
9226: CALL_OW 302
9230: NOT
9231: IFFALSE 9338
// begin uc_side := rus ;
9233: LD_ADDR_OWVAR 20
9237: PUSH
9238: LD_EXP 24
9242: ST_TO_ADDR
// uc_nation := nation_russian ;
9243: LD_ADDR_OWVAR 21
9247: PUSH
9248: LD_INT 3
9250: ST_TO_ADDR
// uc_direction := 5 ;
9251: LD_ADDR_OWVAR 24
9255: PUSH
9256: LD_INT 5
9258: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9259: LD_ADDR_OWVAR 37
9263: PUSH
9264: LD_INT 22
9266: ST_TO_ADDR
// vc_control := control_computer ;
9267: LD_ADDR_OWVAR 38
9271: PUSH
9272: LD_INT 3
9274: ST_TO_ADDR
// vc_engine := engine_siberite ;
9275: LD_ADDR_OWVAR 39
9279: PUSH
9280: LD_INT 3
9282: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9283: LD_ADDR_OWVAR 40
9287: PUSH
9288: LD_INT 51
9290: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9291: LD_ADDR_LOC 8
9295: PUSH
9296: CALL_OW 45
9300: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9301: LD_LOC 8
9305: PPUSH
9306: LD_INT 9
9308: PPUSH
9309: LD_INT 0
9311: PPUSH
9312: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9316: LD_INT 18
9318: PPUSH
9319: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9323: LD_LOC 8
9327: PPUSH
9328: LD_INT 55
9330: PPUSH
9331: LD_INT 84
9333: PPUSH
9334: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9338: LD_VAR 0 3
9342: PUSH
9343: LD_LOC 8
9347: PPUSH
9348: CALL_OW 302
9352: AND
9353: IFFALSE 9423
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9355: LD_VAR 0 3
9359: PPUSH
9360: LD_EXP 50
9364: PPUSH
9365: CALL_OW 115
// Wait ( 0 0$2 ) ;
9369: LD_INT 70
9371: PPUSH
9372: CALL_OW 67
// for un in sc_utok do
9376: LD_ADDR_VAR 0 4
9380: PUSH
9381: LD_VAR 0 3
9385: PUSH
9386: FOR_IN
9387: IFFALSE 9419
// if not IsOK ( un ) then
9389: LD_VAR 0 4
9393: PPUSH
9394: CALL_OW 302
9398: NOT
9399: IFFALSE 9417
// sc_utok := sc_utok diff un ;
9401: LD_ADDR_VAR 0 3
9405: PUSH
9406: LD_VAR 0 3
9410: PUSH
9411: LD_VAR 0 4
9415: DIFF
9416: ST_TO_ADDR
9417: GO 9386
9419: POP
9420: POP
// end ;
9421: GO 9338
// Wait ( 0 0$5 ) ;
9423: LD_INT 175
9425: PPUSH
9426: CALL_OW 67
// enable ;
9430: ENABLE
// end ;
9431: PPOPN 4
9433: END
// every 0 0$3 marked 9 do
9434: GO 9436
9436: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9437: LD_LOC 8
9441: PPUSH
9442: LD_INT 3
9444: PPUSH
9445: CALL_OW 308
9449: PUSH
9450: LD_LOC 8
9454: PPUSH
9455: LD_INT 4
9457: PPUSH
9458: CALL_OW 289
9462: PUSH
9463: LD_INT 40
9465: EQUAL
9466: AND
9467: IFFALSE 9476
// YouLost ( Artefact ) ;
9469: LD_STRING Artefact
9471: PPUSH
9472: CALL_OW 104
// enable ;
9476: ENABLE
// end ;
9477: END
// on UnitDestroyed ( human ) do var i , un ;
9478: LD_INT 0
9480: PPUSH
9481: PPUSH
// begin if human = Burlak then
9482: LD_VAR 0 1
9486: PUSH
9487: LD_EXP 1
9491: EQUAL
9492: IFFALSE 9501
// YouLost ( Burlak ) ;
9494: LD_STRING Burlak
9496: PPUSH
9497: CALL_OW 104
// if human = Gossudarov then
9501: LD_VAR 0 1
9505: PUSH
9506: LD_EXP 8
9510: EQUAL
9511: IFFALSE 9520
// YouLost ( Gossudarov ) ;
9513: LD_STRING Gossudarov
9515: PPUSH
9516: CALL_OW 104
// if human = Masha then
9520: LD_VAR 0 1
9524: PUSH
9525: LD_EXP 43
9529: EQUAL
9530: IFFALSE 9540
// lost_masha := true ;
9532: LD_ADDR_EXP 52
9536: PUSH
9537: LD_INT 1
9539: ST_TO_ADDR
// if human in straz then
9540: LD_VAR 0 1
9544: PUSH
9545: LD_EXP 45
9549: IN
9550: IFFALSE 9599
// begin straz := straz diff human ;
9552: LD_ADDR_EXP 45
9556: PUSH
9557: LD_EXP 45
9561: PUSH
9562: LD_VAR 0 1
9566: DIFF
9567: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9568: LD_EXP 62
9572: PPUSH
9573: LD_VAR 0 1
9577: PPUSH
9578: LD_INT 1
9580: PPUSH
9581: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9585: LD_ADDR_EXP 53
9589: PUSH
9590: LD_EXP 53
9594: PUSH
9595: LD_INT 1
9597: PLUS
9598: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9599: LD_VAR 0 1
9603: PPUSH
9604: CALL_OW 255
9608: PUSH
9609: LD_INT 3
9611: EQUAL
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_EXP 60
9622: IN
9623: AND
9624: IFFALSE 9671
// begin for i in attackGroup do
9626: LD_ADDR_VAR 0 2
9630: PUSH
9631: LD_EXP 60
9635: PUSH
9636: FOR_IN
9637: IFFALSE 9669
// if i = human then
9639: LD_VAR 0 2
9643: PUSH
9644: LD_VAR 0 1
9648: EQUAL
9649: IFFALSE 9667
// attackGroup = attackGroup diff i ;
9651: LD_ADDR_EXP 60
9655: PUSH
9656: LD_EXP 60
9660: PUSH
9661: LD_VAR 0 2
9665: DIFF
9666: ST_TO_ADDR
9667: GO 9636
9669: POP
9670: POP
// end ; end ;
9671: PPOPN 3
9673: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9674: LD_VAR 0 1
9678: PUSH
9679: LD_EXP 8
9683: EQUAL
9684: IFFALSE 9705
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9686: LD_EXP 8
9690: PPUSH
9691: CALL_OW 310
9695: PPUSH
9696: LD_EXP 23
9700: PPUSH
9701: CALL_OW 235
// SetSide ( num , you ) ;
9705: LD_VAR 0 1
9709: PPUSH
9710: LD_EXP 23
9714: PPUSH
9715: CALL_OW 235
// end ;
9719: PPOPN 1
9721: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9722: LD_VAR 0 1
9726: PPUSH
9727: CALL_OW 255
9731: PUSH
9732: LD_EXP 24
9736: NONEQUAL
9737: IFFALSE 9749
// Artifact_cargo := un ;
9739: LD_ADDR_EXP 50
9743: PUSH
9744: LD_VAR 0 1
9748: ST_TO_ADDR
// end ; end_of_file
9749: PPOPN 2
9751: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9752: GO 9754
9754: DISABLE
9755: LD_INT 0
9757: PPUSH
9758: PPUSH
9759: PPUSH
9760: PPUSH
9761: PPUSH
9762: PPUSH
9763: PPUSH
// begin case tick of 0 .. 30000 :
9764: LD_OWVAR 1
9768: PUSH
9769: LD_INT 0
9771: DOUBLE
9772: GREATEREQUAL
9773: IFFALSE 9781
9775: LD_INT 30000
9777: DOUBLE
9778: LESSEQUAL
9779: IFTRUE 9783
9781: GO 9793
9783: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9784: LD_INT 1050
9786: PPUSH
9787: CALL_OW 67
9791: GO 9969
9793: LD_INT 30001
9795: DOUBLE
9796: GREATEREQUAL
9797: IFFALSE 9805
9799: LD_INT 50000
9801: DOUBLE
9802: LESSEQUAL
9803: IFTRUE 9807
9805: GO 9817
9807: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9808: LD_INT 1575
9810: PPUSH
9811: CALL_OW 67
9815: GO 9969
9817: LD_INT 50001
9819: DOUBLE
9820: GREATEREQUAL
9821: IFFALSE 9829
9823: LD_INT 70000
9825: DOUBLE
9826: LESSEQUAL
9827: IFTRUE 9831
9829: GO 9841
9831: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9832: LD_INT 2100
9834: PPUSH
9835: CALL_OW 67
9839: GO 9969
9841: LD_INT 70001
9843: DOUBLE
9844: GREATEREQUAL
9845: IFFALSE 9853
9847: LD_INT 90000
9849: DOUBLE
9850: LESSEQUAL
9851: IFTRUE 9855
9853: GO 9865
9855: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9856: LD_INT 2625
9858: PPUSH
9859: CALL_OW 67
9863: GO 9969
9865: LD_INT 70001
9867: DOUBLE
9868: GREATEREQUAL
9869: IFFALSE 9877
9871: LD_INT 90000
9873: DOUBLE
9874: LESSEQUAL
9875: IFTRUE 9879
9877: GO 9889
9879: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9880: LD_INT 3150
9882: PPUSH
9883: CALL_OW 67
9887: GO 9969
9889: LD_INT 90001
9891: DOUBLE
9892: GREATEREQUAL
9893: IFFALSE 9901
9895: LD_INT 110000
9897: DOUBLE
9898: LESSEQUAL
9899: IFTRUE 9903
9901: GO 9913
9903: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9904: LD_INT 3675
9906: PPUSH
9907: CALL_OW 67
9911: GO 9969
9913: LD_INT 110001
9915: DOUBLE
9916: GREATEREQUAL
9917: IFFALSE 9925
9919: LD_INT 130000
9921: DOUBLE
9922: LESSEQUAL
9923: IFTRUE 9927
9925: GO 9937
9927: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9928: LD_INT 4200
9930: PPUSH
9931: CALL_OW 67
9935: GO 9969
9937: LD_INT 130001
9939: DOUBLE
9940: GREATEREQUAL
9941: IFFALSE 9949
9943: LD_INT 150000
9945: DOUBLE
9946: LESSEQUAL
9947: IFTRUE 9951
9949: GO 9961
9951: POP
// Wait ( 2 2$15 ) ; else
9952: LD_INT 4725
9954: PPUSH
9955: CALL_OW 67
9959: GO 9969
9961: POP
// Wait ( 2 2$30 ) ; end ;
9962: LD_INT 5250
9964: PPUSH
9965: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9969: LD_ADDR_LOC 9
9973: PUSH
9974: LD_INT 22
9976: PUSH
9977: LD_INT 3
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 43
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: PUSH
9992: LD_INT 23
9994: PUSH
9995: LD_INT 3
9997: PUSH
9998: LD_INT 1
10000: PUSH
10001: LD_INT 45
10003: PUSH
10004: EMPTY
10005: LIST
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_INT 21
10012: PUSH
10013: LD_INT 3
10015: PUSH
10016: LD_INT 1
10018: PUSH
10019: LD_INT 43
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: LIST
10026: LIST
10027: PUSH
10028: LD_INT 24
10030: PUSH
10031: LD_INT 3
10033: PUSH
10034: LD_INT 1
10036: PUSH
10037: LD_INT 45
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: LIST
10044: LIST
10045: PUSH
10046: LD_INT 21
10048: PUSH
10049: LD_INT 3
10051: PUSH
10052: LD_INT 1
10054: PUSH
10055: LD_INT 45
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: PUSH
10064: LD_INT 22
10066: PUSH
10067: LD_INT 3
10069: PUSH
10070: LD_INT 1
10072: PUSH
10073: LD_INT 44
10075: PUSH
10076: EMPTY
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: PUSH
10082: LD_INT 24
10084: PUSH
10085: LD_INT 3
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 46
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: PUSH
10100: LD_INT 23
10102: PUSH
10103: LD_INT 3
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 46
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: PUSH
10118: LD_INT 24
10120: PUSH
10121: LD_INT 3
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 46
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 23
10138: PUSH
10139: LD_INT 3
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 24
10156: PUSH
10157: LD_INT 3
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: LD_INT 49
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: PUSH
10172: LD_INT 23
10174: PUSH
10175: LD_INT 3
10177: PUSH
10178: LD_INT 1
10180: PUSH
10181: LD_INT 49
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: LIST
10203: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10204: LD_ADDR_VAR 0 1
10208: PUSH
10209: LD_INT 22
10211: PUSH
10212: LD_EXP 23
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 21
10223: PUSH
10224: LD_INT 2
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: ST_TO_ADDR
// if filter < 3 then
10240: LD_VAR 0 1
10244: PUSH
10245: LD_INT 3
10247: LESS
10248: IFFALSE 10258
// filter := 3 ;
10250: LD_ADDR_VAR 0 1
10254: PUSH
10255: LD_INT 3
10257: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10258: LD_INT 22
10260: PUSH
10261: LD_INT 3
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PUSH
10268: LD_INT 21
10270: PUSH
10271: LD_INT 2
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: PUSH
10278: LD_INT 50
10280: PUSH
10281: EMPTY
10282: LIST
10283: PUSH
10284: LD_INT 2
10286: PUSH
10287: LD_INT 34
10289: PUSH
10290: LD_INT 43
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: PUSH
10297: LD_INT 34
10299: PUSH
10300: LD_INT 45
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: PUSH
10307: LD_INT 34
10309: PUSH
10310: LD_INT 44
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PUSH
10317: LD_INT 34
10319: PUSH
10320: LD_INT 46
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 34
10329: PUSH
10330: LD_INT 47
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: LD_INT 34
10339: PUSH
10340: LD_INT 49
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: PPUSH
10362: CALL_OW 69
10366: PUSH
10367: LD_INT 6
10369: LESSEQUAL
10370: IFFALSE 10901
// for i := 1 to ( filter div 3 ) do
10372: LD_ADDR_VAR 0 2
10376: PUSH
10377: DOUBLE
10378: LD_INT 1
10380: DEC
10381: ST_TO_ADDR
10382: LD_VAR 0 1
10386: PUSH
10387: LD_INT 3
10389: DIV
10390: PUSH
10391: FOR_TO
10392: IFFALSE 10899
// begin uc_side := rus ;
10394: LD_ADDR_OWVAR 20
10398: PUSH
10399: LD_EXP 24
10403: ST_TO_ADDR
// uc_nation := nation_russian ;
10404: LD_ADDR_OWVAR 21
10408: PUSH
10409: LD_INT 3
10411: ST_TO_ADDR
// uc_direction := 5 ;
10412: LD_ADDR_OWVAR 24
10416: PUSH
10417: LD_INT 5
10419: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10420: LD_OWVAR 1
10424: PUSH
10425: LD_INT 60000
10427: LESS
10428: PUSH
10429: LD_INT 28
10431: PPUSH
10432: LD_EXP 23
10436: PPUSH
10437: CALL_OW 321
10441: PUSH
10442: LD_INT 2
10444: EQUAL
10445: OR
10446: IFFALSE 10472
// typ := rand ( 1 , vehicles - 2 ) else
10448: LD_ADDR_VAR 0 4
10452: PUSH
10453: LD_INT 1
10455: PPUSH
10456: LD_LOC 9
10460: PUSH
10461: LD_INT 2
10463: MINUS
10464: PPUSH
10465: CALL_OW 12
10469: ST_TO_ADDR
10470: GO 10490
// typ := rand ( 1 , vehicles ) ;
10472: LD_ADDR_VAR 0 4
10476: PUSH
10477: LD_INT 1
10479: PPUSH
10480: LD_LOC 9
10484: PPUSH
10485: CALL_OW 12
10489: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10490: LD_ADDR_OWVAR 37
10494: PUSH
10495: LD_LOC 9
10499: PUSH
10500: LD_VAR 0 4
10504: ARRAY
10505: PUSH
10506: LD_INT 1
10508: ARRAY
10509: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10510: LD_ADDR_OWVAR 38
10514: PUSH
10515: LD_LOC 9
10519: PUSH
10520: LD_VAR 0 4
10524: ARRAY
10525: PUSH
10526: LD_INT 2
10528: ARRAY
10529: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10530: LD_ADDR_OWVAR 39
10534: PUSH
10535: LD_LOC 9
10539: PUSH
10540: LD_VAR 0 4
10544: ARRAY
10545: PUSH
10546: LD_INT 3
10548: ARRAY
10549: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10550: LD_ADDR_OWVAR 40
10554: PUSH
10555: LD_LOC 9
10559: PUSH
10560: LD_VAR 0 4
10564: ARRAY
10565: PUSH
10566: LD_INT 4
10568: ARRAY
10569: ST_TO_ADDR
// auto := CreateVehicle ;
10570: LD_ADDR_VAR 0 5
10574: PUSH
10575: CALL_OW 45
10579: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10580: LD_VAR 0 5
10584: PPUSH
10585: LD_INT 9
10587: PPUSH
10588: LD_INT 0
10590: PPUSH
10591: CALL_OW 49
// attack := attack ^ auto ;
10595: LD_ADDR_LOC 10
10599: PUSH
10600: LD_LOC 10
10604: PUSH
10605: LD_VAR 0 5
10609: ADD
10610: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10611: LD_VAR 0 5
10615: PPUSH
10616: LD_INT 52
10618: PPUSH
10619: LD_INT 61
10621: PPUSH
10622: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10626: LD_VAR 0 5
10630: PPUSH
10631: LD_INT 52
10633: PPUSH
10634: LD_INT 61
10636: PPUSH
10637: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10641: LD_INT 1
10643: PPUSH
10644: LD_INT 2
10646: PPUSH
10647: CALL_OW 12
10651: PUSH
10652: LD_INT 1
10654: DOUBLE
10655: EQUAL
10656: IFTRUE 10660
10658: GO 10678
10660: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10661: LD_VAR 0 5
10665: PPUSH
10666: LD_INT 35
10668: PPUSH
10669: LD_INT 30
10671: PPUSH
10672: CALL_OW 174
10676: GO 10705
10678: LD_INT 2
10680: DOUBLE
10681: EQUAL
10682: IFTRUE 10686
10684: GO 10704
10686: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10687: LD_VAR 0 5
10691: PPUSH
10692: LD_INT 17
10694: PPUSH
10695: LD_INT 29
10697: PPUSH
10698: CALL_OW 174
10702: GO 10705
10704: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10705: LD_VAR 0 5
10709: PPUSH
10710: LD_INT 29
10712: PPUSH
10713: LD_INT 5
10715: PPUSH
10716: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10720: LD_INT 1
10722: PPUSH
10723: LD_INT 2
10725: PPUSH
10726: CALL_OW 12
10730: PUSH
10731: LD_INT 1
10733: DOUBLE
10734: EQUAL
10735: IFTRUE 10739
10737: GO 10757
10739: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10740: LD_VAR 0 5
10744: PPUSH
10745: LD_INT 60
10747: PPUSH
10748: LD_INT 30
10750: PPUSH
10751: CALL_OW 174
10755: GO 10784
10757: LD_INT 2
10759: DOUBLE
10760: EQUAL
10761: IFTRUE 10765
10763: GO 10783
10765: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10766: LD_VAR 0 5
10770: PPUSH
10771: LD_INT 84
10773: PPUSH
10774: LD_INT 30
10776: PPUSH
10777: CALL_OW 174
10781: GO 10784
10783: POP
// case Rand ( 1 , 2 ) of 1 :
10784: LD_INT 1
10786: PPUSH
10787: LD_INT 2
10789: PPUSH
10790: CALL_OW 12
10794: PUSH
10795: LD_INT 1
10797: DOUBLE
10798: EQUAL
10799: IFTRUE 10803
10801: GO 10821
10803: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10804: LD_VAR 0 5
10808: PPUSH
10809: LD_INT 71
10811: PPUSH
10812: LD_INT 59
10814: PPUSH
10815: CALL_OW 174
10819: GO 10848
10821: LD_INT 2
10823: DOUBLE
10824: EQUAL
10825: IFTRUE 10829
10827: GO 10847
10829: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10830: LD_VAR 0 5
10834: PPUSH
10835: LD_INT 92
10837: PPUSH
10838: LD_INT 66
10840: PPUSH
10841: CALL_OW 174
10845: GO 10848
10847: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10848: LD_VAR 0 5
10852: PPUSH
10853: LD_INT 78
10855: PPUSH
10856: LD_INT 88
10858: PPUSH
10859: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10863: LD_VAR 0 5
10867: PPUSH
10868: LD_INT 117
10870: PPUSH
10871: LD_INT 90
10873: PPUSH
10874: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10878: LD_VAR 0 5
10882: PPUSH
10883: LD_INT 15
10885: PPUSH
10886: CALL_OW 173
// Wait ( 0 0$4 ) ;
10890: LD_INT 140
10892: PPUSH
10893: CALL_OW 67
// end ;
10897: GO 10391
10899: POP
10900: POP
// enable ;
10901: ENABLE
// end ;
10902: PPOPN 7
10904: END
// export function PrepareInfantry ; var i , clovek ; begin
10905: LD_INT 0
10907: PPUSH
10908: PPUSH
10909: PPUSH
// for i = 1 to 6 do
10910: LD_ADDR_VAR 0 2
10914: PUSH
10915: DOUBLE
10916: LD_INT 1
10918: DEC
10919: ST_TO_ADDR
10920: LD_INT 6
10922: PUSH
10923: FOR_TO
10924: IFFALSE 11101
// begin uc_side = 3 ;
10926: LD_ADDR_OWVAR 20
10930: PUSH
10931: LD_INT 3
10933: ST_TO_ADDR
// uc_nation = 3 ;
10934: LD_ADDR_OWVAR 21
10938: PUSH
10939: LD_INT 3
10941: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10942: LD_INT 1
10944: PPUSH
10945: LD_INT 3
10947: PPUSH
10948: CALL_OW 12
10952: PUSH
10953: LD_INT 1
10955: DOUBLE
10956: EQUAL
10957: IFTRUE 10961
10959: GO 10991
10961: POP
// PrepareHuman ( sex_male , class_soldier , rand ( 3 , 5 + Difficulty ) ) ; 2 .. 3 :
10962: LD_INT 1
10964: PPUSH
10965: LD_INT 1
10967: PPUSH
10968: LD_INT 3
10970: PPUSH
10971: LD_INT 5
10973: PUSH
10974: LD_OWVAR 67
10978: PLUS
10979: PPUSH
10980: CALL_OW 12
10984: PPUSH
10985: CALL_OW 380
10989: GO 11036
10991: LD_INT 2
10993: DOUBLE
10994: GREATEREQUAL
10995: IFFALSE 11003
10997: LD_INT 3
10999: DOUBLE
11000: LESSEQUAL
11001: IFTRUE 11005
11003: GO 11035
11005: POP
// PrepareHuman ( sex_male , class_bazooker , rand ( 3 , 4 + Difficulty ) ) ; end ;
11006: LD_INT 1
11008: PPUSH
11009: LD_INT 9
11011: PPUSH
11012: LD_INT 3
11014: PPUSH
11015: LD_INT 4
11017: PUSH
11018: LD_OWVAR 67
11022: PLUS
11023: PPUSH
11024: CALL_OW 12
11028: PPUSH
11029: CALL_OW 380
11033: GO 11036
11035: POP
// hc_name :=  ;
11036: LD_ADDR_OWVAR 26
11040: PUSH
11041: LD_STRING 
11043: ST_TO_ADDR
// clovek := CreateHuman ;
11044: LD_ADDR_VAR 0 3
11048: PUSH
11049: CALL_OW 44
11053: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
11054: LD_VAR 0 3
11058: PPUSH
11059: LD_INT 9
11061: PPUSH
11062: LD_INT 0
11064: PPUSH
11065: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11069: LD_ADDR_EXP 59
11073: PUSH
11074: LD_EXP 59
11078: PUSH
11079: LD_INT 1
11081: MINUS
11082: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11083: LD_ADDR_EXP 60
11087: PUSH
11088: LD_EXP 60
11092: PUSH
11093: LD_VAR 0 3
11097: ADD
11098: ST_TO_ADDR
// end ;
11099: GO 10923
11101: POP
11102: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11103: LD_EXP 60
11107: PPUSH
11108: LD_INT 52
11110: PPUSH
11111: LD_INT 61
11113: PPUSH
11114: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11118: LD_INT 1
11120: PPUSH
11121: LD_INT 2
11123: PPUSH
11124: CALL_OW 12
11128: PUSH
11129: LD_INT 1
11131: DOUBLE
11132: EQUAL
11133: IFTRUE 11137
11135: GO 11155
11137: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11138: LD_EXP 60
11142: PPUSH
11143: LD_INT 35
11145: PPUSH
11146: LD_INT 30
11148: PPUSH
11149: CALL_OW 174
11153: GO 11182
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11181
11163: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11164: LD_EXP 60
11168: PPUSH
11169: LD_INT 17
11171: PPUSH
11172: LD_INT 29
11174: PPUSH
11175: CALL_OW 174
11179: GO 11182
11181: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11182: LD_EXP 60
11186: PPUSH
11187: LD_INT 29
11189: PPUSH
11190: LD_INT 5
11192: PPUSH
11193: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11197: LD_INT 1
11199: PPUSH
11200: LD_INT 2
11202: PPUSH
11203: CALL_OW 12
11207: PUSH
11208: LD_INT 1
11210: DOUBLE
11211: EQUAL
11212: IFTRUE 11216
11214: GO 11234
11216: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11217: LD_EXP 60
11221: PPUSH
11222: LD_INT 60
11224: PPUSH
11225: LD_INT 30
11227: PPUSH
11228: CALL_OW 174
11232: GO 11261
11234: LD_INT 2
11236: DOUBLE
11237: EQUAL
11238: IFTRUE 11242
11240: GO 11260
11242: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11243: LD_EXP 60
11247: PPUSH
11248: LD_INT 84
11250: PPUSH
11251: LD_INT 30
11253: PPUSH
11254: CALL_OW 174
11258: GO 11261
11260: POP
// case Rand ( 1 , 2 ) of 1 :
11261: LD_INT 1
11263: PPUSH
11264: LD_INT 2
11266: PPUSH
11267: CALL_OW 12
11271: PUSH
11272: LD_INT 1
11274: DOUBLE
11275: EQUAL
11276: IFTRUE 11280
11278: GO 11298
11280: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11281: LD_EXP 60
11285: PPUSH
11286: LD_INT 71
11288: PPUSH
11289: LD_INT 59
11291: PPUSH
11292: CALL_OW 174
11296: GO 11325
11298: LD_INT 2
11300: DOUBLE
11301: EQUAL
11302: IFTRUE 11306
11304: GO 11324
11306: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11307: LD_EXP 60
11311: PPUSH
11312: LD_INT 92
11314: PPUSH
11315: LD_INT 66
11317: PPUSH
11318: CALL_OW 174
11322: GO 11325
11324: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11325: LD_EXP 60
11329: PPUSH
11330: LD_INT 78
11332: PPUSH
11333: LD_INT 88
11335: PPUSH
11336: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11340: LD_EXP 60
11344: PPUSH
11345: LD_INT 117
11347: PPUSH
11348: LD_INT 90
11350: PPUSH
11351: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11355: LD_EXP 60
11359: PPUSH
11360: LD_INT 15
11362: PPUSH
11363: CALL_OW 173
// end ;
11367: LD_VAR 0 1
11371: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11372: LD_EXP 60
11376: PUSH
11377: EMPTY
11378: EQUAL
11379: PUSH
11380: LD_EXP 61
11384: PUSH
11385: LD_INT 1
11387: EQUAL
11388: AND
11389: IFFALSE 11399
11391: GO 11393
11393: DISABLE
// begin enable ;
11394: ENABLE
// PrepareInfantry ;
11395: CALL 10905 0 0
// end ;
11399: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11400: GO 11402
11402: DISABLE
11403: LD_INT 0
11405: PPUSH
11406: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11407: LD_ADDR_VAR 0 1
11411: PUSH
11412: LD_INT 15
11414: PPUSH
11415: LD_INT 22
11417: PUSH
11418: LD_EXP 24
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 50
11429: PUSH
11430: EMPTY
11431: LIST
11432: PUSH
11433: LD_INT 2
11435: PUSH
11436: LD_INT 21
11438: PUSH
11439: LD_INT 2
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: PUSH
11446: LD_INT 21
11448: PUSH
11449: LD_INT 1
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: LIST
11465: PPUSH
11466: CALL_OW 70
11470: ST_TO_ADDR
// case tick of 0 .. 30000 :
11471: LD_OWVAR 1
11475: PUSH
11476: LD_INT 0
11478: DOUBLE
11479: GREATEREQUAL
11480: IFFALSE 11488
11482: LD_INT 30000
11484: DOUBLE
11485: LESSEQUAL
11486: IFTRUE 11490
11488: GO 11507
11490: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11491: LD_ADDR_VAR 0 2
11495: PUSH
11496: LD_EXP 34
11500: PUSH
11501: LD_INT 4
11503: MINUS
11504: ST_TO_ADDR
11505: GO 11611
11507: LD_INT 30001
11509: DOUBLE
11510: GREATEREQUAL
11511: IFFALSE 11519
11513: LD_INT 50000
11515: DOUBLE
11516: LESSEQUAL
11517: IFTRUE 11521
11519: GO 11538
11521: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11522: LD_ADDR_VAR 0 2
11526: PUSH
11527: LD_EXP 34
11531: PUSH
11532: LD_INT 3
11534: MINUS
11535: ST_TO_ADDR
11536: GO 11611
11538: LD_INT 50001
11540: DOUBLE
11541: GREATEREQUAL
11542: IFFALSE 11550
11544: LD_INT 70000
11546: DOUBLE
11547: LESSEQUAL
11548: IFTRUE 11552
11550: GO 11569
11552: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11553: LD_ADDR_VAR 0 2
11557: PUSH
11558: LD_EXP 34
11562: PUSH
11563: LD_INT 2
11565: MINUS
11566: ST_TO_ADDR
11567: GO 11611
11569: LD_INT 70001
11571: DOUBLE
11572: GREATEREQUAL
11573: IFFALSE 11581
11575: LD_INT 90000
11577: DOUBLE
11578: LESSEQUAL
11579: IFTRUE 11583
11581: GO 11600
11583: POP
// mnozstvi := maxaut - 1 ; else
11584: LD_ADDR_VAR 0 2
11588: PUSH
11589: LD_EXP 34
11593: PUSH
11594: LD_INT 1
11596: MINUS
11597: ST_TO_ADDR
11598: GO 11611
11600: POP
// mnozstvi := maxaut ; end ;
11601: LD_ADDR_VAR 0 2
11605: PUSH
11606: LD_EXP 34
11610: ST_TO_ADDR
// if filter >= mnozstvi then
11611: LD_VAR 0 1
11615: PUSH
11616: LD_VAR 0 2
11620: GREATEREQUAL
11621: IFFALSE 11638
// ComMoveXY ( filter , 138 , 69 ) ;
11623: LD_VAR 0 1
11627: PPUSH
11628: LD_INT 138
11630: PPUSH
11631: LD_INT 69
11633: PPUSH
11634: CALL_OW 111
// enable ;
11638: ENABLE
// end ;
11639: PPOPN 2
11641: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11642: GO 11644
11644: DISABLE
11645: LD_INT 0
11647: PPUSH
11648: PPUSH
11649: PPUSH
11650: PPUSH
11651: PPUSH
11652: PPUSH
// begin enable ;
11653: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11654: LD_ADDR_VAR 0 1
11658: PUSH
11659: LD_INT 12
11661: PPUSH
11662: LD_INT 22
11664: PUSH
11665: LD_EXP 24
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 50
11676: PUSH
11677: EMPTY
11678: LIST
11679: PUSH
11680: LD_INT 3
11682: PUSH
11683: LD_INT 34
11685: PUSH
11686: LD_INT 49
11688: PUSH
11689: EMPTY
11690: LIST
11691: LIST
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: PPUSH
11702: CALL_OW 70
11706: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11707: LD_INT 33
11709: PPUSH
11710: LD_EXP 23
11714: PPUSH
11715: CALL_OW 321
11719: PUSH
11720: LD_INT 2
11722: EQUAL
11723: IFFALSE 11777
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11725: LD_ADDR_VAR 0 2
11729: PUSH
11730: LD_INT 12
11732: PPUSH
11733: LD_INT 22
11735: PUSH
11736: LD_EXP 23
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 4
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 101
11757: PUSH
11758: LD_EXP 24
11762: PUSH
11763: EMPTY
11764: LIST
11765: LIST
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: PPUSH
11772: CALL_OW 70
11776: ST_TO_ADDR
// if filter_you = 0 then
11777: LD_VAR 0 2
11781: PUSH
11782: LD_INT 0
11784: EQUAL
11785: IFFALSE 11894
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11787: LD_ADDR_VAR 0 2
11791: PUSH
11792: LD_INT 22
11794: PUSH
11795: LD_EXP 23
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: PUSH
11804: LD_INT 50
11806: PUSH
11807: EMPTY
11808: LIST
11809: PUSH
11810: LD_INT 2
11812: PUSH
11813: LD_INT 21
11815: PUSH
11816: LD_INT 1
11818: PUSH
11819: EMPTY
11820: LIST
11821: LIST
11822: PUSH
11823: LD_INT 21
11825: PUSH
11826: LD_INT 2
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: PUSH
11833: LD_INT 21
11835: PUSH
11836: LD_INT 3
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: ST_TO_ADDR
// if filter_you = 0 then
11859: LD_VAR 0 2
11863: PUSH
11864: LD_INT 0
11866: EQUAL
11867: IFFALSE 11894
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11869: LD_ADDR_VAR 0 2
11873: PUSH
11874: LD_INT 12
11876: PPUSH
11877: LD_INT 22
11879: PUSH
11880: LD_EXP 23
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PPUSH
11889: CALL_OW 70
11893: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11894: LD_VAR 0 1
11898: PUSH
11899: LD_INT 0
11901: GREATER
11902: PUSH
11903: LD_VAR 0 2
11907: PUSH
11908: LD_INT 0
11910: GREATER
11911: AND
11912: IFFALSE 12303
// begin for un_rus in filter_rus do
11914: LD_ADDR_VAR 0 3
11918: PUSH
11919: LD_VAR 0 1
11923: PUSH
11924: FOR_IN
11925: IFFALSE 12301
// begin Wait ( 5 ) ;
11927: LD_INT 5
11929: PPUSH
11930: CALL_OW 67
// min := 99999 ;
11934: LD_ADDR_VAR 0 5
11938: PUSH
11939: LD_INT 99999
11941: ST_TO_ADDR
// cil := 0 ;
11942: LD_ADDR_VAR 0 6
11946: PUSH
11947: LD_INT 0
11949: ST_TO_ADDR
// for un_you in filter_you do
11950: LD_ADDR_VAR 0 4
11954: PUSH
11955: LD_VAR 0 2
11959: PUSH
11960: FOR_IN
11961: IFFALSE 12157
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11963: LD_VAR 0 4
11967: PPUSH
11968: CALL_OW 320
11972: PUSH
11973: LD_VAR 0 4
11977: PPUSH
11978: CALL_OW 256
11982: PUSH
11983: LD_VAR 0 5
11987: LESS
11988: AND
11989: PUSH
11990: LD_VAR 0 3
11994: PPUSH
11995: LD_VAR 0 4
11999: PPUSH
12000: CALL_OW 296
12004: PUSH
12005: LD_INT 2
12007: PUSH
12008: LD_INT 2
12010: PUSH
12011: LD_INT 4
12013: PUSH
12014: LD_INT 6
12016: PUSH
12017: LD_INT 5
12019: PUSH
12020: LD_INT 9
12022: PUSH
12023: LD_INT 0
12025: PUSH
12026: LD_INT 2
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: PUSH
12039: LD_VAR 0 3
12043: PPUSH
12044: CALL_OW 264
12048: PUSH
12049: LD_INT 41
12051: MINUS
12052: ARRAY
12053: GREATEREQUAL
12054: AND
12055: PUSH
12056: LD_VAR 0 3
12060: PPUSH
12061: LD_VAR 0 4
12065: PPUSH
12066: CALL_OW 296
12070: PUSH
12071: LD_INT 15
12073: PUSH
12074: LD_INT 16
12076: PUSH
12077: LD_INT 17
12079: PUSH
12080: LD_INT 22
12082: PUSH
12083: LD_INT 20
12085: PUSH
12086: LD_INT 28
12088: PUSH
12089: LD_INT 0
12091: PUSH
12092: LD_INT 51
12094: PUSH
12095: EMPTY
12096: LIST
12097: LIST
12098: LIST
12099: LIST
12100: LIST
12101: LIST
12102: LIST
12103: LIST
12104: PUSH
12105: LD_VAR 0 3
12109: PPUSH
12110: CALL_OW 264
12114: PUSH
12115: LD_INT 41
12117: MINUS
12118: ARRAY
12119: LESSEQUAL
12120: AND
12121: IFFALSE 12148
// begin min := GetLives ( un_you ) ;
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_VAR 0 4
12132: PPUSH
12133: CALL_OW 256
12137: ST_TO_ADDR
// cil := un_you ;
12138: LD_ADDR_VAR 0 6
12142: PUSH
12143: LD_VAR 0 4
12147: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12148: LD_INT 5
12150: PPUSH
12151: CALL_OW 67
// end ;
12155: GO 11960
12157: POP
12158: POP
// if cil <> 0 then
12159: LD_VAR 0 6
12163: PUSH
12164: LD_INT 0
12166: NONEQUAL
12167: IFFALSE 12185
// ComAttackUnit ( un_rus , cil ) else
12169: LD_VAR 0 3
12173: PPUSH
12174: LD_VAR 0 6
12178: PPUSH
12179: CALL_OW 115
12183: GO 12299
// begin for un_you in filter_you do
12185: LD_ADDR_VAR 0 4
12189: PUSH
12190: LD_VAR 0 2
12194: PUSH
12195: FOR_IN
12196: IFFALSE 12283
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12198: LD_VAR 0 4
12202: PPUSH
12203: CALL_OW 266
12207: PUSH
12208: LD_INT 0
12210: PUSH
12211: LD_INT 1
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: IN
12218: IFFALSE 12232
// cil := un_you else
12220: LD_ADDR_VAR 0 6
12224: PUSH
12225: LD_VAR 0 4
12229: ST_TO_ADDR
12230: GO 12274
// if GetLives ( un_you ) < min then
12232: LD_VAR 0 4
12236: PPUSH
12237: CALL_OW 256
12241: PUSH
12242: LD_VAR 0 5
12246: LESS
12247: IFFALSE 12274
// begin min := GetLives ( un_you ) ;
12249: LD_ADDR_VAR 0 5
12253: PUSH
12254: LD_VAR 0 4
12258: PPUSH
12259: CALL_OW 256
12263: ST_TO_ADDR
// cil := un_you ;
12264: LD_ADDR_VAR 0 6
12268: PUSH
12269: LD_VAR 0 4
12273: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12274: LD_INT 5
12276: PPUSH
12277: CALL_OW 67
// end ;
12281: GO 12195
12283: POP
12284: POP
// ComAttackUnit ( un_rus , cil ) end ;
12285: LD_VAR 0 3
12289: PPUSH
12290: LD_VAR 0 6
12294: PPUSH
12295: CALL_OW 115
// end ;
12299: GO 11924
12301: POP
12302: POP
// end ; end ;
12303: PPOPN 6
12305: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12306: GO 12308
12308: DISABLE
12309: LD_INT 0
12311: PPUSH
12312: PPUSH
12313: PPUSH
12314: PPUSH
12315: PPUSH
12316: PPUSH
// begin enable ;
12317: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12318: LD_ADDR_VAR 0 1
12322: PUSH
12323: LD_INT 21
12325: PPUSH
12326: LD_INT 22
12328: PUSH
12329: LD_EXP 24
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 3
12340: PUSH
12341: LD_INT 2
12343: PUSH
12344: LD_INT 21
12346: PUSH
12347: LD_INT 3
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 34
12356: PUSH
12357: LD_INT 49
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 34
12366: PUSH
12367: LD_INT 51
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 25
12376: PUSH
12377: LD_INT 4
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 25
12386: PUSH
12387: LD_INT 2
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: LD_INT 54
12396: PUSH
12397: EMPTY
12398: LIST
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: LIST
12413: PPUSH
12414: CALL_OW 70
12418: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12419: LD_ADDR_VAR 0 1
12423: PUSH
12424: LD_VAR 0 1
12428: PUSH
12429: LD_EXP 45
12433: DIFF
12434: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12435: LD_ADDR_VAR 0 2
12439: PUSH
12440: LD_INT 21
12442: PPUSH
12443: LD_INT 22
12445: PUSH
12446: LD_EXP 23
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: LD_INT 21
12457: PUSH
12458: LD_INT 2
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PPUSH
12469: CALL_OW 70
12473: ST_TO_ADDR
// if not filter_you then
12474: LD_VAR 0 2
12478: NOT
12479: IFFALSE 12552
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12481: LD_ADDR_VAR 0 2
12485: PUSH
12486: LD_INT 21
12488: PPUSH
12489: LD_INT 22
12491: PUSH
12492: LD_EXP 23
12496: PUSH
12497: EMPTY
12498: LIST
12499: LIST
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 4
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: PUSH
12511: EMPTY
12512: LIST
12513: LIST
12514: PPUSH
12515: CALL_OW 70
12519: ST_TO_ADDR
// if not filter_you then
12520: LD_VAR 0 2
12524: NOT
12525: IFFALSE 12552
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12527: LD_ADDR_VAR 0 2
12531: PUSH
12532: LD_INT 21
12534: PPUSH
12535: LD_INT 22
12537: PUSH
12538: LD_EXP 23
12542: PUSH
12543: EMPTY
12544: LIST
12545: LIST
12546: PPUSH
12547: CALL_OW 70
12551: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12552: LD_VAR 0 1
12556: PUSH
12557: LD_INT 0
12559: GREATER
12560: PUSH
12561: LD_VAR 0 2
12565: PUSH
12566: LD_INT 0
12568: GREATER
12569: AND
12570: IFFALSE 12961
// begin for un_rus in filter_rus do
12572: LD_ADDR_VAR 0 3
12576: PUSH
12577: LD_VAR 0 1
12581: PUSH
12582: FOR_IN
12583: IFFALSE 12959
// begin Wait ( 5 ) ;
12585: LD_INT 5
12587: PPUSH
12588: CALL_OW 67
// min := 99999 ;
12592: LD_ADDR_VAR 0 5
12596: PUSH
12597: LD_INT 99999
12599: ST_TO_ADDR
// cil := 0 ;
12600: LD_ADDR_VAR 0 6
12604: PUSH
12605: LD_INT 0
12607: ST_TO_ADDR
// for un_you in filter_you do
12608: LD_ADDR_VAR 0 4
12612: PUSH
12613: LD_VAR 0 2
12617: PUSH
12618: FOR_IN
12619: IFFALSE 12815
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12621: LD_VAR 0 4
12625: PPUSH
12626: CALL_OW 302
12630: PUSH
12631: LD_VAR 0 4
12635: PPUSH
12636: CALL_OW 256
12640: PUSH
12641: LD_VAR 0 5
12645: LESS
12646: AND
12647: PUSH
12648: LD_VAR 0 3
12652: PPUSH
12653: LD_VAR 0 4
12657: PPUSH
12658: CALL_OW 296
12662: PUSH
12663: LD_INT 2
12665: PUSH
12666: LD_INT 2
12668: PUSH
12669: LD_INT 4
12671: PUSH
12672: LD_INT 6
12674: PUSH
12675: LD_INT 5
12677: PUSH
12678: LD_INT 9
12680: PUSH
12681: LD_INT 0
12683: PUSH
12684: LD_INT 2
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: LIST
12695: LIST
12696: PUSH
12697: LD_VAR 0 3
12701: PPUSH
12702: CALL_OW 264
12706: PUSH
12707: LD_INT 41
12709: MINUS
12710: ARRAY
12711: GREATEREQUAL
12712: AND
12713: PUSH
12714: LD_VAR 0 3
12718: PPUSH
12719: LD_VAR 0 4
12723: PPUSH
12724: CALL_OW 296
12728: PUSH
12729: LD_INT 15
12731: PUSH
12732: LD_INT 16
12734: PUSH
12735: LD_INT 17
12737: PUSH
12738: LD_INT 22
12740: PUSH
12741: LD_INT 20
12743: PUSH
12744: LD_INT 28
12746: PUSH
12747: LD_INT 0
12749: PUSH
12750: LD_INT 51
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: PUSH
12763: LD_VAR 0 3
12767: PPUSH
12768: CALL_OW 264
12772: PUSH
12773: LD_INT 41
12775: MINUS
12776: ARRAY
12777: LESSEQUAL
12778: AND
12779: IFFALSE 12806
// begin min := GetLives ( un_you ) ;
12781: LD_ADDR_VAR 0 5
12785: PUSH
12786: LD_VAR 0 4
12790: PPUSH
12791: CALL_OW 256
12795: ST_TO_ADDR
// cil := un_you ;
12796: LD_ADDR_VAR 0 6
12800: PUSH
12801: LD_VAR 0 4
12805: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12806: LD_INT 5
12808: PPUSH
12809: CALL_OW 67
// end ;
12813: GO 12618
12815: POP
12816: POP
// if cil <> 0 then
12817: LD_VAR 0 6
12821: PUSH
12822: LD_INT 0
12824: NONEQUAL
12825: IFFALSE 12843
// ComAttackUnit ( un_rus , cil ) else
12827: LD_VAR 0 3
12831: PPUSH
12832: LD_VAR 0 6
12836: PPUSH
12837: CALL_OW 115
12841: GO 12957
// begin for un_you in filter_you do
12843: LD_ADDR_VAR 0 4
12847: PUSH
12848: LD_VAR 0 2
12852: PUSH
12853: FOR_IN
12854: IFFALSE 12941
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12856: LD_VAR 0 4
12860: PPUSH
12861: CALL_OW 266
12865: PUSH
12866: LD_INT 0
12868: PUSH
12869: LD_INT 1
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: IN
12876: IFFALSE 12890
// cil := un_you else
12878: LD_ADDR_VAR 0 6
12882: PUSH
12883: LD_VAR 0 4
12887: ST_TO_ADDR
12888: GO 12932
// if GetLives ( un_you ) < min then
12890: LD_VAR 0 4
12894: PPUSH
12895: CALL_OW 256
12899: PUSH
12900: LD_VAR 0 5
12904: LESS
12905: IFFALSE 12932
// begin min := GetLives ( un_you ) ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: LD_VAR 0 4
12916: PPUSH
12917: CALL_OW 256
12921: ST_TO_ADDR
// cil := un_you ;
12922: LD_ADDR_VAR 0 6
12926: PUSH
12927: LD_VAR 0 4
12931: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12932: LD_INT 5
12934: PPUSH
12935: CALL_OW 67
// end ;
12939: GO 12853
12941: POP
12942: POP
// ComAttackUnit ( un_rus , cil ) end ;
12943: LD_VAR 0 3
12947: PPUSH
12948: LD_VAR 0 6
12952: PPUSH
12953: CALL_OW 115
// end ;
12957: GO 12582
12959: POP
12960: POP
// end ; end ;
12961: PPOPN 6
12963: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12964: GO 12966
12966: DISABLE
12967: LD_INT 0
12969: PPUSH
12970: PPUSH
12971: PPUSH
12972: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12973: LD_INT 28
12975: PPUSH
12976: LD_EXP 23
12980: PPUSH
12981: CALL_OW 321
12985: PUSH
12986: LD_INT 2
12988: EQUAL
12989: NOT
12990: IFFALSE 12993
// enable ;
12992: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
12993: LD_ADDR_VAR 0 1
12997: PUSH
12998: LD_INT 12
13000: PPUSH
13001: LD_INT 22
13003: PUSH
13004: LD_EXP 24
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: PUSH
13013: LD_INT 50
13015: PUSH
13016: EMPTY
13017: LIST
13018: PUSH
13019: LD_INT 34
13021: PUSH
13022: LD_INT 49
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: PPUSH
13034: CALL_OW 70
13038: ST_TO_ADDR
// if filter_rus > 0 then
13039: LD_VAR 0 1
13043: PUSH
13044: LD_INT 0
13046: GREATER
13047: IFFALSE 13088
// for un_rus in filter_rus do
13049: LD_ADDR_VAR 0 3
13053: PUSH
13054: LD_VAR 0 1
13058: PUSH
13059: FOR_IN
13060: IFFALSE 13086
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
13062: LD_VAR 0 3
13066: PPUSH
13067: LD_INT 122
13069: PPUSH
13070: LD_INT 27
13072: PPUSH
13073: CALL_OW 111
// Wait ( 5 ) ;
13077: LD_INT 5
13079: PPUSH
13080: CALL_OW 67
// end ;
13084: GO 13059
13086: POP
13087: POP
// end ;
13088: PPOPN 4
13090: END
// every 1 1$0 + 0 0$5.5 do
13091: GO 13093
13093: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13094: LD_INT 59
13096: PPUSH
13097: LD_EXP 24
13101: PPUSH
13102: CALL_OW 321
13106: PUSH
13107: LD_INT 2
13109: EQUAL
13110: NOT
13111: PUSH
13112: LD_OWVAR 1
13116: PUSH
13117: LD_EXP 54
13121: GREATEREQUAL
13122: AND
13123: IFFALSE 13140
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13125: LD_INT 59
13127: PPUSH
13128: LD_EXP 24
13132: PPUSH
13133: LD_INT 2
13135: PPUSH
13136: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13140: LD_INT 50
13142: PPUSH
13143: LD_EXP 24
13147: PPUSH
13148: CALL_OW 321
13152: PUSH
13153: LD_INT 2
13155: EQUAL
13156: NOT
13157: PUSH
13158: LD_OWVAR 1
13162: PUSH
13163: LD_EXP 55
13167: GREATEREQUAL
13168: AND
13169: IFFALSE 13186
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13171: LD_INT 50
13173: PPUSH
13174: LD_EXP 24
13178: PPUSH
13179: LD_INT 2
13181: PPUSH
13182: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13186: LD_INT 53
13188: PPUSH
13189: LD_EXP 24
13193: PPUSH
13194: CALL_OW 321
13198: PUSH
13199: LD_INT 2
13201: EQUAL
13202: NOT
13203: PUSH
13204: LD_OWVAR 1
13208: PUSH
13209: LD_EXP 56
13213: GREATEREQUAL
13214: AND
13215: IFFALSE 13232
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13217: LD_INT 53
13219: PPUSH
13220: LD_EXP 24
13224: PPUSH
13225: LD_INT 2
13227: PPUSH
13228: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13232: LD_INT 56
13234: PPUSH
13235: LD_EXP 24
13239: PPUSH
13240: CALL_OW 321
13244: PUSH
13245: LD_INT 2
13247: EQUAL
13248: NOT
13249: PUSH
13250: LD_OWVAR 1
13254: PUSH
13255: LD_EXP 57
13259: GREATEREQUAL
13260: AND
13261: IFFALSE 13278
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13263: LD_INT 56
13265: PPUSH
13266: LD_EXP 24
13270: PPUSH
13271: LD_INT 2
13273: PPUSH
13274: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13278: LD_INT 65
13280: PPUSH
13281: LD_EXP 24
13285: PPUSH
13286: CALL_OW 321
13290: PUSH
13291: LD_INT 2
13293: EQUAL
13294: NOT
13295: PUSH
13296: LD_OWVAR 1
13300: PUSH
13301: LD_EXP 58
13305: GREATEREQUAL
13306: AND
13307: IFFALSE 13324
// SetTech ( tech_ST3 , rus , state_researched ) ;
13309: LD_INT 65
13311: PPUSH
13312: LD_EXP 24
13316: PPUSH
13317: LD_INT 2
13319: PPUSH
13320: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13324: LD_INT 59
13326: PPUSH
13327: LD_EXP 24
13331: PPUSH
13332: CALL_OW 321
13336: PUSH
13337: LD_INT 2
13339: EQUAL
13340: PUSH
13341: LD_INT 50
13343: PPUSH
13344: LD_EXP 24
13348: PPUSH
13349: CALL_OW 321
13353: PUSH
13354: LD_INT 2
13356: EQUAL
13357: AND
13358: PUSH
13359: LD_INT 53
13361: PPUSH
13362: LD_EXP 24
13366: PPUSH
13367: CALL_OW 321
13371: PUSH
13372: LD_INT 2
13374: EQUAL
13375: AND
13376: PUSH
13377: LD_INT 56
13379: PPUSH
13380: LD_EXP 24
13384: PPUSH
13385: CALL_OW 321
13389: PUSH
13390: LD_INT 2
13392: EQUAL
13393: AND
13394: PUSH
13395: LD_INT 65
13397: PPUSH
13398: LD_EXP 24
13402: PPUSH
13403: CALL_OW 321
13407: PUSH
13408: LD_INT 2
13410: EQUAL
13411: AND
13412: NOT
13413: IFFALSE 13416
// enable ;
13415: ENABLE
// end ; end_of_file
13416: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13417: GO 13419
13419: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13420: LD_ADDR_EXP 63
13424: PUSH
13425: LD_INT 14
13427: PUSH
13428: LD_INT 18
13430: PUSH
13431: LD_INT 19
13433: PUSH
13434: LD_INT 20
13436: PUSH
13437: LD_INT 21
13439: PUSH
13440: LD_INT 22
13442: PUSH
13443: LD_INT 23
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13455: LD_ADDR_EXP 64
13459: PUSH
13460: LD_INT 22
13462: PUSH
13463: LD_EXP 24
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PUSH
13472: LD_INT 21
13474: PUSH
13475: LD_INT 3
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PPUSH
13486: CALL_OW 69
13490: PUSH
13491: LD_INT 14
13493: PUSH
13494: LD_INT 15
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: ADD
13501: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13502: LD_ADDR_EXP 65
13506: PUSH
13507: LD_INT 22
13509: PUSH
13510: LD_EXP 24
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: PUSH
13519: LD_INT 30
13521: PUSH
13522: LD_INT 1
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PPUSH
13533: CALL_OW 69
13537: PUSH
13538: LD_INT 1
13540: ARRAY
13541: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13542: LD_ADDR_EXP 66
13546: PUSH
13547: LD_INT 22
13549: PUSH
13550: LD_EXP 24
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 30
13561: PUSH
13562: LD_INT 8
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PPUSH
13573: CALL_OW 69
13577: PUSH
13578: LD_INT 1
13580: ARRAY
13581: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13582: LD_ADDR_EXP 67
13586: PUSH
13587: LD_INT 22
13589: PUSH
13590: LD_EXP 24
13594: PUSH
13595: EMPTY
13596: LIST
13597: LIST
13598: PUSH
13599: LD_INT 30
13601: PUSH
13602: LD_INT 31
13604: PUSH
13605: EMPTY
13606: LIST
13607: LIST
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 69
13617: PUSH
13618: LD_INT 1
13620: ARRAY
13621: ST_TO_ADDR
// enable ( 401 ) ;
13622: LD_INT 401
13624: ENABLE_MARKED
// end ;
13625: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13626: GO 13628
13628: DISABLE
13629: LD_INT 0
13631: PPUSH
13632: PPUSH
13633: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13634: LD_EXP 62
13638: PPUSH
13639: CALL_OW 386
13643: NOT
13644: IFFALSE 13699
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13646: LD_ADDR_EXP 62
13650: PUSH
13651: LD_INT 100
13653: PPUSH
13654: LD_EXP 63
13658: PPUSH
13659: LD_EXP 64
13663: PUSH
13664: LD_EXP 63
13668: ADD
13669: PPUSH
13670: LD_INT 1
13672: PUSH
13673: LD_INT 23
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PUSH
13680: LD_INT 10
13682: PUSH
13683: LD_INT 22
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: PPUSH
13694: CALL_OW 414
13698: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13699: LD_EXP 65
13703: PPUSH
13704: CALL_OW 300
13708: PUSH
13709: LD_EXP 66
13713: PPUSH
13714: CALL_OW 300
13718: OR
13719: PUSH
13720: LD_EXP 67
13724: PPUSH
13725: CALL_OW 300
13729: OR
13730: IFFALSE 13956
// begin for un in rus_mcrep_units do
13732: LD_ADDR_VAR 0 1
13736: PUSH
13737: LD_EXP 63
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13954
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL_OW 388
13754: PUSH
13755: LD_INT 0
13757: EQUAL
13758: PUSH
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 256
13768: PUSH
13769: LD_INT 1000
13771: EQUAL
13772: AND
13773: IFFALSE 13940
// case GetClass ( un ) of class_engineer :
13775: LD_VAR 0 1
13779: PPUSH
13780: CALL_OW 257
13784: PUSH
13785: LD_INT 2
13787: DOUBLE
13788: EQUAL
13789: IFTRUE 13793
13791: GO 13837
13793: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13794: LD_EXP 65
13798: PPUSH
13799: CALL_OW 300
13803: PUSH
13804: LD_EXP 65
13808: PPUSH
13809: CALL_OW 313
13813: PUSH
13814: LD_INT 6
13816: EQUAL
13817: NOT
13818: AND
13819: IFFALSE 13835
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13821: LD_VAR 0 1
13825: PPUSH
13826: LD_EXP 65
13830: PPUSH
13831: CALL_OW 120
13835: GO 13938
13837: LD_INT 4
13839: DOUBLE
13840: EQUAL
13841: IFTRUE 13845
13843: GO 13889
13845: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13846: LD_EXP 66
13850: PPUSH
13851: CALL_OW 300
13855: PUSH
13856: LD_EXP 66
13860: PPUSH
13861: CALL_OW 313
13865: PUSH
13866: LD_INT 6
13868: EQUAL
13869: NOT
13870: AND
13871: IFFALSE 13887
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13873: LD_VAR 0 1
13877: PPUSH
13878: LD_EXP 66
13882: PPUSH
13883: CALL_OW 120
13887: GO 13938
13889: LD_INT 1
13891: DOUBLE
13892: EQUAL
13893: IFTRUE 13897
13895: GO 13937
13897: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13898: LD_EXP 67
13902: PPUSH
13903: CALL_OW 300
13907: PUSH
13908: LD_EXP 67
13912: PPUSH
13913: CALL_OW 313
13917: NOT
13918: AND
13919: IFFALSE 13935
// ComEnterUnit ( un , rus_breastwork ) ; end else
13921: LD_VAR 0 1
13925: PPUSH
13926: LD_EXP 67
13930: PPUSH
13931: CALL_OW 120
13935: GO 13938
13937: POP
13938: GO 13952
// ComMoveToArea ( un , BluekherRepairArea ) ;
13940: LD_VAR 0 1
13944: PPUSH
13945: LD_INT 23
13947: PPUSH
13948: CALL_OW 113
13952: GO 13742
13954: POP
13955: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13956: LD_ADDR_VAR 0 3
13960: PUSH
13961: LD_INT 22
13963: PPUSH
13964: LD_INT 22
13966: PUSH
13967: LD_EXP 24
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: LD_INT 2
13978: PUSH
13979: LD_INT 25
13981: PUSH
13982: LD_INT 2
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: PUSH
13989: LD_INT 25
13991: PUSH
13992: LD_INT 4
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: EMPTY
14000: LIST
14001: LIST
14002: LIST
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PPUSH
14008: CALL_OW 71
14012: ST_TO_ADDR
// if filter then
14013: LD_VAR 0 3
14017: IFFALSE 14034
// ComMoveXY ( filter , 48 , 88 ) ;
14019: LD_VAR 0 3
14023: PPUSH
14024: LD_INT 48
14026: PPUSH
14027: LD_INT 88
14029: PPUSH
14030: CALL_OW 111
// enable ;
14034: ENABLE
// end ; end_of_file
14035: PPOPN 3
14037: END
// every 0 0$2 + 0 0$0.1 do
14038: GO 14040
14040: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
14041: LD_INT 22
14043: PUSH
14044: LD_INT 7
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: LD_INT 2
14053: PUSH
14054: LD_INT 25
14056: PUSH
14057: LD_INT 12
14059: PUSH
14060: EMPTY
14061: LIST
14062: LIST
14063: PUSH
14064: LD_INT 25
14066: PUSH
14067: LD_INT 16
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: PUSH
14074: LD_INT 25
14076: PUSH
14077: LD_INT 15
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: PUSH
14084: LD_INT 25
14086: PUSH
14087: LD_INT 17
14089: PUSH
14090: EMPTY
14091: LIST
14092: LIST
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: PUSH
14101: EMPTY
14102: LIST
14103: LIST
14104: PPUSH
14105: CALL_OW 69
14109: PUSH
14110: LD_INT 22
14112: PUSH
14113: LD_INT 7
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: PUSH
14120: LD_INT 21
14122: PUSH
14123: LD_INT 1
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: PUSH
14130: LD_INT 3
14132: PUSH
14133: LD_INT 2
14135: PUSH
14136: LD_INT 25
14138: PUSH
14139: LD_INT 12
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: LD_INT 25
14148: PUSH
14149: LD_INT 16
14151: PUSH
14152: EMPTY
14153: LIST
14154: LIST
14155: PUSH
14156: LD_INT 25
14158: PUSH
14159: LD_INT 15
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: PUSH
14166: LD_INT 25
14168: PUSH
14169: LD_INT 17
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: LIST
14180: LIST
14181: LIST
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: LIST
14191: PPUSH
14192: CALL_OW 69
14196: GREATER
14197: IFFALSE 14208
// begin SetAchievement ( ACH_POTA ) ;
14199: LD_STRING ACH_POTA
14201: PPUSH
14202: CALL_OW 543
// exit ;
14206: GO 14209
// end ; enable ;
14208: ENABLE
// end ; end_of_file
14209: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14210: LD_INT 0
14212: PPUSH
14213: PPUSH
// if not missionNumber then
14214: LD_VAR 0 2
14218: NOT
14219: IFFALSE 14223
// exit ;
14221: GO 14353
// achiv := false ;
14223: LD_ADDR_VAR 0 7
14227: PUSH
14228: LD_INT 0
14230: ST_TO_ADDR
// case campaignNumber of 1 :
14231: LD_VAR 0 1
14235: PUSH
14236: LD_INT 1
14238: DOUBLE
14239: EQUAL
14240: IFTRUE 14244
14242: GO 14255
14244: POP
// achiv := ACH_GOTA ; 2 :
14245: LD_ADDR_VAR 0 7
14249: PUSH
14250: LD_STRING ACH_GOTA
14252: ST_TO_ADDR
14253: GO 14305
14255: LD_INT 2
14257: DOUBLE
14258: EQUAL
14259: IFTRUE 14263
14261: GO 14266
14263: POP
// ; 3 :
14264: GO 14305
14266: LD_INT 3
14268: DOUBLE
14269: EQUAL
14270: IFTRUE 14274
14272: GO 14285
14274: POP
// achiv := ACH_MOTSU ; 4 :
14275: LD_ADDR_VAR 0 7
14279: PUSH
14280: LD_STRING ACH_MOTSU
14282: ST_TO_ADDR
14283: GO 14305
14285: LD_INT 4
14287: DOUBLE
14288: EQUAL
14289: IFTRUE 14293
14291: GO 14304
14293: POP
// achiv := ACH_LOP ; end ;
14294: LD_ADDR_VAR 0 7
14298: PUSH
14299: LD_STRING ACH_LOP
14301: ST_TO_ADDR
14302: GO 14305
14304: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14305: LD_OWVAR 67
14309: PUSH
14310: LD_INT 3
14312: EQUAL
14313: PUSH
14314: LD_VAR 0 7
14318: AND
14319: PUSH
14320: LD_VAR 0 3
14324: AND
14325: PUSH
14326: LD_VAR 0 4
14330: AND
14331: PUSH
14332: LD_VAR 0 5
14336: AND
14337: IFFALSE 14353
// SetAchievementEX ( achiv , missionNumber ) ;
14339: LD_VAR 0 7
14343: PPUSH
14344: LD_VAR 0 2
14348: PPUSH
14349: CALL_OW 564
// end ;
14353: LD_VAR 0 6
14357: RET
// export function SA_BehemothConstructed ; begin
14358: LD_INT 0
14360: PPUSH
// SetAchievement ( ACH_SMC ) ;
14361: LD_STRING ACH_SMC
14363: PPUSH
14364: CALL_OW 543
// end ;
14368: LD_VAR 0 1
14372: RET
