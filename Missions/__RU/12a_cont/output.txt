// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 3 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 3
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$45 , 0 0$40 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1575
 345: PUSH
 346: LD_INT 1400
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 4200
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// while scientists > 5 do
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1286
// scientists = Delete ( scientists , scientists + 0 ) ;
1260: LD_ADDR_EXP 40
1264: PUSH
1265: LD_EXP 40
1269: PPUSH
1270: LD_EXP 40
1274: PUSH
1275: LD_INT 0
1277: PLUS
1278: PPUSH
1279: CALL_OW 3
1283: ST_TO_ADDR
1284: GO 1250
// survivors3 = survivors3 diff scientists ;
1286: LD_ADDR_EXP 22
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 40
1300: DIFF
1301: ST_TO_ADDR
// if scientists < 5 then
1302: LD_EXP 40
1306: PUSH
1307: LD_INT 5
1309: LESS
1310: IFFALSE 1401
// for i := 1 to 5 - scientists do
1312: LD_ADDR_VAR 0 3
1316: PUSH
1317: DOUBLE
1318: LD_INT 1
1320: DEC
1321: ST_TO_ADDR
1322: LD_INT 5
1324: PUSH
1325: LD_EXP 40
1329: MINUS
1330: PUSH
1331: FOR_TO
1332: IFFALSE 1399
// begin uc_side = ally ;
1334: LD_ADDR_OWVAR 20
1338: PUSH
1339: LD_EXP 25
1343: ST_TO_ADDR
// uc_nation := nation_russian ;
1344: LD_ADDR_OWVAR 21
1348: PUSH
1349: LD_INT 3
1351: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1352: LD_INT 0
1354: PPUSH
1355: LD_INT 4
1357: PPUSH
1358: LD_INT 5
1360: PPUSH
1361: LD_INT 7
1363: PPUSH
1364: CALL_OW 12
1368: PPUSH
1369: CALL_OW 380
// hc_name :=  ;
1373: LD_ADDR_OWVAR 26
1377: PUSH
1378: LD_STRING 
1380: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1381: LD_ADDR_EXP 40
1385: PUSH
1386: LD_EXP 40
1390: PUSH
1391: CALL_OW 44
1395: ADD
1396: ST_TO_ADDR
// end ;
1397: GO 1331
1399: POP
1400: POP
// for un in scientists do
1401: LD_ADDR_VAR 0 2
1405: PUSH
1406: LD_EXP 40
1410: PUSH
1411: FOR_IN
1412: IFFALSE 1430
// SetSide ( un , ally ) ;
1414: LD_VAR 0 2
1418: PPUSH
1419: LD_EXP 25
1423: PPUSH
1424: CALL_OW 235
1428: GO 1411
1430: POP
1431: POP
// possible := all_possible diff scientists ;
1432: LD_ADDR_EXP 38
1436: PUSH
1437: LD_EXP 39
1441: PUSH
1442: LD_EXP 40
1446: DIFF
1447: ST_TO_ADDR
// if scientists > 5 then
1448: LD_EXP 40
1452: PUSH
1453: LD_INT 5
1455: GREATER
1456: IFFALSE 1500
// for i = scientists downto 5 do
1458: LD_ADDR_VAR 0 3
1462: PUSH
1463: DOUBLE
1464: LD_EXP 40
1468: INC
1469: ST_TO_ADDR
1470: LD_INT 5
1472: PUSH
1473: FOR_DOWNTO
1474: IFFALSE 1498
// scientists := Delete ( scientists , i ) ;
1476: LD_ADDR_EXP 40
1480: PUSH
1481: LD_EXP 40
1485: PPUSH
1486: LD_VAR 0 3
1490: PPUSH
1491: CALL_OW 3
1495: ST_TO_ADDR
1496: GO 1473
1498: POP
1499: POP
// for un in scientists do
1500: LD_ADDR_VAR 0 2
1504: PUSH
1505: LD_EXP 40
1509: PUSH
1510: FOR_IN
1511: IFFALSE 1527
// PlaceHumanInUnit ( un , 2 ) ;
1513: LD_VAR 0 2
1517: PPUSH
1518: LD_INT 2
1520: PPUSH
1521: CALL_OW 52
1525: GO 1510
1527: POP
1528: POP
// new := [ ] ;
1529: LD_ADDR_EXP 36
1533: PUSH
1534: EMPTY
1535: ST_TO_ADDR
// if possible < 10 then
1536: LD_EXP 38
1540: PUSH
1541: LD_INT 10
1543: LESS
1544: IFFALSE 1627
// for i := 1 to 10 - possible do
1546: LD_ADDR_VAR 0 3
1550: PUSH
1551: DOUBLE
1552: LD_INT 1
1554: DEC
1555: ST_TO_ADDR
1556: LD_INT 10
1558: PUSH
1559: LD_EXP 38
1563: MINUS
1564: PUSH
1565: FOR_TO
1566: IFFALSE 1625
// begin uc_side = rus ;
1568: LD_ADDR_OWVAR 20
1572: PUSH
1573: LD_EXP 24
1577: ST_TO_ADDR
// uc_nation := nation_russian ;
1578: LD_ADDR_OWVAR 21
1582: PUSH
1583: LD_INT 3
1585: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1586: LD_INT 0
1588: PPUSH
1589: LD_INT 0
1591: PPUSH
1592: LD_INT 5
1594: PPUSH
1595: CALL_OW 380
// hc_name :=  ;
1599: LD_ADDR_OWVAR 26
1603: PUSH
1604: LD_STRING 
1606: ST_TO_ADDR
// new := new ^ CreateHuman ;
1607: LD_ADDR_EXP 36
1611: PUSH
1612: LD_EXP 36
1616: PUSH
1617: CALL_OW 44
1621: ADD
1622: ST_TO_ADDR
// end ;
1623: GO 1565
1625: POP
1626: POP
// uc_side = rus ;
1627: LD_ADDR_OWVAR 20
1631: PUSH
1632: LD_EXP 24
1636: ST_TO_ADDR
// uc_nation := nation_russian ;
1637: LD_ADDR_OWVAR 21
1641: PUSH
1642: LD_INT 3
1644: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1645: LD_ADDR_EXP 1
1649: PUSH
1650: LD_STRING Burlak
1652: PPUSH
1653: CALL 565 0 1
1657: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1658: LD_EXP 1
1662: PPUSH
1663: LD_INT 3
1665: PPUSH
1666: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1670: LD_ADDR_EXP 20
1674: PUSH
1675: LD_STRING Platonov
1677: PPUSH
1678: CALL_OW 25
1682: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1683: LD_INT 1
1685: PPUSH
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 4
1691: PPUSH
1692: CALL_OW 380
// hc_name :=  ;
1696: LD_ADDR_OWVAR 26
1700: PUSH
1701: LD_STRING 
1703: ST_TO_ADDR
// RSoldier := CreateHuman ;
1704: LD_ADDR_EXP 21
1708: PUSH
1709: CALL_OW 44
1713: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1714: LD_ADDR_VAR 0 3
1718: PUSH
1719: DOUBLE
1720: LD_INT 1
1722: DEC
1723: ST_TO_ADDR
1724: LD_EXP 31
1728: PUSH
1729: LD_INT 3
1731: PUSH
1732: LD_EXP 30
1736: MUL
1737: PLUS
1738: PUSH
1739: FOR_TO
1740: IFFALSE 1832
// begin case Rand ( 1 , 2 ) of 1 :
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: CALL_OW 12
1752: PUSH
1753: LD_INT 1
1755: DOUBLE
1756: EQUAL
1757: IFTRUE 1761
1759: GO 1779
1761: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1762: LD_INT 1
1764: PPUSH
1765: LD_INT 1
1767: PPUSH
1768: LD_EXP 32
1772: PPUSH
1773: CALL_OW 380
1777: GO 1806
1779: LD_INT 2
1781: DOUBLE
1782: EQUAL
1783: IFTRUE 1787
1785: GO 1805
1787: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_EXP 32
1798: PPUSH
1799: CALL_OW 380
1803: GO 1806
1805: POP
// hc_name :=  ;
1806: LD_ADDR_OWVAR 26
1810: PUSH
1811: LD_STRING 
1813: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1814: LD_ADDR_EXP 29
1818: PUSH
1819: LD_EXP 29
1823: PUSH
1824: CALL_OW 44
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1739
1832: POP
1833: POP
// end ;
1834: LD_VAR 0 1
1838: RET
// function select_people ; var units , un ; begin
1839: LD_INT 0
1841: PPUSH
1842: PPUSH
1843: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1844: LD_ADDR_EXP 41
1848: PUSH
1849: LD_STRING 
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 5
1857: PPUSH
1858: LD_INT -1
1860: PUSH
1861: LD_INT -4
1863: PUSH
1864: LD_INT -6
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: PUSH
1872: LD_EXP 1
1876: ADD
1877: PUSH
1878: LD_INT -2
1880: PUSH
1881: LD_INT -4
1883: PUSH
1884: LD_INT -6
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: ADD
1892: PUSH
1893: LD_EXP 20
1897: ADD
1898: PUSH
1899: LD_INT -2
1901: PUSH
1902: LD_INT -5
1904: PUSH
1905: LD_INT -3
1907: PUSH
1908: EMPTY
1909: LIST
1910: LIST
1911: LIST
1912: ADD
1913: PUSH
1914: LD_EXP 38
1918: ADD
1919: PUSH
1920: LD_EXP 22
1924: ADD
1925: PUSH
1926: LD_EXP 36
1930: ADD
1931: PPUSH
1932: LD_INT 1
1934: PUSH
1935: LD_INT 3
1937: PUSH
1938: LD_INT 2
1940: PUSH
1941: LD_INT 4
1943: PUSH
1944: LD_INT 9
1946: PUSH
1947: LD_INT 0
1949: PUSH
1950: LD_INT 2
1952: PUSH
1953: EMPTY
1954: LIST
1955: LIST
1956: LIST
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: LIST
1964: PPUSH
1965: CALL_OW 42
1969: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1970: LD_EXP 41
1974: PUSH
1975: LD_EXP 1
1979: DIFF
1980: PPUSH
1981: LD_EXP 27
1985: PPUSH
1986: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1990: LD_ADDR_VAR 0 3
1994: PUSH
1995: LD_EXP 41
1999: PUSH
2000: LD_EXP 1
2004: DIFF
2005: PUSH
2006: FOR_IN
2007: IFFALSE 2026
// PlaceUnitArea ( un , BaseArea , false ) ;
2009: LD_VAR 0 3
2013: PPUSH
2014: LD_INT 2
2016: PPUSH
2017: LD_INT 0
2019: PPUSH
2020: CALL_OW 49
2024: GO 2006
2026: POP
2027: POP
// end ;
2028: LD_VAR 0 1
2032: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
2033: LD_INT 0
2035: PPUSH
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
2040: LD_ADDR_VAR 0 3
2044: PUSH
2045: LD_STRING EscapeVehicle_12a
2047: PPUSH
2048: LD_INT 1
2050: PUSH
2051: LD_INT 0
2053: PUSH
2054: LD_INT 0
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: LIST
2061: PPUSH
2062: CALL_OW 30
2066: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2067: LD_ADDR_LOC 1
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 1
2079: ARRAY
2080: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 3
2090: PUSH
2091: LD_INT 2
2093: ARRAY
2094: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 3
2104: PUSH
2105: LD_INT 3
2107: ARRAY
2108: ST_TO_ADDR
// if MashaWanted then
2109: LD_LOC 1
2113: IFFALSE 2317
// begin veh := LoadVariable ( Masha , false ) ;
2115: LD_ADDR_VAR 0 2
2119: PUSH
2120: LD_STRING Masha
2122: PPUSH
2123: LD_INT 0
2125: PPUSH
2126: CALL_OW 30
2130: ST_TO_ADDR
// if veh then
2131: LD_VAR 0 2
2135: IFFALSE 2239
// begin uc_side := rus ;
2137: LD_ADDR_OWVAR 20
2141: PUSH
2142: LD_EXP 24
2146: ST_TO_ADDR
// uc_nation := nation_russian ;
2147: LD_ADDR_OWVAR 21
2151: PUSH
2152: LD_INT 3
2154: ST_TO_ADDR
// uc_direction := 2 ;
2155: LD_ADDR_OWVAR 24
2159: PUSH
2160: LD_INT 2
2162: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2163: LD_ADDR_OWVAR 37
2167: PUSH
2168: LD_VAR 0 2
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_VAR 0 2
2186: PUSH
2187: LD_INT 2
2189: ARRAY
2190: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2191: LD_ADDR_OWVAR 38
2195: PUSH
2196: LD_VAR 0 2
2200: PUSH
2201: LD_INT 3
2203: ARRAY
2204: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2205: LD_ADDR_OWVAR 40
2209: PUSH
2210: LD_VAR 0 2
2214: PUSH
2215: LD_INT 4
2217: ARRAY
2218: ST_TO_ADDR
// RealMasha := true ;
2219: LD_ADDR_EXP 42
2223: PUSH
2224: LD_INT 1
2226: ST_TO_ADDR
// Masha := CreateVehicle ;
2227: LD_ADDR_EXP 43
2231: PUSH
2232: CALL_OW 45
2236: ST_TO_ADDR
// end else
2237: GO 2315
// begin uc_side := rus ;
2239: LD_ADDR_OWVAR 20
2243: PUSH
2244: LD_EXP 24
2248: ST_TO_ADDR
// uc_nation := nation_russian ;
2249: LD_ADDR_OWVAR 21
2253: PUSH
2254: LD_INT 3
2256: ST_TO_ADDR
// uc_direction := 2 ;
2257: LD_ADDR_OWVAR 24
2261: PUSH
2262: LD_INT 2
2264: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2265: LD_ADDR_OWVAR 37
2269: PUSH
2270: LD_INT 22
2272: ST_TO_ADDR
// vc_engine := engine_siberite ;
2273: LD_ADDR_OWVAR 39
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2281: LD_ADDR_OWVAR 40
2285: PUSH
2286: LD_INT 43
2288: ST_TO_ADDR
// vc_control := control_manual ;
2289: LD_ADDR_OWVAR 38
2293: PUSH
2294: LD_INT 1
2296: ST_TO_ADDR
// RealMasha := false ;
2297: LD_ADDR_EXP 42
2301: PUSH
2302: LD_INT 0
2304: ST_TO_ADDR
// Masha := CreateVehicle ;
2305: LD_ADDR_EXP 43
2309: PUSH
2310: CALL_OW 45
2314: ST_TO_ADDR
// end ; end else
2315: GO 2397
// begin uc_side := rus ;
2317: LD_ADDR_OWVAR 20
2321: PUSH
2322: LD_EXP 24
2326: ST_TO_ADDR
// uc_nation := nation_russian ;
2327: LD_ADDR_OWVAR 21
2331: PUSH
2332: LD_INT 3
2334: ST_TO_ADDR
// uc_direction := 2 ;
2335: LD_ADDR_OWVAR 24
2339: PUSH
2340: LD_INT 2
2342: ST_TO_ADDR
// vc_chassis := Chassis ;
2343: LD_ADDR_OWVAR 37
2347: PUSH
2348: LD_VAR 0 4
2352: ST_TO_ADDR
// vc_engine := engine_siberite ;
2353: LD_ADDR_OWVAR 39
2357: PUSH
2358: LD_INT 3
2360: ST_TO_ADDR
// vc_weapon := Weapon ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_VAR 0 5
2370: ST_TO_ADDR
// vc_control := control_manual ;
2371: LD_ADDR_OWVAR 38
2375: PUSH
2376: LD_INT 1
2378: ST_TO_ADDR
// RealMasha := false ;
2379: LD_ADDR_EXP 42
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// Masha := CreateVehicle ;
2387: LD_ADDR_EXP 43
2391: PUSH
2392: CALL_OW 45
2396: ST_TO_ADDR
// end ; SetMark ( Masha , 1 ) ;
2397: LD_EXP 43
2401: PPUSH
2402: LD_INT 1
2404: PPUSH
2405: CALL_OW 242
// if GetEngine ( Masha ) <> engine_siberite then
2409: LD_EXP 43
2413: PPUSH
2414: CALL_OW 262
2418: PUSH
2419: LD_INT 3
2421: NONEQUAL
2422: IFFALSE 2444
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2424: LD_EXP 43
2428: PPUSH
2429: LD_INT 70
2431: PPUSH
2432: LD_INT 95
2434: PPUSH
2435: CALL_OW 12
2439: PPUSH
2440: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2444: LD_EXP 43
2448: PPUSH
2449: LD_INT 47
2451: PPUSH
2452: LD_INT 87
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL_OW 48
// end ;
2462: LD_VAR 0 1
2466: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2467: LD_INT 1
2469: PPUSH
2470: LD_STRING bluekher
2472: PPUSH
2473: CALL_OW 500
// IngameOn ;
2477: CALL_OW 8
// Randomize ;
2481: CALL_OW 10
// RandomizeAll ;
2485: CALL_OW 11
// InitBc ;
2489: CALL_OW 21
// InitHc ;
2493: CALL_OW 19
// InitUc ;
2497: CALL_OW 18
// InitVc ;
2501: CALL_OW 20
// disable ( 1 ) ;
2505: LD_INT 1
2507: DISABLE_MARKED
// disable ( 2 ) ;
2508: LD_INT 2
2510: DISABLE_MARKED
// disable ( 3 ) ;
2511: LD_INT 3
2513: DISABLE_MARKED
// disable ( 4 ) ;
2514: LD_INT 4
2516: DISABLE_MARKED
// disable ( 6 ) ;
2517: LD_INT 6
2519: DISABLE_MARKED
// disable ( 7 ) ;
2520: LD_INT 7
2522: DISABLE_MARKED
// disable ( 8 ) ;
2523: LD_INT 8
2525: DISABLE_MARKED
// disable ( 9 ) ;
2526: LD_INT 9
2528: DISABLE_MARKED
// disable ( 333 ) ;
2529: LD_INT 333
2531: DISABLE_MARKED
// disable ( 337 ) ;
2532: LD_INT 337
2534: DISABLE_MARKED
// disable ( 401 ) ;
2535: LD_INT 401
2537: DISABLE_MARKED
// read_parameters ;
2538: CALL 0 0 0
// set_difficulty ;
2542: CALL 257 0 0
// create_people ;
2546: CALL 609 0 0
// select_people ;
2550: CALL 1839 0 0
// place_masha ;
2554: CALL 2033 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2558: LD_INT 53
2560: PPUSH
2561: LD_INT 90
2563: PPUSH
2564: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2568: LD_EXP 1
2572: PPUSH
2573: LD_INT 51
2575: PPUSH
2576: LD_INT 88
2578: PPUSH
2579: LD_INT 0
2581: PPUSH
2582: CALL_OW 48
// ComHold ( Burlak ) ;
2586: LD_EXP 1
2590: PPUSH
2591: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2595: LD_EXP 21
2599: PPUSH
2600: LD_INT 54
2602: PPUSH
2603: LD_INT 90
2605: PPUSH
2606: LD_INT 0
2608: PPUSH
2609: CALL_OW 48
// ComHold ( RSoldier ) ;
2613: LD_EXP 21
2617: PPUSH
2618: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2622: LD_EXP 1
2626: PPUSH
2627: LD_EXP 21
2631: PPUSH
2632: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2636: LD_EXP 21
2640: PPUSH
2641: LD_EXP 1
2645: PPUSH
2646: CALL_OW 119
// D_Platonov ;
2650: CALL 5300 0 0
// IngameOff ;
2654: CALL_OW 9
// SaveForQuickRestart ;
2658: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2662: LD_STRING MRun
2664: PPUSH
2665: CALL_OW 337
// ComMoveXY ( Burlak , 39 , 67 ) ;
2669: LD_EXP 1
2673: PPUSH
2674: LD_INT 39
2676: PPUSH
2677: LD_INT 67
2679: PPUSH
2680: CALL_OW 111
// ChangeSideFog ( you , you ) ;
2684: LD_EXP 23
2688: PPUSH
2689: LD_EXP 23
2693: PPUSH
2694: CALL_OW 343
// SetSide ( Burlak , you ) ;
2698: LD_EXP 1
2702: PPUSH
2703: LD_EXP 23
2707: PPUSH
2708: CALL_OW 235
// SetSide ( Masha , you ) ;
2712: LD_EXP 43
2716: PPUSH
2717: LD_EXP 23
2721: PPUSH
2722: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2726: LD_INT 1
2728: PPUSH
2729: LD_INT 2
2731: PPUSH
2732: CALL_OW 12
2736: PUSH
2737: LD_INT 1
2739: DOUBLE
2740: EQUAL
2741: IFTRUE 2745
2743: GO 2803
2745: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2746: LD_ADDR_LOC 2
2750: PUSH
2751: DOUBLE
2752: LD_EXP 31
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: DEC
2761: ST_TO_ADDR
2762: LD_EXP 31
2766: PUSH
2767: LD_EXP 30
2771: PLUS
2772: PUSH
2773: FOR_TO
2774: IFFALSE 2799
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2776: LD_EXP 29
2780: PUSH
2781: LD_LOC 2
2785: ARRAY
2786: PPUSH
2787: LD_INT 4
2789: PPUSH
2790: LD_INT 0
2792: PPUSH
2793: CALL_OW 49
2797: GO 2773
2799: POP
2800: POP
// end ; 2 :
2801: GO 2870
2803: LD_INT 2
2805: DOUBLE
2806: EQUAL
2807: IFTRUE 2811
2809: GO 2869
2811: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2812: LD_ADDR_LOC 2
2816: PUSH
2817: DOUBLE
2818: LD_EXP 31
2822: PUSH
2823: LD_INT 1
2825: PLUS
2826: DEC
2827: ST_TO_ADDR
2828: LD_EXP 31
2832: PUSH
2833: LD_EXP 30
2837: PLUS
2838: PUSH
2839: FOR_TO
2840: IFFALSE 2865
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2842: LD_EXP 29
2846: PUSH
2847: LD_LOC 2
2851: ARRAY
2852: PPUSH
2853: LD_INT 5
2855: PPUSH
2856: LD_INT 0
2858: PPUSH
2859: CALL_OW 49
2863: GO 2839
2865: POP
2866: POP
// end ; end ;
2867: GO 2870
2869: POP
// case Rand ( 1 , 2 ) of 1 :
2870: LD_INT 1
2872: PPUSH
2873: LD_INT 2
2875: PPUSH
2876: CALL_OW 12
2880: PUSH
2881: LD_INT 1
2883: DOUBLE
2884: EQUAL
2885: IFTRUE 2889
2887: GO 2957
2889: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2890: LD_ADDR_LOC 2
2894: PUSH
2895: DOUBLE
2896: LD_EXP 31
2900: PUSH
2901: LD_INT 1
2903: PLUS
2904: PUSH
2905: LD_EXP 30
2909: PLUS
2910: DEC
2911: ST_TO_ADDR
2912: LD_EXP 31
2916: PUSH
2917: LD_INT 2
2919: PUSH
2920: LD_EXP 30
2924: MUL
2925: PLUS
2926: PUSH
2927: FOR_TO
2928: IFFALSE 2953
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2930: LD_EXP 29
2934: PUSH
2935: LD_LOC 2
2939: ARRAY
2940: PPUSH
2941: LD_INT 8
2943: PPUSH
2944: LD_INT 0
2946: PPUSH
2947: CALL_OW 49
2951: GO 2927
2953: POP
2954: POP
// end ; 2 :
2955: GO 3034
2957: LD_INT 2
2959: DOUBLE
2960: EQUAL
2961: IFTRUE 2965
2963: GO 3033
2965: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2966: LD_ADDR_LOC 2
2970: PUSH
2971: DOUBLE
2972: LD_EXP 31
2976: PUSH
2977: LD_INT 1
2979: PLUS
2980: PUSH
2981: LD_EXP 30
2985: PLUS
2986: DEC
2987: ST_TO_ADDR
2988: LD_EXP 31
2992: PUSH
2993: LD_INT 2
2995: PUSH
2996: LD_EXP 30
3000: MUL
3001: PLUS
3002: PUSH
3003: FOR_TO
3004: IFFALSE 3029
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
3006: LD_EXP 29
3010: PUSH
3011: LD_LOC 2
3015: ARRAY
3016: PPUSH
3017: LD_INT 7
3019: PPUSH
3020: LD_INT 0
3022: PPUSH
3023: CALL_OW 49
3027: GO 3003
3029: POP
3030: POP
// end ; end ;
3031: GO 3034
3033: POP
// case Rand ( 1 , 2 ) of 1 :
3034: LD_INT 1
3036: PPUSH
3037: LD_INT 2
3039: PPUSH
3040: CALL_OW 12
3044: PUSH
3045: LD_INT 1
3047: DOUBLE
3048: EQUAL
3049: IFTRUE 3053
3051: GO 3125
3053: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3054: LD_ADDR_LOC 2
3058: PUSH
3059: DOUBLE
3060: LD_EXP 31
3064: PUSH
3065: LD_INT 1
3067: PLUS
3068: PUSH
3069: LD_INT 2
3071: PUSH
3072: LD_EXP 30
3076: MUL
3077: PLUS
3078: DEC
3079: ST_TO_ADDR
3080: LD_EXP 31
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_EXP 30
3092: MUL
3093: PLUS
3094: PUSH
3095: FOR_TO
3096: IFFALSE 3121
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3098: LD_EXP 29
3102: PUSH
3103: LD_LOC 2
3107: ARRAY
3108: PPUSH
3109: LD_INT 6
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 49
3119: GO 3095
3121: POP
3122: POP
// end ; 2 :
3123: GO 3206
3125: LD_INT 2
3127: DOUBLE
3128: EQUAL
3129: IFTRUE 3133
3131: GO 3205
3133: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3134: LD_ADDR_LOC 2
3138: PUSH
3139: DOUBLE
3140: LD_EXP 31
3144: PUSH
3145: LD_INT 1
3147: PLUS
3148: PUSH
3149: LD_INT 2
3151: PUSH
3152: LD_EXP 30
3156: MUL
3157: PLUS
3158: DEC
3159: ST_TO_ADDR
3160: LD_EXP 31
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_EXP 30
3172: MUL
3173: PLUS
3174: PUSH
3175: FOR_TO
3176: IFFALSE 3201
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3178: LD_EXP 29
3182: PUSH
3183: LD_LOC 2
3187: ARRAY
3188: PPUSH
3189: LD_INT 16
3191: PPUSH
3192: LD_INT 0
3194: PPUSH
3195: CALL_OW 49
3199: GO 3175
3201: POP
3202: POP
// end ; end ;
3203: GO 3206
3205: POP
// Wait ( 1 1$20 ) ;
3206: LD_INT 2800
3208: PPUSH
3209: CALL_OW 67
// for i := 1 to pursuers_base do
3213: LD_ADDR_LOC 2
3217: PUSH
3218: DOUBLE
3219: LD_INT 1
3221: DEC
3222: ST_TO_ADDR
3223: LD_EXP 31
3227: PUSH
3228: FOR_TO
3229: IFFALSE 3298
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3231: LD_EXP 29
3235: PUSH
3236: LD_LOC 2
3240: ARRAY
3241: PPUSH
3242: LD_INT 9
3244: PPUSH
3245: LD_INT 0
3247: PPUSH
3248: CALL_OW 49
3252: NOT
3253: IFFALSE 3276
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3255: LD_EXP 29
3259: PUSH
3260: LD_LOC 2
3264: ARRAY
3265: PPUSH
3266: LD_INT 3
3268: PPUSH
3269: LD_INT 0
3271: PPUSH
3272: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3276: LD_EXP 29
3280: PUSH
3281: LD_LOC 2
3285: ARRAY
3286: PPUSH
3287: LD_EXP 1
3291: PPUSH
3292: CALL_OW 115
// end ;
3296: GO 3228
3298: POP
3299: POP
// Wait ( straz_start ) ;
3300: LD_EXP 35
3304: PPUSH
3305: CALL_OW 67
// enable ( 1 ) ;
3309: LD_INT 1
3311: ENABLE_MARKED
// enable ( 2 ) ;
3312: LD_INT 2
3314: ENABLE_MARKED
// end ;
3315: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3316: LD_INT 0
3318: PPUSH
3319: PPUSH
3320: PPUSH
3321: PPUSH
3322: PPUSH
3323: PPUSH
3324: PPUSH
3325: PPUSH
3326: PPUSH
3327: PPUSH
3328: PPUSH
3329: PPUSH
3330: PPUSH
3331: PPUSH
3332: PPUSH
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
3341: PPUSH
// gained_medals := [ ] ;
3342: LD_ADDR_OWVAR 61
3346: PUSH
3347: EMPTY
3348: ST_TO_ADDR
// missing_medals := [ ] ;
3349: LD_ADDR_OWVAR 62
3353: PUSH
3354: EMPTY
3355: ST_TO_ADDR
// reward_units := [ ] ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: EMPTY
3362: ST_TO_ADDR
// if scientists_dead = 0 then
3363: LD_EXP 49
3367: PUSH
3368: LD_INT 0
3370: EQUAL
3371: IFFALSE 3385
// AddMedal ( Science , 1 ) else
3373: LD_STRING Science
3375: PPUSH
3376: LD_INT 1
3378: PPUSH
3379: CALL_OW 101
3383: GO 3396
// AddMedal ( Science , - 1 ) ;
3385: LD_STRING Science
3387: PPUSH
3388: LD_INT 1
3390: NEG
3391: PPUSH
3392: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3396: LD_ADDR_VAR 0 4
3400: PUSH
3401: LD_INT 22
3403: PUSH
3404: LD_EXP 23
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 30
3418: PUSH
3419: LD_INT 0
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 30
3428: PUSH
3429: LD_INT 1
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: ST_TO_ADDR
// matros := 0 ;
3450: LD_ADDR_VAR 0 2
3454: PUSH
3455: LD_INT 0
3457: ST_TO_ADDR
// if 0 + filter <> 0 then
3458: LD_INT 0
3460: PUSH
3461: LD_VAR 0 4
3465: PLUS
3466: PUSH
3467: LD_INT 0
3469: NONEQUAL
3470: IFFALSE 3518
// for un in filter do
3472: LD_ADDR_VAR 0 3
3476: PUSH
3477: LD_VAR 0 4
3481: PUSH
3482: FOR_IN
3483: IFFALSE 3516
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3485: LD_ADDR_VAR 0 2
3489: PUSH
3490: LD_VAR 0 2
3494: PUSH
3495: LD_VAR 0 3
3499: PPUSH
3500: CALL_OW 274
3504: PPUSH
3505: LD_INT 1
3507: PPUSH
3508: CALL_OW 275
3512: PLUS
3513: ST_TO_ADDR
3514: GO 3482
3516: POP
3517: POP
// if matros > 100 then
3518: LD_VAR 0 2
3522: PUSH
3523: LD_INT 100
3525: GREATER
3526: IFFALSE 3540
// AddMedal ( Effectivity , 1 ) else
3528: LD_STRING Effectivity
3530: PPUSH
3531: LD_INT 1
3533: PPUSH
3534: CALL_OW 101
3538: GO 3551
// AddMedal ( Effectivity , - 1 ) ;
3540: LD_STRING Effectivity
3542: PPUSH
3543: LD_INT 1
3545: NEG
3546: PPUSH
3547: CALL_OW 101
// rus_building_destroyed := false ;
3551: LD_ADDR_VAR 0 7
3555: PUSH
3556: LD_INT 0
3558: ST_TO_ADDR
// for un in rus_mcrep_bui do
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: LD_EXP 64
3568: PUSH
3569: FOR_IN
3570: IFFALSE 3600
// if not IsLive ( un ) then
3572: LD_VAR 0 3
3576: PPUSH
3577: CALL_OW 300
3581: NOT
3582: IFFALSE 3598
// rus_building_destroyed := rus_building_destroyed + 1 ;
3584: LD_ADDR_VAR 0 7
3588: PUSH
3589: LD_VAR 0 7
3593: PUSH
3594: LD_INT 1
3596: PLUS
3597: ST_TO_ADDR
3598: GO 3569
3600: POP
3601: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3602: LD_EXP 53
3606: PUSH
3607: LD_INT 5
3609: GREATEREQUAL
3610: PUSH
3611: LD_VAR 0 7
3615: PUSH
3616: LD_INT 2
3618: GREATEREQUAL
3619: OR
3620: IFFALSE 3635
// AddMedal ( LittleLosses , - 1 ) else
3622: LD_STRING LittleLosses
3624: PPUSH
3625: LD_INT 1
3627: NEG
3628: PPUSH
3629: CALL_OW 101
3633: GO 3645
// AddMedal ( LittleLosses , 1 ) ;
3635: LD_STRING LittleLosses
3637: PPUSH
3638: LD_INT 1
3640: PPUSH
3641: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , killed_russians >= 5 or rus_building_destroyed >= 2 ) ;
3645: LD_INT 4
3647: PPUSH
3648: LD_INT 5
3650: PPUSH
3651: LD_EXP 49
3655: PUSH
3656: LD_INT 0
3658: EQUAL
3659: PPUSH
3660: LD_VAR 0 2
3664: PUSH
3665: LD_INT 100
3667: GREATER
3668: PPUSH
3669: LD_EXP 53
3673: PUSH
3674: LD_INT 5
3676: GREATEREQUAL
3677: PUSH
3678: LD_VAR 0 7
3682: PUSH
3683: LD_INT 2
3685: GREATEREQUAL
3686: OR
3687: PPUSH
3688: CALL 14209 0 5
// GiveMedals ( Main ) ;
3692: LD_STRING Main
3694: PPUSH
3695: CALL_OW 102
// for un in player_units do
3699: LD_ADDR_VAR 0 3
3703: PUSH
3704: LD_EXP 41
3708: PUSH
3709: FOR_IN
3710: IFFALSE 3742
// if not IsDead ( un ) then
3712: LD_VAR 0 3
3716: PPUSH
3717: CALL_OW 301
3721: NOT
3722: IFFALSE 3740
// reward_units := reward_units ^ un ;
3724: LD_ADDR_VAR 0 5
3728: PUSH
3729: LD_VAR 0 5
3733: PUSH
3734: LD_VAR 0 3
3738: ADD
3739: ST_TO_ADDR
3740: GO 3709
3742: POP
3743: POP
// RewardPeople ( reward_units ) ;
3744: LD_VAR 0 5
3748: PPUSH
3749: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3753: LD_EXP 40
3757: PUSH
3758: LD_EXP 39
3762: PUSH
3763: LD_EXP 8
3767: ADD
3768: DIFF
3769: PPUSH
3770: LD_STRING scientists
3772: PPUSH
3773: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3777: LD_ADDR_VAR 0 6
3781: PUSH
3782: LD_EXP 41
3786: PUSH
3787: LD_EXP 39
3791: PUSH
3792: LD_EXP 40
3796: ADD
3797: PUSH
3798: LD_EXP 1
3802: ADD
3803: PUSH
3804: LD_EXP 8
3808: ADD
3809: DIFF
3810: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3811: LD_VAR 0 6
3815: PPUSH
3816: LD_STRING survivors5
3818: PPUSH
3819: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3823: LD_EXP 1
3827: PPUSH
3828: LD_STRING Burlak
3830: PPUSH
3831: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3835: LD_EXP 2
3839: PPUSH
3840: LD_STRING Belkov
3842: PPUSH
3843: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3847: LD_EXP 3
3851: PPUSH
3852: LD_STRING Gnyevko
3854: PPUSH
3855: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3859: LD_EXP 4
3863: PPUSH
3864: LD_STRING Kirilenkova
3866: PPUSH
3867: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3871: LD_EXP 5
3875: PPUSH
3876: LD_STRING Gleb
3878: PPUSH
3879: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3883: LD_EXP 6
3887: PPUSH
3888: LD_STRING Petrosyan
3890: PPUSH
3891: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3895: LD_EXP 7
3899: PPUSH
3900: LD_STRING Titov
3902: PPUSH
3903: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3907: LD_EXP 8
3911: PPUSH
3912: LD_STRING Gossudarov
3914: PPUSH
3915: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3919: LD_EXP 9
3923: PPUSH
3924: LD_STRING Kovalyuk
3926: PPUSH
3927: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3931: LD_EXP 10
3935: PPUSH
3936: LD_STRING Scholtze
3938: PPUSH
3939: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3943: LD_EXP 11
3947: PPUSH
3948: LD_STRING Kuzmov
3950: PPUSH
3951: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3955: LD_EXP 12
3959: PPUSH
3960: LD_STRING Karamazov
3962: PPUSH
3963: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3967: LD_EXP 13
3971: PPUSH
3972: LD_STRING Petrovova
3974: PPUSH
3975: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3979: LD_EXP 14
3983: PPUSH
3984: LD_STRING Lipshchin
3986: PPUSH
3987: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3991: LD_EXP 15
3995: PPUSH
3996: LD_STRING Dolgov
3998: PPUSH
3999: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4003: LD_EXP 16
4007: PPUSH
4008: LD_STRING Xavier
4010: PPUSH
4011: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4015: LD_EXP 17
4019: PPUSH
4020: LD_STRING Oblukov
4022: PPUSH
4023: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4027: LD_EXP 18
4031: PPUSH
4032: LD_STRING Kozlov
4034: PPUSH
4035: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4039: LD_EXP 19
4043: PPUSH
4044: LD_STRING Kapitsova
4046: PPUSH
4047: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
4051: LD_EXP 42
4055: PUSH
4056: LD_EXP 52
4060: AND
4061: PUSH
4062: LD_LOC 1
4066: NOT
4067: OR
4068: IFFALSE 4077
// DeleteVariable ( Masha ) ;
4070: LD_STRING Masha
4072: PPUSH
4073: CALL_OW 41
// if Belkov in scientists then
4077: LD_EXP 2
4081: PUSH
4082: LD_EXP 40
4086: IN
4087: IFFALSE 4099
// belkov_side := 2 else
4089: LD_ADDR_VAR 0 8
4093: PUSH
4094: LD_INT 2
4096: ST_TO_ADDR
4097: GO 4129
// if Belkov in player_units then
4099: LD_EXP 2
4103: PUSH
4104: LD_EXP 41
4108: IN
4109: IFFALSE 4121
// belkov_side := 1 else
4111: LD_ADDR_VAR 0 8
4115: PUSH
4116: LD_INT 1
4118: ST_TO_ADDR
4119: GO 4129
// belkov_side := 0 ;
4121: LD_ADDR_VAR 0 8
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// if Gnyevko in scientists then
4129: LD_EXP 3
4133: PUSH
4134: LD_EXP 40
4138: IN
4139: IFFALSE 4151
// gnyevko_side := 2 else
4141: LD_ADDR_VAR 0 9
4145: PUSH
4146: LD_INT 2
4148: ST_TO_ADDR
4149: GO 4181
// if Gnyevko in player_units then
4151: LD_EXP 3
4155: PUSH
4156: LD_EXP 41
4160: IN
4161: IFFALSE 4173
// gnyevko_side := 1 else
4163: LD_ADDR_VAR 0 9
4167: PUSH
4168: LD_INT 1
4170: ST_TO_ADDR
4171: GO 4181
// gnyevko_side := 0 ;
4173: LD_ADDR_VAR 0 9
4177: PUSH
4178: LD_INT 0
4180: ST_TO_ADDR
// if Kirilenkova in scientists then
4181: LD_EXP 4
4185: PUSH
4186: LD_EXP 40
4190: IN
4191: IFFALSE 4203
// kiril_side := 2 else
4193: LD_ADDR_VAR 0 10
4197: PUSH
4198: LD_INT 2
4200: ST_TO_ADDR
4201: GO 4233
// if Kirilenkova in player_units then
4203: LD_EXP 4
4207: PUSH
4208: LD_EXP 41
4212: IN
4213: IFFALSE 4225
// kiril_side := 1 else
4215: LD_ADDR_VAR 0 10
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
4223: GO 4233
// kiril_side := 0 ;
4225: LD_ADDR_VAR 0 10
4229: PUSH
4230: LD_INT 0
4232: ST_TO_ADDR
// if Gleb in scientists then
4233: LD_EXP 5
4237: PUSH
4238: LD_EXP 40
4242: IN
4243: IFFALSE 4255
// gleb_side := 2 else
4245: LD_ADDR_VAR 0 16
4249: PUSH
4250: LD_INT 2
4252: ST_TO_ADDR
4253: GO 4285
// if Gleb in player_units then
4255: LD_EXP 5
4259: PUSH
4260: LD_EXP 41
4264: IN
4265: IFFALSE 4277
// gleb_side := 1 else
4267: LD_ADDR_VAR 0 16
4271: PUSH
4272: LD_INT 1
4274: ST_TO_ADDR
4275: GO 4285
// gleb_side := 0 ;
4277: LD_ADDR_VAR 0 16
4281: PUSH
4282: LD_INT 0
4284: ST_TO_ADDR
// if Petrosyan in scientists then
4285: LD_EXP 6
4289: PUSH
4290: LD_EXP 40
4294: IN
4295: IFFALSE 4307
// petros_side := 2 else
4297: LD_ADDR_VAR 0 15
4301: PUSH
4302: LD_INT 2
4304: ST_TO_ADDR
4305: GO 4337
// if Petrosyan in player_units then
4307: LD_EXP 6
4311: PUSH
4312: LD_EXP 41
4316: IN
4317: IFFALSE 4329
// petros_side := 1 else
4319: LD_ADDR_VAR 0 15
4323: PUSH
4324: LD_INT 1
4326: ST_TO_ADDR
4327: GO 4337
// petros_side := 0 ;
4329: LD_ADDR_VAR 0 15
4333: PUSH
4334: LD_INT 0
4336: ST_TO_ADDR
// if Titov in scientists then
4337: LD_EXP 7
4341: PUSH
4342: LD_EXP 40
4346: IN
4347: IFFALSE 4359
// titov_side := 2 else
4349: LD_ADDR_VAR 0 19
4353: PUSH
4354: LD_INT 2
4356: ST_TO_ADDR
4357: GO 4389
// if Titov in player_units then
4359: LD_EXP 7
4363: PUSH
4364: LD_EXP 41
4368: IN
4369: IFFALSE 4381
// titov_side := 1 else
4371: LD_ADDR_VAR 0 19
4375: PUSH
4376: LD_INT 1
4378: ST_TO_ADDR
4379: GO 4389
// titov_side := 0 ;
4381: LD_ADDR_VAR 0 19
4385: PUSH
4386: LD_INT 0
4388: ST_TO_ADDR
// if Kovalyuk in scientists then
4389: LD_EXP 9
4393: PUSH
4394: LD_EXP 40
4398: IN
4399: IFFALSE 4411
// kovalyuk_side := 2 else
4401: LD_ADDR_VAR 0 11
4405: PUSH
4406: LD_INT 2
4408: ST_TO_ADDR
4409: GO 4441
// if Kovalyuk in player_units then
4411: LD_EXP 9
4415: PUSH
4416: LD_EXP 41
4420: IN
4421: IFFALSE 4433
// kovalyuk_side := 1 else
4423: LD_ADDR_VAR 0 11
4427: PUSH
4428: LD_INT 1
4430: ST_TO_ADDR
4431: GO 4441
// kovalyuk_side := 0 ;
4433: LD_ADDR_VAR 0 11
4437: PUSH
4438: LD_INT 0
4440: ST_TO_ADDR
// if Scholtze in scientists then
4441: LD_EXP 10
4445: PUSH
4446: LD_EXP 40
4450: IN
4451: IFFALSE 4463
// scholtze_side := 2 else
4453: LD_ADDR_VAR 0 12
4457: PUSH
4458: LD_INT 2
4460: ST_TO_ADDR
4461: GO 4493
// if Scholtze in player_units then
4463: LD_EXP 10
4467: PUSH
4468: LD_EXP 41
4472: IN
4473: IFFALSE 4485
// scholtze_side := 1 else
4475: LD_ADDR_VAR 0 12
4479: PUSH
4480: LD_INT 1
4482: ST_TO_ADDR
4483: GO 4493
// scholtze_side := 0 ;
4485: LD_ADDR_VAR 0 12
4489: PUSH
4490: LD_INT 0
4492: ST_TO_ADDR
// if Kuzmov in scientists then
4493: LD_EXP 11
4497: PUSH
4498: LD_EXP 40
4502: IN
4503: IFFALSE 4515
// kuzmov_side := 2 else
4505: LD_ADDR_VAR 0 13
4509: PUSH
4510: LD_INT 2
4512: ST_TO_ADDR
4513: GO 4545
// if Kuzmov in player_units then
4515: LD_EXP 11
4519: PUSH
4520: LD_EXP 41
4524: IN
4525: IFFALSE 4537
// kuzmov_side := 1 else
4527: LD_ADDR_VAR 0 13
4531: PUSH
4532: LD_INT 1
4534: ST_TO_ADDR
4535: GO 4545
// kuzmov_side := 0 ;
4537: LD_ADDR_VAR 0 13
4541: PUSH
4542: LD_INT 0
4544: ST_TO_ADDR
// if Karamazov in scientists then
4545: LD_EXP 12
4549: PUSH
4550: LD_EXP 40
4554: IN
4555: IFFALSE 4567
// karam_side := 2 else
4557: LD_ADDR_VAR 0 14
4561: PUSH
4562: LD_INT 2
4564: ST_TO_ADDR
4565: GO 4597
// if Karamazov in player_units then
4567: LD_EXP 12
4571: PUSH
4572: LD_EXP 41
4576: IN
4577: IFFALSE 4589
// karam_side := 1 else
4579: LD_ADDR_VAR 0 14
4583: PUSH
4584: LD_INT 1
4586: ST_TO_ADDR
4587: GO 4597
// karam_side := 0 ;
4589: LD_ADDR_VAR 0 14
4593: PUSH
4594: LD_INT 0
4596: ST_TO_ADDR
// if Petrovova in scientists then
4597: LD_EXP 13
4601: PUSH
4602: LD_EXP 40
4606: IN
4607: IFFALSE 4619
// petrov_side := 2 else
4609: LD_ADDR_VAR 0 17
4613: PUSH
4614: LD_INT 2
4616: ST_TO_ADDR
4617: GO 4649
// if Petrovova in player_units then
4619: LD_EXP 13
4623: PUSH
4624: LD_EXP 41
4628: IN
4629: IFFALSE 4641
// petrov_side := 1 else
4631: LD_ADDR_VAR 0 17
4635: PUSH
4636: LD_INT 1
4638: ST_TO_ADDR
4639: GO 4649
// petrov_side := 0 ;
4641: LD_ADDR_VAR 0 17
4645: PUSH
4646: LD_INT 0
4648: ST_TO_ADDR
// if Lipshchin in scientists then
4649: LD_EXP 14
4653: PUSH
4654: LD_EXP 40
4658: IN
4659: IFFALSE 4671
// lipshchin_side := 2 else
4661: LD_ADDR_VAR 0 18
4665: PUSH
4666: LD_INT 2
4668: ST_TO_ADDR
4669: GO 4701
// if Lipshchin in player_units then
4671: LD_EXP 14
4675: PUSH
4676: LD_EXP 41
4680: IN
4681: IFFALSE 4693
// lipshchin_side := 1 else
4683: LD_ADDR_VAR 0 18
4687: PUSH
4688: LD_INT 1
4690: ST_TO_ADDR
4691: GO 4701
// lipshchin_side := 0 ;
4693: LD_ADDR_VAR 0 18
4697: PUSH
4698: LD_INT 0
4700: ST_TO_ADDR
// if Dolgov in scientists then
4701: LD_EXP 15
4705: PUSH
4706: LD_EXP 40
4710: IN
4711: IFFALSE 4723
// dolgov_side := 2 else
4713: LD_ADDR_VAR 0 20
4717: PUSH
4718: LD_INT 2
4720: ST_TO_ADDR
4721: GO 4753
// if Dolgov in player_units then
4723: LD_EXP 15
4727: PUSH
4728: LD_EXP 41
4732: IN
4733: IFFALSE 4745
// dolgov_side := 1 else
4735: LD_ADDR_VAR 0 20
4739: PUSH
4740: LD_INT 1
4742: ST_TO_ADDR
4743: GO 4753
// dolgov_side := 0 ;
4745: LD_ADDR_VAR 0 20
4749: PUSH
4750: LD_INT 0
4752: ST_TO_ADDR
// if Xavier in scientists then
4753: LD_EXP 16
4757: PUSH
4758: LD_EXP 40
4762: IN
4763: IFFALSE 4775
// xavier_side := 2 else
4765: LD_ADDR_VAR 0 21
4769: PUSH
4770: LD_INT 2
4772: ST_TO_ADDR
4773: GO 4805
// if Xavier in player_units then
4775: LD_EXP 16
4779: PUSH
4780: LD_EXP 41
4784: IN
4785: IFFALSE 4797
// xavier_side := 1 else
4787: LD_ADDR_VAR 0 21
4791: PUSH
4792: LD_INT 1
4794: ST_TO_ADDR
4795: GO 4805
// xavier_side := 0 ;
4797: LD_ADDR_VAR 0 21
4801: PUSH
4802: LD_INT 0
4804: ST_TO_ADDR
// if Oblukov in scientists then
4805: LD_EXP 17
4809: PUSH
4810: LD_EXP 40
4814: IN
4815: IFFALSE 4827
// oblukov_side := 2 else
4817: LD_ADDR_VAR 0 22
4821: PUSH
4822: LD_INT 2
4824: ST_TO_ADDR
4825: GO 4857
// if Oblukov in player_units then
4827: LD_EXP 17
4831: PUSH
4832: LD_EXP 41
4836: IN
4837: IFFALSE 4849
// oblukov_side := 1 else
4839: LD_ADDR_VAR 0 22
4843: PUSH
4844: LD_INT 1
4846: ST_TO_ADDR
4847: GO 4857
// oblukov_side := 0 ;
4849: LD_ADDR_VAR 0 22
4853: PUSH
4854: LD_INT 0
4856: ST_TO_ADDR
// if Kozlov in scientists then
4857: LD_EXP 18
4861: PUSH
4862: LD_EXP 40
4866: IN
4867: IFFALSE 4879
// kozlov_side := 2 else
4869: LD_ADDR_VAR 0 23
4873: PUSH
4874: LD_INT 2
4876: ST_TO_ADDR
4877: GO 4909
// if Kozlov in player_units then
4879: LD_EXP 18
4883: PUSH
4884: LD_EXP 41
4888: IN
4889: IFFALSE 4901
// kozlov_side := 1 else
4891: LD_ADDR_VAR 0 23
4895: PUSH
4896: LD_INT 1
4898: ST_TO_ADDR
4899: GO 4909
// kozlov_side := 0 ;
4901: LD_ADDR_VAR 0 23
4905: PUSH
4906: LD_INT 0
4908: ST_TO_ADDR
// if Kapitsova in scientists then
4909: LD_EXP 19
4913: PUSH
4914: LD_EXP 40
4918: IN
4919: IFFALSE 4931
// kapitsova_side := 2 else
4921: LD_ADDR_VAR 0 24
4925: PUSH
4926: LD_INT 2
4928: ST_TO_ADDR
4929: GO 4961
// if Kapitsova in player_units then
4931: LD_EXP 19
4935: PUSH
4936: LD_EXP 41
4940: IN
4941: IFFALSE 4953
// kapitsova_side := 1 else
4943: LD_ADDR_VAR 0 24
4947: PUSH
4948: LD_INT 1
4950: ST_TO_ADDR
4951: GO 4961
// kapitsova_side := 0 ;
4953: LD_ADDR_VAR 0 24
4957: PUSH
4958: LD_INT 0
4960: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4961: LD_VAR 0 8
4965: PPUSH
4966: LD_STRING belkov_side
4968: PPUSH
4969: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4973: LD_VAR 0 9
4977: PPUSH
4978: LD_STRING gnyevko_side
4980: PPUSH
4981: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4985: LD_VAR 0 10
4989: PPUSH
4990: LD_STRING kiril_side
4992: PPUSH
4993: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4997: LD_VAR 0 16
5001: PPUSH
5002: LD_STRING gleb_side
5004: PPUSH
5005: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
5009: LD_VAR 0 15
5013: PPUSH
5014: LD_STRING petros_side
5016: PPUSH
5017: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
5021: LD_VAR 0 19
5025: PPUSH
5026: LD_STRING titov_side
5028: PPUSH
5029: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
5033: LD_VAR 0 11
5037: PPUSH
5038: LD_STRING kovalyuk_side
5040: PPUSH
5041: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
5045: LD_VAR 0 12
5049: PPUSH
5050: LD_STRING scholtze_side
5052: PPUSH
5053: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5057: LD_VAR 0 13
5061: PPUSH
5062: LD_STRING kuzmov_side
5064: PPUSH
5065: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5069: LD_VAR 0 14
5073: PPUSH
5074: LD_STRING karam_side
5076: PPUSH
5077: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5081: LD_VAR 0 17
5085: PPUSH
5086: LD_STRING petrov_side
5088: PPUSH
5089: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5093: LD_VAR 0 18
5097: PPUSH
5098: LD_STRING lipshchin_side
5100: PPUSH
5101: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5105: LD_VAR 0 20
5109: PPUSH
5110: LD_STRING dolgov_side
5112: PPUSH
5113: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5117: LD_VAR 0 21
5121: PPUSH
5122: LD_STRING xavier_side
5124: PPUSH
5125: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5129: LD_VAR 0 22
5133: PPUSH
5134: LD_STRING oblukov_side
5136: PPUSH
5137: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5141: LD_VAR 0 23
5145: PPUSH
5146: LD_STRING kozlov_side
5148: PPUSH
5149: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5153: LD_VAR 0 24
5157: PPUSH
5158: LD_STRING kapitsova_side
5160: PPUSH
5161: CALL_OW 39
// YouWin ;
5165: CALL_OW 103
// exit ;
5169: GO 5171
// end ; end_of_file
5171: LD_VAR 0 1
5175: RET
// export function D_Start ; begin
5176: LD_INT 0
5178: PPUSH
// DisableExclamations ;
5179: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5183: LD_EXP 8
5187: PPUSH
5188: LD_STRING DStart-Gos-1
5190: PPUSH
5191: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5195: LD_EXP 1
5199: PPUSH
5200: LD_STRING DStart-Bur-1
5202: PPUSH
5203: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5207: LD_EXP 8
5211: PPUSH
5212: LD_STRING DStart-Gos-2
5214: PPUSH
5215: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5219: LD_EXP 1
5223: PPUSH
5224: LD_STRING DStart-Bur-2
5226: PPUSH
5227: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5231: LD_EXP 8
5235: PPUSH
5236: LD_STRING DStart-Gos-3
5238: PPUSH
5239: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5243: LD_EXP 1
5247: PPUSH
5248: LD_STRING DStart-Bur-3
5250: PPUSH
5251: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5255: LD_EXP 8
5259: PPUSH
5260: LD_STRING DStart-Gos-4
5262: PPUSH
5263: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5267: LD_EXP 1
5271: PPUSH
5272: LD_STRING DStart-Bur-4
5274: PPUSH
5275: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5279: LD_EXP 8
5283: PPUSH
5284: LD_STRING DStart-Gos-5
5286: PPUSH
5287: CALL_OW 88
// EnableExclamations ;
5291: CALL_OW 473
// end ;
5295: LD_VAR 0 1
5299: RET
// export function D_Platonov ; begin
5300: LD_INT 0
5302: PPUSH
// DisableExclamations ;
5303: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5307: LD_EXP 21
5311: PPUSH
5312: LD_STRING DPlatonov-Rsol1-1
5314: PPUSH
5315: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5319: LD_EXP 1
5323: PPUSH
5324: LD_STRING DPlatonov-Bur-1
5326: PPUSH
5327: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5331: LD_EXP 21
5335: PPUSH
5336: LD_STRING DPlatonov-Rsol1-2
5338: PPUSH
5339: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5343: LD_EXP 1
5347: PPUSH
5348: LD_STRING DPlatonov-Bur-2
5350: PPUSH
5351: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5355: LD_EXP 1
5359: PPUSH
5360: LD_EXP 43
5364: PPUSH
5365: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5369: LD_EXP 21
5373: PPUSH
5374: LD_STRING DPlatonov-Rsol1-3
5376: PPUSH
5377: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5381: LD_INT 7
5383: PPUSH
5384: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5388: LD_EXP 43
5392: PPUSH
5393: CALL_OW 311
5397: PUSH
5398: LD_EXP 1
5402: EQUAL
5403: IFFALSE 5381
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5405: LD_EXP 1
5409: PPUSH
5410: LD_STRING DPlatonov-Bur-3
5412: PPUSH
5413: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5417: LD_EXP 1
5421: PPUSH
5422: LD_EXP 21
5426: PPUSH
5427: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5431: LD_INT 7
5433: PPUSH
5434: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5438: LD_EXP 43
5442: PPUSH
5443: CALL_OW 320
5447: PUSH
5448: LD_EXP 21
5452: EQUAL
5453: IFFALSE 5431
// Wait ( 0 0$0.5 ) ;
5455: LD_INT 18
5457: PPUSH
5458: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5462: LD_EXP 21
5466: PPUSH
5467: LD_STRING DPlatonov-Rsol1-4
5469: PPUSH
5470: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5474: LD_EXP 21
5478: PPUSH
5479: LD_EXP 43
5483: PPUSH
5484: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5488: LD_EXP 1
5492: PPUSH
5493: LD_EXP 21
5497: PPUSH
5498: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5502: LD_EXP 20
5506: PPUSH
5507: LD_STRING DPlatonov-Pla-4
5509: PPUSH
5510: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5514: LD_EXP 20
5518: PPUSH
5519: LD_STRING DPlatonov-Pla-4a
5521: PPUSH
5522: CALL_OW 88
// EnableExclamations ;
5526: CALL_OW 473
// end ;
5530: LD_VAR 0 1
5534: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5535: LD_INT 0
5537: PPUSH
5538: PPUSH
5539: PPUSH
5540: PPUSH
// DisableExclamations ;
5541: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5545: LD_EXP 2
5549: PPUSH
5550: CALL_OW 302
5554: PUSH
5555: LD_EXP 2
5559: PPUSH
5560: CALL_OW 255
5564: PUSH
5565: LD_EXP 23
5569: EQUAL
5570: AND
5571: IFFALSE 5585
// Say ( Belkov , DGosStart-Bel-1 ) ;
5573: LD_EXP 2
5577: PPUSH
5578: LD_STRING DGosStart-Bel-1
5580: PPUSH
5581: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5585: LD_EXP 3
5589: PPUSH
5590: CALL_OW 302
5594: PUSH
5595: LD_EXP 3
5599: PPUSH
5600: CALL_OW 255
5604: PUSH
5605: LD_EXP 23
5609: EQUAL
5610: AND
5611: IFFALSE 5625
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5613: LD_EXP 3
5617: PPUSH
5618: LD_STRING DGosStart-Gny-1
5620: PPUSH
5621: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5625: LD_EXP 5
5629: PPUSH
5630: CALL_OW 302
5634: PUSH
5635: LD_EXP 5
5639: PPUSH
5640: CALL_OW 255
5644: PUSH
5645: LD_EXP 23
5649: EQUAL
5650: AND
5651: IFFALSE 5665
// Say ( Gleb , DGosStart-Glb-1 ) ;
5653: LD_EXP 5
5657: PPUSH
5658: LD_STRING DGosStart-Glb-1
5660: PPUSH
5661: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5665: LD_EXP 6
5669: PPUSH
5670: CALL_OW 302
5674: PUSH
5675: LD_EXP 6
5679: PPUSH
5680: CALL_OW 255
5684: PUSH
5685: LD_EXP 23
5689: EQUAL
5690: AND
5691: IFFALSE 5705
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5693: LD_EXP 6
5697: PPUSH
5698: LD_STRING DGosStart-Pty-1
5700: PPUSH
5701: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5705: LD_EXP 7
5709: PPUSH
5710: CALL_OW 302
5714: PUSH
5715: LD_EXP 7
5719: PPUSH
5720: CALL_OW 255
5724: PUSH
5725: LD_EXP 23
5729: EQUAL
5730: AND
5731: IFFALSE 5745
// Say ( Titov , DGosStart-Tit-1 ) ;
5733: LD_EXP 7
5737: PPUSH
5738: LD_STRING DGosStart-Tit-1
5740: PPUSH
5741: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5745: LD_EXP 4
5749: PPUSH
5750: CALL_OW 302
5754: PUSH
5755: LD_EXP 4
5759: PPUSH
5760: CALL_OW 255
5764: PUSH
5765: LD_EXP 23
5769: EQUAL
5770: AND
5771: IFFALSE 5785
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5773: LD_EXP 4
5777: PPUSH
5778: LD_STRING DGosStart-Kir-1
5780: PPUSH
5781: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5785: LD_EXP 2
5789: PPUSH
5790: CALL_OW 302
5794: PUSH
5795: LD_EXP 2
5799: PPUSH
5800: CALL_OW 255
5804: PUSH
5805: LD_EXP 23
5809: EQUAL
5810: AND
5811: PUSH
5812: LD_EXP 3
5816: PPUSH
5817: CALL_OW 302
5821: PUSH
5822: LD_EXP 3
5826: PPUSH
5827: CALL_OW 255
5831: PUSH
5832: LD_EXP 23
5836: EQUAL
5837: AND
5838: OR
5839: PUSH
5840: LD_EXP 5
5844: PPUSH
5845: CALL_OW 302
5849: PUSH
5850: LD_EXP 5
5854: PPUSH
5855: CALL_OW 255
5859: PUSH
5860: LD_EXP 23
5864: EQUAL
5865: AND
5866: OR
5867: PUSH
5868: LD_EXP 6
5872: PPUSH
5873: CALL_OW 302
5877: PUSH
5878: LD_EXP 6
5882: PPUSH
5883: CALL_OW 255
5887: PUSH
5888: LD_EXP 23
5892: EQUAL
5893: AND
5894: OR
5895: PUSH
5896: LD_EXP 7
5900: PPUSH
5901: CALL_OW 302
5905: PUSH
5906: LD_EXP 7
5910: PPUSH
5911: CALL_OW 255
5915: PUSH
5916: LD_EXP 23
5920: EQUAL
5921: AND
5922: OR
5923: PUSH
5924: LD_EXP 4
5928: PPUSH
5929: CALL_OW 302
5933: PUSH
5934: LD_EXP 4
5938: PPUSH
5939: CALL_OW 255
5943: PUSH
5944: LD_EXP 23
5948: EQUAL
5949: AND
5950: OR
5951: NOT
5952: IFFALSE 6316
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5954: LD_ADDR_VAR 0 4
5958: PUSH
5959: LD_INT 22
5961: PUSH
5962: LD_EXP 23
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 26
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 50
5983: PUSH
5984: EMPTY
5985: LIST
5986: PUSH
5987: LD_INT 3
5989: PUSH
5990: LD_INT 23
5992: PUSH
5993: LD_INT 0
5995: PUSH
5996: EMPTY
5997: LIST
5998: LIST
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: PUSH
6004: EMPTY
6005: LIST
6006: LIST
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6015: LD_ADDR_VAR 0 4
6019: PUSH
6020: LD_VAR 0 4
6024: PUSH
6025: LD_EXP 1
6029: DIFF
6030: ST_TO_ADDR
// if 0 + filter_all > 0 then
6031: LD_INT 0
6033: PUSH
6034: LD_VAR 0 4
6038: PLUS
6039: PUSH
6040: LD_INT 0
6042: GREATER
6043: IFFALSE 6144
// begin filter := [ ] ;
6045: LD_ADDR_VAR 0 3
6049: PUSH
6050: EMPTY
6051: ST_TO_ADDR
// for un in filter_all do
6052: LD_ADDR_VAR 0 2
6056: PUSH
6057: LD_VAR 0 4
6061: PUSH
6062: FOR_IN
6063: IFFALSE 6096
// if not ( un in all_possible ) then
6065: LD_VAR 0 2
6069: PUSH
6070: LD_EXP 39
6074: IN
6075: NOT
6076: IFFALSE 6094
// filter := filter union un ;
6078: LD_ADDR_VAR 0 3
6082: PUSH
6083: LD_VAR 0 3
6087: PUSH
6088: LD_VAR 0 2
6092: UNION
6093: ST_TO_ADDR
6094: GO 6062
6096: POP
6097: POP
// if filter > 0 then
6098: LD_VAR 0 3
6102: PUSH
6103: LD_INT 0
6105: GREATER
6106: IFFALSE 6126
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6108: LD_VAR 0 3
6112: PUSH
6113: LD_INT 1
6115: ARRAY
6116: PPUSH
6117: LD_STRING DGosStart-Sol1-1
6119: PPUSH
6120: CALL_OW 88
6124: GO 6142
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6126: LD_VAR 0 4
6130: PUSH
6131: LD_INT 1
6133: ARRAY
6134: PPUSH
6135: LD_STRING DGosStart-Sol1-1
6137: PPUSH
6138: CALL_OW 88
// end else
6142: GO 6316
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6144: LD_ADDR_VAR 0 4
6148: PUSH
6149: LD_INT 22
6151: PUSH
6152: LD_EXP 23
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: PUSH
6161: LD_INT 26
6163: PUSH
6164: LD_INT 2
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PUSH
6171: LD_INT 50
6173: PUSH
6174: EMPTY
6175: LIST
6176: PUSH
6177: LD_INT 3
6179: PUSH
6180: LD_INT 23
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL_OW 69
6204: ST_TO_ADDR
// if 0 + filter_all > 0 then
6205: LD_INT 0
6207: PUSH
6208: LD_VAR 0 4
6212: PLUS
6213: PUSH
6214: LD_INT 0
6216: GREATER
6217: IFFALSE 6316
// begin filter := [ ] ;
6219: LD_ADDR_VAR 0 3
6223: PUSH
6224: EMPTY
6225: ST_TO_ADDR
// for un in filter_all do
6226: LD_ADDR_VAR 0 2
6230: PUSH
6231: LD_VAR 0 4
6235: PUSH
6236: FOR_IN
6237: IFFALSE 6270
// if not ( un in all_possible ) then
6239: LD_VAR 0 2
6243: PUSH
6244: LD_EXP 39
6248: IN
6249: NOT
6250: IFFALSE 6268
// filter := filter union un ;
6252: LD_ADDR_VAR 0 3
6256: PUSH
6257: LD_VAR 0 3
6261: PUSH
6262: LD_VAR 0 2
6266: UNION
6267: ST_TO_ADDR
6268: GO 6236
6270: POP
6271: POP
// if filter > 0 then
6272: LD_VAR 0 3
6276: PUSH
6277: LD_INT 0
6279: GREATER
6280: IFFALSE 6300
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6282: LD_VAR 0 3
6286: PUSH
6287: LD_INT 1
6289: ARRAY
6290: PPUSH
6291: LD_STRING DGosStart-FSol1-1
6293: PPUSH
6294: CALL_OW 88
6298: GO 6316
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6300: LD_VAR 0 4
6304: PUSH
6305: LD_INT 1
6307: ARRAY
6308: PPUSH
6309: LD_STRING DGosStart-FSol1-1
6311: PPUSH
6312: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6316: LD_EXP 1
6320: PPUSH
6321: LD_STRING DGosStart-Bur-1
6323: PPUSH
6324: CALL_OW 88
// Wait ( 0 0$20 ) ;
6328: LD_INT 700
6330: PPUSH
6331: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6335: LD_EXP 1
6339: PPUSH
6340: LD_STRING DGosStart-Bur-1a
6342: PPUSH
6343: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6347: LD_EXP 8
6351: PPUSH
6352: LD_STRING DGosStart-Gos-1
6354: PPUSH
6355: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6359: LD_EXP 1
6363: PPUSH
6364: LD_STRING DGosStart-Bur-2
6366: PPUSH
6367: CALL_OW 88
// Hint ( Signal ) ;
6371: LD_STRING Signal
6373: PPUSH
6374: CALL_OW 339
// attackAvalaible = 1 ;
6378: LD_ADDR_EXP 61
6382: PUSH
6383: LD_INT 1
6385: ST_TO_ADDR
// enable ( 6 ) ;
6386: LD_INT 6
6388: ENABLE_MARKED
// EnableExclamations ;
6389: CALL_OW 473
// end ;
6393: LD_VAR 0 1
6397: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6398: LD_INT 0
6400: PPUSH
6401: PPUSH
6402: PPUSH
6403: PPUSH
// DisableExclamations ;
6404: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6408: LD_EXP 1
6412: PPUSH
6413: LD_STRING DSituation-Bur-1
6415: PPUSH
6416: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6420: LD_ADDR_VAR 0 4
6424: PUSH
6425: LD_INT 22
6427: PUSH
6428: LD_EXP 23
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: LD_INT 26
6439: PUSH
6440: LD_INT 2
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 50
6449: PUSH
6450: EMPTY
6451: LIST
6452: PUSH
6453: LD_INT 3
6455: PUSH
6456: LD_INT 23
6458: PUSH
6459: LD_INT 0
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: LIST
6475: PPUSH
6476: CALL_OW 69
6480: ST_TO_ADDR
// if 0 + filter_all > 0 then
6481: LD_INT 0
6483: PUSH
6484: LD_VAR 0 4
6488: PLUS
6489: PUSH
6490: LD_INT 0
6492: GREATER
6493: IFFALSE 6594
// begin filter := [ ] ;
6495: LD_ADDR_VAR 0 3
6499: PUSH
6500: EMPTY
6501: ST_TO_ADDR
// for un in filter_all do
6502: LD_ADDR_VAR 0 2
6506: PUSH
6507: LD_VAR 0 4
6511: PUSH
6512: FOR_IN
6513: IFFALSE 6546
// if not ( un in all_possible ) then
6515: LD_VAR 0 2
6519: PUSH
6520: LD_EXP 39
6524: IN
6525: NOT
6526: IFFALSE 6544
// filter := filter union un ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: LD_VAR 0 3
6537: PUSH
6538: LD_VAR 0 2
6542: UNION
6543: ST_TO_ADDR
6544: GO 6512
6546: POP
6547: POP
// if filter > 0 then
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 0
6555: GREATER
6556: IFFALSE 6576
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 1
6565: ARRAY
6566: PPUSH
6567: LD_STRING DSituation-RFSol1-1
6569: PPUSH
6570: CALL_OW 88
6574: GO 6592
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6576: LD_VAR 0 4
6580: PUSH
6581: LD_INT 1
6583: ARRAY
6584: PPUSH
6585: LD_STRING DSituation-RFSol1-1
6587: PPUSH
6588: CALL_OW 88
// end else
6592: GO 6782
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6594: LD_ADDR_VAR 0 4
6598: PUSH
6599: LD_INT 22
6601: PUSH
6602: LD_EXP 23
6606: PUSH
6607: EMPTY
6608: LIST
6609: LIST
6610: PUSH
6611: LD_INT 26
6613: PUSH
6614: LD_INT 1
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: PUSH
6621: LD_INT 50
6623: PUSH
6624: EMPTY
6625: LIST
6626: PUSH
6627: LD_INT 3
6629: PUSH
6630: LD_INT 23
6632: PUSH
6633: LD_INT 0
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: PPUSH
6650: CALL_OW 69
6654: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6655: LD_ADDR_VAR 0 4
6659: PUSH
6660: LD_VAR 0 4
6664: PUSH
6665: LD_EXP 1
6669: DIFF
6670: ST_TO_ADDR
// if 0 + filter_all > 0 then
6671: LD_INT 0
6673: PUSH
6674: LD_VAR 0 4
6678: PLUS
6679: PUSH
6680: LD_INT 0
6682: GREATER
6683: IFFALSE 6782
// begin filter := [ ] ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: EMPTY
6691: ST_TO_ADDR
// for un in filter_all do
6692: LD_ADDR_VAR 0 2
6696: PUSH
6697: LD_VAR 0 4
6701: PUSH
6702: FOR_IN
6703: IFFALSE 6736
// if not ( un in all_possible ) then
6705: LD_VAR 0 2
6709: PUSH
6710: LD_EXP 39
6714: IN
6715: NOT
6716: IFFALSE 6734
// filter := filter union un ;
6718: LD_ADDR_VAR 0 3
6722: PUSH
6723: LD_VAR 0 3
6727: PUSH
6728: LD_VAR 0 2
6732: UNION
6733: ST_TO_ADDR
6734: GO 6702
6736: POP
6737: POP
// if filter > 0 then
6738: LD_VAR 0 3
6742: PUSH
6743: LD_INT 0
6745: GREATER
6746: IFFALSE 6766
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6748: LD_VAR 0 3
6752: PUSH
6753: LD_INT 1
6755: ARRAY
6756: PPUSH
6757: LD_STRING DSituation-RSol1-1
6759: PPUSH
6760: CALL_OW 88
6764: GO 6782
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6766: LD_VAR 0 4
6770: PUSH
6771: LD_INT 1
6773: ARRAY
6774: PPUSH
6775: LD_STRING DSituation-RSol1-1
6777: PPUSH
6778: CALL_OW 88
// end ; end ; EnableExclamations ;
6782: CALL_OW 473
// end ;
6786: LD_VAR 0 1
6790: RET
// export function D_GO1 ; begin
6791: LD_INT 0
6793: PPUSH
// DisableExclamations ;
6794: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6798: LD_EXP 1
6802: PPUSH
6803: LD_STRING DGO#1-Bur-1
6805: PPUSH
6806: CALL_OW 88
// EnableExclamations ;
6810: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6814: LD_INT 11
6816: PPUSH
6817: LD_INT 1
6819: PPUSH
6820: CALL_OW 424
// end ;
6824: LD_VAR 0 1
6828: RET
// export function D_SeeYou ; begin
6829: LD_INT 0
6831: PPUSH
// DisableExclamations ;
6832: CALL_OW 474
// DialogueOn ;
6836: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6840: LD_EXP 8
6844: PPUSH
6845: LD_STRING DSeeYou-Gos-1
6847: PPUSH
6848: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6852: LD_EXP 1
6856: PPUSH
6857: LD_STRING DSeeYou-Bur-1
6859: PPUSH
6860: CALL_OW 88
// DialogueOff ;
6864: CALL_OW 7
// EnableExclamations ;
6868: CALL_OW 473
// end ; end_of_file
6872: LD_VAR 0 1
6876: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6877: GO 6879
6879: DISABLE
6880: LD_INT 0
6882: PPUSH
6883: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6884: LD_EXP 1
6888: PPUSH
6889: LD_INT 1
6891: PPUSH
6892: CALL_OW 308
6896: IFFALSE 6962
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6898: LD_ADDR_VAR 0 1
6902: PUSH
6903: LD_INT 22
6905: PUSH
6906: LD_EXP 27
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: ST_TO_ADDR
// for un in filter do
6920: LD_ADDR_VAR 0 2
6924: PUSH
6925: LD_VAR 0 1
6929: PUSH
6930: FOR_IN
6931: IFFALSE 6949
// setside ( un , you ) ;
6933: LD_VAR 0 2
6937: PPUSH
6938: LD_EXP 23
6942: PPUSH
6943: CALL_OW 235
6947: GO 6930
6949: POP
6950: POP
// BurlakReachedBase := true ;
6951: LD_ADDR_EXP 28
6955: PUSH
6956: LD_INT 1
6958: ST_TO_ADDR
// disable ;
6959: DISABLE
// end else
6960: GO 6963
// enable ;
6962: ENABLE
// end ;
6963: PPOPN 2
6965: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6966: GO 6968
6968: DISABLE
6969: LD_INT 0
6971: PPUSH
6972: PPUSH
6973: PPUSH
6974: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6975: LD_EXP 1
6979: PPUSH
6980: LD_INT 10
6982: PPUSH
6983: CALL_OW 308
6987: IFFALSE 7218
// begin DisableExclamations ;
6989: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6993: LD_ADDR_VAR 0 1
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_EXP 27
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PPUSH
7010: CALL_OW 69
7014: ST_TO_ADDR
// skill := 0 ;
7015: LD_ADDR_VAR 0 3
7019: PUSH
7020: LD_INT 0
7022: ST_TO_ADDR
// for un in filter do
7023: LD_ADDR_VAR 0 2
7027: PUSH
7028: LD_VAR 0 1
7032: PUSH
7033: FOR_IN
7034: IFFALSE 7068
// if GetSkill ( un , skill_engineering ) >= skill then
7036: LD_VAR 0 2
7040: PPUSH
7041: LD_INT 2
7043: PPUSH
7044: CALL_OW 259
7048: PUSH
7049: LD_VAR 0 3
7053: GREATEREQUAL
7054: IFFALSE 7066
// inzenyr := un ;
7056: LD_ADDR_VAR 0 4
7060: PUSH
7061: LD_VAR 0 2
7065: ST_TO_ADDR
7066: GO 7033
7068: POP
7069: POP
// ComStop ( inzenyr ) ;
7070: LD_VAR 0 4
7074: PPUSH
7075: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7079: LD_VAR 0 4
7083: PPUSH
7084: CALL_OW 257
7088: PUSH
7089: LD_INT 2
7091: NONEQUAL
7092: IFFALSE 7183
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7094: LD_ADDR_VAR 0 1
7098: PUSH
7099: LD_INT 30
7101: PUSH
7102: LD_INT 1
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: PUSH
7109: LD_INT 22
7111: PUSH
7112: LD_EXP 27
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL_OW 69
7129: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7130: LD_VAR 0 4
7134: PPUSH
7135: LD_VAR 0 1
7139: PUSH
7140: LD_INT 1
7142: ARRAY
7143: PPUSH
7144: CALL_OW 120
// Wait ( 10 ) ;
7148: LD_INT 10
7150: PPUSH
7151: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7155: LD_VAR 0 4
7159: PPUSH
7160: LD_INT 2
7162: PPUSH
7163: CALL_OW 183
// Wait ( 10 ) ;
7167: LD_INT 10
7169: PPUSH
7170: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7174: LD_VAR 0 4
7178: PPUSH
7179: CALL_OW 182
// end ; Wait ( 10 ) ;
7183: LD_INT 10
7185: PPUSH
7186: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7190: LD_VAR 0 4
7194: PPUSH
7195: LD_INT 26
7197: PPUSH
7198: LD_INT 126
7200: PPUSH
7201: LD_INT 17
7203: PPUSH
7204: LD_INT 5
7206: PPUSH
7207: CALL_OW 205
// EnableExclamations ;
7211: CALL_OW 473
// disable ;
7215: DISABLE
// end else
7216: GO 7219
// enable ;
7218: ENABLE
// end ;
7219: PPOPN 4
7221: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7222: GO 7224
7224: DISABLE
7225: LD_INT 0
7227: PPUSH
7228: PPUSH
// begin if straz < bazooker then
7229: LD_EXP 45
7233: PUSH
7234: LD_EXP 51
7238: LESS
7239: IFFALSE 7387
// begin bazooker := bazooker + 1 ;
7241: LD_ADDR_EXP 51
7245: PUSH
7246: LD_EXP 51
7250: PUSH
7251: LD_INT 1
7253: PLUS
7254: ST_TO_ADDR
// while straz < bazooker do
7255: LD_EXP 45
7259: PUSH
7260: LD_EXP 51
7264: LESS
7265: IFFALSE 7387
// begin uc_side := rus ;
7267: LD_ADDR_OWVAR 20
7271: PUSH
7272: LD_EXP 24
7276: ST_TO_ADDR
// uc_nation := nation_russian ;
7277: LD_ADDR_OWVAR 21
7281: PUSH
7282: LD_INT 3
7284: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 4 + difficulty ) ;
7285: LD_INT 1
7287: PPUSH
7288: LD_INT 9
7290: PPUSH
7291: LD_INT 4
7293: PUSH
7294: LD_OWVAR 67
7298: PLUS
7299: PPUSH
7300: CALL_OW 380
// hc_name :=  ;
7304: LD_ADDR_OWVAR 26
7308: PUSH
7309: LD_STRING 
7311: ST_TO_ADDR
// bazukr := CreateHuman ;
7312: LD_ADDR_VAR 0 2
7316: PUSH
7317: CALL_OW 44
7321: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7322: LD_EXP 62
7326: PPUSH
7327: LD_VAR 0 2
7331: PPUSH
7332: LD_INT 1
7334: PPUSH
7335: CALL_OW 394
// straz := straz ^ bazukr ;
7339: LD_ADDR_EXP 45
7343: PUSH
7344: LD_EXP 45
7348: PUSH
7349: LD_VAR 0 2
7353: ADD
7354: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7355: LD_VAR 0 2
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: LD_INT 0
7365: PPUSH
7366: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7370: LD_VAR 0 2
7374: PPUSH
7375: LD_INT 66
7377: PPUSH
7378: LD_INT 48
7380: PPUSH
7381: CALL_OW 114
// end ;
7385: GO 7255
// end ; end ;
7387: PPOPN 2
7389: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7390: GO 7392
7392: DISABLE
7393: LD_INT 0
7395: PPUSH
// begin if ( 0 + straz ) <> 0 then
7396: LD_INT 0
7398: PUSH
7399: LD_EXP 45
7403: PLUS
7404: PUSH
7405: LD_INT 0
7407: NONEQUAL
7408: IFFALSE 7651
// begin for un in straz do
7410: LD_ADDR_VAR 0 1
7414: PUSH
7415: LD_EXP 45
7419: PUSH
7420: FOR_IN
7421: IFFALSE 7649
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7423: LD_VAR 0 1
7427: PPUSH
7428: CALL_OW 314
7432: NOT
7433: PUSH
7434: LD_VAR 0 1
7438: PPUSH
7439: CALL_OW 256
7443: PUSH
7444: LD_INT 601
7446: GREATER
7447: AND
7448: IFFALSE 7647
// begin if GetY ( un ) > 60 then
7450: LD_VAR 0 1
7454: PPUSH
7455: CALL_OW 251
7459: PUSH
7460: LD_INT 60
7462: GREATER
7463: IFFALSE 7557
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7465: LD_VAR 0 1
7469: PPUSH
7470: LD_INT 66
7472: PPUSH
7473: LD_INT 48
7475: PPUSH
7476: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7480: LD_VAR 0 1
7484: PPUSH
7485: LD_INT 63
7487: PPUSH
7488: LD_INT 74
7490: PPUSH
7491: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7495: LD_VAR 0 1
7499: PPUSH
7500: LD_INT 73
7502: PPUSH
7503: LD_INT 90
7505: PPUSH
7506: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7510: LD_VAR 0 1
7514: PPUSH
7515: LD_INT 76
7517: PPUSH
7518: LD_INT 95
7520: PPUSH
7521: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7525: LD_VAR 0 1
7529: PPUSH
7530: LD_INT 72
7532: PPUSH
7533: LD_INT 95
7535: PPUSH
7536: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7540: LD_VAR 0 1
7544: PPUSH
7545: LD_INT 50
7547: PPUSH
7548: LD_INT 73
7550: PPUSH
7551: CALL_OW 174
// end else
7555: GO 7647
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7557: LD_VAR 0 1
7561: PPUSH
7562: LD_INT 73
7564: PPUSH
7565: LD_INT 90
7567: PPUSH
7568: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7572: LD_VAR 0 1
7576: PPUSH
7577: LD_INT 76
7579: PPUSH
7580: LD_INT 95
7582: PPUSH
7583: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7587: LD_VAR 0 1
7591: PPUSH
7592: LD_INT 72
7594: PPUSH
7595: LD_INT 95
7597: PPUSH
7598: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7602: LD_VAR 0 1
7606: PPUSH
7607: LD_INT 50
7609: PPUSH
7610: LD_INT 73
7612: PPUSH
7613: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7617: LD_VAR 0 1
7621: PPUSH
7622: LD_INT 63
7624: PPUSH
7625: LD_INT 74
7627: PPUSH
7628: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7632: LD_VAR 0 1
7636: PPUSH
7637: LD_INT 66
7639: PPUSH
7640: LD_INT 48
7642: PPUSH
7643: CALL_OW 174
// end ; end ; end ;
7647: GO 7420
7649: POP
7650: POP
// end ; enable ;
7651: ENABLE
// end ;
7652: PPOPN 1
7654: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7655: GO 7657
7657: DISABLE
7658: LD_INT 0
7660: PPUSH
7661: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7662: LD_EXP 1
7666: PPUSH
7667: LD_INT 2
7669: PPUSH
7670: CALL_OW 308
7674: IFFALSE 7718
// begin disabled5 := true ;
7676: LD_ADDR_LOC 4
7680: PUSH
7681: LD_INT 1
7683: ST_TO_ADDR
// D_GosStart ;
7684: CALL 5535 0 0
// Wait ( 0 0$5 ) ;
7688: LD_INT 175
7690: PPUSH
7691: CALL_OW 67
// D_Situation ;
7695: CALL 6398 0 0
// ChangeMissionObjectives ( MHold ) ;
7699: LD_STRING MHold
7701: PPUSH
7702: CALL_OW 337
// disable ;
7706: DISABLE
// enable ( 333 ) ;
7707: LD_INT 333
7709: ENABLE_MARKED
// enable ( 334 ) ;
7710: LD_INT 334
7712: ENABLE_MARKED
// enable ( 337 ) ;
7713: LD_INT 337
7715: ENABLE_MARKED
// end else
7716: GO 7719
// enable ;
7718: ENABLE
// end ;
7719: PPOPN 2
7721: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7722: GO 7724
7724: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7725: LD_EXP 8
7729: PPUSH
7730: CALL_OW 306
7734: PUSH
7735: LD_INT 1
7737: EQUAL
7738: IFFALSE 7764
// begin if WasSelected = false then
7740: LD_EXP 46
7744: PUSH
7745: LD_INT 0
7747: EQUAL
7748: IFFALSE 7762
// begin QueryQGO ;
7750: CALL 7781 0 0
// WasSelected := true ;
7754: LD_ADDR_EXP 46
7758: PUSH
7759: LD_INT 1
7761: ST_TO_ADDR
// end ; end else
7762: GO 7772
// WasSelected := false ;
7764: LD_ADDR_EXP 46
7768: PUSH
7769: LD_INT 0
7771: ST_TO_ADDR
// if not disabled3 then
7772: LD_LOC 3
7776: NOT
7777: IFFALSE 7780
// enable ;
7779: ENABLE
// end ;
7780: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7781: LD_INT 0
7783: PPUSH
7784: PPUSH
7785: PPUSH
7786: PPUSH
7787: PPUSH
7788: PPUSH
// res := Query ( QGO ) ;
7789: LD_ADDR_VAR 0 2
7793: PUSH
7794: LD_STRING QGO
7796: PPUSH
7797: CALL_OW 97
7801: ST_TO_ADDR
// if res = 1 then
7802: LD_VAR 0 2
7806: PUSH
7807: LD_INT 1
7809: EQUAL
7810: IFFALSE 8186
// begin disabled3 := true ;
7812: LD_ADDR_LOC 3
7816: PUSH
7817: LD_INT 1
7819: ST_TO_ADDR
// D_GO1 ;
7820: CALL 6791 0 0
// ChangeMissionObjectives ( MGuide ) ;
7824: LD_STRING MGuide
7826: PPUSH
7827: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7831: LD_ADDR_VAR 0 3
7835: PUSH
7836: LD_INT 3
7838: PPUSH
7839: LD_INT 21
7841: PUSH
7842: LD_INT 2
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: PUSH
7849: LD_INT 34
7851: PUSH
7852: LD_INT 51
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 70
7867: ST_TO_ADDR
// if filter = 0 then
7868: LD_VAR 0 3
7872: PUSH
7873: LD_INT 0
7875: EQUAL
7876: IFFALSE 8027
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7878: LD_EXP 8
7882: PPUSH
7883: LD_INT 57
7885: PPUSH
7886: LD_INT 98
7888: PPUSH
7889: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7893: LD_INT 35
7895: PPUSH
7896: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7900: LD_EXP 8
7904: PPUSH
7905: CALL_OW 314
7909: NOT
7910: IFFALSE 7893
// RemoveUnit ( Gossudarov ) ;
7912: LD_EXP 8
7916: PPUSH
7917: CALL_OW 64
// uc_side := ally ;
7921: LD_ADDR_OWVAR 20
7925: PUSH
7926: LD_EXP 25
7930: ST_TO_ADDR
// uc_nation := nation_russian ;
7931: LD_ADDR_OWVAR 21
7935: PUSH
7936: LD_INT 3
7938: ST_TO_ADDR
// uc_direction := 5 ;
7939: LD_ADDR_OWVAR 24
7943: PUSH
7944: LD_INT 5
7946: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7947: LD_ADDR_OWVAR 37
7951: PUSH
7952: LD_INT 21
7954: ST_TO_ADDR
// vc_engine := engine_combustion ;
7955: LD_ADDR_OWVAR 39
7959: PUSH
7960: LD_INT 1
7962: ST_TO_ADDR
// vc_control := control_manual ;
7963: LD_ADDR_OWVAR 38
7967: PUSH
7968: LD_INT 1
7970: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7971: LD_ADDR_OWVAR 40
7975: PUSH
7976: LD_INT 51
7978: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7979: LD_ADDR_VAR 0 4
7983: PUSH
7984: CALL_OW 45
7988: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7989: LD_EXP 8
7993: PPUSH
7994: LD_VAR 0 4
7998: PPUSH
7999: CALL_OW 52
// Wait ( 0 0$5 ) ;
8003: LD_INT 175
8005: PPUSH
8006: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
8010: LD_VAR 0 4
8014: PPUSH
8015: LD_INT 9
8017: PPUSH
8018: LD_INT 0
8020: PPUSH
8021: CALL_OW 49
// end else
8025: GO 8045
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
8027: LD_EXP 8
8031: PPUSH
8032: LD_VAR 0 3
8036: PUSH
8037: LD_INT 1
8039: ARRAY
8040: PPUSH
8041: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8045: LD_EXP 8
8049: PPUSH
8050: LD_INT 4
8052: PPUSH
8053: CALL_OW 469
8057: PUSH
8058: LD_INT 1
8060: ARRAY
8061: PPUSH
8062: LD_INT 4
8064: PPUSH
8065: CALL_OW 469
8069: PUSH
8070: LD_INT 2
8072: ARRAY
8073: PPUSH
8074: CALL_OW 220
// Wait ( 0 0$5 ) ;
8078: LD_INT 175
8080: PPUSH
8081: CALL_OW 67
// ComExitBuilding ( scientists ) ;
8085: LD_EXP 40
8089: PPUSH
8090: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
8094: LD_EXP 40
8098: PUSH
8099: LD_EXP 8
8103: ADD
8104: PPUSH
8105: LD_INT 50
8107: PPUSH
8108: LD_INT 58
8110: PPUSH
8111: CALL_OW 171
// for un in scientists ^ Gossudarov do
8115: LD_ADDR_VAR 0 6
8119: PUSH
8120: LD_EXP 40
8124: PUSH
8125: LD_EXP 8
8129: ADD
8130: PUSH
8131: FOR_IN
8132: IFFALSE 8150
// AddComSailEvent ( un , un ) ;
8134: LD_VAR 0 6
8138: PPUSH
8139: LD_VAR 0 6
8143: PPUSH
8144: CALL_OW 224
8148: GO 8131
8150: POP
8151: POP
// player_units := player_units union scientists union Gossudarov ;
8152: LD_ADDR_EXP 41
8156: PUSH
8157: LD_EXP 41
8161: PUSH
8162: LD_EXP 40
8166: UNION
8167: PUSH
8168: LD_EXP 8
8172: UNION
8173: ST_TO_ADDR
// enable ( 4 ) ;
8174: LD_INT 4
8176: ENABLE_MARKED
// enable ( 7 ) ;
8177: LD_INT 7
8179: ENABLE_MARKED
// enable ( 8 ) ;
8180: LD_INT 8
8182: ENABLE_MARKED
// enable ( 9 ) ;
8183: LD_INT 9
8185: ENABLE_MARKED
// end ; end ;
8186: LD_VAR 0 1
8190: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8191: GO 8193
8193: DISABLE
8194: LD_INT 0
8196: PPUSH
// begin for un in scientists do
8197: LD_ADDR_VAR 0 1
8201: PUSH
8202: LD_EXP 40
8206: PUSH
8207: FOR_IN
8208: IFFALSE 8278
// begin if IsInArea ( un , ExitArea ) then
8210: LD_VAR 0 1
8214: PPUSH
8215: LD_INT 11
8217: PPUSH
8218: CALL_OW 308
8222: IFFALSE 8249
// begin scientists_saved := scientists_saved union un ;
8224: LD_ADDR_EXP 48
8228: PUSH
8229: LD_EXP 48
8233: PUSH
8234: LD_VAR 0 1
8238: UNION
8239: ST_TO_ADDR
// RemoveUnit ( un ) ;
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 64
// end ; if IsDead ( un ) then
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 301
8258: IFFALSE 8276
// scientists_dead := scientists_dead union un ;
8260: LD_ADDR_EXP 49
8264: PUSH
8265: LD_EXP 49
8269: PUSH
8270: LD_VAR 0 1
8274: UNION
8275: ST_TO_ADDR
// end ;
8276: GO 8207
8278: POP
8279: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8280: LD_EXP 8
8284: PPUSH
8285: LD_INT 11
8287: PPUSH
8288: CALL_OW 308
8292: PUSH
8293: LD_EXP 8
8297: PPUSH
8298: CALL_OW 310
8302: PPUSH
8303: LD_INT 11
8305: PPUSH
8306: CALL_OW 308
8310: OR
8311: PUSH
8312: LD_EXP 48
8316: PUSH
8317: LD_EXP 49
8321: PLUS
8322: PUSH
8323: LD_EXP 40
8327: EQUAL
8328: AND
8329: PUSH
8330: LD_EXP 50
8334: PPUSH
8335: CALL_OW 255
8339: PUSH
8340: LD_EXP 23
8344: EQUAL
8345: AND
8346: PUSH
8347: LD_EXP 50
8351: PPUSH
8352: LD_INT 11
8354: PPUSH
8355: CALL_OW 308
8359: AND
8360: PUSH
8361: LD_EXP 50
8365: PPUSH
8366: LD_INT 4
8368: PPUSH
8369: CALL_OW 289
8373: PUSH
8374: LD_INT 40
8376: EQUAL
8377: AND
8378: IFFALSE 8390
// begin D_SeeYou ;
8380: CALL 6829 0 0
// TheEnd ;
8384: CALL 3316 0 0
// end else
8388: GO 8391
// enable ;
8390: ENABLE
// end ;
8391: PPOPN 1
8393: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8394: GO 8396
8396: DISABLE
8397: LD_INT 0
8399: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8400: LD_EXP 1
8404: PPUSH
8405: LD_INT 18
8407: PPUSH
8408: CALL_OW 308
8412: PUSH
8413: LD_EXP 43
8417: PPUSH
8418: LD_INT 18
8420: PPUSH
8421: CALL_OW 308
8425: OR
8426: IFFALSE 8443
// begin Wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// Attack1 := true ;
8435: LD_ADDR_LOC 5
8439: PUSH
8440: LD_INT 1
8442: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8443: LD_EXP 1
8447: PPUSH
8448: LD_INT 19
8450: PPUSH
8451: CALL_OW 308
8455: PUSH
8456: LD_EXP 43
8460: PPUSH
8461: LD_INT 19
8463: PPUSH
8464: CALL_OW 308
8468: OR
8469: IFFALSE 8486
// begin Wait ( 0 0$3 ) ;
8471: LD_INT 105
8473: PPUSH
8474: CALL_OW 67
// Attack2 := true ;
8478: LD_ADDR_LOC 6
8482: PUSH
8483: LD_INT 1
8485: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8486: LD_EXP 1
8490: PPUSH
8491: LD_INT 20
8493: PPUSH
8494: CALL_OW 308
8498: PUSH
8499: LD_EXP 43
8503: PPUSH
8504: LD_INT 20
8506: PPUSH
8507: CALL_OW 308
8511: OR
8512: IFFALSE 8529
// begin Wait ( 0 0$3 ) ;
8514: LD_INT 105
8516: PPUSH
8517: CALL_OW 67
// Attack3 := true ;
8521: LD_ADDR_LOC 7
8525: PUSH
8526: LD_INT 1
8528: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8529: LD_LOC 5
8533: PUSH
8534: LD_LOC 6
8538: NOT
8539: AND
8540: PUSH
8541: LD_LOC 7
8545: NOT
8546: AND
8547: IFFALSE 8610
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8549: LD_ADDR_VAR 0 1
8553: PUSH
8554: DOUBLE
8555: LD_EXP 31
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: DEC
8564: ST_TO_ADDR
8565: LD_EXP 31
8569: PUSH
8570: LD_EXP 30
8574: PLUS
8575: PUSH
8576: FOR_TO
8577: IFFALSE 8608
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8579: LD_EXP 29
8583: PUSH
8584: LD_VAR 0 1
8588: ARRAY
8589: PPUSH
8590: LD_EXP 1
8594: PPUSH
8595: CALL_OW 115
// Wait ( 2 ) ;
8599: LD_INT 2
8601: PPUSH
8602: CALL_OW 67
// end ;
8606: GO 8576
8608: POP
8609: POP
// if Attack1 and Attack2 and not Attack3 then
8610: LD_LOC 5
8614: PUSH
8615: LD_LOC 6
8619: AND
8620: PUSH
8621: LD_LOC 7
8625: NOT
8626: AND
8627: IFFALSE 8694
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8629: LD_ADDR_VAR 0 1
8633: PUSH
8634: DOUBLE
8635: LD_EXP 31
8639: PUSH
8640: LD_INT 1
8642: PLUS
8643: DEC
8644: ST_TO_ADDR
8645: LD_EXP 31
8649: PUSH
8650: LD_INT 2
8652: PUSH
8653: LD_EXP 30
8657: MUL
8658: PLUS
8659: PUSH
8660: FOR_TO
8661: IFFALSE 8692
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8663: LD_EXP 29
8667: PUSH
8668: LD_VAR 0 1
8672: ARRAY
8673: PPUSH
8674: LD_EXP 1
8678: PPUSH
8679: CALL_OW 115
// Wait ( 2 ) ;
8683: LD_INT 2
8685: PPUSH
8686: CALL_OW 67
// end ;
8690: GO 8660
8692: POP
8693: POP
// if Attack1 and Attack2 and Attack3 then
8694: LD_LOC 5
8698: PUSH
8699: LD_LOC 6
8703: AND
8704: PUSH
8705: LD_LOC 7
8709: AND
8710: IFFALSE 8777
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8712: LD_ADDR_VAR 0 1
8716: PUSH
8717: DOUBLE
8718: LD_EXP 31
8722: PUSH
8723: LD_INT 1
8725: PLUS
8726: DEC
8727: ST_TO_ADDR
8728: LD_EXP 31
8732: PUSH
8733: LD_INT 3
8735: PUSH
8736: LD_EXP 30
8740: MUL
8741: PLUS
8742: PUSH
8743: FOR_TO
8744: IFFALSE 8775
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8746: LD_EXP 29
8750: PUSH
8751: LD_VAR 0 1
8755: ARRAY
8756: PPUSH
8757: LD_EXP 1
8761: PPUSH
8762: CALL_OW 115
// Wait ( 2 ) ;
8766: LD_INT 2
8768: PPUSH
8769: CALL_OW 67
// end ;
8773: GO 8743
8775: POP
8776: POP
// for i := 1 to pursuers_base do
8777: LD_ADDR_VAR 0 1
8781: PUSH
8782: DOUBLE
8783: LD_INT 1
8785: DEC
8786: ST_TO_ADDR
8787: LD_EXP 31
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8824
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8795: LD_EXP 29
8799: PUSH
8800: LD_VAR 0 1
8804: ARRAY
8805: PPUSH
8806: LD_EXP 1
8810: PPUSH
8811: CALL_OW 115
// Wait ( 2 ) ;
8815: LD_INT 2
8817: PPUSH
8818: CALL_OW 67
// end ;
8822: GO 8792
8824: POP
8825: POP
// if not disabled5 then
8826: LD_LOC 4
8830: NOT
8831: IFFALSE 8834
// enable ;
8833: ENABLE
// end ;
8834: PPOPN 1
8836: END
// every 0 0$1 marked 6 do
8837: GO 8839
8839: DISABLE
// begin if Goss_time > 0 then
8840: LD_EXP 47
8844: PUSH
8845: LD_INT 0
8847: GREATER
8848: IFFALSE 8884
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8850: LD_ADDR_OWVAR 47
8854: PUSH
8855: LD_STRING #Ru12a-1
8857: PUSH
8858: LD_EXP 47
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8867: LD_ADDR_EXP 47
8871: PUSH
8872: LD_EXP 47
8876: PUSH
8877: LD_INT 35
8879: MINUS
8880: ST_TO_ADDR
// enable ;
8881: ENABLE
// end else
8882: GO 8895
// begin display_strings :=  ;
8884: LD_ADDR_OWVAR 47
8888: PUSH
8889: LD_STRING 
8891: ST_TO_ADDR
// enable ( 3 ) ;
8892: LD_INT 3
8894: ENABLE_MARKED
// end ; end ;
8895: END
// every 0 0$1 marked 7 do
8896: GO 8898
8898: DISABLE
// begin if FindArtifact ( 4 ) then
8899: LD_INT 4
8901: PPUSH
8902: CALL_OW 469
8906: IFFALSE 8960
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8908: LD_LOC 8
8912: PPUSH
8913: LD_INT 4
8915: PPUSH
8916: CALL_OW 469
8920: PUSH
8921: LD_INT 1
8923: ARRAY
8924: PPUSH
8925: LD_INT 4
8927: PPUSH
8928: CALL_OW 469
8932: PUSH
8933: LD_INT 2
8935: ARRAY
8936: PPUSH
8937: CALL_OW 160
// Wait ( 3 ) ;
8941: LD_INT 3
8943: PPUSH
8944: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8948: LD_LOC 8
8952: PPUSH
8953: LD_INT 9
8955: PPUSH
8956: CALL_OW 173
// end ; enable ;
8960: ENABLE
// end ;
8961: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8962: GO 8964
8964: DISABLE
8965: LD_INT 0
8967: PPUSH
8968: PPUSH
8969: PPUSH
8970: PPUSH
// begin Wait ( pausa ) ;
8971: LD_EXP 37
8975: PPUSH
8976: CALL_OW 67
// sc_utok := [ ] ;
8980: LD_ADDR_VAR 0 3
8984: PUSH
8985: EMPTY
8986: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: DOUBLE
8993: LD_INT 1
8995: DEC
8996: ST_TO_ADDR
8997: LD_INT 2
8999: PUSH
9000: LD_OWVAR 67
9004: PLUS
9005: PUSH
9006: FOR_TO
9007: IFFALSE 9211
// begin uc_side := rus ;
9009: LD_ADDR_OWVAR 20
9013: PUSH
9014: LD_EXP 24
9018: ST_TO_ADDR
// uc_nation := nation_russian ;
9019: LD_ADDR_OWVAR 21
9023: PUSH
9024: LD_INT 3
9026: ST_TO_ADDR
// uc_direction := 5 ;
9027: LD_ADDR_OWVAR 24
9031: PUSH
9032: LD_INT 5
9034: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
9035: LD_INT 1
9037: PPUSH
9038: LD_INT 3
9040: PPUSH
9041: CALL_OW 12
9045: PUSH
9046: LD_INT 1
9048: DOUBLE
9049: EQUAL
9050: IFTRUE 9054
9052: GO 9078
9054: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9055: LD_INT 1
9057: PPUSH
9058: LD_INT 1
9060: PPUSH
9061: LD_INT 4
9063: PPUSH
9064: LD_INT 8
9066: PPUSH
9067: CALL_OW 12
9071: PPUSH
9072: CALL_OW 380
9076: GO 9117
9078: LD_INT 2
9080: DOUBLE
9081: GREATEREQUAL
9082: IFFALSE 9090
9084: LD_INT 3
9086: DOUBLE
9087: LESSEQUAL
9088: IFTRUE 9092
9090: GO 9116
9092: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9093: LD_INT 1
9095: PPUSH
9096: LD_INT 9
9098: PPUSH
9099: LD_INT 3
9101: PPUSH
9102: LD_INT 7
9104: PPUSH
9105: CALL_OW 12
9109: PPUSH
9110: CALL_OW 380
9114: GO 9117
9116: POP
// hc_name :=  ;
9117: LD_ADDR_OWVAR 26
9121: PUSH
9122: LD_STRING 
9124: ST_TO_ADDR
// clovek := CreateHuman ;
9125: LD_ADDR_VAR 0 2
9129: PUSH
9130: CALL_OW 44
9134: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9135: LD_VAR 0 2
9139: PPUSH
9140: LD_INT 9
9142: PPUSH
9143: LD_INT 0
9145: PPUSH
9146: CALL_OW 49
// Wait ( 0 0$2 ) ;
9150: LD_INT 70
9152: PPUSH
9153: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9157: LD_VAR 0 2
9161: PPUSH
9162: LD_INT 50
9164: PPUSH
9165: LD_INT 84
9167: PPUSH
9168: CALL_OW 111
// Wait ( 2 ) ;
9172: LD_INT 2
9174: PPUSH
9175: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9179: LD_VAR 0 2
9183: PPUSH
9184: LD_EXP 50
9188: PPUSH
9189: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9193: LD_ADDR_VAR 0 3
9197: PUSH
9198: LD_VAR 0 3
9202: PUSH
9203: LD_VAR 0 2
9207: ADD
9208: ST_TO_ADDR
// end ;
9209: GO 9006
9211: POP
9212: POP
// Wait ( 0 0$10 ) ;
9213: LD_INT 350
9215: PPUSH
9216: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9220: LD_LOC 8
9224: PPUSH
9225: CALL_OW 302
9229: NOT
9230: IFFALSE 9337
// begin uc_side := rus ;
9232: LD_ADDR_OWVAR 20
9236: PUSH
9237: LD_EXP 24
9241: ST_TO_ADDR
// uc_nation := nation_russian ;
9242: LD_ADDR_OWVAR 21
9246: PUSH
9247: LD_INT 3
9249: ST_TO_ADDR
// uc_direction := 5 ;
9250: LD_ADDR_OWVAR 24
9254: PUSH
9255: LD_INT 5
9257: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9258: LD_ADDR_OWVAR 37
9262: PUSH
9263: LD_INT 22
9265: ST_TO_ADDR
// vc_control := control_computer ;
9266: LD_ADDR_OWVAR 38
9270: PUSH
9271: LD_INT 3
9273: ST_TO_ADDR
// vc_engine := engine_siberite ;
9274: LD_ADDR_OWVAR 39
9278: PUSH
9279: LD_INT 3
9281: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9282: LD_ADDR_OWVAR 40
9286: PUSH
9287: LD_INT 51
9289: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9290: LD_ADDR_LOC 8
9294: PUSH
9295: CALL_OW 45
9299: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9300: LD_LOC 8
9304: PPUSH
9305: LD_INT 9
9307: PPUSH
9308: LD_INT 0
9310: PPUSH
9311: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9315: LD_INT 18
9317: PPUSH
9318: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9322: LD_LOC 8
9326: PPUSH
9327: LD_INT 55
9329: PPUSH
9330: LD_INT 84
9332: PPUSH
9333: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9337: LD_VAR 0 3
9341: PUSH
9342: LD_LOC 8
9346: PPUSH
9347: CALL_OW 302
9351: AND
9352: IFFALSE 9422
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9354: LD_VAR 0 3
9358: PPUSH
9359: LD_EXP 50
9363: PPUSH
9364: CALL_OW 115
// Wait ( 0 0$2 ) ;
9368: LD_INT 70
9370: PPUSH
9371: CALL_OW 67
// for un in sc_utok do
9375: LD_ADDR_VAR 0 4
9379: PUSH
9380: LD_VAR 0 3
9384: PUSH
9385: FOR_IN
9386: IFFALSE 9418
// if not IsOK ( un ) then
9388: LD_VAR 0 4
9392: PPUSH
9393: CALL_OW 302
9397: NOT
9398: IFFALSE 9416
// sc_utok := sc_utok diff un ;
9400: LD_ADDR_VAR 0 3
9404: PUSH
9405: LD_VAR 0 3
9409: PUSH
9410: LD_VAR 0 4
9414: DIFF
9415: ST_TO_ADDR
9416: GO 9385
9418: POP
9419: POP
// end ;
9420: GO 9337
// Wait ( 0 0$5 ) ;
9422: LD_INT 175
9424: PPUSH
9425: CALL_OW 67
// enable ;
9429: ENABLE
// end ;
9430: PPOPN 4
9432: END
// every 0 0$3 marked 9 do
9433: GO 9435
9435: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9436: LD_LOC 8
9440: PPUSH
9441: LD_INT 3
9443: PPUSH
9444: CALL_OW 308
9448: PUSH
9449: LD_LOC 8
9453: PPUSH
9454: LD_INT 4
9456: PPUSH
9457: CALL_OW 289
9461: PUSH
9462: LD_INT 40
9464: EQUAL
9465: AND
9466: IFFALSE 9475
// YouLost ( Artefact ) ;
9468: LD_STRING Artefact
9470: PPUSH
9471: CALL_OW 104
// enable ;
9475: ENABLE
// end ;
9476: END
// on UnitDestroyed ( human ) do var i , un ;
9477: LD_INT 0
9479: PPUSH
9480: PPUSH
// begin if human = Burlak then
9481: LD_VAR 0 1
9485: PUSH
9486: LD_EXP 1
9490: EQUAL
9491: IFFALSE 9500
// YouLost ( Burlak ) ;
9493: LD_STRING Burlak
9495: PPUSH
9496: CALL_OW 104
// if human = Gossudarov then
9500: LD_VAR 0 1
9504: PUSH
9505: LD_EXP 8
9509: EQUAL
9510: IFFALSE 9519
// YouLost ( Gossudarov ) ;
9512: LD_STRING Gossudarov
9514: PPUSH
9515: CALL_OW 104
// if human = Masha then
9519: LD_VAR 0 1
9523: PUSH
9524: LD_EXP 43
9528: EQUAL
9529: IFFALSE 9539
// lost_masha := true ;
9531: LD_ADDR_EXP 52
9535: PUSH
9536: LD_INT 1
9538: ST_TO_ADDR
// if human in straz then
9539: LD_VAR 0 1
9543: PUSH
9544: LD_EXP 45
9548: IN
9549: IFFALSE 9598
// begin straz := straz diff human ;
9551: LD_ADDR_EXP 45
9555: PUSH
9556: LD_EXP 45
9560: PUSH
9561: LD_VAR 0 1
9565: DIFF
9566: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9567: LD_EXP 62
9571: PPUSH
9572: LD_VAR 0 1
9576: PPUSH
9577: LD_INT 1
9579: PPUSH
9580: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9584: LD_ADDR_EXP 53
9588: PUSH
9589: LD_EXP 53
9593: PUSH
9594: LD_INT 1
9596: PLUS
9597: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9598: LD_VAR 0 1
9602: PPUSH
9603: CALL_OW 255
9607: PUSH
9608: LD_INT 3
9610: EQUAL
9611: PUSH
9612: LD_VAR 0 1
9616: PUSH
9617: LD_EXP 60
9621: IN
9622: AND
9623: IFFALSE 9670
// begin for i in attackGroup do
9625: LD_ADDR_VAR 0 2
9629: PUSH
9630: LD_EXP 60
9634: PUSH
9635: FOR_IN
9636: IFFALSE 9668
// if i = human then
9638: LD_VAR 0 2
9642: PUSH
9643: LD_VAR 0 1
9647: EQUAL
9648: IFFALSE 9666
// attackGroup = attackGroup diff i ;
9650: LD_ADDR_EXP 60
9654: PUSH
9655: LD_EXP 60
9659: PUSH
9660: LD_VAR 0 2
9664: DIFF
9665: ST_TO_ADDR
9666: GO 9635
9668: POP
9669: POP
// end ; end ;
9670: PPOPN 3
9672: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9673: LD_VAR 0 1
9677: PUSH
9678: LD_EXP 8
9682: EQUAL
9683: IFFALSE 9704
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9685: LD_EXP 8
9689: PPUSH
9690: CALL_OW 310
9694: PPUSH
9695: LD_EXP 23
9699: PPUSH
9700: CALL_OW 235
// SetSide ( num , you ) ;
9704: LD_VAR 0 1
9708: PPUSH
9709: LD_EXP 23
9713: PPUSH
9714: CALL_OW 235
// end ;
9718: PPOPN 1
9720: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9721: LD_VAR 0 1
9725: PPUSH
9726: CALL_OW 255
9730: PUSH
9731: LD_EXP 24
9735: NONEQUAL
9736: IFFALSE 9748
// Artifact_cargo := un ;
9738: LD_ADDR_EXP 50
9742: PUSH
9743: LD_VAR 0 1
9747: ST_TO_ADDR
// end ; end_of_file
9748: PPOPN 2
9750: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9751: GO 9753
9753: DISABLE
9754: LD_INT 0
9756: PPUSH
9757: PPUSH
9758: PPUSH
9759: PPUSH
9760: PPUSH
9761: PPUSH
9762: PPUSH
// begin case tick of 0 .. 30000 :
9763: LD_OWVAR 1
9767: PUSH
9768: LD_INT 0
9770: DOUBLE
9771: GREATEREQUAL
9772: IFFALSE 9780
9774: LD_INT 30000
9776: DOUBLE
9777: LESSEQUAL
9778: IFTRUE 9782
9780: GO 9792
9782: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9783: LD_INT 1050
9785: PPUSH
9786: CALL_OW 67
9790: GO 9968
9792: LD_INT 30001
9794: DOUBLE
9795: GREATEREQUAL
9796: IFFALSE 9804
9798: LD_INT 50000
9800: DOUBLE
9801: LESSEQUAL
9802: IFTRUE 9806
9804: GO 9816
9806: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9807: LD_INT 1575
9809: PPUSH
9810: CALL_OW 67
9814: GO 9968
9816: LD_INT 50001
9818: DOUBLE
9819: GREATEREQUAL
9820: IFFALSE 9828
9822: LD_INT 70000
9824: DOUBLE
9825: LESSEQUAL
9826: IFTRUE 9830
9828: GO 9840
9830: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9831: LD_INT 2100
9833: PPUSH
9834: CALL_OW 67
9838: GO 9968
9840: LD_INT 70001
9842: DOUBLE
9843: GREATEREQUAL
9844: IFFALSE 9852
9846: LD_INT 90000
9848: DOUBLE
9849: LESSEQUAL
9850: IFTRUE 9854
9852: GO 9864
9854: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9855: LD_INT 2625
9857: PPUSH
9858: CALL_OW 67
9862: GO 9968
9864: LD_INT 70001
9866: DOUBLE
9867: GREATEREQUAL
9868: IFFALSE 9876
9870: LD_INT 90000
9872: DOUBLE
9873: LESSEQUAL
9874: IFTRUE 9878
9876: GO 9888
9878: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9879: LD_INT 3150
9881: PPUSH
9882: CALL_OW 67
9886: GO 9968
9888: LD_INT 90001
9890: DOUBLE
9891: GREATEREQUAL
9892: IFFALSE 9900
9894: LD_INT 110000
9896: DOUBLE
9897: LESSEQUAL
9898: IFTRUE 9902
9900: GO 9912
9902: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9903: LD_INT 3675
9905: PPUSH
9906: CALL_OW 67
9910: GO 9968
9912: LD_INT 110001
9914: DOUBLE
9915: GREATEREQUAL
9916: IFFALSE 9924
9918: LD_INT 130000
9920: DOUBLE
9921: LESSEQUAL
9922: IFTRUE 9926
9924: GO 9936
9926: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9927: LD_INT 4200
9929: PPUSH
9930: CALL_OW 67
9934: GO 9968
9936: LD_INT 130001
9938: DOUBLE
9939: GREATEREQUAL
9940: IFFALSE 9948
9942: LD_INT 150000
9944: DOUBLE
9945: LESSEQUAL
9946: IFTRUE 9950
9948: GO 9960
9950: POP
// Wait ( 2 2$15 ) ; else
9951: LD_INT 4725
9953: PPUSH
9954: CALL_OW 67
9958: GO 9968
9960: POP
// Wait ( 2 2$30 ) ; end ;
9961: LD_INT 5250
9963: PPUSH
9964: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9968: LD_ADDR_LOC 9
9972: PUSH
9973: LD_INT 22
9975: PUSH
9976: LD_INT 3
9978: PUSH
9979: LD_INT 1
9981: PUSH
9982: LD_INT 43
9984: PUSH
9985: EMPTY
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 23
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 1
9999: PUSH
10000: LD_INT 45
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: LIST
10007: LIST
10008: PUSH
10009: LD_INT 21
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 1
10017: PUSH
10018: LD_INT 43
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: LIST
10026: PUSH
10027: LD_INT 24
10029: PUSH
10030: LD_INT 3
10032: PUSH
10033: LD_INT 1
10035: PUSH
10036: LD_INT 45
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: LIST
10043: LIST
10044: PUSH
10045: LD_INT 21
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 1
10053: PUSH
10054: LD_INT 45
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: LIST
10061: LIST
10062: PUSH
10063: LD_INT 22
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 1
10071: PUSH
10072: LD_INT 44
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: PUSH
10081: LD_INT 24
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: LD_INT 46
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: PUSH
10099: LD_INT 23
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 3
10107: PUSH
10108: LD_INT 46
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: PUSH
10117: LD_INT 24
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 46
10128: PUSH
10129: EMPTY
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 23
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 47
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: PUSH
10153: LD_INT 24
10155: PUSH
10156: LD_INT 3
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 49
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 23
10173: PUSH
10174: LD_INT 3
10176: PUSH
10177: LD_INT 1
10179: PUSH
10180: LD_INT 49
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10203: LD_ADDR_VAR 0 1
10207: PUSH
10208: LD_INT 22
10210: PUSH
10211: LD_EXP 23
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 21
10222: PUSH
10223: LD_INT 2
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: PPUSH
10234: CALL_OW 69
10238: ST_TO_ADDR
// if filter < 3 then
10239: LD_VAR 0 1
10243: PUSH
10244: LD_INT 3
10246: LESS
10247: IFFALSE 10257
// filter := 3 ;
10249: LD_ADDR_VAR 0 1
10253: PUSH
10254: LD_INT 3
10256: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10257: LD_INT 22
10259: PUSH
10260: LD_INT 3
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: PUSH
10267: LD_INT 21
10269: PUSH
10270: LD_INT 2
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: EMPTY
10281: LIST
10282: PUSH
10283: LD_INT 2
10285: PUSH
10286: LD_INT 34
10288: PUSH
10289: LD_INT 43
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: LD_INT 34
10298: PUSH
10299: LD_INT 45
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: PUSH
10306: LD_INT 34
10308: PUSH
10309: LD_INT 44
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: PUSH
10316: LD_INT 34
10318: PUSH
10319: LD_INT 46
10321: PUSH
10322: EMPTY
10323: LIST
10324: LIST
10325: PUSH
10326: LD_INT 34
10328: PUSH
10329: LD_INT 47
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 34
10338: PUSH
10339: LD_INT 49
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: PPUSH
10361: CALL_OW 69
10365: PUSH
10366: LD_INT 6
10368: LESSEQUAL
10369: IFFALSE 10900
// for i := 1 to ( filter div 3 ) do
10371: LD_ADDR_VAR 0 2
10375: PUSH
10376: DOUBLE
10377: LD_INT 1
10379: DEC
10380: ST_TO_ADDR
10381: LD_VAR 0 1
10385: PUSH
10386: LD_INT 3
10388: DIV
10389: PUSH
10390: FOR_TO
10391: IFFALSE 10898
// begin uc_side := rus ;
10393: LD_ADDR_OWVAR 20
10397: PUSH
10398: LD_EXP 24
10402: ST_TO_ADDR
// uc_nation := nation_russian ;
10403: LD_ADDR_OWVAR 21
10407: PUSH
10408: LD_INT 3
10410: ST_TO_ADDR
// uc_direction := 5 ;
10411: LD_ADDR_OWVAR 24
10415: PUSH
10416: LD_INT 5
10418: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10419: LD_OWVAR 1
10423: PUSH
10424: LD_INT 60000
10426: LESS
10427: PUSH
10428: LD_INT 28
10430: PPUSH
10431: LD_EXP 23
10435: PPUSH
10436: CALL_OW 321
10440: PUSH
10441: LD_INT 2
10443: EQUAL
10444: OR
10445: IFFALSE 10471
// typ := rand ( 1 , vehicles - 2 ) else
10447: LD_ADDR_VAR 0 4
10451: PUSH
10452: LD_INT 1
10454: PPUSH
10455: LD_LOC 9
10459: PUSH
10460: LD_INT 2
10462: MINUS
10463: PPUSH
10464: CALL_OW 12
10468: ST_TO_ADDR
10469: GO 10489
// typ := rand ( 1 , vehicles ) ;
10471: LD_ADDR_VAR 0 4
10475: PUSH
10476: LD_INT 1
10478: PPUSH
10479: LD_LOC 9
10483: PPUSH
10484: CALL_OW 12
10488: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10489: LD_ADDR_OWVAR 37
10493: PUSH
10494: LD_LOC 9
10498: PUSH
10499: LD_VAR 0 4
10503: ARRAY
10504: PUSH
10505: LD_INT 1
10507: ARRAY
10508: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10509: LD_ADDR_OWVAR 38
10513: PUSH
10514: LD_LOC 9
10518: PUSH
10519: LD_VAR 0 4
10523: ARRAY
10524: PUSH
10525: LD_INT 2
10527: ARRAY
10528: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10529: LD_ADDR_OWVAR 39
10533: PUSH
10534: LD_LOC 9
10538: PUSH
10539: LD_VAR 0 4
10543: ARRAY
10544: PUSH
10545: LD_INT 3
10547: ARRAY
10548: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10549: LD_ADDR_OWVAR 40
10553: PUSH
10554: LD_LOC 9
10558: PUSH
10559: LD_VAR 0 4
10563: ARRAY
10564: PUSH
10565: LD_INT 4
10567: ARRAY
10568: ST_TO_ADDR
// auto := CreateVehicle ;
10569: LD_ADDR_VAR 0 5
10573: PUSH
10574: CALL_OW 45
10578: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10579: LD_VAR 0 5
10583: PPUSH
10584: LD_INT 9
10586: PPUSH
10587: LD_INT 0
10589: PPUSH
10590: CALL_OW 49
// attack := attack ^ auto ;
10594: LD_ADDR_LOC 10
10598: PUSH
10599: LD_LOC 10
10603: PUSH
10604: LD_VAR 0 5
10608: ADD
10609: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10610: LD_VAR 0 5
10614: PPUSH
10615: LD_INT 52
10617: PPUSH
10618: LD_INT 61
10620: PPUSH
10621: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10625: LD_VAR 0 5
10629: PPUSH
10630: LD_INT 52
10632: PPUSH
10633: LD_INT 61
10635: PPUSH
10636: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10640: LD_INT 1
10642: PPUSH
10643: LD_INT 2
10645: PPUSH
10646: CALL_OW 12
10650: PUSH
10651: LD_INT 1
10653: DOUBLE
10654: EQUAL
10655: IFTRUE 10659
10657: GO 10677
10659: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10660: LD_VAR 0 5
10664: PPUSH
10665: LD_INT 35
10667: PPUSH
10668: LD_INT 30
10670: PPUSH
10671: CALL_OW 174
10675: GO 10704
10677: LD_INT 2
10679: DOUBLE
10680: EQUAL
10681: IFTRUE 10685
10683: GO 10703
10685: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10686: LD_VAR 0 5
10690: PPUSH
10691: LD_INT 17
10693: PPUSH
10694: LD_INT 29
10696: PPUSH
10697: CALL_OW 174
10701: GO 10704
10703: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10704: LD_VAR 0 5
10708: PPUSH
10709: LD_INT 29
10711: PPUSH
10712: LD_INT 5
10714: PPUSH
10715: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10719: LD_INT 1
10721: PPUSH
10722: LD_INT 2
10724: PPUSH
10725: CALL_OW 12
10729: PUSH
10730: LD_INT 1
10732: DOUBLE
10733: EQUAL
10734: IFTRUE 10738
10736: GO 10756
10738: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10739: LD_VAR 0 5
10743: PPUSH
10744: LD_INT 60
10746: PPUSH
10747: LD_INT 30
10749: PPUSH
10750: CALL_OW 174
10754: GO 10783
10756: LD_INT 2
10758: DOUBLE
10759: EQUAL
10760: IFTRUE 10764
10762: GO 10782
10764: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10765: LD_VAR 0 5
10769: PPUSH
10770: LD_INT 84
10772: PPUSH
10773: LD_INT 30
10775: PPUSH
10776: CALL_OW 174
10780: GO 10783
10782: POP
// case Rand ( 1 , 2 ) of 1 :
10783: LD_INT 1
10785: PPUSH
10786: LD_INT 2
10788: PPUSH
10789: CALL_OW 12
10793: PUSH
10794: LD_INT 1
10796: DOUBLE
10797: EQUAL
10798: IFTRUE 10802
10800: GO 10820
10802: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10803: LD_VAR 0 5
10807: PPUSH
10808: LD_INT 71
10810: PPUSH
10811: LD_INT 59
10813: PPUSH
10814: CALL_OW 174
10818: GO 10847
10820: LD_INT 2
10822: DOUBLE
10823: EQUAL
10824: IFTRUE 10828
10826: GO 10846
10828: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10829: LD_VAR 0 5
10833: PPUSH
10834: LD_INT 92
10836: PPUSH
10837: LD_INT 66
10839: PPUSH
10840: CALL_OW 174
10844: GO 10847
10846: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10847: LD_VAR 0 5
10851: PPUSH
10852: LD_INT 78
10854: PPUSH
10855: LD_INT 88
10857: PPUSH
10858: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10862: LD_VAR 0 5
10866: PPUSH
10867: LD_INT 117
10869: PPUSH
10870: LD_INT 90
10872: PPUSH
10873: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10877: LD_VAR 0 5
10881: PPUSH
10882: LD_INT 15
10884: PPUSH
10885: CALL_OW 173
// Wait ( 0 0$4 ) ;
10889: LD_INT 140
10891: PPUSH
10892: CALL_OW 67
// end ;
10896: GO 10390
10898: POP
10899: POP
// enable ;
10900: ENABLE
// end ;
10901: PPOPN 7
10903: END
// export function PrepareInfantry ; var i , clovek ; begin
10904: LD_INT 0
10906: PPUSH
10907: PPUSH
10908: PPUSH
// for i = 1 to 6 do
10909: LD_ADDR_VAR 0 2
10913: PUSH
10914: DOUBLE
10915: LD_INT 1
10917: DEC
10918: ST_TO_ADDR
10919: LD_INT 6
10921: PUSH
10922: FOR_TO
10923: IFFALSE 11100
// begin uc_side = 3 ;
10925: LD_ADDR_OWVAR 20
10929: PUSH
10930: LD_INT 3
10932: ST_TO_ADDR
// uc_nation = 3 ;
10933: LD_ADDR_OWVAR 21
10937: PUSH
10938: LD_INT 3
10940: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10941: LD_INT 1
10943: PPUSH
10944: LD_INT 3
10946: PPUSH
10947: CALL_OW 12
10951: PUSH
10952: LD_INT 1
10954: DOUBLE
10955: EQUAL
10956: IFTRUE 10960
10958: GO 10990
10960: POP
// PrepareHuman ( sex_male , class_soldier , rand ( 3 , 5 + Difficulty ) ) ; 2 .. 3 :
10961: LD_INT 1
10963: PPUSH
10964: LD_INT 1
10966: PPUSH
10967: LD_INT 3
10969: PPUSH
10970: LD_INT 5
10972: PUSH
10973: LD_OWVAR 67
10977: PLUS
10978: PPUSH
10979: CALL_OW 12
10983: PPUSH
10984: CALL_OW 380
10988: GO 11035
10990: LD_INT 2
10992: DOUBLE
10993: GREATEREQUAL
10994: IFFALSE 11002
10996: LD_INT 3
10998: DOUBLE
10999: LESSEQUAL
11000: IFTRUE 11004
11002: GO 11034
11004: POP
// PrepareHuman ( sex_male , class_bazooker , rand ( 3 , 4 + Difficulty ) ) ; end ;
11005: LD_INT 1
11007: PPUSH
11008: LD_INT 9
11010: PPUSH
11011: LD_INT 3
11013: PPUSH
11014: LD_INT 4
11016: PUSH
11017: LD_OWVAR 67
11021: PLUS
11022: PPUSH
11023: CALL_OW 12
11027: PPUSH
11028: CALL_OW 380
11032: GO 11035
11034: POP
// hc_name :=  ;
11035: LD_ADDR_OWVAR 26
11039: PUSH
11040: LD_STRING 
11042: ST_TO_ADDR
// clovek := CreateHuman ;
11043: LD_ADDR_VAR 0 3
11047: PUSH
11048: CALL_OW 44
11052: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
11053: LD_VAR 0 3
11057: PPUSH
11058: LD_INT 9
11060: PPUSH
11061: LD_INT 0
11063: PPUSH
11064: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11068: LD_ADDR_EXP 59
11072: PUSH
11073: LD_EXP 59
11077: PUSH
11078: LD_INT 1
11080: MINUS
11081: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11082: LD_ADDR_EXP 60
11086: PUSH
11087: LD_EXP 60
11091: PUSH
11092: LD_VAR 0 3
11096: ADD
11097: ST_TO_ADDR
// end ;
11098: GO 10922
11100: POP
11101: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11102: LD_EXP 60
11106: PPUSH
11107: LD_INT 52
11109: PPUSH
11110: LD_INT 61
11112: PPUSH
11113: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11117: LD_INT 1
11119: PPUSH
11120: LD_INT 2
11122: PPUSH
11123: CALL_OW 12
11127: PUSH
11128: LD_INT 1
11130: DOUBLE
11131: EQUAL
11132: IFTRUE 11136
11134: GO 11154
11136: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11137: LD_EXP 60
11141: PPUSH
11142: LD_INT 35
11144: PPUSH
11145: LD_INT 30
11147: PPUSH
11148: CALL_OW 174
11152: GO 11181
11154: LD_INT 2
11156: DOUBLE
11157: EQUAL
11158: IFTRUE 11162
11160: GO 11180
11162: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11163: LD_EXP 60
11167: PPUSH
11168: LD_INT 17
11170: PPUSH
11171: LD_INT 29
11173: PPUSH
11174: CALL_OW 174
11178: GO 11181
11180: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11181: LD_EXP 60
11185: PPUSH
11186: LD_INT 29
11188: PPUSH
11189: LD_INT 5
11191: PPUSH
11192: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11196: LD_INT 1
11198: PPUSH
11199: LD_INT 2
11201: PPUSH
11202: CALL_OW 12
11206: PUSH
11207: LD_INT 1
11209: DOUBLE
11210: EQUAL
11211: IFTRUE 11215
11213: GO 11233
11215: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11216: LD_EXP 60
11220: PPUSH
11221: LD_INT 60
11223: PPUSH
11224: LD_INT 30
11226: PPUSH
11227: CALL_OW 174
11231: GO 11260
11233: LD_INT 2
11235: DOUBLE
11236: EQUAL
11237: IFTRUE 11241
11239: GO 11259
11241: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11242: LD_EXP 60
11246: PPUSH
11247: LD_INT 84
11249: PPUSH
11250: LD_INT 30
11252: PPUSH
11253: CALL_OW 174
11257: GO 11260
11259: POP
// case Rand ( 1 , 2 ) of 1 :
11260: LD_INT 1
11262: PPUSH
11263: LD_INT 2
11265: PPUSH
11266: CALL_OW 12
11270: PUSH
11271: LD_INT 1
11273: DOUBLE
11274: EQUAL
11275: IFTRUE 11279
11277: GO 11297
11279: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11280: LD_EXP 60
11284: PPUSH
11285: LD_INT 71
11287: PPUSH
11288: LD_INT 59
11290: PPUSH
11291: CALL_OW 174
11295: GO 11324
11297: LD_INT 2
11299: DOUBLE
11300: EQUAL
11301: IFTRUE 11305
11303: GO 11323
11305: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11306: LD_EXP 60
11310: PPUSH
11311: LD_INT 92
11313: PPUSH
11314: LD_INT 66
11316: PPUSH
11317: CALL_OW 174
11321: GO 11324
11323: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11324: LD_EXP 60
11328: PPUSH
11329: LD_INT 78
11331: PPUSH
11332: LD_INT 88
11334: PPUSH
11335: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11339: LD_EXP 60
11343: PPUSH
11344: LD_INT 117
11346: PPUSH
11347: LD_INT 90
11349: PPUSH
11350: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11354: LD_EXP 60
11358: PPUSH
11359: LD_INT 15
11361: PPUSH
11362: CALL_OW 173
// end ;
11366: LD_VAR 0 1
11370: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11371: LD_EXP 60
11375: PUSH
11376: EMPTY
11377: EQUAL
11378: PUSH
11379: LD_EXP 61
11383: PUSH
11384: LD_INT 1
11386: EQUAL
11387: AND
11388: IFFALSE 11398
11390: GO 11392
11392: DISABLE
// begin enable ;
11393: ENABLE
// PrepareInfantry ;
11394: CALL 10904 0 0
// end ;
11398: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11399: GO 11401
11401: DISABLE
11402: LD_INT 0
11404: PPUSH
11405: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11406: LD_ADDR_VAR 0 1
11410: PUSH
11411: LD_INT 15
11413: PPUSH
11414: LD_INT 22
11416: PUSH
11417: LD_EXP 24
11421: PUSH
11422: EMPTY
11423: LIST
11424: LIST
11425: PUSH
11426: LD_INT 50
11428: PUSH
11429: EMPTY
11430: LIST
11431: PUSH
11432: LD_INT 2
11434: PUSH
11435: LD_INT 21
11437: PUSH
11438: LD_INT 2
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: PUSH
11445: LD_INT 21
11447: PUSH
11448: LD_INT 1
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PUSH
11455: EMPTY
11456: LIST
11457: LIST
11458: LIST
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: LIST
11464: PPUSH
11465: CALL_OW 70
11469: ST_TO_ADDR
// case tick of 0 .. 30000 :
11470: LD_OWVAR 1
11474: PUSH
11475: LD_INT 0
11477: DOUBLE
11478: GREATEREQUAL
11479: IFFALSE 11487
11481: LD_INT 30000
11483: DOUBLE
11484: LESSEQUAL
11485: IFTRUE 11489
11487: GO 11506
11489: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11490: LD_ADDR_VAR 0 2
11494: PUSH
11495: LD_EXP 34
11499: PUSH
11500: LD_INT 4
11502: MINUS
11503: ST_TO_ADDR
11504: GO 11610
11506: LD_INT 30001
11508: DOUBLE
11509: GREATEREQUAL
11510: IFFALSE 11518
11512: LD_INT 50000
11514: DOUBLE
11515: LESSEQUAL
11516: IFTRUE 11520
11518: GO 11537
11520: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11521: LD_ADDR_VAR 0 2
11525: PUSH
11526: LD_EXP 34
11530: PUSH
11531: LD_INT 3
11533: MINUS
11534: ST_TO_ADDR
11535: GO 11610
11537: LD_INT 50001
11539: DOUBLE
11540: GREATEREQUAL
11541: IFFALSE 11549
11543: LD_INT 70000
11545: DOUBLE
11546: LESSEQUAL
11547: IFTRUE 11551
11549: GO 11568
11551: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11552: LD_ADDR_VAR 0 2
11556: PUSH
11557: LD_EXP 34
11561: PUSH
11562: LD_INT 2
11564: MINUS
11565: ST_TO_ADDR
11566: GO 11610
11568: LD_INT 70001
11570: DOUBLE
11571: GREATEREQUAL
11572: IFFALSE 11580
11574: LD_INT 90000
11576: DOUBLE
11577: LESSEQUAL
11578: IFTRUE 11582
11580: GO 11599
11582: POP
// mnozstvi := maxaut - 1 ; else
11583: LD_ADDR_VAR 0 2
11587: PUSH
11588: LD_EXP 34
11592: PUSH
11593: LD_INT 1
11595: MINUS
11596: ST_TO_ADDR
11597: GO 11610
11599: POP
// mnozstvi := maxaut ; end ;
11600: LD_ADDR_VAR 0 2
11604: PUSH
11605: LD_EXP 34
11609: ST_TO_ADDR
// if filter >= mnozstvi then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_VAR 0 2
11619: GREATEREQUAL
11620: IFFALSE 11637
// ComMoveXY ( filter , 138 , 69 ) ;
11622: LD_VAR 0 1
11626: PPUSH
11627: LD_INT 138
11629: PPUSH
11630: LD_INT 69
11632: PPUSH
11633: CALL_OW 111
// enable ;
11637: ENABLE
// end ;
11638: PPOPN 2
11640: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11641: GO 11643
11643: DISABLE
11644: LD_INT 0
11646: PPUSH
11647: PPUSH
11648: PPUSH
11649: PPUSH
11650: PPUSH
11651: PPUSH
// begin enable ;
11652: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11653: LD_ADDR_VAR 0 1
11657: PUSH
11658: LD_INT 12
11660: PPUSH
11661: LD_INT 22
11663: PUSH
11664: LD_EXP 24
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: LD_INT 50
11675: PUSH
11676: EMPTY
11677: LIST
11678: PUSH
11679: LD_INT 3
11681: PUSH
11682: LD_INT 34
11684: PUSH
11685: LD_INT 49
11687: PUSH
11688: EMPTY
11689: LIST
11690: LIST
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: LIST
11700: PPUSH
11701: CALL_OW 70
11705: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11706: LD_INT 33
11708: PPUSH
11709: LD_EXP 23
11713: PPUSH
11714: CALL_OW 321
11718: PUSH
11719: LD_INT 2
11721: EQUAL
11722: IFFALSE 11776
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11724: LD_ADDR_VAR 0 2
11728: PUSH
11729: LD_INT 12
11731: PPUSH
11732: LD_INT 22
11734: PUSH
11735: LD_EXP 23
11739: PUSH
11740: EMPTY
11741: LIST
11742: LIST
11743: PUSH
11744: LD_INT 25
11746: PUSH
11747: LD_INT 4
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 101
11756: PUSH
11757: LD_EXP 24
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: LIST
11770: PPUSH
11771: CALL_OW 70
11775: ST_TO_ADDR
// if filter_you = 0 then
11776: LD_VAR 0 2
11780: PUSH
11781: LD_INT 0
11783: EQUAL
11784: IFFALSE 11893
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11786: LD_ADDR_VAR 0 2
11790: PUSH
11791: LD_INT 22
11793: PUSH
11794: LD_EXP 23
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PUSH
11803: LD_INT 50
11805: PUSH
11806: EMPTY
11807: LIST
11808: PUSH
11809: LD_INT 2
11811: PUSH
11812: LD_INT 21
11814: PUSH
11815: LD_INT 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 21
11824: PUSH
11825: LD_INT 2
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 21
11834: PUSH
11835: LD_INT 3
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PPUSH
11853: CALL_OW 69
11857: ST_TO_ADDR
// if filter_you = 0 then
11858: LD_VAR 0 2
11862: PUSH
11863: LD_INT 0
11865: EQUAL
11866: IFFALSE 11893
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11868: LD_ADDR_VAR 0 2
11872: PUSH
11873: LD_INT 12
11875: PPUSH
11876: LD_INT 22
11878: PUSH
11879: LD_EXP 23
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: PPUSH
11888: CALL_OW 70
11892: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11893: LD_VAR 0 1
11897: PUSH
11898: LD_INT 0
11900: GREATER
11901: PUSH
11902: LD_VAR 0 2
11906: PUSH
11907: LD_INT 0
11909: GREATER
11910: AND
11911: IFFALSE 12302
// begin for un_rus in filter_rus do
11913: LD_ADDR_VAR 0 3
11917: PUSH
11918: LD_VAR 0 1
11922: PUSH
11923: FOR_IN
11924: IFFALSE 12300
// begin Wait ( 5 ) ;
11926: LD_INT 5
11928: PPUSH
11929: CALL_OW 67
// min := 99999 ;
11933: LD_ADDR_VAR 0 5
11937: PUSH
11938: LD_INT 99999
11940: ST_TO_ADDR
// cil := 0 ;
11941: LD_ADDR_VAR 0 6
11945: PUSH
11946: LD_INT 0
11948: ST_TO_ADDR
// for un_you in filter_you do
11949: LD_ADDR_VAR 0 4
11953: PUSH
11954: LD_VAR 0 2
11958: PUSH
11959: FOR_IN
11960: IFFALSE 12156
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11962: LD_VAR 0 4
11966: PPUSH
11967: CALL_OW 320
11971: PUSH
11972: LD_VAR 0 4
11976: PPUSH
11977: CALL_OW 256
11981: PUSH
11982: LD_VAR 0 5
11986: LESS
11987: AND
11988: PUSH
11989: LD_VAR 0 3
11993: PPUSH
11994: LD_VAR 0 4
11998: PPUSH
11999: CALL_OW 296
12003: PUSH
12004: LD_INT 2
12006: PUSH
12007: LD_INT 2
12009: PUSH
12010: LD_INT 4
12012: PUSH
12013: LD_INT 6
12015: PUSH
12016: LD_INT 5
12018: PUSH
12019: LD_INT 9
12021: PUSH
12022: LD_INT 0
12024: PUSH
12025: LD_INT 2
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: LIST
12036: LIST
12037: PUSH
12038: LD_VAR 0 3
12042: PPUSH
12043: CALL_OW 264
12047: PUSH
12048: LD_INT 41
12050: MINUS
12051: ARRAY
12052: GREATEREQUAL
12053: AND
12054: PUSH
12055: LD_VAR 0 3
12059: PPUSH
12060: LD_VAR 0 4
12064: PPUSH
12065: CALL_OW 296
12069: PUSH
12070: LD_INT 15
12072: PUSH
12073: LD_INT 16
12075: PUSH
12076: LD_INT 17
12078: PUSH
12079: LD_INT 22
12081: PUSH
12082: LD_INT 20
12084: PUSH
12085: LD_INT 28
12087: PUSH
12088: LD_INT 0
12090: PUSH
12091: LD_INT 51
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: LIST
12098: LIST
12099: LIST
12100: LIST
12101: LIST
12102: LIST
12103: PUSH
12104: LD_VAR 0 3
12108: PPUSH
12109: CALL_OW 264
12113: PUSH
12114: LD_INT 41
12116: MINUS
12117: ARRAY
12118: LESSEQUAL
12119: AND
12120: IFFALSE 12147
// begin min := GetLives ( un_you ) ;
12122: LD_ADDR_VAR 0 5
12126: PUSH
12127: LD_VAR 0 4
12131: PPUSH
12132: CALL_OW 256
12136: ST_TO_ADDR
// cil := un_you ;
12137: LD_ADDR_VAR 0 6
12141: PUSH
12142: LD_VAR 0 4
12146: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12147: LD_INT 5
12149: PPUSH
12150: CALL_OW 67
// end ;
12154: GO 11959
12156: POP
12157: POP
// if cil <> 0 then
12158: LD_VAR 0 6
12162: PUSH
12163: LD_INT 0
12165: NONEQUAL
12166: IFFALSE 12184
// ComAttackUnit ( un_rus , cil ) else
12168: LD_VAR 0 3
12172: PPUSH
12173: LD_VAR 0 6
12177: PPUSH
12178: CALL_OW 115
12182: GO 12298
// begin for un_you in filter_you do
12184: LD_ADDR_VAR 0 4
12188: PUSH
12189: LD_VAR 0 2
12193: PUSH
12194: FOR_IN
12195: IFFALSE 12282
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12197: LD_VAR 0 4
12201: PPUSH
12202: CALL_OW 266
12206: PUSH
12207: LD_INT 0
12209: PUSH
12210: LD_INT 1
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: IN
12217: IFFALSE 12231
// cil := un_you else
12219: LD_ADDR_VAR 0 6
12223: PUSH
12224: LD_VAR 0 4
12228: ST_TO_ADDR
12229: GO 12273
// if GetLives ( un_you ) < min then
12231: LD_VAR 0 4
12235: PPUSH
12236: CALL_OW 256
12240: PUSH
12241: LD_VAR 0 5
12245: LESS
12246: IFFALSE 12273
// begin min := GetLives ( un_you ) ;
12248: LD_ADDR_VAR 0 5
12252: PUSH
12253: LD_VAR 0 4
12257: PPUSH
12258: CALL_OW 256
12262: ST_TO_ADDR
// cil := un_you ;
12263: LD_ADDR_VAR 0 6
12267: PUSH
12268: LD_VAR 0 4
12272: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12273: LD_INT 5
12275: PPUSH
12276: CALL_OW 67
// end ;
12280: GO 12194
12282: POP
12283: POP
// ComAttackUnit ( un_rus , cil ) end ;
12284: LD_VAR 0 3
12288: PPUSH
12289: LD_VAR 0 6
12293: PPUSH
12294: CALL_OW 115
// end ;
12298: GO 11923
12300: POP
12301: POP
// end ; end ;
12302: PPOPN 6
12304: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12305: GO 12307
12307: DISABLE
12308: LD_INT 0
12310: PPUSH
12311: PPUSH
12312: PPUSH
12313: PPUSH
12314: PPUSH
12315: PPUSH
// begin enable ;
12316: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12317: LD_ADDR_VAR 0 1
12321: PUSH
12322: LD_INT 21
12324: PPUSH
12325: LD_INT 22
12327: PUSH
12328: LD_EXP 24
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 3
12339: PUSH
12340: LD_INT 2
12342: PUSH
12343: LD_INT 21
12345: PUSH
12346: LD_INT 3
12348: PUSH
12349: EMPTY
12350: LIST
12351: LIST
12352: PUSH
12353: LD_INT 34
12355: PUSH
12356: LD_INT 49
12358: PUSH
12359: EMPTY
12360: LIST
12361: LIST
12362: PUSH
12363: LD_INT 34
12365: PUSH
12366: LD_INT 51
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PUSH
12373: LD_INT 25
12375: PUSH
12376: LD_INT 4
12378: PUSH
12379: EMPTY
12380: LIST
12381: LIST
12382: PUSH
12383: LD_INT 25
12385: PUSH
12386: LD_INT 2
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_INT 54
12395: PUSH
12396: EMPTY
12397: LIST
12398: PUSH
12399: EMPTY
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: LIST
12412: PPUSH
12413: CALL_OW 70
12417: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12418: LD_ADDR_VAR 0 1
12422: PUSH
12423: LD_VAR 0 1
12427: PUSH
12428: LD_EXP 45
12432: DIFF
12433: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12434: LD_ADDR_VAR 0 2
12438: PUSH
12439: LD_INT 21
12441: PPUSH
12442: LD_INT 22
12444: PUSH
12445: LD_EXP 23
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: PUSH
12454: LD_INT 21
12456: PUSH
12457: LD_INT 2
12459: PUSH
12460: EMPTY
12461: LIST
12462: LIST
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PPUSH
12468: CALL_OW 70
12472: ST_TO_ADDR
// if not filter_you then
12473: LD_VAR 0 2
12477: NOT
12478: IFFALSE 12551
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12480: LD_ADDR_VAR 0 2
12484: PUSH
12485: LD_INT 21
12487: PPUSH
12488: LD_INT 22
12490: PUSH
12491: LD_EXP 23
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: LD_INT 25
12502: PUSH
12503: LD_INT 4
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PPUSH
12514: CALL_OW 70
12518: ST_TO_ADDR
// if not filter_you then
12519: LD_VAR 0 2
12523: NOT
12524: IFFALSE 12551
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12526: LD_ADDR_VAR 0 2
12530: PUSH
12531: LD_INT 21
12533: PPUSH
12534: LD_INT 22
12536: PUSH
12537: LD_EXP 23
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PPUSH
12546: CALL_OW 70
12550: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12551: LD_VAR 0 1
12555: PUSH
12556: LD_INT 0
12558: GREATER
12559: PUSH
12560: LD_VAR 0 2
12564: PUSH
12565: LD_INT 0
12567: GREATER
12568: AND
12569: IFFALSE 12960
// begin for un_rus in filter_rus do
12571: LD_ADDR_VAR 0 3
12575: PUSH
12576: LD_VAR 0 1
12580: PUSH
12581: FOR_IN
12582: IFFALSE 12958
// begin Wait ( 5 ) ;
12584: LD_INT 5
12586: PPUSH
12587: CALL_OW 67
// min := 99999 ;
12591: LD_ADDR_VAR 0 5
12595: PUSH
12596: LD_INT 99999
12598: ST_TO_ADDR
// cil := 0 ;
12599: LD_ADDR_VAR 0 6
12603: PUSH
12604: LD_INT 0
12606: ST_TO_ADDR
// for un_you in filter_you do
12607: LD_ADDR_VAR 0 4
12611: PUSH
12612: LD_VAR 0 2
12616: PUSH
12617: FOR_IN
12618: IFFALSE 12814
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12620: LD_VAR 0 4
12624: PPUSH
12625: CALL_OW 302
12629: PUSH
12630: LD_VAR 0 4
12634: PPUSH
12635: CALL_OW 256
12639: PUSH
12640: LD_VAR 0 5
12644: LESS
12645: AND
12646: PUSH
12647: LD_VAR 0 3
12651: PPUSH
12652: LD_VAR 0 4
12656: PPUSH
12657: CALL_OW 296
12661: PUSH
12662: LD_INT 2
12664: PUSH
12665: LD_INT 2
12667: PUSH
12668: LD_INT 4
12670: PUSH
12671: LD_INT 6
12673: PUSH
12674: LD_INT 5
12676: PUSH
12677: LD_INT 9
12679: PUSH
12680: LD_INT 0
12682: PUSH
12683: LD_INT 2
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: LIST
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: LIST
12695: PUSH
12696: LD_VAR 0 3
12700: PPUSH
12701: CALL_OW 264
12705: PUSH
12706: LD_INT 41
12708: MINUS
12709: ARRAY
12710: GREATEREQUAL
12711: AND
12712: PUSH
12713: LD_VAR 0 3
12717: PPUSH
12718: LD_VAR 0 4
12722: PPUSH
12723: CALL_OW 296
12727: PUSH
12728: LD_INT 15
12730: PUSH
12731: LD_INT 16
12733: PUSH
12734: LD_INT 17
12736: PUSH
12737: LD_INT 22
12739: PUSH
12740: LD_INT 20
12742: PUSH
12743: LD_INT 28
12745: PUSH
12746: LD_INT 0
12748: PUSH
12749: LD_INT 51
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: LIST
12761: PUSH
12762: LD_VAR 0 3
12766: PPUSH
12767: CALL_OW 264
12771: PUSH
12772: LD_INT 41
12774: MINUS
12775: ARRAY
12776: LESSEQUAL
12777: AND
12778: IFFALSE 12805
// begin min := GetLives ( un_you ) ;
12780: LD_ADDR_VAR 0 5
12784: PUSH
12785: LD_VAR 0 4
12789: PPUSH
12790: CALL_OW 256
12794: ST_TO_ADDR
// cil := un_you ;
12795: LD_ADDR_VAR 0 6
12799: PUSH
12800: LD_VAR 0 4
12804: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12805: LD_INT 5
12807: PPUSH
12808: CALL_OW 67
// end ;
12812: GO 12617
12814: POP
12815: POP
// if cil <> 0 then
12816: LD_VAR 0 6
12820: PUSH
12821: LD_INT 0
12823: NONEQUAL
12824: IFFALSE 12842
// ComAttackUnit ( un_rus , cil ) else
12826: LD_VAR 0 3
12830: PPUSH
12831: LD_VAR 0 6
12835: PPUSH
12836: CALL_OW 115
12840: GO 12956
// begin for un_you in filter_you do
12842: LD_ADDR_VAR 0 4
12846: PUSH
12847: LD_VAR 0 2
12851: PUSH
12852: FOR_IN
12853: IFFALSE 12940
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12855: LD_VAR 0 4
12859: PPUSH
12860: CALL_OW 266
12864: PUSH
12865: LD_INT 0
12867: PUSH
12868: LD_INT 1
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: IN
12875: IFFALSE 12889
// cil := un_you else
12877: LD_ADDR_VAR 0 6
12881: PUSH
12882: LD_VAR 0 4
12886: ST_TO_ADDR
12887: GO 12931
// if GetLives ( un_you ) < min then
12889: LD_VAR 0 4
12893: PPUSH
12894: CALL_OW 256
12898: PUSH
12899: LD_VAR 0 5
12903: LESS
12904: IFFALSE 12931
// begin min := GetLives ( un_you ) ;
12906: LD_ADDR_VAR 0 5
12910: PUSH
12911: LD_VAR 0 4
12915: PPUSH
12916: CALL_OW 256
12920: ST_TO_ADDR
// cil := un_you ;
12921: LD_ADDR_VAR 0 6
12925: PUSH
12926: LD_VAR 0 4
12930: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12931: LD_INT 5
12933: PPUSH
12934: CALL_OW 67
// end ;
12938: GO 12852
12940: POP
12941: POP
// ComAttackUnit ( un_rus , cil ) end ;
12942: LD_VAR 0 3
12946: PPUSH
12947: LD_VAR 0 6
12951: PPUSH
12952: CALL_OW 115
// end ;
12956: GO 12581
12958: POP
12959: POP
// end ; end ;
12960: PPOPN 6
12962: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12963: GO 12965
12965: DISABLE
12966: LD_INT 0
12968: PPUSH
12969: PPUSH
12970: PPUSH
12971: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12972: LD_INT 28
12974: PPUSH
12975: LD_EXP 23
12979: PPUSH
12980: CALL_OW 321
12984: PUSH
12985: LD_INT 2
12987: EQUAL
12988: NOT
12989: IFFALSE 12992
// enable ;
12991: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
12992: LD_ADDR_VAR 0 1
12996: PUSH
12997: LD_INT 12
12999: PPUSH
13000: LD_INT 22
13002: PUSH
13003: LD_EXP 24
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: LD_INT 50
13014: PUSH
13015: EMPTY
13016: LIST
13017: PUSH
13018: LD_INT 34
13020: PUSH
13021: LD_INT 49
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: PPUSH
13033: CALL_OW 70
13037: ST_TO_ADDR
// if filter_rus > 0 then
13038: LD_VAR 0 1
13042: PUSH
13043: LD_INT 0
13045: GREATER
13046: IFFALSE 13087
// for un_rus in filter_rus do
13048: LD_ADDR_VAR 0 3
13052: PUSH
13053: LD_VAR 0 1
13057: PUSH
13058: FOR_IN
13059: IFFALSE 13085
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
13061: LD_VAR 0 3
13065: PPUSH
13066: LD_INT 122
13068: PPUSH
13069: LD_INT 27
13071: PPUSH
13072: CALL_OW 111
// Wait ( 5 ) ;
13076: LD_INT 5
13078: PPUSH
13079: CALL_OW 67
// end ;
13083: GO 13058
13085: POP
13086: POP
// end ;
13087: PPOPN 4
13089: END
// every 1 1$0 + 0 0$5.5 do
13090: GO 13092
13092: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13093: LD_INT 59
13095: PPUSH
13096: LD_EXP 24
13100: PPUSH
13101: CALL_OW 321
13105: PUSH
13106: LD_INT 2
13108: EQUAL
13109: NOT
13110: PUSH
13111: LD_OWVAR 1
13115: PUSH
13116: LD_EXP 54
13120: GREATEREQUAL
13121: AND
13122: IFFALSE 13139
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13124: LD_INT 59
13126: PPUSH
13127: LD_EXP 24
13131: PPUSH
13132: LD_INT 2
13134: PPUSH
13135: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13139: LD_INT 50
13141: PPUSH
13142: LD_EXP 24
13146: PPUSH
13147: CALL_OW 321
13151: PUSH
13152: LD_INT 2
13154: EQUAL
13155: NOT
13156: PUSH
13157: LD_OWVAR 1
13161: PUSH
13162: LD_EXP 55
13166: GREATEREQUAL
13167: AND
13168: IFFALSE 13185
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13170: LD_INT 50
13172: PPUSH
13173: LD_EXP 24
13177: PPUSH
13178: LD_INT 2
13180: PPUSH
13181: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13185: LD_INT 53
13187: PPUSH
13188: LD_EXP 24
13192: PPUSH
13193: CALL_OW 321
13197: PUSH
13198: LD_INT 2
13200: EQUAL
13201: NOT
13202: PUSH
13203: LD_OWVAR 1
13207: PUSH
13208: LD_EXP 56
13212: GREATEREQUAL
13213: AND
13214: IFFALSE 13231
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13216: LD_INT 53
13218: PPUSH
13219: LD_EXP 24
13223: PPUSH
13224: LD_INT 2
13226: PPUSH
13227: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13231: LD_INT 56
13233: PPUSH
13234: LD_EXP 24
13238: PPUSH
13239: CALL_OW 321
13243: PUSH
13244: LD_INT 2
13246: EQUAL
13247: NOT
13248: PUSH
13249: LD_OWVAR 1
13253: PUSH
13254: LD_EXP 57
13258: GREATEREQUAL
13259: AND
13260: IFFALSE 13277
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13262: LD_INT 56
13264: PPUSH
13265: LD_EXP 24
13269: PPUSH
13270: LD_INT 2
13272: PPUSH
13273: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13277: LD_INT 65
13279: PPUSH
13280: LD_EXP 24
13284: PPUSH
13285: CALL_OW 321
13289: PUSH
13290: LD_INT 2
13292: EQUAL
13293: NOT
13294: PUSH
13295: LD_OWVAR 1
13299: PUSH
13300: LD_EXP 58
13304: GREATEREQUAL
13305: AND
13306: IFFALSE 13323
// SetTech ( tech_ST3 , rus , state_researched ) ;
13308: LD_INT 65
13310: PPUSH
13311: LD_EXP 24
13315: PPUSH
13316: LD_INT 2
13318: PPUSH
13319: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13323: LD_INT 59
13325: PPUSH
13326: LD_EXP 24
13330: PPUSH
13331: CALL_OW 321
13335: PUSH
13336: LD_INT 2
13338: EQUAL
13339: PUSH
13340: LD_INT 50
13342: PPUSH
13343: LD_EXP 24
13347: PPUSH
13348: CALL_OW 321
13352: PUSH
13353: LD_INT 2
13355: EQUAL
13356: AND
13357: PUSH
13358: LD_INT 53
13360: PPUSH
13361: LD_EXP 24
13365: PPUSH
13366: CALL_OW 321
13370: PUSH
13371: LD_INT 2
13373: EQUAL
13374: AND
13375: PUSH
13376: LD_INT 56
13378: PPUSH
13379: LD_EXP 24
13383: PPUSH
13384: CALL_OW 321
13388: PUSH
13389: LD_INT 2
13391: EQUAL
13392: AND
13393: PUSH
13394: LD_INT 65
13396: PPUSH
13397: LD_EXP 24
13401: PPUSH
13402: CALL_OW 321
13406: PUSH
13407: LD_INT 2
13409: EQUAL
13410: AND
13411: NOT
13412: IFFALSE 13415
// enable ;
13414: ENABLE
// end ; end_of_file
13415: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13416: GO 13418
13418: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13419: LD_ADDR_EXP 63
13423: PUSH
13424: LD_INT 14
13426: PUSH
13427: LD_INT 18
13429: PUSH
13430: LD_INT 19
13432: PUSH
13433: LD_INT 20
13435: PUSH
13436: LD_INT 21
13438: PUSH
13439: LD_INT 22
13441: PUSH
13442: LD_INT 23
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13454: LD_ADDR_EXP 64
13458: PUSH
13459: LD_INT 22
13461: PUSH
13462: LD_EXP 24
13466: PUSH
13467: EMPTY
13468: LIST
13469: LIST
13470: PUSH
13471: LD_INT 21
13473: PUSH
13474: LD_INT 3
13476: PUSH
13477: EMPTY
13478: LIST
13479: LIST
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: PPUSH
13485: CALL_OW 69
13489: PUSH
13490: LD_INT 14
13492: PUSH
13493: LD_INT 15
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: ADD
13500: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13501: LD_ADDR_EXP 65
13505: PUSH
13506: LD_INT 22
13508: PUSH
13509: LD_EXP 24
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: PUSH
13518: LD_INT 30
13520: PUSH
13521: LD_INT 1
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: EMPTY
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 69
13536: PUSH
13537: LD_INT 1
13539: ARRAY
13540: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13541: LD_ADDR_EXP 66
13545: PUSH
13546: LD_INT 22
13548: PUSH
13549: LD_EXP 24
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: PUSH
13558: LD_INT 30
13560: PUSH
13561: LD_INT 8
13563: PUSH
13564: EMPTY
13565: LIST
13566: LIST
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PPUSH
13572: CALL_OW 69
13576: PUSH
13577: LD_INT 1
13579: ARRAY
13580: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13581: LD_ADDR_EXP 67
13585: PUSH
13586: LD_INT 22
13588: PUSH
13589: LD_EXP 24
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 30
13600: PUSH
13601: LD_INT 31
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: PPUSH
13612: CALL_OW 69
13616: PUSH
13617: LD_INT 1
13619: ARRAY
13620: ST_TO_ADDR
// enable ( 401 ) ;
13621: LD_INT 401
13623: ENABLE_MARKED
// end ;
13624: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13625: GO 13627
13627: DISABLE
13628: LD_INT 0
13630: PPUSH
13631: PPUSH
13632: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13633: LD_EXP 62
13637: PPUSH
13638: CALL_OW 386
13642: NOT
13643: IFFALSE 13698
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13645: LD_ADDR_EXP 62
13649: PUSH
13650: LD_INT 100
13652: PPUSH
13653: LD_EXP 63
13657: PPUSH
13658: LD_EXP 64
13662: PUSH
13663: LD_EXP 63
13667: ADD
13668: PPUSH
13669: LD_INT 1
13671: PUSH
13672: LD_INT 23
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: PUSH
13679: LD_INT 10
13681: PUSH
13682: LD_INT 22
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 414
13697: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13698: LD_EXP 65
13702: PPUSH
13703: CALL_OW 300
13707: PUSH
13708: LD_EXP 66
13712: PPUSH
13713: CALL_OW 300
13717: OR
13718: PUSH
13719: LD_EXP 67
13723: PPUSH
13724: CALL_OW 300
13728: OR
13729: IFFALSE 13955
// begin for un in rus_mcrep_units do
13731: LD_ADDR_VAR 0 1
13735: PUSH
13736: LD_EXP 63
13740: PUSH
13741: FOR_IN
13742: IFFALSE 13953
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13744: LD_VAR 0 1
13748: PPUSH
13749: CALL_OW 388
13753: PUSH
13754: LD_INT 0
13756: EQUAL
13757: PUSH
13758: LD_VAR 0 1
13762: PPUSH
13763: CALL_OW 256
13767: PUSH
13768: LD_INT 1000
13770: EQUAL
13771: AND
13772: IFFALSE 13939
// case GetClass ( un ) of class_engineer :
13774: LD_VAR 0 1
13778: PPUSH
13779: CALL_OW 257
13783: PUSH
13784: LD_INT 2
13786: DOUBLE
13787: EQUAL
13788: IFTRUE 13792
13790: GO 13836
13792: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13793: LD_EXP 65
13797: PPUSH
13798: CALL_OW 300
13802: PUSH
13803: LD_EXP 65
13807: PPUSH
13808: CALL_OW 313
13812: PUSH
13813: LD_INT 6
13815: EQUAL
13816: NOT
13817: AND
13818: IFFALSE 13834
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13820: LD_VAR 0 1
13824: PPUSH
13825: LD_EXP 65
13829: PPUSH
13830: CALL_OW 120
13834: GO 13937
13836: LD_INT 4
13838: DOUBLE
13839: EQUAL
13840: IFTRUE 13844
13842: GO 13888
13844: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13845: LD_EXP 66
13849: PPUSH
13850: CALL_OW 300
13854: PUSH
13855: LD_EXP 66
13859: PPUSH
13860: CALL_OW 313
13864: PUSH
13865: LD_INT 6
13867: EQUAL
13868: NOT
13869: AND
13870: IFFALSE 13886
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13872: LD_VAR 0 1
13876: PPUSH
13877: LD_EXP 66
13881: PPUSH
13882: CALL_OW 120
13886: GO 13937
13888: LD_INT 1
13890: DOUBLE
13891: EQUAL
13892: IFTRUE 13896
13894: GO 13936
13896: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13897: LD_EXP 67
13901: PPUSH
13902: CALL_OW 300
13906: PUSH
13907: LD_EXP 67
13911: PPUSH
13912: CALL_OW 313
13916: NOT
13917: AND
13918: IFFALSE 13934
// ComEnterUnit ( un , rus_breastwork ) ; end else
13920: LD_VAR 0 1
13924: PPUSH
13925: LD_EXP 67
13929: PPUSH
13930: CALL_OW 120
13934: GO 13937
13936: POP
13937: GO 13951
// ComMoveToArea ( un , BluekherRepairArea ) ;
13939: LD_VAR 0 1
13943: PPUSH
13944: LD_INT 23
13946: PPUSH
13947: CALL_OW 113
13951: GO 13741
13953: POP
13954: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13955: LD_ADDR_VAR 0 3
13959: PUSH
13960: LD_INT 22
13962: PPUSH
13963: LD_INT 22
13965: PUSH
13966: LD_EXP 24
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PUSH
13975: LD_INT 2
13977: PUSH
13978: LD_INT 25
13980: PUSH
13981: LD_INT 2
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PUSH
13988: LD_INT 25
13990: PUSH
13991: LD_INT 4
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: PUSH
13998: EMPTY
13999: LIST
14000: LIST
14001: LIST
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: PPUSH
14007: CALL_OW 71
14011: ST_TO_ADDR
// if filter then
14012: LD_VAR 0 3
14016: IFFALSE 14033
// ComMoveXY ( filter , 48 , 88 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 48
14025: PPUSH
14026: LD_INT 88
14028: PPUSH
14029: CALL_OW 111
// enable ;
14033: ENABLE
// end ; end_of_file
14034: PPOPN 3
14036: END
// every 0 0$2 + 0 0$0.1 do
14037: GO 14039
14039: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
14040: LD_INT 22
14042: PUSH
14043: LD_INT 7
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: PUSH
14050: LD_INT 2
14052: PUSH
14053: LD_INT 25
14055: PUSH
14056: LD_INT 12
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: PUSH
14063: LD_INT 25
14065: PUSH
14066: LD_INT 16
14068: PUSH
14069: EMPTY
14070: LIST
14071: LIST
14072: PUSH
14073: LD_INT 25
14075: PUSH
14076: LD_INT 15
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: PUSH
14083: LD_INT 25
14085: PUSH
14086: LD_INT 17
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: PUSH
14093: EMPTY
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: PUSH
14100: EMPTY
14101: LIST
14102: LIST
14103: PPUSH
14104: CALL_OW 69
14108: PUSH
14109: LD_INT 22
14111: PUSH
14112: LD_INT 7
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PUSH
14119: LD_INT 21
14121: PUSH
14122: LD_INT 1
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: LD_INT 2
14134: PUSH
14135: LD_INT 25
14137: PUSH
14138: LD_INT 12
14140: PUSH
14141: EMPTY
14142: LIST
14143: LIST
14144: PUSH
14145: LD_INT 25
14147: PUSH
14148: LD_INT 16
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: PUSH
14155: LD_INT 25
14157: PUSH
14158: LD_INT 15
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: PUSH
14165: LD_INT 25
14167: PUSH
14168: LD_INT 17
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: PUSH
14175: EMPTY
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: LIST
14181: PUSH
14182: EMPTY
14183: LIST
14184: LIST
14185: PUSH
14186: EMPTY
14187: LIST
14188: LIST
14189: LIST
14190: PPUSH
14191: CALL_OW 69
14195: GREATER
14196: IFFALSE 14207
// begin SetAchievement ( ACH_POTA ) ;
14198: LD_STRING ACH_POTA
14200: PPUSH
14201: CALL_OW 543
// exit ;
14205: GO 14208
// end ; enable ;
14207: ENABLE
// end ; end_of_file
14208: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14209: LD_INT 0
14211: PPUSH
14212: PPUSH
// if not missionNumber then
14213: LD_VAR 0 2
14217: NOT
14218: IFFALSE 14222
// exit ;
14220: GO 14352
// achiv := false ;
14222: LD_ADDR_VAR 0 7
14226: PUSH
14227: LD_INT 0
14229: ST_TO_ADDR
// case campaignNumber of 1 :
14230: LD_VAR 0 1
14234: PUSH
14235: LD_INT 1
14237: DOUBLE
14238: EQUAL
14239: IFTRUE 14243
14241: GO 14254
14243: POP
// achiv := ACH_GOTA ; 2 :
14244: LD_ADDR_VAR 0 7
14248: PUSH
14249: LD_STRING ACH_GOTA
14251: ST_TO_ADDR
14252: GO 14304
14254: LD_INT 2
14256: DOUBLE
14257: EQUAL
14258: IFTRUE 14262
14260: GO 14265
14262: POP
// ; 3 :
14263: GO 14304
14265: LD_INT 3
14267: DOUBLE
14268: EQUAL
14269: IFTRUE 14273
14271: GO 14284
14273: POP
// achiv := ACH_MOTSU ; 4 :
14274: LD_ADDR_VAR 0 7
14278: PUSH
14279: LD_STRING ACH_MOTSU
14281: ST_TO_ADDR
14282: GO 14304
14284: LD_INT 4
14286: DOUBLE
14287: EQUAL
14288: IFTRUE 14292
14290: GO 14303
14292: POP
// achiv := ACH_LOP ; end ;
14293: LD_ADDR_VAR 0 7
14297: PUSH
14298: LD_STRING ACH_LOP
14300: ST_TO_ADDR
14301: GO 14304
14303: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14304: LD_OWVAR 67
14308: PUSH
14309: LD_INT 3
14311: EQUAL
14312: PUSH
14313: LD_VAR 0 7
14317: AND
14318: PUSH
14319: LD_VAR 0 3
14323: AND
14324: PUSH
14325: LD_VAR 0 4
14329: AND
14330: PUSH
14331: LD_VAR 0 5
14335: AND
14336: IFFALSE 14352
// SetAchievementEX ( achiv , missionNumber ) ;
14338: LD_VAR 0 7
14342: PPUSH
14343: LD_VAR 0 2
14347: PPUSH
14348: CALL_OW 564
// end ;
14352: LD_VAR 0 6
14356: RET
// export function SA_BehemothConstructed ; begin
14357: LD_INT 0
14359: PPUSH
// SetAchievement ( ACH_SMC ) ;
14360: LD_STRING ACH_SMC
14362: PPUSH
14363: CALL_OW 543
// end ;
14367: LD_VAR 0 1
14371: RET
