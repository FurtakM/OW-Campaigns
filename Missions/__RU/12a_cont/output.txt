// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 4 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 4
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$40 , 0 0$30 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1400
 345: PUSH
 346: LD_INT 1050
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 1 1$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 2100
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// while scientists > 5 do
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1286
// scientists = Delete ( scientists , scientists + 0 ) ;
1260: LD_ADDR_EXP 40
1264: PUSH
1265: LD_EXP 40
1269: PPUSH
1270: LD_EXP 40
1274: PUSH
1275: LD_INT 0
1277: PLUS
1278: PPUSH
1279: CALL_OW 3
1283: ST_TO_ADDR
1284: GO 1250
// survivors3 = survivors3 diff scientists ;
1286: LD_ADDR_EXP 22
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 40
1300: DIFF
1301: ST_TO_ADDR
// if scientists < 5 then
1302: LD_EXP 40
1306: PUSH
1307: LD_INT 5
1309: LESS
1310: IFFALSE 1401
// for i := 1 to 5 - scientists do
1312: LD_ADDR_VAR 0 3
1316: PUSH
1317: DOUBLE
1318: LD_INT 1
1320: DEC
1321: ST_TO_ADDR
1322: LD_INT 5
1324: PUSH
1325: LD_EXP 40
1329: MINUS
1330: PUSH
1331: FOR_TO
1332: IFFALSE 1399
// begin uc_side = ally ;
1334: LD_ADDR_OWVAR 20
1338: PUSH
1339: LD_EXP 25
1343: ST_TO_ADDR
// uc_nation := nation_russian ;
1344: LD_ADDR_OWVAR 21
1348: PUSH
1349: LD_INT 3
1351: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1352: LD_INT 0
1354: PPUSH
1355: LD_INT 4
1357: PPUSH
1358: LD_INT 5
1360: PPUSH
1361: LD_INT 7
1363: PPUSH
1364: CALL_OW 12
1368: PPUSH
1369: CALL_OW 380
// hc_name :=  ;
1373: LD_ADDR_OWVAR 26
1377: PUSH
1378: LD_STRING 
1380: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1381: LD_ADDR_EXP 40
1385: PUSH
1386: LD_EXP 40
1390: PUSH
1391: CALL_OW 44
1395: ADD
1396: ST_TO_ADDR
// end ;
1397: GO 1331
1399: POP
1400: POP
// for un in scientists do
1401: LD_ADDR_VAR 0 2
1405: PUSH
1406: LD_EXP 40
1410: PUSH
1411: FOR_IN
1412: IFFALSE 1430
// SetSide ( un , ally ) ;
1414: LD_VAR 0 2
1418: PPUSH
1419: LD_EXP 25
1423: PPUSH
1424: CALL_OW 235
1428: GO 1411
1430: POP
1431: POP
// possible := all_possible diff scientists ;
1432: LD_ADDR_EXP 38
1436: PUSH
1437: LD_EXP 39
1441: PUSH
1442: LD_EXP 40
1446: DIFF
1447: ST_TO_ADDR
// for un in scientists do
1448: LD_ADDR_VAR 0 2
1452: PUSH
1453: LD_EXP 40
1457: PUSH
1458: FOR_IN
1459: IFFALSE 1475
// PlaceHumanInUnit ( un , 2 ) ;
1461: LD_VAR 0 2
1465: PPUSH
1466: LD_INT 2
1468: PPUSH
1469: CALL_OW 52
1473: GO 1458
1475: POP
1476: POP
// new := [ ] ;
1477: LD_ADDR_EXP 36
1481: PUSH
1482: EMPTY
1483: ST_TO_ADDR
// if possible < 10 then
1484: LD_EXP 38
1488: PUSH
1489: LD_INT 10
1491: LESS
1492: IFFALSE 1575
// for i := 1 to 10 - possible do
1494: LD_ADDR_VAR 0 3
1498: PUSH
1499: DOUBLE
1500: LD_INT 1
1502: DEC
1503: ST_TO_ADDR
1504: LD_INT 10
1506: PUSH
1507: LD_EXP 38
1511: MINUS
1512: PUSH
1513: FOR_TO
1514: IFFALSE 1573
// begin uc_side = rus ;
1516: LD_ADDR_OWVAR 20
1520: PUSH
1521: LD_EXP 24
1525: ST_TO_ADDR
// uc_nation := nation_russian ;
1526: LD_ADDR_OWVAR 21
1530: PUSH
1531: LD_INT 3
1533: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1534: LD_INT 0
1536: PPUSH
1537: LD_INT 0
1539: PPUSH
1540: LD_INT 5
1542: PPUSH
1543: CALL_OW 380
// hc_name :=  ;
1547: LD_ADDR_OWVAR 26
1551: PUSH
1552: LD_STRING 
1554: ST_TO_ADDR
// new := new ^ CreateHuman ;
1555: LD_ADDR_EXP 36
1559: PUSH
1560: LD_EXP 36
1564: PUSH
1565: CALL_OW 44
1569: ADD
1570: ST_TO_ADDR
// end ;
1571: GO 1513
1573: POP
1574: POP
// uc_side = rus ;
1575: LD_ADDR_OWVAR 20
1579: PUSH
1580: LD_EXP 24
1584: ST_TO_ADDR
// uc_nation := nation_russian ;
1585: LD_ADDR_OWVAR 21
1589: PUSH
1590: LD_INT 3
1592: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1593: LD_ADDR_EXP 1
1597: PUSH
1598: LD_STRING Burlak
1600: PPUSH
1601: CALL 565 0 1
1605: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1606: LD_EXP 1
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1618: LD_ADDR_EXP 20
1622: PUSH
1623: LD_STRING Platonov
1625: PPUSH
1626: CALL_OW 25
1630: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 1
1636: PPUSH
1637: LD_INT 4
1639: PPUSH
1640: CALL_OW 380
// hc_name :=  ;
1644: LD_ADDR_OWVAR 26
1648: PUSH
1649: LD_STRING 
1651: ST_TO_ADDR
// RSoldier := CreateHuman ;
1652: LD_ADDR_EXP 21
1656: PUSH
1657: CALL_OW 44
1661: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1662: LD_ADDR_VAR 0 3
1666: PUSH
1667: DOUBLE
1668: LD_INT 1
1670: DEC
1671: ST_TO_ADDR
1672: LD_EXP 31
1676: PUSH
1677: LD_INT 3
1679: PUSH
1680: LD_EXP 30
1684: MUL
1685: PLUS
1686: PUSH
1687: FOR_TO
1688: IFFALSE 1780
// begin case Rand ( 1 , 2 ) of 1 :
1690: LD_INT 1
1692: PPUSH
1693: LD_INT 2
1695: PPUSH
1696: CALL_OW 12
1700: PUSH
1701: LD_INT 1
1703: DOUBLE
1704: EQUAL
1705: IFTRUE 1709
1707: GO 1727
1709: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1710: LD_INT 1
1712: PPUSH
1713: LD_INT 1
1715: PPUSH
1716: LD_EXP 32
1720: PPUSH
1721: CALL_OW 380
1725: GO 1754
1727: LD_INT 2
1729: DOUBLE
1730: EQUAL
1731: IFTRUE 1735
1733: GO 1753
1735: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 9
1741: PPUSH
1742: LD_EXP 32
1746: PPUSH
1747: CALL_OW 380
1751: GO 1754
1753: POP
// hc_name :=  ;
1754: LD_ADDR_OWVAR 26
1758: PUSH
1759: LD_STRING 
1761: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1762: LD_ADDR_EXP 29
1766: PUSH
1767: LD_EXP 29
1771: PUSH
1772: CALL_OW 44
1776: ADD
1777: ST_TO_ADDR
// end ;
1778: GO 1687
1780: POP
1781: POP
// end ;
1782: LD_VAR 0 1
1786: RET
// function select_people ; var units , un ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
1791: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1792: LD_ADDR_EXP 41
1796: PUSH
1797: LD_STRING 
1799: PPUSH
1800: LD_INT 5
1802: PPUSH
1803: LD_INT 5
1805: PPUSH
1806: LD_INT -1
1808: PUSH
1809: LD_INT -4
1811: PUSH
1812: LD_INT -6
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 1
1824: ADD
1825: PUSH
1826: LD_INT -2
1828: PUSH
1829: LD_INT -4
1831: PUSH
1832: LD_INT -6
1834: PUSH
1835: EMPTY
1836: LIST
1837: LIST
1838: LIST
1839: ADD
1840: PUSH
1841: LD_EXP 20
1845: ADD
1846: PUSH
1847: LD_INT -2
1849: PUSH
1850: LD_INT -5
1852: PUSH
1853: LD_INT -3
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: ADD
1861: PUSH
1862: LD_EXP 38
1866: ADD
1867: PUSH
1868: LD_EXP 22
1872: ADD
1873: PUSH
1874: LD_EXP 36
1878: ADD
1879: PPUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 2
1888: PUSH
1889: LD_INT 4
1891: PUSH
1892: LD_INT 9
1894: PUSH
1895: LD_INT 0
1897: PUSH
1898: LD_INT 2
1900: PUSH
1901: EMPTY
1902: LIST
1903: LIST
1904: LIST
1905: PUSH
1906: EMPTY
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: PPUSH
1913: CALL_OW 42
1917: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1918: LD_EXP 41
1922: PUSH
1923: LD_EXP 1
1927: DIFF
1928: PPUSH
1929: LD_EXP 27
1933: PPUSH
1934: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1938: LD_ADDR_VAR 0 3
1942: PUSH
1943: LD_EXP 41
1947: PUSH
1948: LD_EXP 1
1952: DIFF
1953: PUSH
1954: FOR_IN
1955: IFFALSE 1974
// PlaceUnitArea ( un , BaseArea , false ) ;
1957: LD_VAR 0 3
1961: PPUSH
1962: LD_INT 2
1964: PPUSH
1965: LD_INT 0
1967: PPUSH
1968: CALL_OW 49
1972: GO 1954
1974: POP
1975: POP
// end ;
1976: LD_VAR 0 1
1980: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
1981: LD_INT 0
1983: PPUSH
1984: PPUSH
1985: PPUSH
1986: PPUSH
1987: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
1988: LD_ADDR_VAR 0 3
1992: PUSH
1993: LD_STRING EscapeVehicle_12a
1995: PPUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 0
2001: PUSH
2002: LD_INT 0
2004: PUSH
2005: EMPTY
2006: LIST
2007: LIST
2008: LIST
2009: PPUSH
2010: CALL_OW 30
2014: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2015: LD_ADDR_LOC 1
2019: PUSH
2020: LD_VAR 0 3
2024: PUSH
2025: LD_INT 1
2027: ARRAY
2028: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2029: LD_ADDR_VAR 0 4
2033: PUSH
2034: LD_VAR 0 3
2038: PUSH
2039: LD_INT 2
2041: ARRAY
2042: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 3
2052: PUSH
2053: LD_INT 3
2055: ARRAY
2056: ST_TO_ADDR
// if MashaWanted then
2057: LD_LOC 1
2061: IFFALSE 2277
// begin veh := LoadVariable ( Masha , false ) ;
2063: LD_ADDR_VAR 0 2
2067: PUSH
2068: LD_STRING Masha
2070: PPUSH
2071: LD_INT 0
2073: PPUSH
2074: CALL_OW 30
2078: ST_TO_ADDR
// if veh then
2079: LD_VAR 0 2
2083: IFFALSE 2199
// begin uc_side := rus ;
2085: LD_ADDR_OWVAR 20
2089: PUSH
2090: LD_EXP 24
2094: ST_TO_ADDR
// uc_nation := nation_russian ;
2095: LD_ADDR_OWVAR 21
2099: PUSH
2100: LD_INT 3
2102: ST_TO_ADDR
// uc_direction := 2 ;
2103: LD_ADDR_OWVAR 24
2107: PUSH
2108: LD_INT 2
2110: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2111: LD_ADDR_OWVAR 37
2115: PUSH
2116: LD_VAR 0 2
2120: PUSH
2121: LD_INT 1
2123: ARRAY
2124: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2125: LD_ADDR_OWVAR 39
2129: PUSH
2130: LD_VAR 0 2
2134: PUSH
2135: LD_INT 2
2137: ARRAY
2138: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2139: LD_ADDR_OWVAR 38
2143: PUSH
2144: LD_VAR 0 2
2148: PUSH
2149: LD_INT 3
2151: ARRAY
2152: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2153: LD_ADDR_OWVAR 40
2157: PUSH
2158: LD_VAR 0 2
2162: PUSH
2163: LD_INT 4
2165: ARRAY
2166: ST_TO_ADDR
// RealMasha := true ;
2167: LD_ADDR_EXP 42
2171: PUSH
2172: LD_INT 1
2174: ST_TO_ADDR
// Masha := CreateVehicle ;
2175: LD_ADDR_EXP 43
2179: PUSH
2180: CALL_OW 45
2184: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
2185: LD_EXP 43
2189: PPUSH
2190: LD_INT 1
2192: PPUSH
2193: CALL_OW 242
// end else
2197: GO 2275
// begin uc_side := rus ;
2199: LD_ADDR_OWVAR 20
2203: PUSH
2204: LD_EXP 24
2208: ST_TO_ADDR
// uc_nation := nation_russian ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 3
2216: ST_TO_ADDR
// uc_direction := 2 ;
2217: LD_ADDR_OWVAR 24
2221: PUSH
2222: LD_INT 2
2224: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2225: LD_ADDR_OWVAR 37
2229: PUSH
2230: LD_INT 22
2232: ST_TO_ADDR
// vc_engine := engine_siberite ;
2233: LD_ADDR_OWVAR 39
2237: PUSH
2238: LD_INT 3
2240: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2241: LD_ADDR_OWVAR 40
2245: PUSH
2246: LD_INT 43
2248: ST_TO_ADDR
// vc_control := control_manual ;
2249: LD_ADDR_OWVAR 38
2253: PUSH
2254: LD_INT 1
2256: ST_TO_ADDR
// RealMasha := false ;
2257: LD_ADDR_EXP 42
2261: PUSH
2262: LD_INT 0
2264: ST_TO_ADDR
// Masha := CreateVehicle ;
2265: LD_ADDR_EXP 43
2269: PUSH
2270: CALL_OW 45
2274: ST_TO_ADDR
// end ; end else
2275: GO 2357
// begin uc_side := rus ;
2277: LD_ADDR_OWVAR 20
2281: PUSH
2282: LD_EXP 24
2286: ST_TO_ADDR
// uc_nation := nation_russian ;
2287: LD_ADDR_OWVAR 21
2291: PUSH
2292: LD_INT 3
2294: ST_TO_ADDR
// uc_direction := 2 ;
2295: LD_ADDR_OWVAR 24
2299: PUSH
2300: LD_INT 2
2302: ST_TO_ADDR
// vc_chassis := Chassis ;
2303: LD_ADDR_OWVAR 37
2307: PUSH
2308: LD_VAR 0 4
2312: ST_TO_ADDR
// vc_engine := engine_siberite ;
2313: LD_ADDR_OWVAR 39
2317: PUSH
2318: LD_INT 3
2320: ST_TO_ADDR
// vc_weapon := Weapon ;
2321: LD_ADDR_OWVAR 40
2325: PUSH
2326: LD_VAR 0 5
2330: ST_TO_ADDR
// vc_control := control_manual ;
2331: LD_ADDR_OWVAR 38
2335: PUSH
2336: LD_INT 1
2338: ST_TO_ADDR
// RealMasha := false ;
2339: LD_ADDR_EXP 42
2343: PUSH
2344: LD_INT 0
2346: ST_TO_ADDR
// Masha := CreateVehicle ;
2347: LD_ADDR_EXP 43
2351: PUSH
2352: CALL_OW 45
2356: ST_TO_ADDR
// end ; if GetEngine ( Masha ) <> engine_siberite then
2357: LD_EXP 43
2361: PPUSH
2362: CALL_OW 262
2366: PUSH
2367: LD_INT 3
2369: NONEQUAL
2370: IFFALSE 2392
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2372: LD_EXP 43
2376: PPUSH
2377: LD_INT 70
2379: PPUSH
2380: LD_INT 95
2382: PPUSH
2383: CALL_OW 12
2387: PPUSH
2388: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2392: LD_EXP 43
2396: PPUSH
2397: LD_INT 47
2399: PPUSH
2400: LD_INT 87
2402: PPUSH
2403: LD_INT 0
2405: PPUSH
2406: CALL_OW 48
// end ;
2410: LD_VAR 0 1
2414: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2415: LD_INT 1
2417: PPUSH
2418: LD_STRING bluekher
2420: PPUSH
2421: CALL_OW 500
// IngameOn ;
2425: CALL_OW 8
// Randomize ;
2429: CALL_OW 10
// RandomizeAll ;
2433: CALL_OW 11
// InitBc ;
2437: CALL_OW 21
// InitHc ;
2441: CALL_OW 19
// InitUc ;
2445: CALL_OW 18
// InitVc ;
2449: CALL_OW 20
// disable ( 1 ) ;
2453: LD_INT 1
2455: DISABLE_MARKED
// disable ( 2 ) ;
2456: LD_INT 2
2458: DISABLE_MARKED
// disable ( 3 ) ;
2459: LD_INT 3
2461: DISABLE_MARKED
// disable ( 4 ) ;
2462: LD_INT 4
2464: DISABLE_MARKED
// disable ( 6 ) ;
2465: LD_INT 6
2467: DISABLE_MARKED
// disable ( 7 ) ;
2468: LD_INT 7
2470: DISABLE_MARKED
// disable ( 8 ) ;
2471: LD_INT 8
2473: DISABLE_MARKED
// disable ( 9 ) ;
2474: LD_INT 9
2476: DISABLE_MARKED
// disable ( 333 ) ;
2477: LD_INT 333
2479: DISABLE_MARKED
// disable ( 337 ) ;
2480: LD_INT 337
2482: DISABLE_MARKED
// disable ( 401 ) ;
2483: LD_INT 401
2485: DISABLE_MARKED
// read_parameters ;
2486: CALL 0 0 0
// set_difficulty ;
2490: CALL 257 0 0
// create_people ;
2494: CALL 609 0 0
// select_people ;
2498: CALL 1787 0 0
// place_masha ;
2502: CALL 1981 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2506: LD_INT 53
2508: PPUSH
2509: LD_INT 90
2511: PPUSH
2512: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2516: LD_EXP 1
2520: PPUSH
2521: LD_INT 51
2523: PPUSH
2524: LD_INT 88
2526: PPUSH
2527: LD_INT 0
2529: PPUSH
2530: CALL_OW 48
// ComHold ( Burlak ) ;
2534: LD_EXP 1
2538: PPUSH
2539: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2543: LD_EXP 21
2547: PPUSH
2548: LD_INT 54
2550: PPUSH
2551: LD_INT 90
2553: PPUSH
2554: LD_INT 0
2556: PPUSH
2557: CALL_OW 48
// ComHold ( RSoldier ) ;
2561: LD_EXP 21
2565: PPUSH
2566: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2570: LD_EXP 1
2574: PPUSH
2575: LD_EXP 21
2579: PPUSH
2580: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2584: LD_EXP 21
2588: PPUSH
2589: LD_EXP 1
2593: PPUSH
2594: CALL_OW 119
// D_Platonov ;
2598: CALL 5248 0 0
// IngameOff ;
2602: CALL_OW 9
// SaveForQuickRestart ;
2606: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2610: LD_STRING MRun
2612: PPUSH
2613: CALL_OW 337
// ChangeSideFog ( you , you ) ;
2617: LD_EXP 23
2621: PPUSH
2622: LD_EXP 23
2626: PPUSH
2627: CALL_OW 343
// SetSide ( Burlak , you ) ;
2631: LD_EXP 1
2635: PPUSH
2636: LD_EXP 23
2640: PPUSH
2641: CALL_OW 235
// SetSide ( Masha , you ) ;
2645: LD_EXP 43
2649: PPUSH
2650: LD_EXP 23
2654: PPUSH
2655: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2659: LD_INT 1
2661: PPUSH
2662: LD_INT 2
2664: PPUSH
2665: CALL_OW 12
2669: PUSH
2670: LD_INT 1
2672: DOUBLE
2673: EQUAL
2674: IFTRUE 2678
2676: GO 2736
2678: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2679: LD_ADDR_LOC 2
2683: PUSH
2684: DOUBLE
2685: LD_EXP 31
2689: PUSH
2690: LD_INT 1
2692: PLUS
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 31
2699: PUSH
2700: LD_EXP 30
2704: PLUS
2705: PUSH
2706: FOR_TO
2707: IFFALSE 2732
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2709: LD_EXP 29
2713: PUSH
2714: LD_LOC 2
2718: ARRAY
2719: PPUSH
2720: LD_INT 4
2722: PPUSH
2723: LD_INT 0
2725: PPUSH
2726: CALL_OW 49
2730: GO 2706
2732: POP
2733: POP
// end ; 2 :
2734: GO 2803
2736: LD_INT 2
2738: DOUBLE
2739: EQUAL
2740: IFTRUE 2744
2742: GO 2802
2744: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2745: LD_ADDR_LOC 2
2749: PUSH
2750: DOUBLE
2751: LD_EXP 31
2755: PUSH
2756: LD_INT 1
2758: PLUS
2759: DEC
2760: ST_TO_ADDR
2761: LD_EXP 31
2765: PUSH
2766: LD_EXP 30
2770: PLUS
2771: PUSH
2772: FOR_TO
2773: IFFALSE 2798
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2775: LD_EXP 29
2779: PUSH
2780: LD_LOC 2
2784: ARRAY
2785: PPUSH
2786: LD_INT 5
2788: PPUSH
2789: LD_INT 0
2791: PPUSH
2792: CALL_OW 49
2796: GO 2772
2798: POP
2799: POP
// end ; end ;
2800: GO 2803
2802: POP
// case Rand ( 1 , 2 ) of 1 :
2803: LD_INT 1
2805: PPUSH
2806: LD_INT 2
2808: PPUSH
2809: CALL_OW 12
2813: PUSH
2814: LD_INT 1
2816: DOUBLE
2817: EQUAL
2818: IFTRUE 2822
2820: GO 2890
2822: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2823: LD_ADDR_LOC 2
2827: PUSH
2828: DOUBLE
2829: LD_EXP 31
2833: PUSH
2834: LD_INT 1
2836: PLUS
2837: PUSH
2838: LD_EXP 30
2842: PLUS
2843: DEC
2844: ST_TO_ADDR
2845: LD_EXP 31
2849: PUSH
2850: LD_INT 2
2852: PUSH
2853: LD_EXP 30
2857: MUL
2858: PLUS
2859: PUSH
2860: FOR_TO
2861: IFFALSE 2886
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2863: LD_EXP 29
2867: PUSH
2868: LD_LOC 2
2872: ARRAY
2873: PPUSH
2874: LD_INT 8
2876: PPUSH
2877: LD_INT 0
2879: PPUSH
2880: CALL_OW 49
2884: GO 2860
2886: POP
2887: POP
// end ; 2 :
2888: GO 2967
2890: LD_INT 2
2892: DOUBLE
2893: EQUAL
2894: IFTRUE 2898
2896: GO 2966
2898: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2899: LD_ADDR_LOC 2
2903: PUSH
2904: DOUBLE
2905: LD_EXP 31
2909: PUSH
2910: LD_INT 1
2912: PLUS
2913: PUSH
2914: LD_EXP 30
2918: PLUS
2919: DEC
2920: ST_TO_ADDR
2921: LD_EXP 31
2925: PUSH
2926: LD_INT 2
2928: PUSH
2929: LD_EXP 30
2933: MUL
2934: PLUS
2935: PUSH
2936: FOR_TO
2937: IFFALSE 2962
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
2939: LD_EXP 29
2943: PUSH
2944: LD_LOC 2
2948: ARRAY
2949: PPUSH
2950: LD_INT 7
2952: PPUSH
2953: LD_INT 0
2955: PPUSH
2956: CALL_OW 49
2960: GO 2936
2962: POP
2963: POP
// end ; end ;
2964: GO 2967
2966: POP
// case Rand ( 1 , 2 ) of 1 :
2967: LD_INT 1
2969: PPUSH
2970: LD_INT 2
2972: PPUSH
2973: CALL_OW 12
2977: PUSH
2978: LD_INT 1
2980: DOUBLE
2981: EQUAL
2982: IFTRUE 2986
2984: GO 3058
2986: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
2987: LD_ADDR_LOC 2
2991: PUSH
2992: DOUBLE
2993: LD_EXP 31
2997: PUSH
2998: LD_INT 1
3000: PLUS
3001: PUSH
3002: LD_INT 2
3004: PUSH
3005: LD_EXP 30
3009: MUL
3010: PLUS
3011: DEC
3012: ST_TO_ADDR
3013: LD_EXP 31
3017: PUSH
3018: LD_INT 3
3020: PUSH
3021: LD_EXP 30
3025: MUL
3026: PLUS
3027: PUSH
3028: FOR_TO
3029: IFFALSE 3054
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3031: LD_EXP 29
3035: PUSH
3036: LD_LOC 2
3040: ARRAY
3041: PPUSH
3042: LD_INT 6
3044: PPUSH
3045: LD_INT 0
3047: PPUSH
3048: CALL_OW 49
3052: GO 3028
3054: POP
3055: POP
// end ; 2 :
3056: GO 3139
3058: LD_INT 2
3060: DOUBLE
3061: EQUAL
3062: IFTRUE 3066
3064: GO 3138
3066: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3067: LD_ADDR_LOC 2
3071: PUSH
3072: DOUBLE
3073: LD_EXP 31
3077: PUSH
3078: LD_INT 1
3080: PLUS
3081: PUSH
3082: LD_INT 2
3084: PUSH
3085: LD_EXP 30
3089: MUL
3090: PLUS
3091: DEC
3092: ST_TO_ADDR
3093: LD_EXP 31
3097: PUSH
3098: LD_INT 3
3100: PUSH
3101: LD_EXP 30
3105: MUL
3106: PLUS
3107: PUSH
3108: FOR_TO
3109: IFFALSE 3134
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3111: LD_EXP 29
3115: PUSH
3116: LD_LOC 2
3120: ARRAY
3121: PPUSH
3122: LD_INT 16
3124: PPUSH
3125: LD_INT 0
3127: PPUSH
3128: CALL_OW 49
3132: GO 3108
3134: POP
3135: POP
// end ; end ;
3136: GO 3139
3138: POP
// ComMoveXY ( Masha , 40 , 69 ) ;
3139: LD_EXP 43
3143: PPUSH
3144: LD_INT 40
3146: PPUSH
3147: LD_INT 69
3149: PPUSH
3150: CALL_OW 111
// Wait ( 1 1$0 ) ;
3154: LD_INT 2100
3156: PPUSH
3157: CALL_OW 67
// for i := 1 to pursuers_base do
3161: LD_ADDR_LOC 2
3165: PUSH
3166: DOUBLE
3167: LD_INT 1
3169: DEC
3170: ST_TO_ADDR
3171: LD_EXP 31
3175: PUSH
3176: FOR_TO
3177: IFFALSE 3246
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3179: LD_EXP 29
3183: PUSH
3184: LD_LOC 2
3188: ARRAY
3189: PPUSH
3190: LD_INT 9
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 49
3200: NOT
3201: IFFALSE 3224
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3203: LD_EXP 29
3207: PUSH
3208: LD_LOC 2
3212: ARRAY
3213: PPUSH
3214: LD_INT 3
3216: PPUSH
3217: LD_INT 0
3219: PPUSH
3220: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3224: LD_EXP 29
3228: PUSH
3229: LD_LOC 2
3233: ARRAY
3234: PPUSH
3235: LD_EXP 1
3239: PPUSH
3240: CALL_OW 115
// end ;
3244: GO 3176
3246: POP
3247: POP
// Wait ( straz_start ) ;
3248: LD_EXP 35
3252: PPUSH
3253: CALL_OW 67
// enable ( 1 ) ;
3257: LD_INT 1
3259: ENABLE_MARKED
// enable ( 2 ) ;
3260: LD_INT 2
3262: ENABLE_MARKED
// end ;
3263: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3264: LD_INT 0
3266: PPUSH
3267: PPUSH
3268: PPUSH
3269: PPUSH
3270: PPUSH
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
3275: PPUSH
3276: PPUSH
3277: PPUSH
3278: PPUSH
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
3285: PPUSH
3286: PPUSH
3287: PPUSH
3288: PPUSH
3289: PPUSH
// gained_medals := [ ] ;
3290: LD_ADDR_OWVAR 61
3294: PUSH
3295: EMPTY
3296: ST_TO_ADDR
// missing_medals := [ ] ;
3297: LD_ADDR_OWVAR 62
3301: PUSH
3302: EMPTY
3303: ST_TO_ADDR
// reward_units := [ ] ;
3304: LD_ADDR_VAR 0 5
3308: PUSH
3309: EMPTY
3310: ST_TO_ADDR
// if scientists_dead = 0 then
3311: LD_EXP 49
3315: PUSH
3316: LD_INT 0
3318: EQUAL
3319: IFFALSE 3333
// AddMedal ( Science , 1 ) else
3321: LD_STRING Science
3323: PPUSH
3324: LD_INT 1
3326: PPUSH
3327: CALL_OW 101
3331: GO 3344
// AddMedal ( Science , - 1 ) ;
3333: LD_STRING Science
3335: PPUSH
3336: LD_INT 1
3338: NEG
3339: PPUSH
3340: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3344: LD_ADDR_VAR 0 4
3348: PUSH
3349: LD_INT 22
3351: PUSH
3352: LD_EXP 23
3356: PUSH
3357: EMPTY
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 2
3363: PUSH
3364: LD_INT 30
3366: PUSH
3367: LD_INT 0
3369: PUSH
3370: EMPTY
3371: LIST
3372: LIST
3373: PUSH
3374: LD_INT 30
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: EMPTY
3385: LIST
3386: LIST
3387: LIST
3388: PUSH
3389: EMPTY
3390: LIST
3391: LIST
3392: PPUSH
3393: CALL_OW 69
3397: ST_TO_ADDR
// matros := 0 ;
3398: LD_ADDR_VAR 0 2
3402: PUSH
3403: LD_INT 0
3405: ST_TO_ADDR
// if 0 + filter <> 0 then
3406: LD_INT 0
3408: PUSH
3409: LD_VAR 0 4
3413: PLUS
3414: PUSH
3415: LD_INT 0
3417: NONEQUAL
3418: IFFALSE 3466
// for un in filter do
3420: LD_ADDR_VAR 0 3
3424: PUSH
3425: LD_VAR 0 4
3429: PUSH
3430: FOR_IN
3431: IFFALSE 3464
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3433: LD_ADDR_VAR 0 2
3437: PUSH
3438: LD_VAR 0 2
3442: PUSH
3443: LD_VAR 0 3
3447: PPUSH
3448: CALL_OW 274
3452: PPUSH
3453: LD_INT 1
3455: PPUSH
3456: CALL_OW 275
3460: PLUS
3461: ST_TO_ADDR
3462: GO 3430
3464: POP
3465: POP
// if matros > 100 then
3466: LD_VAR 0 2
3470: PUSH
3471: LD_INT 100
3473: GREATER
3474: IFFALSE 3488
// AddMedal ( Effectivity , 1 ) else
3476: LD_STRING Effectivity
3478: PPUSH
3479: LD_INT 1
3481: PPUSH
3482: CALL_OW 101
3486: GO 3499
// AddMedal ( Effectivity , - 1 ) ;
3488: LD_STRING Effectivity
3490: PPUSH
3491: LD_INT 1
3493: NEG
3494: PPUSH
3495: CALL_OW 101
// rus_building_destroyed := false ;
3499: LD_ADDR_VAR 0 7
3503: PUSH
3504: LD_INT 0
3506: ST_TO_ADDR
// for un in rus_mcrep_bui do
3507: LD_ADDR_VAR 0 3
3511: PUSH
3512: LD_EXP 64
3516: PUSH
3517: FOR_IN
3518: IFFALSE 3548
// if not IsLive ( un ) then
3520: LD_VAR 0 3
3524: PPUSH
3525: CALL_OW 300
3529: NOT
3530: IFFALSE 3546
// rus_building_destroyed := rus_building_destroyed + 1 ;
3532: LD_ADDR_VAR 0 7
3536: PUSH
3537: LD_VAR 0 7
3541: PUSH
3542: LD_INT 1
3544: PLUS
3545: ST_TO_ADDR
3546: GO 3517
3548: POP
3549: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3550: LD_EXP 53
3554: PUSH
3555: LD_INT 5
3557: GREATEREQUAL
3558: PUSH
3559: LD_VAR 0 7
3563: PUSH
3564: LD_INT 2
3566: GREATEREQUAL
3567: OR
3568: IFFALSE 3583
// AddMedal ( LittleLosses , - 1 ) else
3570: LD_STRING LittleLosses
3572: PPUSH
3573: LD_INT 1
3575: NEG
3576: PPUSH
3577: CALL_OW 101
3581: GO 3593
// AddMedal ( LittleLosses , 1 ) ;
3583: LD_STRING LittleLosses
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , killed_russians >= 5 or rus_building_destroyed >= 2 ) ;
3593: LD_INT 4
3595: PPUSH
3596: LD_INT 5
3598: PPUSH
3599: LD_EXP 49
3603: PUSH
3604: LD_INT 0
3606: EQUAL
3607: PPUSH
3608: LD_VAR 0 2
3612: PUSH
3613: LD_INT 100
3615: GREATER
3616: PPUSH
3617: LD_EXP 53
3621: PUSH
3622: LD_INT 5
3624: GREATEREQUAL
3625: PUSH
3626: LD_VAR 0 7
3630: PUSH
3631: LD_INT 2
3633: GREATEREQUAL
3634: OR
3635: PPUSH
3636: CALL 14145 0 5
// GiveMedals ( Main ) ;
3640: LD_STRING Main
3642: PPUSH
3643: CALL_OW 102
// for un in player_units do
3647: LD_ADDR_VAR 0 3
3651: PUSH
3652: LD_EXP 41
3656: PUSH
3657: FOR_IN
3658: IFFALSE 3690
// if not IsDead ( un ) then
3660: LD_VAR 0 3
3664: PPUSH
3665: CALL_OW 301
3669: NOT
3670: IFFALSE 3688
// reward_units := reward_units ^ un ;
3672: LD_ADDR_VAR 0 5
3676: PUSH
3677: LD_VAR 0 5
3681: PUSH
3682: LD_VAR 0 3
3686: ADD
3687: ST_TO_ADDR
3688: GO 3657
3690: POP
3691: POP
// RewardPeople ( reward_units ) ;
3692: LD_VAR 0 5
3696: PPUSH
3697: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3701: LD_EXP 40
3705: PUSH
3706: LD_EXP 39
3710: PUSH
3711: LD_EXP 8
3715: ADD
3716: DIFF
3717: PPUSH
3718: LD_STRING scientists
3720: PPUSH
3721: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3725: LD_ADDR_VAR 0 6
3729: PUSH
3730: LD_EXP 41
3734: PUSH
3735: LD_EXP 39
3739: PUSH
3740: LD_EXP 40
3744: ADD
3745: PUSH
3746: LD_EXP 1
3750: ADD
3751: PUSH
3752: LD_EXP 8
3756: ADD
3757: DIFF
3758: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3759: LD_VAR 0 6
3763: PPUSH
3764: LD_STRING survivors5
3766: PPUSH
3767: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3771: LD_EXP 1
3775: PPUSH
3776: LD_STRING Burlak
3778: PPUSH
3779: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3783: LD_EXP 2
3787: PPUSH
3788: LD_STRING Belkov
3790: PPUSH
3791: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3795: LD_EXP 3
3799: PPUSH
3800: LD_STRING Gnyevko
3802: PPUSH
3803: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3807: LD_EXP 4
3811: PPUSH
3812: LD_STRING Kirilenkova
3814: PPUSH
3815: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3819: LD_EXP 5
3823: PPUSH
3824: LD_STRING Gleb
3826: PPUSH
3827: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3831: LD_EXP 6
3835: PPUSH
3836: LD_STRING Petrosyan
3838: PPUSH
3839: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3843: LD_EXP 7
3847: PPUSH
3848: LD_STRING Titov
3850: PPUSH
3851: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3855: LD_EXP 8
3859: PPUSH
3860: LD_STRING Gossudarov
3862: PPUSH
3863: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3867: LD_EXP 9
3871: PPUSH
3872: LD_STRING Kovalyuk
3874: PPUSH
3875: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3879: LD_EXP 10
3883: PPUSH
3884: LD_STRING Scholtze
3886: PPUSH
3887: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3891: LD_EXP 11
3895: PPUSH
3896: LD_STRING Kuzmov
3898: PPUSH
3899: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3903: LD_EXP 12
3907: PPUSH
3908: LD_STRING Karamazov
3910: PPUSH
3911: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3915: LD_EXP 13
3919: PPUSH
3920: LD_STRING Petrovova
3922: PPUSH
3923: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3927: LD_EXP 14
3931: PPUSH
3932: LD_STRING Lipshchin
3934: PPUSH
3935: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3939: LD_EXP 15
3943: PPUSH
3944: LD_STRING Dolgov
3946: PPUSH
3947: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
3951: LD_EXP 16
3955: PPUSH
3956: LD_STRING Xavier
3958: PPUSH
3959: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
3963: LD_EXP 17
3967: PPUSH
3968: LD_STRING Oblukov
3970: PPUSH
3971: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
3975: LD_EXP 18
3979: PPUSH
3980: LD_STRING Kozlov
3982: PPUSH
3983: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
3987: LD_EXP 19
3991: PPUSH
3992: LD_STRING Kapitsova
3994: PPUSH
3995: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
3999: LD_EXP 42
4003: PUSH
4004: LD_EXP 52
4008: AND
4009: PUSH
4010: LD_LOC 1
4014: NOT
4015: OR
4016: IFFALSE 4025
// DeleteVariable ( Masha ) ;
4018: LD_STRING Masha
4020: PPUSH
4021: CALL_OW 41
// if Belkov in scientists then
4025: LD_EXP 2
4029: PUSH
4030: LD_EXP 40
4034: IN
4035: IFFALSE 4047
// belkov_side := 2 else
4037: LD_ADDR_VAR 0 8
4041: PUSH
4042: LD_INT 2
4044: ST_TO_ADDR
4045: GO 4077
// if Belkov in player_units then
4047: LD_EXP 2
4051: PUSH
4052: LD_EXP 41
4056: IN
4057: IFFALSE 4069
// belkov_side := 1 else
4059: LD_ADDR_VAR 0 8
4063: PUSH
4064: LD_INT 1
4066: ST_TO_ADDR
4067: GO 4077
// belkov_side := 0 ;
4069: LD_ADDR_VAR 0 8
4073: PUSH
4074: LD_INT 0
4076: ST_TO_ADDR
// if Gnyevko in scientists then
4077: LD_EXP 3
4081: PUSH
4082: LD_EXP 40
4086: IN
4087: IFFALSE 4099
// gnyevko_side := 2 else
4089: LD_ADDR_VAR 0 9
4093: PUSH
4094: LD_INT 2
4096: ST_TO_ADDR
4097: GO 4129
// if Gnyevko in player_units then
4099: LD_EXP 3
4103: PUSH
4104: LD_EXP 41
4108: IN
4109: IFFALSE 4121
// gnyevko_side := 1 else
4111: LD_ADDR_VAR 0 9
4115: PUSH
4116: LD_INT 1
4118: ST_TO_ADDR
4119: GO 4129
// gnyevko_side := 0 ;
4121: LD_ADDR_VAR 0 9
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// if Kirilenkova in scientists then
4129: LD_EXP 4
4133: PUSH
4134: LD_EXP 40
4138: IN
4139: IFFALSE 4151
// kiril_side := 2 else
4141: LD_ADDR_VAR 0 10
4145: PUSH
4146: LD_INT 2
4148: ST_TO_ADDR
4149: GO 4181
// if Kirilenkova in player_units then
4151: LD_EXP 4
4155: PUSH
4156: LD_EXP 41
4160: IN
4161: IFFALSE 4173
// kiril_side := 1 else
4163: LD_ADDR_VAR 0 10
4167: PUSH
4168: LD_INT 1
4170: ST_TO_ADDR
4171: GO 4181
// kiril_side := 0 ;
4173: LD_ADDR_VAR 0 10
4177: PUSH
4178: LD_INT 0
4180: ST_TO_ADDR
// if Gleb in scientists then
4181: LD_EXP 5
4185: PUSH
4186: LD_EXP 40
4190: IN
4191: IFFALSE 4203
// gleb_side := 2 else
4193: LD_ADDR_VAR 0 16
4197: PUSH
4198: LD_INT 2
4200: ST_TO_ADDR
4201: GO 4233
// if Gleb in player_units then
4203: LD_EXP 5
4207: PUSH
4208: LD_EXP 41
4212: IN
4213: IFFALSE 4225
// gleb_side := 1 else
4215: LD_ADDR_VAR 0 16
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
4223: GO 4233
// gleb_side := 0 ;
4225: LD_ADDR_VAR 0 16
4229: PUSH
4230: LD_INT 0
4232: ST_TO_ADDR
// if Petrosyan in scientists then
4233: LD_EXP 6
4237: PUSH
4238: LD_EXP 40
4242: IN
4243: IFFALSE 4255
// petros_side := 2 else
4245: LD_ADDR_VAR 0 15
4249: PUSH
4250: LD_INT 2
4252: ST_TO_ADDR
4253: GO 4285
// if Petrosyan in player_units then
4255: LD_EXP 6
4259: PUSH
4260: LD_EXP 41
4264: IN
4265: IFFALSE 4277
// petros_side := 1 else
4267: LD_ADDR_VAR 0 15
4271: PUSH
4272: LD_INT 1
4274: ST_TO_ADDR
4275: GO 4285
// petros_side := 0 ;
4277: LD_ADDR_VAR 0 15
4281: PUSH
4282: LD_INT 0
4284: ST_TO_ADDR
// if Titov in scientists then
4285: LD_EXP 7
4289: PUSH
4290: LD_EXP 40
4294: IN
4295: IFFALSE 4307
// titov_side := 2 else
4297: LD_ADDR_VAR 0 19
4301: PUSH
4302: LD_INT 2
4304: ST_TO_ADDR
4305: GO 4337
// if Titov in player_units then
4307: LD_EXP 7
4311: PUSH
4312: LD_EXP 41
4316: IN
4317: IFFALSE 4329
// titov_side := 1 else
4319: LD_ADDR_VAR 0 19
4323: PUSH
4324: LD_INT 1
4326: ST_TO_ADDR
4327: GO 4337
// titov_side := 0 ;
4329: LD_ADDR_VAR 0 19
4333: PUSH
4334: LD_INT 0
4336: ST_TO_ADDR
// if Kovalyuk in scientists then
4337: LD_EXP 9
4341: PUSH
4342: LD_EXP 40
4346: IN
4347: IFFALSE 4359
// kovalyuk_side := 2 else
4349: LD_ADDR_VAR 0 11
4353: PUSH
4354: LD_INT 2
4356: ST_TO_ADDR
4357: GO 4389
// if Kovalyuk in player_units then
4359: LD_EXP 9
4363: PUSH
4364: LD_EXP 41
4368: IN
4369: IFFALSE 4381
// kovalyuk_side := 1 else
4371: LD_ADDR_VAR 0 11
4375: PUSH
4376: LD_INT 1
4378: ST_TO_ADDR
4379: GO 4389
// kovalyuk_side := 0 ;
4381: LD_ADDR_VAR 0 11
4385: PUSH
4386: LD_INT 0
4388: ST_TO_ADDR
// if Scholtze in scientists then
4389: LD_EXP 10
4393: PUSH
4394: LD_EXP 40
4398: IN
4399: IFFALSE 4411
// scholtze_side := 2 else
4401: LD_ADDR_VAR 0 12
4405: PUSH
4406: LD_INT 2
4408: ST_TO_ADDR
4409: GO 4441
// if Scholtze in player_units then
4411: LD_EXP 10
4415: PUSH
4416: LD_EXP 41
4420: IN
4421: IFFALSE 4433
// scholtze_side := 1 else
4423: LD_ADDR_VAR 0 12
4427: PUSH
4428: LD_INT 1
4430: ST_TO_ADDR
4431: GO 4441
// scholtze_side := 0 ;
4433: LD_ADDR_VAR 0 12
4437: PUSH
4438: LD_INT 0
4440: ST_TO_ADDR
// if Kuzmov in scientists then
4441: LD_EXP 11
4445: PUSH
4446: LD_EXP 40
4450: IN
4451: IFFALSE 4463
// kuzmov_side := 2 else
4453: LD_ADDR_VAR 0 13
4457: PUSH
4458: LD_INT 2
4460: ST_TO_ADDR
4461: GO 4493
// if Kuzmov in player_units then
4463: LD_EXP 11
4467: PUSH
4468: LD_EXP 41
4472: IN
4473: IFFALSE 4485
// kuzmov_side := 1 else
4475: LD_ADDR_VAR 0 13
4479: PUSH
4480: LD_INT 1
4482: ST_TO_ADDR
4483: GO 4493
// kuzmov_side := 0 ;
4485: LD_ADDR_VAR 0 13
4489: PUSH
4490: LD_INT 0
4492: ST_TO_ADDR
// if Karamazov in scientists then
4493: LD_EXP 12
4497: PUSH
4498: LD_EXP 40
4502: IN
4503: IFFALSE 4515
// karam_side := 2 else
4505: LD_ADDR_VAR 0 14
4509: PUSH
4510: LD_INT 2
4512: ST_TO_ADDR
4513: GO 4545
// if Karamazov in player_units then
4515: LD_EXP 12
4519: PUSH
4520: LD_EXP 41
4524: IN
4525: IFFALSE 4537
// karam_side := 1 else
4527: LD_ADDR_VAR 0 14
4531: PUSH
4532: LD_INT 1
4534: ST_TO_ADDR
4535: GO 4545
// karam_side := 0 ;
4537: LD_ADDR_VAR 0 14
4541: PUSH
4542: LD_INT 0
4544: ST_TO_ADDR
// if Petrovova in scientists then
4545: LD_EXP 13
4549: PUSH
4550: LD_EXP 40
4554: IN
4555: IFFALSE 4567
// petrov_side := 2 else
4557: LD_ADDR_VAR 0 17
4561: PUSH
4562: LD_INT 2
4564: ST_TO_ADDR
4565: GO 4597
// if Petrovova in player_units then
4567: LD_EXP 13
4571: PUSH
4572: LD_EXP 41
4576: IN
4577: IFFALSE 4589
// petrov_side := 1 else
4579: LD_ADDR_VAR 0 17
4583: PUSH
4584: LD_INT 1
4586: ST_TO_ADDR
4587: GO 4597
// petrov_side := 0 ;
4589: LD_ADDR_VAR 0 17
4593: PUSH
4594: LD_INT 0
4596: ST_TO_ADDR
// if Lipshchin in scientists then
4597: LD_EXP 14
4601: PUSH
4602: LD_EXP 40
4606: IN
4607: IFFALSE 4619
// lipshchin_side := 2 else
4609: LD_ADDR_VAR 0 18
4613: PUSH
4614: LD_INT 2
4616: ST_TO_ADDR
4617: GO 4649
// if Lipshchin in player_units then
4619: LD_EXP 14
4623: PUSH
4624: LD_EXP 41
4628: IN
4629: IFFALSE 4641
// lipshchin_side := 1 else
4631: LD_ADDR_VAR 0 18
4635: PUSH
4636: LD_INT 1
4638: ST_TO_ADDR
4639: GO 4649
// lipshchin_side := 0 ;
4641: LD_ADDR_VAR 0 18
4645: PUSH
4646: LD_INT 0
4648: ST_TO_ADDR
// if Dolgov in scientists then
4649: LD_EXP 15
4653: PUSH
4654: LD_EXP 40
4658: IN
4659: IFFALSE 4671
// dolgov_side := 2 else
4661: LD_ADDR_VAR 0 20
4665: PUSH
4666: LD_INT 2
4668: ST_TO_ADDR
4669: GO 4701
// if Dolgov in player_units then
4671: LD_EXP 15
4675: PUSH
4676: LD_EXP 41
4680: IN
4681: IFFALSE 4693
// dolgov_side := 1 else
4683: LD_ADDR_VAR 0 20
4687: PUSH
4688: LD_INT 1
4690: ST_TO_ADDR
4691: GO 4701
// dolgov_side := 0 ;
4693: LD_ADDR_VAR 0 20
4697: PUSH
4698: LD_INT 0
4700: ST_TO_ADDR
// if Xavier in scientists then
4701: LD_EXP 16
4705: PUSH
4706: LD_EXP 40
4710: IN
4711: IFFALSE 4723
// xavier_side := 2 else
4713: LD_ADDR_VAR 0 21
4717: PUSH
4718: LD_INT 2
4720: ST_TO_ADDR
4721: GO 4753
// if Xavier in player_units then
4723: LD_EXP 16
4727: PUSH
4728: LD_EXP 41
4732: IN
4733: IFFALSE 4745
// xavier_side := 1 else
4735: LD_ADDR_VAR 0 21
4739: PUSH
4740: LD_INT 1
4742: ST_TO_ADDR
4743: GO 4753
// xavier_side := 0 ;
4745: LD_ADDR_VAR 0 21
4749: PUSH
4750: LD_INT 0
4752: ST_TO_ADDR
// if Oblukov in scientists then
4753: LD_EXP 17
4757: PUSH
4758: LD_EXP 40
4762: IN
4763: IFFALSE 4775
// oblukov_side := 2 else
4765: LD_ADDR_VAR 0 22
4769: PUSH
4770: LD_INT 2
4772: ST_TO_ADDR
4773: GO 4805
// if Oblukov in player_units then
4775: LD_EXP 17
4779: PUSH
4780: LD_EXP 41
4784: IN
4785: IFFALSE 4797
// oblukov_side := 1 else
4787: LD_ADDR_VAR 0 22
4791: PUSH
4792: LD_INT 1
4794: ST_TO_ADDR
4795: GO 4805
// oblukov_side := 0 ;
4797: LD_ADDR_VAR 0 22
4801: PUSH
4802: LD_INT 0
4804: ST_TO_ADDR
// if Kozlov in scientists then
4805: LD_EXP 18
4809: PUSH
4810: LD_EXP 40
4814: IN
4815: IFFALSE 4827
// kozlov_side := 2 else
4817: LD_ADDR_VAR 0 23
4821: PUSH
4822: LD_INT 2
4824: ST_TO_ADDR
4825: GO 4857
// if Kozlov in player_units then
4827: LD_EXP 18
4831: PUSH
4832: LD_EXP 41
4836: IN
4837: IFFALSE 4849
// kozlov_side := 1 else
4839: LD_ADDR_VAR 0 23
4843: PUSH
4844: LD_INT 1
4846: ST_TO_ADDR
4847: GO 4857
// kozlov_side := 0 ;
4849: LD_ADDR_VAR 0 23
4853: PUSH
4854: LD_INT 0
4856: ST_TO_ADDR
// if Kapitsova in scientists then
4857: LD_EXP 19
4861: PUSH
4862: LD_EXP 40
4866: IN
4867: IFFALSE 4879
// kapitsova_side := 2 else
4869: LD_ADDR_VAR 0 24
4873: PUSH
4874: LD_INT 2
4876: ST_TO_ADDR
4877: GO 4909
// if Kapitsova in player_units then
4879: LD_EXP 19
4883: PUSH
4884: LD_EXP 41
4888: IN
4889: IFFALSE 4901
// kapitsova_side := 1 else
4891: LD_ADDR_VAR 0 24
4895: PUSH
4896: LD_INT 1
4898: ST_TO_ADDR
4899: GO 4909
// kapitsova_side := 0 ;
4901: LD_ADDR_VAR 0 24
4905: PUSH
4906: LD_INT 0
4908: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4909: LD_VAR 0 8
4913: PPUSH
4914: LD_STRING belkov_side
4916: PPUSH
4917: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4921: LD_VAR 0 9
4925: PPUSH
4926: LD_STRING gnyevko_side
4928: PPUSH
4929: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4933: LD_VAR 0 10
4937: PPUSH
4938: LD_STRING kiril_side
4940: PPUSH
4941: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4945: LD_VAR 0 16
4949: PPUSH
4950: LD_STRING gleb_side
4952: PPUSH
4953: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
4957: LD_VAR 0 15
4961: PPUSH
4962: LD_STRING petros_side
4964: PPUSH
4965: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
4969: LD_VAR 0 19
4973: PPUSH
4974: LD_STRING titov_side
4976: PPUSH
4977: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
4981: LD_VAR 0 11
4985: PPUSH
4986: LD_STRING kovalyuk_side
4988: PPUSH
4989: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
4993: LD_VAR 0 12
4997: PPUSH
4998: LD_STRING scholtze_side
5000: PPUSH
5001: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5005: LD_VAR 0 13
5009: PPUSH
5010: LD_STRING kuzmov_side
5012: PPUSH
5013: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5017: LD_VAR 0 14
5021: PPUSH
5022: LD_STRING karam_side
5024: PPUSH
5025: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5029: LD_VAR 0 17
5033: PPUSH
5034: LD_STRING petrov_side
5036: PPUSH
5037: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5041: LD_VAR 0 18
5045: PPUSH
5046: LD_STRING lipshchin_side
5048: PPUSH
5049: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5053: LD_VAR 0 20
5057: PPUSH
5058: LD_STRING dolgov_side
5060: PPUSH
5061: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5065: LD_VAR 0 21
5069: PPUSH
5070: LD_STRING xavier_side
5072: PPUSH
5073: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5077: LD_VAR 0 22
5081: PPUSH
5082: LD_STRING oblukov_side
5084: PPUSH
5085: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5089: LD_VAR 0 23
5093: PPUSH
5094: LD_STRING kozlov_side
5096: PPUSH
5097: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5101: LD_VAR 0 24
5105: PPUSH
5106: LD_STRING kapitsova_side
5108: PPUSH
5109: CALL_OW 39
// YouWin ;
5113: CALL_OW 103
// exit ;
5117: GO 5119
// end ; end_of_file
5119: LD_VAR 0 1
5123: RET
// export function D_Start ; begin
5124: LD_INT 0
5126: PPUSH
// DisableExclamations ;
5127: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5131: LD_EXP 8
5135: PPUSH
5136: LD_STRING DStart-Gos-1
5138: PPUSH
5139: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5143: LD_EXP 1
5147: PPUSH
5148: LD_STRING DStart-Bur-1
5150: PPUSH
5151: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5155: LD_EXP 8
5159: PPUSH
5160: LD_STRING DStart-Gos-2
5162: PPUSH
5163: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5167: LD_EXP 1
5171: PPUSH
5172: LD_STRING DStart-Bur-2
5174: PPUSH
5175: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5179: LD_EXP 8
5183: PPUSH
5184: LD_STRING DStart-Gos-3
5186: PPUSH
5187: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5191: LD_EXP 1
5195: PPUSH
5196: LD_STRING DStart-Bur-3
5198: PPUSH
5199: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5203: LD_EXP 8
5207: PPUSH
5208: LD_STRING DStart-Gos-4
5210: PPUSH
5211: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5215: LD_EXP 1
5219: PPUSH
5220: LD_STRING DStart-Bur-4
5222: PPUSH
5223: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5227: LD_EXP 8
5231: PPUSH
5232: LD_STRING DStart-Gos-5
5234: PPUSH
5235: CALL_OW 88
// EnableExclamations ;
5239: CALL_OW 473
// end ;
5243: LD_VAR 0 1
5247: RET
// export function D_Platonov ; begin
5248: LD_INT 0
5250: PPUSH
// DisableExclamations ;
5251: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5255: LD_EXP 21
5259: PPUSH
5260: LD_STRING DPlatonov-Rsol1-1
5262: PPUSH
5263: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5267: LD_EXP 1
5271: PPUSH
5272: LD_STRING DPlatonov-Bur-1
5274: PPUSH
5275: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5279: LD_EXP 21
5283: PPUSH
5284: LD_STRING DPlatonov-Rsol1-2
5286: PPUSH
5287: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5291: LD_EXP 1
5295: PPUSH
5296: LD_STRING DPlatonov-Bur-2
5298: PPUSH
5299: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5303: LD_EXP 1
5307: PPUSH
5308: LD_EXP 43
5312: PPUSH
5313: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5317: LD_EXP 21
5321: PPUSH
5322: LD_STRING DPlatonov-Rsol1-3
5324: PPUSH
5325: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5329: LD_INT 7
5331: PPUSH
5332: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5336: LD_EXP 43
5340: PPUSH
5341: CALL_OW 311
5345: PUSH
5346: LD_EXP 1
5350: EQUAL
5351: IFFALSE 5329
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5353: LD_EXP 1
5357: PPUSH
5358: LD_STRING DPlatonov-Bur-3
5360: PPUSH
5361: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5365: LD_EXP 1
5369: PPUSH
5370: LD_EXP 21
5374: PPUSH
5375: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5379: LD_INT 7
5381: PPUSH
5382: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5386: LD_EXP 43
5390: PPUSH
5391: CALL_OW 320
5395: PUSH
5396: LD_EXP 21
5400: EQUAL
5401: IFFALSE 5379
// Wait ( 0 0$0.5 ) ;
5403: LD_INT 18
5405: PPUSH
5406: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5410: LD_EXP 21
5414: PPUSH
5415: LD_STRING DPlatonov-Rsol1-4
5417: PPUSH
5418: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5422: LD_EXP 21
5426: PPUSH
5427: LD_EXP 43
5431: PPUSH
5432: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5436: LD_EXP 1
5440: PPUSH
5441: LD_EXP 21
5445: PPUSH
5446: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5450: LD_EXP 20
5454: PPUSH
5455: LD_STRING DPlatonov-Pla-4
5457: PPUSH
5458: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5462: LD_EXP 20
5466: PPUSH
5467: LD_STRING DPlatonov-Pla-4a
5469: PPUSH
5470: CALL_OW 88
// EnableExclamations ;
5474: CALL_OW 473
// end ;
5478: LD_VAR 0 1
5482: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5483: LD_INT 0
5485: PPUSH
5486: PPUSH
5487: PPUSH
5488: PPUSH
// DisableExclamations ;
5489: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5493: LD_EXP 2
5497: PPUSH
5498: CALL_OW 302
5502: PUSH
5503: LD_EXP 2
5507: PPUSH
5508: CALL_OW 255
5512: PUSH
5513: LD_EXP 23
5517: EQUAL
5518: AND
5519: IFFALSE 5533
// Say ( Belkov , DGosStart-Bel-1 ) ;
5521: LD_EXP 2
5525: PPUSH
5526: LD_STRING DGosStart-Bel-1
5528: PPUSH
5529: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5533: LD_EXP 3
5537: PPUSH
5538: CALL_OW 302
5542: PUSH
5543: LD_EXP 3
5547: PPUSH
5548: CALL_OW 255
5552: PUSH
5553: LD_EXP 23
5557: EQUAL
5558: AND
5559: IFFALSE 5573
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5561: LD_EXP 3
5565: PPUSH
5566: LD_STRING DGosStart-Gny-1
5568: PPUSH
5569: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5573: LD_EXP 5
5577: PPUSH
5578: CALL_OW 302
5582: PUSH
5583: LD_EXP 5
5587: PPUSH
5588: CALL_OW 255
5592: PUSH
5593: LD_EXP 23
5597: EQUAL
5598: AND
5599: IFFALSE 5613
// Say ( Gleb , DGosStart-Glb-1 ) ;
5601: LD_EXP 5
5605: PPUSH
5606: LD_STRING DGosStart-Glb-1
5608: PPUSH
5609: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5613: LD_EXP 6
5617: PPUSH
5618: CALL_OW 302
5622: PUSH
5623: LD_EXP 6
5627: PPUSH
5628: CALL_OW 255
5632: PUSH
5633: LD_EXP 23
5637: EQUAL
5638: AND
5639: IFFALSE 5653
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5641: LD_EXP 6
5645: PPUSH
5646: LD_STRING DGosStart-Pty-1
5648: PPUSH
5649: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5653: LD_EXP 7
5657: PPUSH
5658: CALL_OW 302
5662: PUSH
5663: LD_EXP 7
5667: PPUSH
5668: CALL_OW 255
5672: PUSH
5673: LD_EXP 23
5677: EQUAL
5678: AND
5679: IFFALSE 5693
// Say ( Titov , DGosStart-Tit-1 ) ;
5681: LD_EXP 7
5685: PPUSH
5686: LD_STRING DGosStart-Tit-1
5688: PPUSH
5689: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5693: LD_EXP 4
5697: PPUSH
5698: CALL_OW 302
5702: PUSH
5703: LD_EXP 4
5707: PPUSH
5708: CALL_OW 255
5712: PUSH
5713: LD_EXP 23
5717: EQUAL
5718: AND
5719: IFFALSE 5733
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5721: LD_EXP 4
5725: PPUSH
5726: LD_STRING DGosStart-Kir-1
5728: PPUSH
5729: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5733: LD_EXP 2
5737: PPUSH
5738: CALL_OW 302
5742: PUSH
5743: LD_EXP 2
5747: PPUSH
5748: CALL_OW 255
5752: PUSH
5753: LD_EXP 23
5757: EQUAL
5758: AND
5759: PUSH
5760: LD_EXP 3
5764: PPUSH
5765: CALL_OW 302
5769: PUSH
5770: LD_EXP 3
5774: PPUSH
5775: CALL_OW 255
5779: PUSH
5780: LD_EXP 23
5784: EQUAL
5785: AND
5786: OR
5787: PUSH
5788: LD_EXP 5
5792: PPUSH
5793: CALL_OW 302
5797: PUSH
5798: LD_EXP 5
5802: PPUSH
5803: CALL_OW 255
5807: PUSH
5808: LD_EXP 23
5812: EQUAL
5813: AND
5814: OR
5815: PUSH
5816: LD_EXP 6
5820: PPUSH
5821: CALL_OW 302
5825: PUSH
5826: LD_EXP 6
5830: PPUSH
5831: CALL_OW 255
5835: PUSH
5836: LD_EXP 23
5840: EQUAL
5841: AND
5842: OR
5843: PUSH
5844: LD_EXP 7
5848: PPUSH
5849: CALL_OW 302
5853: PUSH
5854: LD_EXP 7
5858: PPUSH
5859: CALL_OW 255
5863: PUSH
5864: LD_EXP 23
5868: EQUAL
5869: AND
5870: OR
5871: PUSH
5872: LD_EXP 4
5876: PPUSH
5877: CALL_OW 302
5881: PUSH
5882: LD_EXP 4
5886: PPUSH
5887: CALL_OW 255
5891: PUSH
5892: LD_EXP 23
5896: EQUAL
5897: AND
5898: OR
5899: NOT
5900: IFFALSE 6264
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5902: LD_ADDR_VAR 0 4
5906: PUSH
5907: LD_INT 22
5909: PUSH
5910: LD_EXP 23
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: LD_INT 26
5921: PUSH
5922: LD_INT 1
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: PUSH
5929: LD_INT 50
5931: PUSH
5932: EMPTY
5933: LIST
5934: PUSH
5935: LD_INT 3
5937: PUSH
5938: LD_INT 23
5940: PUSH
5941: LD_INT 0
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: PPUSH
5958: CALL_OW 69
5962: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
5963: LD_ADDR_VAR 0 4
5967: PUSH
5968: LD_VAR 0 4
5972: PUSH
5973: LD_EXP 1
5977: DIFF
5978: ST_TO_ADDR
// if 0 + filter_all > 0 then
5979: LD_INT 0
5981: PUSH
5982: LD_VAR 0 4
5986: PLUS
5987: PUSH
5988: LD_INT 0
5990: GREATER
5991: IFFALSE 6092
// begin filter := [ ] ;
5993: LD_ADDR_VAR 0 3
5997: PUSH
5998: EMPTY
5999: ST_TO_ADDR
// for un in filter_all do
6000: LD_ADDR_VAR 0 2
6004: PUSH
6005: LD_VAR 0 4
6009: PUSH
6010: FOR_IN
6011: IFFALSE 6044
// if not ( un in all_possible ) then
6013: LD_VAR 0 2
6017: PUSH
6018: LD_EXP 39
6022: IN
6023: NOT
6024: IFFALSE 6042
// filter := filter union un ;
6026: LD_ADDR_VAR 0 3
6030: PUSH
6031: LD_VAR 0 3
6035: PUSH
6036: LD_VAR 0 2
6040: UNION
6041: ST_TO_ADDR
6042: GO 6010
6044: POP
6045: POP
// if filter > 0 then
6046: LD_VAR 0 3
6050: PUSH
6051: LD_INT 0
6053: GREATER
6054: IFFALSE 6074
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6056: LD_VAR 0 3
6060: PUSH
6061: LD_INT 1
6063: ARRAY
6064: PPUSH
6065: LD_STRING DGosStart-Sol1-1
6067: PPUSH
6068: CALL_OW 88
6072: GO 6090
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6074: LD_VAR 0 4
6078: PUSH
6079: LD_INT 1
6081: ARRAY
6082: PPUSH
6083: LD_STRING DGosStart-Sol1-1
6085: PPUSH
6086: CALL_OW 88
// end else
6090: GO 6264
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6092: LD_ADDR_VAR 0 4
6096: PUSH
6097: LD_INT 22
6099: PUSH
6100: LD_EXP 23
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 26
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: LD_INT 50
6121: PUSH
6122: EMPTY
6123: LIST
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 23
6130: PUSH
6131: LD_INT 0
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 69
6152: ST_TO_ADDR
// if 0 + filter_all > 0 then
6153: LD_INT 0
6155: PUSH
6156: LD_VAR 0 4
6160: PLUS
6161: PUSH
6162: LD_INT 0
6164: GREATER
6165: IFFALSE 6264
// begin filter := [ ] ;
6167: LD_ADDR_VAR 0 3
6171: PUSH
6172: EMPTY
6173: ST_TO_ADDR
// for un in filter_all do
6174: LD_ADDR_VAR 0 2
6178: PUSH
6179: LD_VAR 0 4
6183: PUSH
6184: FOR_IN
6185: IFFALSE 6218
// if not ( un in all_possible ) then
6187: LD_VAR 0 2
6191: PUSH
6192: LD_EXP 39
6196: IN
6197: NOT
6198: IFFALSE 6216
// filter := filter union un ;
6200: LD_ADDR_VAR 0 3
6204: PUSH
6205: LD_VAR 0 3
6209: PUSH
6210: LD_VAR 0 2
6214: UNION
6215: ST_TO_ADDR
6216: GO 6184
6218: POP
6219: POP
// if filter > 0 then
6220: LD_VAR 0 3
6224: PUSH
6225: LD_INT 0
6227: GREATER
6228: IFFALSE 6248
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6230: LD_VAR 0 3
6234: PUSH
6235: LD_INT 1
6237: ARRAY
6238: PPUSH
6239: LD_STRING DGosStart-FSol1-1
6241: PPUSH
6242: CALL_OW 88
6246: GO 6264
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6248: LD_VAR 0 4
6252: PUSH
6253: LD_INT 1
6255: ARRAY
6256: PPUSH
6257: LD_STRING DGosStart-FSol1-1
6259: PPUSH
6260: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6264: LD_EXP 1
6268: PPUSH
6269: LD_STRING DGosStart-Bur-1
6271: PPUSH
6272: CALL_OW 88
// Wait ( 0 0$20 ) ;
6276: LD_INT 700
6278: PPUSH
6279: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6283: LD_EXP 1
6287: PPUSH
6288: LD_STRING DGosStart-Bur-1a
6290: PPUSH
6291: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6295: LD_EXP 8
6299: PPUSH
6300: LD_STRING DGosStart-Gos-1
6302: PPUSH
6303: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6307: LD_EXP 1
6311: PPUSH
6312: LD_STRING DGosStart-Bur-2
6314: PPUSH
6315: CALL_OW 88
// Hint ( Signal ) ;
6319: LD_STRING Signal
6321: PPUSH
6322: CALL_OW 339
// attackAvalaible = 1 ;
6326: LD_ADDR_EXP 61
6330: PUSH
6331: LD_INT 1
6333: ST_TO_ADDR
// enable ( 6 ) ;
6334: LD_INT 6
6336: ENABLE_MARKED
// EnableExclamations ;
6337: CALL_OW 473
// end ;
6341: LD_VAR 0 1
6345: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6346: LD_INT 0
6348: PPUSH
6349: PPUSH
6350: PPUSH
6351: PPUSH
// DisableExclamations ;
6352: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6356: LD_EXP 1
6360: PPUSH
6361: LD_STRING DSituation-Bur-1
6363: PPUSH
6364: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6368: LD_ADDR_VAR 0 4
6372: PUSH
6373: LD_INT 22
6375: PUSH
6376: LD_EXP 23
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 26
6387: PUSH
6388: LD_INT 2
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: PUSH
6395: LD_INT 50
6397: PUSH
6398: EMPTY
6399: LIST
6400: PUSH
6401: LD_INT 3
6403: PUSH
6404: LD_INT 23
6406: PUSH
6407: LD_INT 0
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: PPUSH
6424: CALL_OW 69
6428: ST_TO_ADDR
// if 0 + filter_all > 0 then
6429: LD_INT 0
6431: PUSH
6432: LD_VAR 0 4
6436: PLUS
6437: PUSH
6438: LD_INT 0
6440: GREATER
6441: IFFALSE 6542
// begin filter := [ ] ;
6443: LD_ADDR_VAR 0 3
6447: PUSH
6448: EMPTY
6449: ST_TO_ADDR
// for un in filter_all do
6450: LD_ADDR_VAR 0 2
6454: PUSH
6455: LD_VAR 0 4
6459: PUSH
6460: FOR_IN
6461: IFFALSE 6494
// if not ( un in all_possible ) then
6463: LD_VAR 0 2
6467: PUSH
6468: LD_EXP 39
6472: IN
6473: NOT
6474: IFFALSE 6492
// filter := filter union un ;
6476: LD_ADDR_VAR 0 3
6480: PUSH
6481: LD_VAR 0 3
6485: PUSH
6486: LD_VAR 0 2
6490: UNION
6491: ST_TO_ADDR
6492: GO 6460
6494: POP
6495: POP
// if filter > 0 then
6496: LD_VAR 0 3
6500: PUSH
6501: LD_INT 0
6503: GREATER
6504: IFFALSE 6524
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6506: LD_VAR 0 3
6510: PUSH
6511: LD_INT 1
6513: ARRAY
6514: PPUSH
6515: LD_STRING DSituation-RFSol1-1
6517: PPUSH
6518: CALL_OW 88
6522: GO 6540
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6524: LD_VAR 0 4
6528: PUSH
6529: LD_INT 1
6531: ARRAY
6532: PPUSH
6533: LD_STRING DSituation-RFSol1-1
6535: PPUSH
6536: CALL_OW 88
// end else
6540: GO 6730
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6542: LD_ADDR_VAR 0 4
6546: PUSH
6547: LD_INT 22
6549: PUSH
6550: LD_EXP 23
6554: PUSH
6555: EMPTY
6556: LIST
6557: LIST
6558: PUSH
6559: LD_INT 26
6561: PUSH
6562: LD_INT 1
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 50
6571: PUSH
6572: EMPTY
6573: LIST
6574: PUSH
6575: LD_INT 3
6577: PUSH
6578: LD_INT 23
6580: PUSH
6581: LD_INT 0
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: LIST
6596: LIST
6597: PPUSH
6598: CALL_OW 69
6602: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6603: LD_ADDR_VAR 0 4
6607: PUSH
6608: LD_VAR 0 4
6612: PUSH
6613: LD_EXP 1
6617: DIFF
6618: ST_TO_ADDR
// if 0 + filter_all > 0 then
6619: LD_INT 0
6621: PUSH
6622: LD_VAR 0 4
6626: PLUS
6627: PUSH
6628: LD_INT 0
6630: GREATER
6631: IFFALSE 6730
// begin filter := [ ] ;
6633: LD_ADDR_VAR 0 3
6637: PUSH
6638: EMPTY
6639: ST_TO_ADDR
// for un in filter_all do
6640: LD_ADDR_VAR 0 2
6644: PUSH
6645: LD_VAR 0 4
6649: PUSH
6650: FOR_IN
6651: IFFALSE 6684
// if not ( un in all_possible ) then
6653: LD_VAR 0 2
6657: PUSH
6658: LD_EXP 39
6662: IN
6663: NOT
6664: IFFALSE 6682
// filter := filter union un ;
6666: LD_ADDR_VAR 0 3
6670: PUSH
6671: LD_VAR 0 3
6675: PUSH
6676: LD_VAR 0 2
6680: UNION
6681: ST_TO_ADDR
6682: GO 6650
6684: POP
6685: POP
// if filter > 0 then
6686: LD_VAR 0 3
6690: PUSH
6691: LD_INT 0
6693: GREATER
6694: IFFALSE 6714
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6696: LD_VAR 0 3
6700: PUSH
6701: LD_INT 1
6703: ARRAY
6704: PPUSH
6705: LD_STRING DSituation-RSol1-1
6707: PPUSH
6708: CALL_OW 88
6712: GO 6730
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6714: LD_VAR 0 4
6718: PUSH
6719: LD_INT 1
6721: ARRAY
6722: PPUSH
6723: LD_STRING DSituation-RSol1-1
6725: PPUSH
6726: CALL_OW 88
// end ; end ; EnableExclamations ;
6730: CALL_OW 473
// end ;
6734: LD_VAR 0 1
6738: RET
// export function D_GO1 ; begin
6739: LD_INT 0
6741: PPUSH
// DisableExclamations ;
6742: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6746: LD_EXP 1
6750: PPUSH
6751: LD_STRING DGO#1-Bur-1
6753: PPUSH
6754: CALL_OW 88
// EnableExclamations ;
6758: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6762: LD_INT 11
6764: PPUSH
6765: LD_INT 1
6767: PPUSH
6768: CALL_OW 424
// end ;
6772: LD_VAR 0 1
6776: RET
// export function D_SeeYou ; begin
6777: LD_INT 0
6779: PPUSH
// DisableExclamations ;
6780: CALL_OW 474
// DialogueOn ;
6784: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6788: LD_EXP 8
6792: PPUSH
6793: LD_STRING DSeeYou-Gos-1
6795: PPUSH
6796: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6800: LD_EXP 1
6804: PPUSH
6805: LD_STRING DSeeYou-Bur-1
6807: PPUSH
6808: CALL_OW 88
// DialogueOff ;
6812: CALL_OW 7
// EnableExclamations ;
6816: CALL_OW 473
// end ; end_of_file
6820: LD_VAR 0 1
6824: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6825: GO 6827
6827: DISABLE
6828: LD_INT 0
6830: PPUSH
6831: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6832: LD_EXP 1
6836: PPUSH
6837: LD_INT 1
6839: PPUSH
6840: CALL_OW 308
6844: IFFALSE 6910
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6846: LD_ADDR_VAR 0 1
6850: PUSH
6851: LD_INT 22
6853: PUSH
6854: LD_EXP 27
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: PPUSH
6863: CALL_OW 69
6867: ST_TO_ADDR
// for un in filter do
6868: LD_ADDR_VAR 0 2
6872: PUSH
6873: LD_VAR 0 1
6877: PUSH
6878: FOR_IN
6879: IFFALSE 6897
// setside ( un , you ) ;
6881: LD_VAR 0 2
6885: PPUSH
6886: LD_EXP 23
6890: PPUSH
6891: CALL_OW 235
6895: GO 6878
6897: POP
6898: POP
// BurlakReachedBase := true ;
6899: LD_ADDR_EXP 28
6903: PUSH
6904: LD_INT 1
6906: ST_TO_ADDR
// disable ;
6907: DISABLE
// end else
6908: GO 6911
// enable ;
6910: ENABLE
// end ;
6911: PPOPN 2
6913: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6914: GO 6916
6916: DISABLE
6917: LD_INT 0
6919: PPUSH
6920: PPUSH
6921: PPUSH
6922: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6923: LD_EXP 1
6927: PPUSH
6928: LD_INT 10
6930: PPUSH
6931: CALL_OW 308
6935: IFFALSE 7166
// begin DisableExclamations ;
6937: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6941: LD_ADDR_VAR 0 1
6945: PUSH
6946: LD_INT 22
6948: PUSH
6949: LD_EXP 27
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: PPUSH
6958: CALL_OW 69
6962: ST_TO_ADDR
// skill := 0 ;
6963: LD_ADDR_VAR 0 3
6967: PUSH
6968: LD_INT 0
6970: ST_TO_ADDR
// for un in filter do
6971: LD_ADDR_VAR 0 2
6975: PUSH
6976: LD_VAR 0 1
6980: PUSH
6981: FOR_IN
6982: IFFALSE 7016
// if GetSkill ( un , skill_engineering ) >= skill then
6984: LD_VAR 0 2
6988: PPUSH
6989: LD_INT 2
6991: PPUSH
6992: CALL_OW 259
6996: PUSH
6997: LD_VAR 0 3
7001: GREATEREQUAL
7002: IFFALSE 7014
// inzenyr := un ;
7004: LD_ADDR_VAR 0 4
7008: PUSH
7009: LD_VAR 0 2
7013: ST_TO_ADDR
7014: GO 6981
7016: POP
7017: POP
// ComStop ( inzenyr ) ;
7018: LD_VAR 0 4
7022: PPUSH
7023: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7027: LD_VAR 0 4
7031: PPUSH
7032: CALL_OW 257
7036: PUSH
7037: LD_INT 2
7039: NONEQUAL
7040: IFFALSE 7131
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7042: LD_ADDR_VAR 0 1
7046: PUSH
7047: LD_INT 30
7049: PUSH
7050: LD_INT 1
7052: PUSH
7053: EMPTY
7054: LIST
7055: LIST
7056: PUSH
7057: LD_INT 22
7059: PUSH
7060: LD_EXP 27
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: PPUSH
7073: CALL_OW 69
7077: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7078: LD_VAR 0 4
7082: PPUSH
7083: LD_VAR 0 1
7087: PUSH
7088: LD_INT 1
7090: ARRAY
7091: PPUSH
7092: CALL_OW 120
// Wait ( 10 ) ;
7096: LD_INT 10
7098: PPUSH
7099: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7103: LD_VAR 0 4
7107: PPUSH
7108: LD_INT 2
7110: PPUSH
7111: CALL_OW 183
// Wait ( 10 ) ;
7115: LD_INT 10
7117: PPUSH
7118: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7122: LD_VAR 0 4
7126: PPUSH
7127: CALL_OW 182
// end ; Wait ( 10 ) ;
7131: LD_INT 10
7133: PPUSH
7134: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7138: LD_VAR 0 4
7142: PPUSH
7143: LD_INT 26
7145: PPUSH
7146: LD_INT 126
7148: PPUSH
7149: LD_INT 17
7151: PPUSH
7152: LD_INT 5
7154: PPUSH
7155: CALL_OW 205
// EnableExclamations ;
7159: CALL_OW 473
// disable ;
7163: DISABLE
// end else
7164: GO 7167
// enable ;
7166: ENABLE
// end ;
7167: PPOPN 4
7169: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7170: GO 7172
7172: DISABLE
7173: LD_INT 0
7175: PPUSH
7176: PPUSH
// begin if straz < bazooker then
7177: LD_EXP 45
7181: PUSH
7182: LD_EXP 51
7186: LESS
7187: IFFALSE 7335
// begin bazooker := bazooker + 1 ;
7189: LD_ADDR_EXP 51
7193: PUSH
7194: LD_EXP 51
7198: PUSH
7199: LD_INT 1
7201: PLUS
7202: ST_TO_ADDR
// while straz < bazooker do
7203: LD_EXP 45
7207: PUSH
7208: LD_EXP 51
7212: LESS
7213: IFFALSE 7335
// begin uc_side := rus ;
7215: LD_ADDR_OWVAR 20
7219: PUSH
7220: LD_EXP 24
7224: ST_TO_ADDR
// uc_nation := nation_russian ;
7225: LD_ADDR_OWVAR 21
7229: PUSH
7230: LD_INT 3
7232: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 7 + difficulty ) ;
7233: LD_INT 1
7235: PPUSH
7236: LD_INT 9
7238: PPUSH
7239: LD_INT 7
7241: PUSH
7242: LD_OWVAR 67
7246: PLUS
7247: PPUSH
7248: CALL_OW 380
// hc_name :=  ;
7252: LD_ADDR_OWVAR 26
7256: PUSH
7257: LD_STRING 
7259: ST_TO_ADDR
// bazukr := CreateHuman ;
7260: LD_ADDR_VAR 0 2
7264: PUSH
7265: CALL_OW 44
7269: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7270: LD_EXP 62
7274: PPUSH
7275: LD_VAR 0 2
7279: PPUSH
7280: LD_INT 1
7282: PPUSH
7283: CALL_OW 394
// straz := straz ^ bazukr ;
7287: LD_ADDR_EXP 45
7291: PUSH
7292: LD_EXP 45
7296: PUSH
7297: LD_VAR 0 2
7301: ADD
7302: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7303: LD_VAR 0 2
7307: PPUSH
7308: LD_INT 9
7310: PPUSH
7311: LD_INT 0
7313: PPUSH
7314: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7318: LD_VAR 0 2
7322: PPUSH
7323: LD_INT 66
7325: PPUSH
7326: LD_INT 48
7328: PPUSH
7329: CALL_OW 114
// end ;
7333: GO 7203
// end ; end ;
7335: PPOPN 2
7337: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7338: GO 7340
7340: DISABLE
7341: LD_INT 0
7343: PPUSH
// begin if ( 0 + straz ) <> 0 then
7344: LD_INT 0
7346: PUSH
7347: LD_EXP 45
7351: PLUS
7352: PUSH
7353: LD_INT 0
7355: NONEQUAL
7356: IFFALSE 7599
// begin for un in straz do
7358: LD_ADDR_VAR 0 1
7362: PUSH
7363: LD_EXP 45
7367: PUSH
7368: FOR_IN
7369: IFFALSE 7597
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7371: LD_VAR 0 1
7375: PPUSH
7376: CALL_OW 314
7380: NOT
7381: PUSH
7382: LD_VAR 0 1
7386: PPUSH
7387: CALL_OW 256
7391: PUSH
7392: LD_INT 601
7394: GREATER
7395: AND
7396: IFFALSE 7595
// begin if GetY ( un ) > 60 then
7398: LD_VAR 0 1
7402: PPUSH
7403: CALL_OW 251
7407: PUSH
7408: LD_INT 60
7410: GREATER
7411: IFFALSE 7505
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7413: LD_VAR 0 1
7417: PPUSH
7418: LD_INT 66
7420: PPUSH
7421: LD_INT 48
7423: PPUSH
7424: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7428: LD_VAR 0 1
7432: PPUSH
7433: LD_INT 63
7435: PPUSH
7436: LD_INT 74
7438: PPUSH
7439: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7443: LD_VAR 0 1
7447: PPUSH
7448: LD_INT 73
7450: PPUSH
7451: LD_INT 90
7453: PPUSH
7454: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7458: LD_VAR 0 1
7462: PPUSH
7463: LD_INT 76
7465: PPUSH
7466: LD_INT 95
7468: PPUSH
7469: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7473: LD_VAR 0 1
7477: PPUSH
7478: LD_INT 72
7480: PPUSH
7481: LD_INT 95
7483: PPUSH
7484: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7488: LD_VAR 0 1
7492: PPUSH
7493: LD_INT 50
7495: PPUSH
7496: LD_INT 73
7498: PPUSH
7499: CALL_OW 174
// end else
7503: GO 7595
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7505: LD_VAR 0 1
7509: PPUSH
7510: LD_INT 73
7512: PPUSH
7513: LD_INT 90
7515: PPUSH
7516: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7520: LD_VAR 0 1
7524: PPUSH
7525: LD_INT 76
7527: PPUSH
7528: LD_INT 95
7530: PPUSH
7531: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7535: LD_VAR 0 1
7539: PPUSH
7540: LD_INT 72
7542: PPUSH
7543: LD_INT 95
7545: PPUSH
7546: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7550: LD_VAR 0 1
7554: PPUSH
7555: LD_INT 50
7557: PPUSH
7558: LD_INT 73
7560: PPUSH
7561: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7565: LD_VAR 0 1
7569: PPUSH
7570: LD_INT 63
7572: PPUSH
7573: LD_INT 74
7575: PPUSH
7576: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7580: LD_VAR 0 1
7584: PPUSH
7585: LD_INT 66
7587: PPUSH
7588: LD_INT 48
7590: PPUSH
7591: CALL_OW 174
// end ; end ; end ;
7595: GO 7368
7597: POP
7598: POP
// end ; enable ;
7599: ENABLE
// end ;
7600: PPOPN 1
7602: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7603: GO 7605
7605: DISABLE
7606: LD_INT 0
7608: PPUSH
7609: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7610: LD_EXP 1
7614: PPUSH
7615: LD_INT 2
7617: PPUSH
7618: CALL_OW 308
7622: IFFALSE 7666
// begin disabled5 := true ;
7624: LD_ADDR_LOC 4
7628: PUSH
7629: LD_INT 1
7631: ST_TO_ADDR
// D_GosStart ;
7632: CALL 5483 0 0
// Wait ( 0 0$5 ) ;
7636: LD_INT 175
7638: PPUSH
7639: CALL_OW 67
// D_Situation ;
7643: CALL 6346 0 0
// ChangeMissionObjectives ( MHold ) ;
7647: LD_STRING MHold
7649: PPUSH
7650: CALL_OW 337
// disable ;
7654: DISABLE
// enable ( 333 ) ;
7655: LD_INT 333
7657: ENABLE_MARKED
// enable ( 334 ) ;
7658: LD_INT 334
7660: ENABLE_MARKED
// enable ( 337 ) ;
7661: LD_INT 337
7663: ENABLE_MARKED
// end else
7664: GO 7667
// enable ;
7666: ENABLE
// end ;
7667: PPOPN 2
7669: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7670: GO 7672
7672: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7673: LD_EXP 8
7677: PPUSH
7678: CALL_OW 306
7682: PUSH
7683: LD_INT 1
7685: EQUAL
7686: IFFALSE 7712
// begin if WasSelected = false then
7688: LD_EXP 46
7692: PUSH
7693: LD_INT 0
7695: EQUAL
7696: IFFALSE 7710
// begin QueryQGO ;
7698: CALL 7729 0 0
// WasSelected := true ;
7702: LD_ADDR_EXP 46
7706: PUSH
7707: LD_INT 1
7709: ST_TO_ADDR
// end ; end else
7710: GO 7720
// WasSelected := false ;
7712: LD_ADDR_EXP 46
7716: PUSH
7717: LD_INT 0
7719: ST_TO_ADDR
// if not disabled3 then
7720: LD_LOC 3
7724: NOT
7725: IFFALSE 7728
// enable ;
7727: ENABLE
// end ;
7728: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un ; begin
7729: LD_INT 0
7731: PPUSH
7732: PPUSH
7733: PPUSH
7734: PPUSH
7735: PPUSH
7736: PPUSH
// res := Query ( QGO ) ;
7737: LD_ADDR_VAR 0 2
7741: PUSH
7742: LD_STRING QGO
7744: PPUSH
7745: CALL_OW 97
7749: ST_TO_ADDR
// if res = 1 then
7750: LD_VAR 0 2
7754: PUSH
7755: LD_INT 1
7757: EQUAL
7758: IFFALSE 8134
// begin disabled3 := true ;
7760: LD_ADDR_LOC 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// D_GO1 ;
7768: CALL 6739 0 0
// ChangeMissionObjectives ( MGuide ) ;
7772: LD_STRING MGuide
7774: PPUSH
7775: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7779: LD_ADDR_VAR 0 3
7783: PUSH
7784: LD_INT 3
7786: PPUSH
7787: LD_INT 21
7789: PUSH
7790: LD_INT 2
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PUSH
7797: LD_INT 34
7799: PUSH
7800: LD_INT 51
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PPUSH
7811: CALL_OW 70
7815: ST_TO_ADDR
// if filter = 0 then
7816: LD_VAR 0 3
7820: PUSH
7821: LD_INT 0
7823: EQUAL
7824: IFFALSE 7975
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7826: LD_EXP 8
7830: PPUSH
7831: LD_INT 57
7833: PPUSH
7834: LD_INT 98
7836: PPUSH
7837: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7841: LD_INT 35
7843: PPUSH
7844: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7848: LD_EXP 8
7852: PPUSH
7853: CALL_OW 314
7857: NOT
7858: IFFALSE 7841
// RemoveUnit ( Gossudarov ) ;
7860: LD_EXP 8
7864: PPUSH
7865: CALL_OW 64
// uc_side := ally ;
7869: LD_ADDR_OWVAR 20
7873: PUSH
7874: LD_EXP 25
7878: ST_TO_ADDR
// uc_nation := nation_russian ;
7879: LD_ADDR_OWVAR 21
7883: PUSH
7884: LD_INT 3
7886: ST_TO_ADDR
// uc_direction := 5 ;
7887: LD_ADDR_OWVAR 24
7891: PUSH
7892: LD_INT 5
7894: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7895: LD_ADDR_OWVAR 37
7899: PUSH
7900: LD_INT 21
7902: ST_TO_ADDR
// vc_engine := engine_combustion ;
7903: LD_ADDR_OWVAR 39
7907: PUSH
7908: LD_INT 1
7910: ST_TO_ADDR
// vc_control := control_manual ;
7911: LD_ADDR_OWVAR 38
7915: PUSH
7916: LD_INT 1
7918: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7919: LD_ADDR_OWVAR 40
7923: PUSH
7924: LD_INT 51
7926: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7927: LD_ADDR_VAR 0 4
7931: PUSH
7932: CALL_OW 45
7936: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7937: LD_EXP 8
7941: PPUSH
7942: LD_VAR 0 4
7946: PPUSH
7947: CALL_OW 52
// Wait ( 0 0$5 ) ;
7951: LD_INT 175
7953: PPUSH
7954: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
7958: LD_VAR 0 4
7962: PPUSH
7963: LD_INT 9
7965: PPUSH
7966: LD_INT 0
7968: PPUSH
7969: CALL_OW 49
// end else
7973: GO 7993
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
7975: LD_EXP 8
7979: PPUSH
7980: LD_VAR 0 3
7984: PUSH
7985: LD_INT 1
7987: ARRAY
7988: PPUSH
7989: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
7993: LD_EXP 8
7997: PPUSH
7998: LD_INT 4
8000: PPUSH
8001: CALL_OW 469
8005: PUSH
8006: LD_INT 1
8008: ARRAY
8009: PPUSH
8010: LD_INT 4
8012: PPUSH
8013: CALL_OW 469
8017: PUSH
8018: LD_INT 2
8020: ARRAY
8021: PPUSH
8022: CALL_OW 220
// Wait ( 0 0$5 ) ;
8026: LD_INT 175
8028: PPUSH
8029: CALL_OW 67
// ComExitBuilding ( scientists ) ;
8033: LD_EXP 40
8037: PPUSH
8038: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
8042: LD_EXP 40
8046: PUSH
8047: LD_EXP 8
8051: ADD
8052: PPUSH
8053: LD_INT 50
8055: PPUSH
8056: LD_INT 58
8058: PPUSH
8059: CALL_OW 171
// for un in scientists ^ Gossudarov do
8063: LD_ADDR_VAR 0 6
8067: PUSH
8068: LD_EXP 40
8072: PUSH
8073: LD_EXP 8
8077: ADD
8078: PUSH
8079: FOR_IN
8080: IFFALSE 8098
// AddComSailEvent ( un , un ) ;
8082: LD_VAR 0 6
8086: PPUSH
8087: LD_VAR 0 6
8091: PPUSH
8092: CALL_OW 224
8096: GO 8079
8098: POP
8099: POP
// player_units := player_units union scientists union Gossudarov ;
8100: LD_ADDR_EXP 41
8104: PUSH
8105: LD_EXP 41
8109: PUSH
8110: LD_EXP 40
8114: UNION
8115: PUSH
8116: LD_EXP 8
8120: UNION
8121: ST_TO_ADDR
// enable ( 4 ) ;
8122: LD_INT 4
8124: ENABLE_MARKED
// enable ( 7 ) ;
8125: LD_INT 7
8127: ENABLE_MARKED
// enable ( 8 ) ;
8128: LD_INT 8
8130: ENABLE_MARKED
// enable ( 9 ) ;
8131: LD_INT 9
8133: ENABLE_MARKED
// end ; end ;
8134: LD_VAR 0 1
8138: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8139: GO 8141
8141: DISABLE
8142: LD_INT 0
8144: PPUSH
// begin for un in scientists do
8145: LD_ADDR_VAR 0 1
8149: PUSH
8150: LD_EXP 40
8154: PUSH
8155: FOR_IN
8156: IFFALSE 8226
// begin if IsInArea ( un , ExitArea ) then
8158: LD_VAR 0 1
8162: PPUSH
8163: LD_INT 11
8165: PPUSH
8166: CALL_OW 308
8170: IFFALSE 8197
// begin scientists_saved := scientists_saved union un ;
8172: LD_ADDR_EXP 48
8176: PUSH
8177: LD_EXP 48
8181: PUSH
8182: LD_VAR 0 1
8186: UNION
8187: ST_TO_ADDR
// RemoveUnit ( un ) ;
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 64
// end ; if IsDead ( un ) then
8197: LD_VAR 0 1
8201: PPUSH
8202: CALL_OW 301
8206: IFFALSE 8224
// scientists_dead := scientists_dead union un ;
8208: LD_ADDR_EXP 49
8212: PUSH
8213: LD_EXP 49
8217: PUSH
8218: LD_VAR 0 1
8222: UNION
8223: ST_TO_ADDR
// end ;
8224: GO 8155
8226: POP
8227: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8228: LD_EXP 8
8232: PPUSH
8233: LD_INT 11
8235: PPUSH
8236: CALL_OW 308
8240: PUSH
8241: LD_EXP 8
8245: PPUSH
8246: CALL_OW 310
8250: PPUSH
8251: LD_INT 11
8253: PPUSH
8254: CALL_OW 308
8258: OR
8259: PUSH
8260: LD_EXP 48
8264: PUSH
8265: LD_EXP 49
8269: PLUS
8270: PUSH
8271: LD_EXP 40
8275: EQUAL
8276: AND
8277: PUSH
8278: LD_EXP 50
8282: PPUSH
8283: CALL_OW 255
8287: PUSH
8288: LD_EXP 23
8292: EQUAL
8293: AND
8294: PUSH
8295: LD_EXP 50
8299: PPUSH
8300: LD_INT 11
8302: PPUSH
8303: CALL_OW 308
8307: AND
8308: PUSH
8309: LD_EXP 50
8313: PPUSH
8314: LD_INT 4
8316: PPUSH
8317: CALL_OW 289
8321: PUSH
8322: LD_INT 40
8324: EQUAL
8325: AND
8326: IFFALSE 8338
// begin D_SeeYou ;
8328: CALL 6777 0 0
// TheEnd ;
8332: CALL 3264 0 0
// end else
8336: GO 8339
// enable ;
8338: ENABLE
// end ;
8339: PPOPN 1
8341: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8342: GO 8344
8344: DISABLE
8345: LD_INT 0
8347: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8348: LD_EXP 1
8352: PPUSH
8353: LD_INT 18
8355: PPUSH
8356: CALL_OW 308
8360: PUSH
8361: LD_EXP 43
8365: PPUSH
8366: LD_INT 18
8368: PPUSH
8369: CALL_OW 308
8373: OR
8374: IFFALSE 8391
// begin Wait ( 0 0$3 ) ;
8376: LD_INT 105
8378: PPUSH
8379: CALL_OW 67
// Attack1 := true ;
8383: LD_ADDR_LOC 5
8387: PUSH
8388: LD_INT 1
8390: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8391: LD_EXP 1
8395: PPUSH
8396: LD_INT 19
8398: PPUSH
8399: CALL_OW 308
8403: PUSH
8404: LD_EXP 43
8408: PPUSH
8409: LD_INT 19
8411: PPUSH
8412: CALL_OW 308
8416: OR
8417: IFFALSE 8434
// begin Wait ( 0 0$3 ) ;
8419: LD_INT 105
8421: PPUSH
8422: CALL_OW 67
// Attack2 := true ;
8426: LD_ADDR_LOC 6
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8434: LD_EXP 1
8438: PPUSH
8439: LD_INT 20
8441: PPUSH
8442: CALL_OW 308
8446: PUSH
8447: LD_EXP 43
8451: PPUSH
8452: LD_INT 20
8454: PPUSH
8455: CALL_OW 308
8459: OR
8460: IFFALSE 8477
// begin Wait ( 0 0$3 ) ;
8462: LD_INT 105
8464: PPUSH
8465: CALL_OW 67
// Attack3 := true ;
8469: LD_ADDR_LOC 7
8473: PUSH
8474: LD_INT 1
8476: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8477: LD_LOC 5
8481: PUSH
8482: LD_LOC 6
8486: NOT
8487: AND
8488: PUSH
8489: LD_LOC 7
8493: NOT
8494: AND
8495: IFFALSE 8558
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: DOUBLE
8503: LD_EXP 31
8507: PUSH
8508: LD_INT 1
8510: PLUS
8511: DEC
8512: ST_TO_ADDR
8513: LD_EXP 31
8517: PUSH
8518: LD_EXP 30
8522: PLUS
8523: PUSH
8524: FOR_TO
8525: IFFALSE 8556
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8527: LD_EXP 29
8531: PUSH
8532: LD_VAR 0 1
8536: ARRAY
8537: PPUSH
8538: LD_EXP 1
8542: PPUSH
8543: CALL_OW 115
// Wait ( 2 ) ;
8547: LD_INT 2
8549: PPUSH
8550: CALL_OW 67
// end ;
8554: GO 8524
8556: POP
8557: POP
// if Attack1 and Attack2 and not Attack3 then
8558: LD_LOC 5
8562: PUSH
8563: LD_LOC 6
8567: AND
8568: PUSH
8569: LD_LOC 7
8573: NOT
8574: AND
8575: IFFALSE 8642
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8577: LD_ADDR_VAR 0 1
8581: PUSH
8582: DOUBLE
8583: LD_EXP 31
8587: PUSH
8588: LD_INT 1
8590: PLUS
8591: DEC
8592: ST_TO_ADDR
8593: LD_EXP 31
8597: PUSH
8598: LD_INT 2
8600: PUSH
8601: LD_EXP 30
8605: MUL
8606: PLUS
8607: PUSH
8608: FOR_TO
8609: IFFALSE 8640
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8611: LD_EXP 29
8615: PUSH
8616: LD_VAR 0 1
8620: ARRAY
8621: PPUSH
8622: LD_EXP 1
8626: PPUSH
8627: CALL_OW 115
// Wait ( 2 ) ;
8631: LD_INT 2
8633: PPUSH
8634: CALL_OW 67
// end ;
8638: GO 8608
8640: POP
8641: POP
// if Attack1 and Attack2 and Attack3 then
8642: LD_LOC 5
8646: PUSH
8647: LD_LOC 6
8651: AND
8652: PUSH
8653: LD_LOC 7
8657: AND
8658: IFFALSE 8725
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8660: LD_ADDR_VAR 0 1
8664: PUSH
8665: DOUBLE
8666: LD_EXP 31
8670: PUSH
8671: LD_INT 1
8673: PLUS
8674: DEC
8675: ST_TO_ADDR
8676: LD_EXP 31
8680: PUSH
8681: LD_INT 3
8683: PUSH
8684: LD_EXP 30
8688: MUL
8689: PLUS
8690: PUSH
8691: FOR_TO
8692: IFFALSE 8723
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8694: LD_EXP 29
8698: PUSH
8699: LD_VAR 0 1
8703: ARRAY
8704: PPUSH
8705: LD_EXP 1
8709: PPUSH
8710: CALL_OW 115
// Wait ( 2 ) ;
8714: LD_INT 2
8716: PPUSH
8717: CALL_OW 67
// end ;
8721: GO 8691
8723: POP
8724: POP
// for i := 1 to pursuers_base do
8725: LD_ADDR_VAR 0 1
8729: PUSH
8730: DOUBLE
8731: LD_INT 1
8733: DEC
8734: ST_TO_ADDR
8735: LD_EXP 31
8739: PUSH
8740: FOR_TO
8741: IFFALSE 8772
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8743: LD_EXP 29
8747: PUSH
8748: LD_VAR 0 1
8752: ARRAY
8753: PPUSH
8754: LD_EXP 1
8758: PPUSH
8759: CALL_OW 115
// Wait ( 2 ) ;
8763: LD_INT 2
8765: PPUSH
8766: CALL_OW 67
// end ;
8770: GO 8740
8772: POP
8773: POP
// if not disabled5 then
8774: LD_LOC 4
8778: NOT
8779: IFFALSE 8782
// enable ;
8781: ENABLE
// end ;
8782: PPOPN 1
8784: END
// every 0 0$1 marked 6 do
8785: GO 8787
8787: DISABLE
// begin if Goss_time > 0 then
8788: LD_EXP 47
8792: PUSH
8793: LD_INT 0
8795: GREATER
8796: IFFALSE 8832
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8798: LD_ADDR_OWVAR 47
8802: PUSH
8803: LD_STRING #Ru12a-1
8805: PUSH
8806: LD_EXP 47
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8815: LD_ADDR_EXP 47
8819: PUSH
8820: LD_EXP 47
8824: PUSH
8825: LD_INT 35
8827: MINUS
8828: ST_TO_ADDR
// enable ;
8829: ENABLE
// end else
8830: GO 8843
// begin display_strings :=  ;
8832: LD_ADDR_OWVAR 47
8836: PUSH
8837: LD_STRING 
8839: ST_TO_ADDR
// enable ( 3 ) ;
8840: LD_INT 3
8842: ENABLE_MARKED
// end ; end ;
8843: END
// every 0 0$1 marked 7 do
8844: GO 8846
8846: DISABLE
// begin if FindArtifact ( 4 ) then
8847: LD_INT 4
8849: PPUSH
8850: CALL_OW 469
8854: IFFALSE 8908
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8856: LD_LOC 8
8860: PPUSH
8861: LD_INT 4
8863: PPUSH
8864: CALL_OW 469
8868: PUSH
8869: LD_INT 1
8871: ARRAY
8872: PPUSH
8873: LD_INT 4
8875: PPUSH
8876: CALL_OW 469
8880: PUSH
8881: LD_INT 2
8883: ARRAY
8884: PPUSH
8885: CALL_OW 160
// Wait ( 3 ) ;
8889: LD_INT 3
8891: PPUSH
8892: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
8896: LD_LOC 8
8900: PPUSH
8901: LD_INT 9
8903: PPUSH
8904: CALL_OW 173
// end ; enable ;
8908: ENABLE
// end ;
8909: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
8910: GO 8912
8912: DISABLE
8913: LD_INT 0
8915: PPUSH
8916: PPUSH
8917: PPUSH
8918: PPUSH
// begin Wait ( pausa ) ;
8919: LD_EXP 37
8923: PPUSH
8924: CALL_OW 67
// sc_utok := [ ] ;
8928: LD_ADDR_VAR 0 3
8932: PUSH
8933: EMPTY
8934: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: DOUBLE
8941: LD_INT 1
8943: DEC
8944: ST_TO_ADDR
8945: LD_INT 2
8947: PUSH
8948: LD_OWVAR 67
8952: PLUS
8953: PUSH
8954: FOR_TO
8955: IFFALSE 9159
// begin uc_side := rus ;
8957: LD_ADDR_OWVAR 20
8961: PUSH
8962: LD_EXP 24
8966: ST_TO_ADDR
// uc_nation := nation_russian ;
8967: LD_ADDR_OWVAR 21
8971: PUSH
8972: LD_INT 3
8974: ST_TO_ADDR
// uc_direction := 5 ;
8975: LD_ADDR_OWVAR 24
8979: PUSH
8980: LD_INT 5
8982: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
8983: LD_INT 1
8985: PPUSH
8986: LD_INT 3
8988: PPUSH
8989: CALL_OW 12
8993: PUSH
8994: LD_INT 1
8996: DOUBLE
8997: EQUAL
8998: IFTRUE 9002
9000: GO 9026
9002: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9003: LD_INT 1
9005: PPUSH
9006: LD_INT 1
9008: PPUSH
9009: LD_INT 4
9011: PPUSH
9012: LD_INT 8
9014: PPUSH
9015: CALL_OW 12
9019: PPUSH
9020: CALL_OW 380
9024: GO 9065
9026: LD_INT 2
9028: DOUBLE
9029: GREATEREQUAL
9030: IFFALSE 9038
9032: LD_INT 3
9034: DOUBLE
9035: LESSEQUAL
9036: IFTRUE 9040
9038: GO 9064
9040: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9041: LD_INT 1
9043: PPUSH
9044: LD_INT 9
9046: PPUSH
9047: LD_INT 3
9049: PPUSH
9050: LD_INT 7
9052: PPUSH
9053: CALL_OW 12
9057: PPUSH
9058: CALL_OW 380
9062: GO 9065
9064: POP
// hc_name :=  ;
9065: LD_ADDR_OWVAR 26
9069: PUSH
9070: LD_STRING 
9072: ST_TO_ADDR
// clovek := CreateHuman ;
9073: LD_ADDR_VAR 0 2
9077: PUSH
9078: CALL_OW 44
9082: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9083: LD_VAR 0 2
9087: PPUSH
9088: LD_INT 9
9090: PPUSH
9091: LD_INT 0
9093: PPUSH
9094: CALL_OW 49
// Wait ( 0 0$2 ) ;
9098: LD_INT 70
9100: PPUSH
9101: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9105: LD_VAR 0 2
9109: PPUSH
9110: LD_INT 50
9112: PPUSH
9113: LD_INT 84
9115: PPUSH
9116: CALL_OW 111
// Wait ( 2 ) ;
9120: LD_INT 2
9122: PPUSH
9123: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9127: LD_VAR 0 2
9131: PPUSH
9132: LD_EXP 50
9136: PPUSH
9137: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9141: LD_ADDR_VAR 0 3
9145: PUSH
9146: LD_VAR 0 3
9150: PUSH
9151: LD_VAR 0 2
9155: ADD
9156: ST_TO_ADDR
// end ;
9157: GO 8954
9159: POP
9160: POP
// Wait ( 0 0$10 ) ;
9161: LD_INT 350
9163: PPUSH
9164: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9168: LD_LOC 8
9172: PPUSH
9173: CALL_OW 302
9177: NOT
9178: IFFALSE 9285
// begin uc_side := rus ;
9180: LD_ADDR_OWVAR 20
9184: PUSH
9185: LD_EXP 24
9189: ST_TO_ADDR
// uc_nation := nation_russian ;
9190: LD_ADDR_OWVAR 21
9194: PUSH
9195: LD_INT 3
9197: ST_TO_ADDR
// uc_direction := 5 ;
9198: LD_ADDR_OWVAR 24
9202: PUSH
9203: LD_INT 5
9205: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9206: LD_ADDR_OWVAR 37
9210: PUSH
9211: LD_INT 22
9213: ST_TO_ADDR
// vc_control := control_computer ;
9214: LD_ADDR_OWVAR 38
9218: PUSH
9219: LD_INT 3
9221: ST_TO_ADDR
// vc_engine := engine_siberite ;
9222: LD_ADDR_OWVAR 39
9226: PUSH
9227: LD_INT 3
9229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9230: LD_ADDR_OWVAR 40
9234: PUSH
9235: LD_INT 51
9237: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9238: LD_ADDR_LOC 8
9242: PUSH
9243: CALL_OW 45
9247: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9248: LD_LOC 8
9252: PPUSH
9253: LD_INT 9
9255: PPUSH
9256: LD_INT 0
9258: PPUSH
9259: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9263: LD_INT 18
9265: PPUSH
9266: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9270: LD_LOC 8
9274: PPUSH
9275: LD_INT 55
9277: PPUSH
9278: LD_INT 84
9280: PPUSH
9281: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9285: LD_VAR 0 3
9289: PUSH
9290: LD_LOC 8
9294: PPUSH
9295: CALL_OW 302
9299: AND
9300: IFFALSE 9370
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9302: LD_VAR 0 3
9306: PPUSH
9307: LD_EXP 50
9311: PPUSH
9312: CALL_OW 115
// Wait ( 0 0$2 ) ;
9316: LD_INT 70
9318: PPUSH
9319: CALL_OW 67
// for un in sc_utok do
9323: LD_ADDR_VAR 0 4
9327: PUSH
9328: LD_VAR 0 3
9332: PUSH
9333: FOR_IN
9334: IFFALSE 9366
// if not IsOK ( un ) then
9336: LD_VAR 0 4
9340: PPUSH
9341: CALL_OW 302
9345: NOT
9346: IFFALSE 9364
// sc_utok := sc_utok diff un ;
9348: LD_ADDR_VAR 0 3
9352: PUSH
9353: LD_VAR 0 3
9357: PUSH
9358: LD_VAR 0 4
9362: DIFF
9363: ST_TO_ADDR
9364: GO 9333
9366: POP
9367: POP
// end ;
9368: GO 9285
// Wait ( 0 0$5 ) ;
9370: LD_INT 175
9372: PPUSH
9373: CALL_OW 67
// enable ;
9377: ENABLE
// end ;
9378: PPOPN 4
9380: END
// every 0 0$3 marked 9 do
9381: GO 9383
9383: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9384: LD_LOC 8
9388: PPUSH
9389: LD_INT 3
9391: PPUSH
9392: CALL_OW 308
9396: PUSH
9397: LD_LOC 8
9401: PPUSH
9402: LD_INT 4
9404: PPUSH
9405: CALL_OW 289
9409: PUSH
9410: LD_INT 40
9412: EQUAL
9413: AND
9414: IFFALSE 9423
// YouLost ( Artefact ) ;
9416: LD_STRING Artefact
9418: PPUSH
9419: CALL_OW 104
// enable ;
9423: ENABLE
// end ;
9424: END
// on UnitDestroyed ( human ) do var i , un ;
9425: LD_INT 0
9427: PPUSH
9428: PPUSH
// begin if human = Burlak then
9429: LD_VAR 0 1
9433: PUSH
9434: LD_EXP 1
9438: EQUAL
9439: IFFALSE 9448
// YouLost ( Burlak ) ;
9441: LD_STRING Burlak
9443: PPUSH
9444: CALL_OW 104
// if human = Gossudarov then
9448: LD_VAR 0 1
9452: PUSH
9453: LD_EXP 8
9457: EQUAL
9458: IFFALSE 9467
// YouLost ( Gossudarov ) ;
9460: LD_STRING Gossudarov
9462: PPUSH
9463: CALL_OW 104
// if human = Masha then
9467: LD_VAR 0 1
9471: PUSH
9472: LD_EXP 43
9476: EQUAL
9477: IFFALSE 9487
// lost_masha := true ;
9479: LD_ADDR_EXP 52
9483: PUSH
9484: LD_INT 1
9486: ST_TO_ADDR
// if human in straz then
9487: LD_VAR 0 1
9491: PUSH
9492: LD_EXP 45
9496: IN
9497: IFFALSE 9546
// begin straz := straz diff human ;
9499: LD_ADDR_EXP 45
9503: PUSH
9504: LD_EXP 45
9508: PUSH
9509: LD_VAR 0 1
9513: DIFF
9514: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9515: LD_EXP 62
9519: PPUSH
9520: LD_VAR 0 1
9524: PPUSH
9525: LD_INT 1
9527: PPUSH
9528: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9532: LD_ADDR_EXP 53
9536: PUSH
9537: LD_EXP 53
9541: PUSH
9542: LD_INT 1
9544: PLUS
9545: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9546: LD_VAR 0 1
9550: PPUSH
9551: CALL_OW 255
9555: PUSH
9556: LD_INT 3
9558: EQUAL
9559: PUSH
9560: LD_VAR 0 1
9564: PUSH
9565: LD_EXP 60
9569: IN
9570: AND
9571: IFFALSE 9618
// begin for i in attackGroup do
9573: LD_ADDR_VAR 0 2
9577: PUSH
9578: LD_EXP 60
9582: PUSH
9583: FOR_IN
9584: IFFALSE 9616
// if i = human then
9586: LD_VAR 0 2
9590: PUSH
9591: LD_VAR 0 1
9595: EQUAL
9596: IFFALSE 9614
// attackGroup = attackGroup diff i ;
9598: LD_ADDR_EXP 60
9602: PUSH
9603: LD_EXP 60
9607: PUSH
9608: LD_VAR 0 2
9612: DIFF
9613: ST_TO_ADDR
9614: GO 9583
9616: POP
9617: POP
// end ; end ;
9618: PPOPN 3
9620: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9621: LD_VAR 0 1
9625: PUSH
9626: LD_EXP 8
9630: EQUAL
9631: IFFALSE 9652
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9633: LD_EXP 8
9637: PPUSH
9638: CALL_OW 310
9642: PPUSH
9643: LD_EXP 23
9647: PPUSH
9648: CALL_OW 235
// SetSide ( num , you ) ;
9652: LD_VAR 0 1
9656: PPUSH
9657: LD_EXP 23
9661: PPUSH
9662: CALL_OW 235
// end ;
9666: PPOPN 1
9668: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9669: LD_VAR 0 1
9673: PPUSH
9674: CALL_OW 255
9678: PUSH
9679: LD_EXP 24
9683: NONEQUAL
9684: IFFALSE 9696
// Artifact_cargo := un ;
9686: LD_ADDR_EXP 50
9690: PUSH
9691: LD_VAR 0 1
9695: ST_TO_ADDR
// end ; end_of_file
9696: PPOPN 2
9698: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9699: GO 9701
9701: DISABLE
9702: LD_INT 0
9704: PPUSH
9705: PPUSH
9706: PPUSH
9707: PPUSH
9708: PPUSH
9709: PPUSH
9710: PPUSH
// begin case tick of 0 .. 30000 :
9711: LD_OWVAR 1
9715: PUSH
9716: LD_INT 0
9718: DOUBLE
9719: GREATEREQUAL
9720: IFFALSE 9728
9722: LD_INT 30000
9724: DOUBLE
9725: LESSEQUAL
9726: IFTRUE 9730
9728: GO 9740
9730: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9731: LD_INT 1050
9733: PPUSH
9734: CALL_OW 67
9738: GO 9916
9740: LD_INT 30001
9742: DOUBLE
9743: GREATEREQUAL
9744: IFFALSE 9752
9746: LD_INT 50000
9748: DOUBLE
9749: LESSEQUAL
9750: IFTRUE 9754
9752: GO 9764
9754: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9755: LD_INT 1575
9757: PPUSH
9758: CALL_OW 67
9762: GO 9916
9764: LD_INT 50001
9766: DOUBLE
9767: GREATEREQUAL
9768: IFFALSE 9776
9770: LD_INT 70000
9772: DOUBLE
9773: LESSEQUAL
9774: IFTRUE 9778
9776: GO 9788
9778: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9779: LD_INT 2100
9781: PPUSH
9782: CALL_OW 67
9786: GO 9916
9788: LD_INT 70001
9790: DOUBLE
9791: GREATEREQUAL
9792: IFFALSE 9800
9794: LD_INT 90000
9796: DOUBLE
9797: LESSEQUAL
9798: IFTRUE 9802
9800: GO 9812
9802: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9803: LD_INT 2625
9805: PPUSH
9806: CALL_OW 67
9810: GO 9916
9812: LD_INT 70001
9814: DOUBLE
9815: GREATEREQUAL
9816: IFFALSE 9824
9818: LD_INT 90000
9820: DOUBLE
9821: LESSEQUAL
9822: IFTRUE 9826
9824: GO 9836
9826: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9827: LD_INT 3150
9829: PPUSH
9830: CALL_OW 67
9834: GO 9916
9836: LD_INT 90001
9838: DOUBLE
9839: GREATEREQUAL
9840: IFFALSE 9848
9842: LD_INT 110000
9844: DOUBLE
9845: LESSEQUAL
9846: IFTRUE 9850
9848: GO 9860
9850: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9851: LD_INT 3675
9853: PPUSH
9854: CALL_OW 67
9858: GO 9916
9860: LD_INT 110001
9862: DOUBLE
9863: GREATEREQUAL
9864: IFFALSE 9872
9866: LD_INT 130000
9868: DOUBLE
9869: LESSEQUAL
9870: IFTRUE 9874
9872: GO 9884
9874: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
9875: LD_INT 4200
9877: PPUSH
9878: CALL_OW 67
9882: GO 9916
9884: LD_INT 130001
9886: DOUBLE
9887: GREATEREQUAL
9888: IFFALSE 9896
9890: LD_INT 150000
9892: DOUBLE
9893: LESSEQUAL
9894: IFTRUE 9898
9896: GO 9908
9898: POP
// Wait ( 2 2$15 ) ; else
9899: LD_INT 4725
9901: PPUSH
9902: CALL_OW 67
9906: GO 9916
9908: POP
// Wait ( 2 2$30 ) ; end ;
9909: LD_INT 5250
9911: PPUSH
9912: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
9916: LD_ADDR_LOC 9
9920: PUSH
9921: LD_INT 22
9923: PUSH
9924: LD_INT 3
9926: PUSH
9927: LD_INT 1
9929: PUSH
9930: LD_INT 43
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: PUSH
9939: LD_INT 23
9941: PUSH
9942: LD_INT 3
9944: PUSH
9945: LD_INT 1
9947: PUSH
9948: LD_INT 45
9950: PUSH
9951: EMPTY
9952: LIST
9953: LIST
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 21
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: LD_INT 1
9965: PUSH
9966: LD_INT 43
9968: PUSH
9969: EMPTY
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: PUSH
9975: LD_INT 24
9977: PUSH
9978: LD_INT 3
9980: PUSH
9981: LD_INT 1
9983: PUSH
9984: LD_INT 45
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 21
9995: PUSH
9996: LD_INT 3
9998: PUSH
9999: LD_INT 1
10001: PUSH
10002: LD_INT 45
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: LIST
10010: PUSH
10011: LD_INT 22
10013: PUSH
10014: LD_INT 3
10016: PUSH
10017: LD_INT 1
10019: PUSH
10020: LD_INT 44
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_INT 24
10031: PUSH
10032: LD_INT 3
10034: PUSH
10035: LD_INT 3
10037: PUSH
10038: LD_INT 46
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: LIST
10045: LIST
10046: PUSH
10047: LD_INT 23
10049: PUSH
10050: LD_INT 3
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: LD_INT 46
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: PUSH
10065: LD_INT 24
10067: PUSH
10068: LD_INT 3
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: LD_INT 46
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 23
10085: PUSH
10086: LD_INT 3
10088: PUSH
10089: LD_INT 3
10091: PUSH
10092: LD_INT 47
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: PUSH
10101: LD_INT 24
10103: PUSH
10104: LD_INT 3
10106: PUSH
10107: LD_INT 3
10109: PUSH
10110: LD_INT 49
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_INT 23
10121: PUSH
10122: LD_INT 3
10124: PUSH
10125: LD_INT 1
10127: PUSH
10128: LD_INT 49
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: PUSH
10137: EMPTY
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10151: LD_ADDR_VAR 0 1
10155: PUSH
10156: LD_INT 22
10158: PUSH
10159: LD_EXP 23
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: LD_INT 21
10170: PUSH
10171: LD_INT 2
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL_OW 69
10186: ST_TO_ADDR
// if filter < 3 then
10187: LD_VAR 0 1
10191: PUSH
10192: LD_INT 3
10194: LESS
10195: IFFALSE 10205
// filter := 3 ;
10197: LD_ADDR_VAR 0 1
10201: PUSH
10202: LD_INT 3
10204: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10205: LD_INT 22
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: LD_INT 21
10217: PUSH
10218: LD_INT 2
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 50
10227: PUSH
10228: EMPTY
10229: LIST
10230: PUSH
10231: LD_INT 2
10233: PUSH
10234: LD_INT 34
10236: PUSH
10237: LD_INT 43
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: PUSH
10244: LD_INT 34
10246: PUSH
10247: LD_INT 45
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: PUSH
10254: LD_INT 34
10256: PUSH
10257: LD_INT 44
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 34
10266: PUSH
10267: LD_INT 46
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: PUSH
10274: LD_INT 34
10276: PUSH
10277: LD_INT 47
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PUSH
10284: LD_INT 34
10286: PUSH
10287: LD_INT 49
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: PPUSH
10309: CALL_OW 69
10313: PUSH
10314: LD_INT 6
10316: LESSEQUAL
10317: IFFALSE 10848
// for i := 1 to ( filter div 3 ) do
10319: LD_ADDR_VAR 0 2
10323: PUSH
10324: DOUBLE
10325: LD_INT 1
10327: DEC
10328: ST_TO_ADDR
10329: LD_VAR 0 1
10333: PUSH
10334: LD_INT 3
10336: DIV
10337: PUSH
10338: FOR_TO
10339: IFFALSE 10846
// begin uc_side := rus ;
10341: LD_ADDR_OWVAR 20
10345: PUSH
10346: LD_EXP 24
10350: ST_TO_ADDR
// uc_nation := nation_russian ;
10351: LD_ADDR_OWVAR 21
10355: PUSH
10356: LD_INT 3
10358: ST_TO_ADDR
// uc_direction := 5 ;
10359: LD_ADDR_OWVAR 24
10363: PUSH
10364: LD_INT 5
10366: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10367: LD_OWVAR 1
10371: PUSH
10372: LD_INT 60000
10374: LESS
10375: PUSH
10376: LD_INT 28
10378: PPUSH
10379: LD_EXP 23
10383: PPUSH
10384: CALL_OW 321
10388: PUSH
10389: LD_INT 2
10391: EQUAL
10392: OR
10393: IFFALSE 10419
// typ := rand ( 1 , vehicles - 2 ) else
10395: LD_ADDR_VAR 0 4
10399: PUSH
10400: LD_INT 1
10402: PPUSH
10403: LD_LOC 9
10407: PUSH
10408: LD_INT 2
10410: MINUS
10411: PPUSH
10412: CALL_OW 12
10416: ST_TO_ADDR
10417: GO 10437
// typ := rand ( 1 , vehicles ) ;
10419: LD_ADDR_VAR 0 4
10423: PUSH
10424: LD_INT 1
10426: PPUSH
10427: LD_LOC 9
10431: PPUSH
10432: CALL_OW 12
10436: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10437: LD_ADDR_OWVAR 37
10441: PUSH
10442: LD_LOC 9
10446: PUSH
10447: LD_VAR 0 4
10451: ARRAY
10452: PUSH
10453: LD_INT 1
10455: ARRAY
10456: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10457: LD_ADDR_OWVAR 38
10461: PUSH
10462: LD_LOC 9
10466: PUSH
10467: LD_VAR 0 4
10471: ARRAY
10472: PUSH
10473: LD_INT 2
10475: ARRAY
10476: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10477: LD_ADDR_OWVAR 39
10481: PUSH
10482: LD_LOC 9
10486: PUSH
10487: LD_VAR 0 4
10491: ARRAY
10492: PUSH
10493: LD_INT 3
10495: ARRAY
10496: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10497: LD_ADDR_OWVAR 40
10501: PUSH
10502: LD_LOC 9
10506: PUSH
10507: LD_VAR 0 4
10511: ARRAY
10512: PUSH
10513: LD_INT 4
10515: ARRAY
10516: ST_TO_ADDR
// auto := CreateVehicle ;
10517: LD_ADDR_VAR 0 5
10521: PUSH
10522: CALL_OW 45
10526: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10527: LD_VAR 0 5
10531: PPUSH
10532: LD_INT 9
10534: PPUSH
10535: LD_INT 0
10537: PPUSH
10538: CALL_OW 49
// attack := attack ^ auto ;
10542: LD_ADDR_LOC 10
10546: PUSH
10547: LD_LOC 10
10551: PUSH
10552: LD_VAR 0 5
10556: ADD
10557: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10558: LD_VAR 0 5
10562: PPUSH
10563: LD_INT 52
10565: PPUSH
10566: LD_INT 61
10568: PPUSH
10569: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10573: LD_VAR 0 5
10577: PPUSH
10578: LD_INT 52
10580: PPUSH
10581: LD_INT 61
10583: PPUSH
10584: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10588: LD_INT 1
10590: PPUSH
10591: LD_INT 2
10593: PPUSH
10594: CALL_OW 12
10598: PUSH
10599: LD_INT 1
10601: DOUBLE
10602: EQUAL
10603: IFTRUE 10607
10605: GO 10625
10607: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10608: LD_VAR 0 5
10612: PPUSH
10613: LD_INT 35
10615: PPUSH
10616: LD_INT 30
10618: PPUSH
10619: CALL_OW 174
10623: GO 10652
10625: LD_INT 2
10627: DOUBLE
10628: EQUAL
10629: IFTRUE 10633
10631: GO 10651
10633: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10634: LD_VAR 0 5
10638: PPUSH
10639: LD_INT 17
10641: PPUSH
10642: LD_INT 29
10644: PPUSH
10645: CALL_OW 174
10649: GO 10652
10651: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10652: LD_VAR 0 5
10656: PPUSH
10657: LD_INT 29
10659: PPUSH
10660: LD_INT 5
10662: PPUSH
10663: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10667: LD_INT 1
10669: PPUSH
10670: LD_INT 2
10672: PPUSH
10673: CALL_OW 12
10677: PUSH
10678: LD_INT 1
10680: DOUBLE
10681: EQUAL
10682: IFTRUE 10686
10684: GO 10704
10686: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10687: LD_VAR 0 5
10691: PPUSH
10692: LD_INT 60
10694: PPUSH
10695: LD_INT 30
10697: PPUSH
10698: CALL_OW 174
10702: GO 10731
10704: LD_INT 2
10706: DOUBLE
10707: EQUAL
10708: IFTRUE 10712
10710: GO 10730
10712: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10713: LD_VAR 0 5
10717: PPUSH
10718: LD_INT 84
10720: PPUSH
10721: LD_INT 30
10723: PPUSH
10724: CALL_OW 174
10728: GO 10731
10730: POP
// case Rand ( 1 , 2 ) of 1 :
10731: LD_INT 1
10733: PPUSH
10734: LD_INT 2
10736: PPUSH
10737: CALL_OW 12
10741: PUSH
10742: LD_INT 1
10744: DOUBLE
10745: EQUAL
10746: IFTRUE 10750
10748: GO 10768
10750: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 71
10758: PPUSH
10759: LD_INT 59
10761: PPUSH
10762: CALL_OW 174
10766: GO 10795
10768: LD_INT 2
10770: DOUBLE
10771: EQUAL
10772: IFTRUE 10776
10774: GO 10794
10776: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10777: LD_VAR 0 5
10781: PPUSH
10782: LD_INT 92
10784: PPUSH
10785: LD_INT 66
10787: PPUSH
10788: CALL_OW 174
10792: GO 10795
10794: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10795: LD_VAR 0 5
10799: PPUSH
10800: LD_INT 78
10802: PPUSH
10803: LD_INT 88
10805: PPUSH
10806: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10810: LD_VAR 0 5
10814: PPUSH
10815: LD_INT 117
10817: PPUSH
10818: LD_INT 90
10820: PPUSH
10821: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10825: LD_VAR 0 5
10829: PPUSH
10830: LD_INT 15
10832: PPUSH
10833: CALL_OW 173
// Wait ( 0 0$4 ) ;
10837: LD_INT 140
10839: PPUSH
10840: CALL_OW 67
// end ;
10844: GO 10338
10846: POP
10847: POP
// enable ;
10848: ENABLE
// end ;
10849: PPOPN 7
10851: END
// export function PrepareInfantry ; var i , clovek ; begin
10852: LD_INT 0
10854: PPUSH
10855: PPUSH
10856: PPUSH
// for i = 1 to 6 do
10857: LD_ADDR_VAR 0 2
10861: PUSH
10862: DOUBLE
10863: LD_INT 1
10865: DEC
10866: ST_TO_ADDR
10867: LD_INT 6
10869: PUSH
10870: FOR_TO
10871: IFFALSE 11036
// begin uc_side = 3 ;
10873: LD_ADDR_OWVAR 20
10877: PUSH
10878: LD_INT 3
10880: ST_TO_ADDR
// uc_nation = 3 ;
10881: LD_ADDR_OWVAR 21
10885: PUSH
10886: LD_INT 3
10888: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
10889: LD_INT 1
10891: PPUSH
10892: LD_INT 3
10894: PPUSH
10895: CALL_OW 12
10899: PUSH
10900: LD_INT 1
10902: DOUBLE
10903: EQUAL
10904: IFTRUE 10908
10906: GO 10932
10908: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
10909: LD_INT 1
10911: PPUSH
10912: LD_INT 1
10914: PPUSH
10915: LD_INT 4
10917: PPUSH
10918: LD_INT 8
10920: PPUSH
10921: CALL_OW 12
10925: PPUSH
10926: CALL_OW 380
10930: GO 10971
10932: LD_INT 2
10934: DOUBLE
10935: GREATEREQUAL
10936: IFFALSE 10944
10938: LD_INT 3
10940: DOUBLE
10941: LESSEQUAL
10942: IFTRUE 10946
10944: GO 10970
10946: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
10947: LD_INT 1
10949: PPUSH
10950: LD_INT 9
10952: PPUSH
10953: LD_INT 3
10955: PPUSH
10956: LD_INT 7
10958: PPUSH
10959: CALL_OW 12
10963: PPUSH
10964: CALL_OW 380
10968: GO 10971
10970: POP
// hc_name :=  ;
10971: LD_ADDR_OWVAR 26
10975: PUSH
10976: LD_STRING 
10978: ST_TO_ADDR
// clovek := CreateHuman ;
10979: LD_ADDR_VAR 0 3
10983: PUSH
10984: CALL_OW 44
10988: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
10989: LD_VAR 0 3
10993: PPUSH
10994: LD_INT 9
10996: PPUSH
10997: LD_INT 0
10999: PPUSH
11000: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11004: LD_ADDR_EXP 59
11008: PUSH
11009: LD_EXP 59
11013: PUSH
11014: LD_INT 1
11016: MINUS
11017: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11018: LD_ADDR_EXP 60
11022: PUSH
11023: LD_EXP 60
11027: PUSH
11028: LD_VAR 0 3
11032: ADD
11033: ST_TO_ADDR
// end ;
11034: GO 10870
11036: POP
11037: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11038: LD_EXP 60
11042: PPUSH
11043: LD_INT 52
11045: PPUSH
11046: LD_INT 61
11048: PPUSH
11049: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11053: LD_INT 1
11055: PPUSH
11056: LD_INT 2
11058: PPUSH
11059: CALL_OW 12
11063: PUSH
11064: LD_INT 1
11066: DOUBLE
11067: EQUAL
11068: IFTRUE 11072
11070: GO 11090
11072: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11073: LD_EXP 60
11077: PPUSH
11078: LD_INT 35
11080: PPUSH
11081: LD_INT 30
11083: PPUSH
11084: CALL_OW 174
11088: GO 11117
11090: LD_INT 2
11092: DOUBLE
11093: EQUAL
11094: IFTRUE 11098
11096: GO 11116
11098: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11099: LD_EXP 60
11103: PPUSH
11104: LD_INT 17
11106: PPUSH
11107: LD_INT 29
11109: PPUSH
11110: CALL_OW 174
11114: GO 11117
11116: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11117: LD_EXP 60
11121: PPUSH
11122: LD_INT 29
11124: PPUSH
11125: LD_INT 5
11127: PPUSH
11128: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11132: LD_INT 1
11134: PPUSH
11135: LD_INT 2
11137: PPUSH
11138: CALL_OW 12
11142: PUSH
11143: LD_INT 1
11145: DOUBLE
11146: EQUAL
11147: IFTRUE 11151
11149: GO 11169
11151: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11152: LD_EXP 60
11156: PPUSH
11157: LD_INT 60
11159: PPUSH
11160: LD_INT 30
11162: PPUSH
11163: CALL_OW 174
11167: GO 11196
11169: LD_INT 2
11171: DOUBLE
11172: EQUAL
11173: IFTRUE 11177
11175: GO 11195
11177: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11178: LD_EXP 60
11182: PPUSH
11183: LD_INT 84
11185: PPUSH
11186: LD_INT 30
11188: PPUSH
11189: CALL_OW 174
11193: GO 11196
11195: POP
// case Rand ( 1 , 2 ) of 1 :
11196: LD_INT 1
11198: PPUSH
11199: LD_INT 2
11201: PPUSH
11202: CALL_OW 12
11206: PUSH
11207: LD_INT 1
11209: DOUBLE
11210: EQUAL
11211: IFTRUE 11215
11213: GO 11233
11215: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11216: LD_EXP 60
11220: PPUSH
11221: LD_INT 71
11223: PPUSH
11224: LD_INT 59
11226: PPUSH
11227: CALL_OW 174
11231: GO 11260
11233: LD_INT 2
11235: DOUBLE
11236: EQUAL
11237: IFTRUE 11241
11239: GO 11259
11241: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11242: LD_EXP 60
11246: PPUSH
11247: LD_INT 92
11249: PPUSH
11250: LD_INT 66
11252: PPUSH
11253: CALL_OW 174
11257: GO 11260
11259: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11260: LD_EXP 60
11264: PPUSH
11265: LD_INT 78
11267: PPUSH
11268: LD_INT 88
11270: PPUSH
11271: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11275: LD_EXP 60
11279: PPUSH
11280: LD_INT 117
11282: PPUSH
11283: LD_INT 90
11285: PPUSH
11286: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11290: LD_EXP 60
11294: PPUSH
11295: LD_INT 15
11297: PPUSH
11298: CALL_OW 173
// end ;
11302: LD_VAR 0 1
11306: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11307: LD_EXP 60
11311: PUSH
11312: EMPTY
11313: EQUAL
11314: PUSH
11315: LD_EXP 61
11319: PUSH
11320: LD_INT 1
11322: EQUAL
11323: AND
11324: IFFALSE 11334
11326: GO 11328
11328: DISABLE
// begin enable ;
11329: ENABLE
// PrepareInfantry ;
11330: CALL 10852 0 0
// end ;
11334: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11335: GO 11337
11337: DISABLE
11338: LD_INT 0
11340: PPUSH
11341: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11342: LD_ADDR_VAR 0 1
11346: PUSH
11347: LD_INT 15
11349: PPUSH
11350: LD_INT 22
11352: PUSH
11353: LD_EXP 24
11357: PUSH
11358: EMPTY
11359: LIST
11360: LIST
11361: PUSH
11362: LD_INT 50
11364: PUSH
11365: EMPTY
11366: LIST
11367: PUSH
11368: LD_INT 2
11370: PUSH
11371: LD_INT 21
11373: PUSH
11374: LD_INT 2
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PUSH
11381: LD_INT 21
11383: PUSH
11384: LD_INT 1
11386: PUSH
11387: EMPTY
11388: LIST
11389: LIST
11390: PUSH
11391: EMPTY
11392: LIST
11393: LIST
11394: LIST
11395: PUSH
11396: EMPTY
11397: LIST
11398: LIST
11399: LIST
11400: PPUSH
11401: CALL_OW 70
11405: ST_TO_ADDR
// case tick of 0 .. 30000 :
11406: LD_OWVAR 1
11410: PUSH
11411: LD_INT 0
11413: DOUBLE
11414: GREATEREQUAL
11415: IFFALSE 11423
11417: LD_INT 30000
11419: DOUBLE
11420: LESSEQUAL
11421: IFTRUE 11425
11423: GO 11442
11425: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11426: LD_ADDR_VAR 0 2
11430: PUSH
11431: LD_EXP 34
11435: PUSH
11436: LD_INT 4
11438: MINUS
11439: ST_TO_ADDR
11440: GO 11546
11442: LD_INT 30001
11444: DOUBLE
11445: GREATEREQUAL
11446: IFFALSE 11454
11448: LD_INT 50000
11450: DOUBLE
11451: LESSEQUAL
11452: IFTRUE 11456
11454: GO 11473
11456: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11457: LD_ADDR_VAR 0 2
11461: PUSH
11462: LD_EXP 34
11466: PUSH
11467: LD_INT 3
11469: MINUS
11470: ST_TO_ADDR
11471: GO 11546
11473: LD_INT 50001
11475: DOUBLE
11476: GREATEREQUAL
11477: IFFALSE 11485
11479: LD_INT 70000
11481: DOUBLE
11482: LESSEQUAL
11483: IFTRUE 11487
11485: GO 11504
11487: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11488: LD_ADDR_VAR 0 2
11492: PUSH
11493: LD_EXP 34
11497: PUSH
11498: LD_INT 2
11500: MINUS
11501: ST_TO_ADDR
11502: GO 11546
11504: LD_INT 70001
11506: DOUBLE
11507: GREATEREQUAL
11508: IFFALSE 11516
11510: LD_INT 90000
11512: DOUBLE
11513: LESSEQUAL
11514: IFTRUE 11518
11516: GO 11535
11518: POP
// mnozstvi := maxaut - 1 ; else
11519: LD_ADDR_VAR 0 2
11523: PUSH
11524: LD_EXP 34
11528: PUSH
11529: LD_INT 1
11531: MINUS
11532: ST_TO_ADDR
11533: GO 11546
11535: POP
// mnozstvi := maxaut ; end ;
11536: LD_ADDR_VAR 0 2
11540: PUSH
11541: LD_EXP 34
11545: ST_TO_ADDR
// if filter >= mnozstvi then
11546: LD_VAR 0 1
11550: PUSH
11551: LD_VAR 0 2
11555: GREATEREQUAL
11556: IFFALSE 11573
// ComMoveXY ( filter , 138 , 69 ) ;
11558: LD_VAR 0 1
11562: PPUSH
11563: LD_INT 138
11565: PPUSH
11566: LD_INT 69
11568: PPUSH
11569: CALL_OW 111
// enable ;
11573: ENABLE
// end ;
11574: PPOPN 2
11576: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11577: GO 11579
11579: DISABLE
11580: LD_INT 0
11582: PPUSH
11583: PPUSH
11584: PPUSH
11585: PPUSH
11586: PPUSH
11587: PPUSH
// begin enable ;
11588: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11589: LD_ADDR_VAR 0 1
11593: PUSH
11594: LD_INT 12
11596: PPUSH
11597: LD_INT 22
11599: PUSH
11600: LD_EXP 24
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 50
11611: PUSH
11612: EMPTY
11613: LIST
11614: PUSH
11615: LD_INT 3
11617: PUSH
11618: LD_INT 34
11620: PUSH
11621: LD_INT 49
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: LIST
11636: PPUSH
11637: CALL_OW 70
11641: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11642: LD_INT 33
11644: PPUSH
11645: LD_EXP 23
11649: PPUSH
11650: CALL_OW 321
11654: PUSH
11655: LD_INT 2
11657: EQUAL
11658: IFFALSE 11712
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11660: LD_ADDR_VAR 0 2
11664: PUSH
11665: LD_INT 12
11667: PPUSH
11668: LD_INT 22
11670: PUSH
11671: LD_EXP 23
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: LD_INT 25
11682: PUSH
11683: LD_INT 4
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 101
11692: PUSH
11693: LD_EXP 24
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: LIST
11706: PPUSH
11707: CALL_OW 70
11711: ST_TO_ADDR
// if filter_you = 0 then
11712: LD_VAR 0 2
11716: PUSH
11717: LD_INT 0
11719: EQUAL
11720: IFFALSE 11829
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11722: LD_ADDR_VAR 0 2
11726: PUSH
11727: LD_INT 22
11729: PUSH
11730: LD_EXP 23
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: LD_INT 50
11741: PUSH
11742: EMPTY
11743: LIST
11744: PUSH
11745: LD_INT 2
11747: PUSH
11748: LD_INT 21
11750: PUSH
11751: LD_INT 1
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: LD_INT 21
11760: PUSH
11761: LD_INT 2
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: PUSH
11768: LD_INT 21
11770: PUSH
11771: LD_INT 3
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: PUSH
11784: EMPTY
11785: LIST
11786: LIST
11787: LIST
11788: PPUSH
11789: CALL_OW 69
11793: ST_TO_ADDR
// if filter_you = 0 then
11794: LD_VAR 0 2
11798: PUSH
11799: LD_INT 0
11801: EQUAL
11802: IFFALSE 11829
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11804: LD_ADDR_VAR 0 2
11808: PUSH
11809: LD_INT 12
11811: PPUSH
11812: LD_INT 22
11814: PUSH
11815: LD_EXP 23
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: PPUSH
11824: CALL_OW 70
11828: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11829: LD_VAR 0 1
11833: PUSH
11834: LD_INT 0
11836: GREATER
11837: PUSH
11838: LD_VAR 0 2
11842: PUSH
11843: LD_INT 0
11845: GREATER
11846: AND
11847: IFFALSE 12238
// begin for un_rus in filter_rus do
11849: LD_ADDR_VAR 0 3
11853: PUSH
11854: LD_VAR 0 1
11858: PUSH
11859: FOR_IN
11860: IFFALSE 12236
// begin Wait ( 5 ) ;
11862: LD_INT 5
11864: PPUSH
11865: CALL_OW 67
// min := 99999 ;
11869: LD_ADDR_VAR 0 5
11873: PUSH
11874: LD_INT 99999
11876: ST_TO_ADDR
// cil := 0 ;
11877: LD_ADDR_VAR 0 6
11881: PUSH
11882: LD_INT 0
11884: ST_TO_ADDR
// for un_you in filter_you do
11885: LD_ADDR_VAR 0 4
11889: PUSH
11890: LD_VAR 0 2
11894: PUSH
11895: FOR_IN
11896: IFFALSE 12092
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
11898: LD_VAR 0 4
11902: PPUSH
11903: CALL_OW 320
11907: PUSH
11908: LD_VAR 0 4
11912: PPUSH
11913: CALL_OW 256
11917: PUSH
11918: LD_VAR 0 5
11922: LESS
11923: AND
11924: PUSH
11925: LD_VAR 0 3
11929: PPUSH
11930: LD_VAR 0 4
11934: PPUSH
11935: CALL_OW 296
11939: PUSH
11940: LD_INT 2
11942: PUSH
11943: LD_INT 2
11945: PUSH
11946: LD_INT 4
11948: PUSH
11949: LD_INT 6
11951: PUSH
11952: LD_INT 5
11954: PUSH
11955: LD_INT 9
11957: PUSH
11958: LD_INT 0
11960: PUSH
11961: LD_INT 2
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: PUSH
11974: LD_VAR 0 3
11978: PPUSH
11979: CALL_OW 264
11983: PUSH
11984: LD_INT 41
11986: MINUS
11987: ARRAY
11988: GREATEREQUAL
11989: AND
11990: PUSH
11991: LD_VAR 0 3
11995: PPUSH
11996: LD_VAR 0 4
12000: PPUSH
12001: CALL_OW 296
12005: PUSH
12006: LD_INT 15
12008: PUSH
12009: LD_INT 16
12011: PUSH
12012: LD_INT 17
12014: PUSH
12015: LD_INT 22
12017: PUSH
12018: LD_INT 20
12020: PUSH
12021: LD_INT 28
12023: PUSH
12024: LD_INT 0
12026: PUSH
12027: LD_INT 51
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: LIST
12039: PUSH
12040: LD_VAR 0 3
12044: PPUSH
12045: CALL_OW 264
12049: PUSH
12050: LD_INT 41
12052: MINUS
12053: ARRAY
12054: LESSEQUAL
12055: AND
12056: IFFALSE 12083
// begin min := GetLives ( un_you ) ;
12058: LD_ADDR_VAR 0 5
12062: PUSH
12063: LD_VAR 0 4
12067: PPUSH
12068: CALL_OW 256
12072: ST_TO_ADDR
// cil := un_you ;
12073: LD_ADDR_VAR 0 6
12077: PUSH
12078: LD_VAR 0 4
12082: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12083: LD_INT 5
12085: PPUSH
12086: CALL_OW 67
// end ;
12090: GO 11895
12092: POP
12093: POP
// if cil <> 0 then
12094: LD_VAR 0 6
12098: PUSH
12099: LD_INT 0
12101: NONEQUAL
12102: IFFALSE 12120
// ComAttackUnit ( un_rus , cil ) else
12104: LD_VAR 0 3
12108: PPUSH
12109: LD_VAR 0 6
12113: PPUSH
12114: CALL_OW 115
12118: GO 12234
// begin for un_you in filter_you do
12120: LD_ADDR_VAR 0 4
12124: PUSH
12125: LD_VAR 0 2
12129: PUSH
12130: FOR_IN
12131: IFFALSE 12218
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12133: LD_VAR 0 4
12137: PPUSH
12138: CALL_OW 266
12142: PUSH
12143: LD_INT 0
12145: PUSH
12146: LD_INT 1
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: IN
12153: IFFALSE 12167
// cil := un_you else
12155: LD_ADDR_VAR 0 6
12159: PUSH
12160: LD_VAR 0 4
12164: ST_TO_ADDR
12165: GO 12209
// if GetLives ( un_you ) < min then
12167: LD_VAR 0 4
12171: PPUSH
12172: CALL_OW 256
12176: PUSH
12177: LD_VAR 0 5
12181: LESS
12182: IFFALSE 12209
// begin min := GetLives ( un_you ) ;
12184: LD_ADDR_VAR 0 5
12188: PUSH
12189: LD_VAR 0 4
12193: PPUSH
12194: CALL_OW 256
12198: ST_TO_ADDR
// cil := un_you ;
12199: LD_ADDR_VAR 0 6
12203: PUSH
12204: LD_VAR 0 4
12208: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12209: LD_INT 5
12211: PPUSH
12212: CALL_OW 67
// end ;
12216: GO 12130
12218: POP
12219: POP
// ComAttackUnit ( un_rus , cil ) end ;
12220: LD_VAR 0 3
12224: PPUSH
12225: LD_VAR 0 6
12229: PPUSH
12230: CALL_OW 115
// end ;
12234: GO 11859
12236: POP
12237: POP
// end ; end ;
12238: PPOPN 6
12240: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12241: GO 12243
12243: DISABLE
12244: LD_INT 0
12246: PPUSH
12247: PPUSH
12248: PPUSH
12249: PPUSH
12250: PPUSH
12251: PPUSH
// begin enable ;
12252: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12253: LD_ADDR_VAR 0 1
12257: PUSH
12258: LD_INT 21
12260: PPUSH
12261: LD_INT 22
12263: PUSH
12264: LD_EXP 24
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 3
12275: PUSH
12276: LD_INT 2
12278: PUSH
12279: LD_INT 21
12281: PUSH
12282: LD_INT 3
12284: PUSH
12285: EMPTY
12286: LIST
12287: LIST
12288: PUSH
12289: LD_INT 34
12291: PUSH
12292: LD_INT 49
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 34
12301: PUSH
12302: LD_INT 51
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PUSH
12309: LD_INT 25
12311: PUSH
12312: LD_INT 4
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 25
12321: PUSH
12322: LD_INT 2
12324: PUSH
12325: EMPTY
12326: LIST
12327: LIST
12328: PUSH
12329: LD_INT 54
12331: PUSH
12332: EMPTY
12333: LIST
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL_OW 70
12353: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12354: LD_ADDR_VAR 0 1
12358: PUSH
12359: LD_VAR 0 1
12363: PUSH
12364: LD_EXP 45
12368: DIFF
12369: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12370: LD_ADDR_VAR 0 2
12374: PUSH
12375: LD_INT 21
12377: PPUSH
12378: LD_INT 22
12380: PUSH
12381: LD_EXP 23
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: PUSH
12390: LD_INT 21
12392: PUSH
12393: LD_INT 2
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PPUSH
12404: CALL_OW 70
12408: ST_TO_ADDR
// if not filter_you then
12409: LD_VAR 0 2
12413: NOT
12414: IFFALSE 12487
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12416: LD_ADDR_VAR 0 2
12420: PUSH
12421: LD_INT 21
12423: PPUSH
12424: LD_INT 22
12426: PUSH
12427: LD_EXP 23
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: PUSH
12436: LD_INT 25
12438: PUSH
12439: LD_INT 4
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PPUSH
12450: CALL_OW 70
12454: ST_TO_ADDR
// if not filter_you then
12455: LD_VAR 0 2
12459: NOT
12460: IFFALSE 12487
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12462: LD_ADDR_VAR 0 2
12466: PUSH
12467: LD_INT 21
12469: PPUSH
12470: LD_INT 22
12472: PUSH
12473: LD_EXP 23
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: PPUSH
12482: CALL_OW 70
12486: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12487: LD_VAR 0 1
12491: PUSH
12492: LD_INT 0
12494: GREATER
12495: PUSH
12496: LD_VAR 0 2
12500: PUSH
12501: LD_INT 0
12503: GREATER
12504: AND
12505: IFFALSE 12896
// begin for un_rus in filter_rus do
12507: LD_ADDR_VAR 0 3
12511: PUSH
12512: LD_VAR 0 1
12516: PUSH
12517: FOR_IN
12518: IFFALSE 12894
// begin Wait ( 5 ) ;
12520: LD_INT 5
12522: PPUSH
12523: CALL_OW 67
// min := 99999 ;
12527: LD_ADDR_VAR 0 5
12531: PUSH
12532: LD_INT 99999
12534: ST_TO_ADDR
// cil := 0 ;
12535: LD_ADDR_VAR 0 6
12539: PUSH
12540: LD_INT 0
12542: ST_TO_ADDR
// for un_you in filter_you do
12543: LD_ADDR_VAR 0 4
12547: PUSH
12548: LD_VAR 0 2
12552: PUSH
12553: FOR_IN
12554: IFFALSE 12750
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12556: LD_VAR 0 4
12560: PPUSH
12561: CALL_OW 302
12565: PUSH
12566: LD_VAR 0 4
12570: PPUSH
12571: CALL_OW 256
12575: PUSH
12576: LD_VAR 0 5
12580: LESS
12581: AND
12582: PUSH
12583: LD_VAR 0 3
12587: PPUSH
12588: LD_VAR 0 4
12592: PPUSH
12593: CALL_OW 296
12597: PUSH
12598: LD_INT 2
12600: PUSH
12601: LD_INT 2
12603: PUSH
12604: LD_INT 4
12606: PUSH
12607: LD_INT 6
12609: PUSH
12610: LD_INT 5
12612: PUSH
12613: LD_INT 9
12615: PUSH
12616: LD_INT 0
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PUSH
12632: LD_VAR 0 3
12636: PPUSH
12637: CALL_OW 264
12641: PUSH
12642: LD_INT 41
12644: MINUS
12645: ARRAY
12646: GREATEREQUAL
12647: AND
12648: PUSH
12649: LD_VAR 0 3
12653: PPUSH
12654: LD_VAR 0 4
12658: PPUSH
12659: CALL_OW 296
12663: PUSH
12664: LD_INT 15
12666: PUSH
12667: LD_INT 16
12669: PUSH
12670: LD_INT 17
12672: PUSH
12673: LD_INT 22
12675: PUSH
12676: LD_INT 20
12678: PUSH
12679: LD_INT 28
12681: PUSH
12682: LD_INT 0
12684: PUSH
12685: LD_INT 51
12687: PUSH
12688: EMPTY
12689: LIST
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: PUSH
12698: LD_VAR 0 3
12702: PPUSH
12703: CALL_OW 264
12707: PUSH
12708: LD_INT 41
12710: MINUS
12711: ARRAY
12712: LESSEQUAL
12713: AND
12714: IFFALSE 12741
// begin min := GetLives ( un_you ) ;
12716: LD_ADDR_VAR 0 5
12720: PUSH
12721: LD_VAR 0 4
12725: PPUSH
12726: CALL_OW 256
12730: ST_TO_ADDR
// cil := un_you ;
12731: LD_ADDR_VAR 0 6
12735: PUSH
12736: LD_VAR 0 4
12740: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12741: LD_INT 5
12743: PPUSH
12744: CALL_OW 67
// end ;
12748: GO 12553
12750: POP
12751: POP
// if cil <> 0 then
12752: LD_VAR 0 6
12756: PUSH
12757: LD_INT 0
12759: NONEQUAL
12760: IFFALSE 12778
// ComAttackUnit ( un_rus , cil ) else
12762: LD_VAR 0 3
12766: PPUSH
12767: LD_VAR 0 6
12771: PPUSH
12772: CALL_OW 115
12776: GO 12892
// begin for un_you in filter_you do
12778: LD_ADDR_VAR 0 4
12782: PUSH
12783: LD_VAR 0 2
12787: PUSH
12788: FOR_IN
12789: IFFALSE 12876
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12791: LD_VAR 0 4
12795: PPUSH
12796: CALL_OW 266
12800: PUSH
12801: LD_INT 0
12803: PUSH
12804: LD_INT 1
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: IN
12811: IFFALSE 12825
// cil := un_you else
12813: LD_ADDR_VAR 0 6
12817: PUSH
12818: LD_VAR 0 4
12822: ST_TO_ADDR
12823: GO 12867
// if GetLives ( un_you ) < min then
12825: LD_VAR 0 4
12829: PPUSH
12830: CALL_OW 256
12834: PUSH
12835: LD_VAR 0 5
12839: LESS
12840: IFFALSE 12867
// begin min := GetLives ( un_you ) ;
12842: LD_ADDR_VAR 0 5
12846: PUSH
12847: LD_VAR 0 4
12851: PPUSH
12852: CALL_OW 256
12856: ST_TO_ADDR
// cil := un_you ;
12857: LD_ADDR_VAR 0 6
12861: PUSH
12862: LD_VAR 0 4
12866: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12867: LD_INT 5
12869: PPUSH
12870: CALL_OW 67
// end ;
12874: GO 12788
12876: POP
12877: POP
// ComAttackUnit ( un_rus , cil ) end ;
12878: LD_VAR 0 3
12882: PPUSH
12883: LD_VAR 0 6
12887: PPUSH
12888: CALL_OW 115
// end ;
12892: GO 12517
12894: POP
12895: POP
// end ; end ;
12896: PPOPN 6
12898: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
12899: GO 12901
12901: DISABLE
12902: LD_INT 0
12904: PPUSH
12905: PPUSH
12906: PPUSH
12907: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
12908: LD_INT 28
12910: PPUSH
12911: LD_EXP 23
12915: PPUSH
12916: CALL_OW 321
12920: PUSH
12921: LD_INT 2
12923: EQUAL
12924: NOT
12925: IFFALSE 12928
// enable ;
12927: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
12928: LD_ADDR_VAR 0 1
12932: PUSH
12933: LD_INT 12
12935: PPUSH
12936: LD_INT 22
12938: PUSH
12939: LD_EXP 24
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: LD_INT 50
12950: PUSH
12951: EMPTY
12952: LIST
12953: PUSH
12954: LD_INT 34
12956: PUSH
12957: LD_INT 49
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 70
12973: ST_TO_ADDR
// if filter_rus > 0 then
12974: LD_VAR 0 1
12978: PUSH
12979: LD_INT 0
12981: GREATER
12982: IFFALSE 13023
// for un_rus in filter_rus do
12984: LD_ADDR_VAR 0 3
12988: PUSH
12989: LD_VAR 0 1
12993: PUSH
12994: FOR_IN
12995: IFFALSE 13021
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
12997: LD_VAR 0 3
13001: PPUSH
13002: LD_INT 122
13004: PPUSH
13005: LD_INT 27
13007: PPUSH
13008: CALL_OW 111
// Wait ( 5 ) ;
13012: LD_INT 5
13014: PPUSH
13015: CALL_OW 67
// end ;
13019: GO 12994
13021: POP
13022: POP
// end ;
13023: PPOPN 4
13025: END
// every 1 1$0 + 0 0$5.5 do
13026: GO 13028
13028: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13029: LD_INT 59
13031: PPUSH
13032: LD_EXP 24
13036: PPUSH
13037: CALL_OW 321
13041: PUSH
13042: LD_INT 2
13044: EQUAL
13045: NOT
13046: PUSH
13047: LD_OWVAR 1
13051: PUSH
13052: LD_EXP 54
13056: GREATEREQUAL
13057: AND
13058: IFFALSE 13075
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13060: LD_INT 59
13062: PPUSH
13063: LD_EXP 24
13067: PPUSH
13068: LD_INT 2
13070: PPUSH
13071: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13075: LD_INT 50
13077: PPUSH
13078: LD_EXP 24
13082: PPUSH
13083: CALL_OW 321
13087: PUSH
13088: LD_INT 2
13090: EQUAL
13091: NOT
13092: PUSH
13093: LD_OWVAR 1
13097: PUSH
13098: LD_EXP 55
13102: GREATEREQUAL
13103: AND
13104: IFFALSE 13121
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13106: LD_INT 50
13108: PPUSH
13109: LD_EXP 24
13113: PPUSH
13114: LD_INT 2
13116: PPUSH
13117: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13121: LD_INT 53
13123: PPUSH
13124: LD_EXP 24
13128: PPUSH
13129: CALL_OW 321
13133: PUSH
13134: LD_INT 2
13136: EQUAL
13137: NOT
13138: PUSH
13139: LD_OWVAR 1
13143: PUSH
13144: LD_EXP 56
13148: GREATEREQUAL
13149: AND
13150: IFFALSE 13167
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13152: LD_INT 53
13154: PPUSH
13155: LD_EXP 24
13159: PPUSH
13160: LD_INT 2
13162: PPUSH
13163: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13167: LD_INT 56
13169: PPUSH
13170: LD_EXP 24
13174: PPUSH
13175: CALL_OW 321
13179: PUSH
13180: LD_INT 2
13182: EQUAL
13183: NOT
13184: PUSH
13185: LD_OWVAR 1
13189: PUSH
13190: LD_EXP 57
13194: GREATEREQUAL
13195: AND
13196: IFFALSE 13213
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13198: LD_INT 56
13200: PPUSH
13201: LD_EXP 24
13205: PPUSH
13206: LD_INT 2
13208: PPUSH
13209: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13213: LD_INT 65
13215: PPUSH
13216: LD_EXP 24
13220: PPUSH
13221: CALL_OW 321
13225: PUSH
13226: LD_INT 2
13228: EQUAL
13229: NOT
13230: PUSH
13231: LD_OWVAR 1
13235: PUSH
13236: LD_EXP 58
13240: GREATEREQUAL
13241: AND
13242: IFFALSE 13259
// SetTech ( tech_ST3 , rus , state_researched ) ;
13244: LD_INT 65
13246: PPUSH
13247: LD_EXP 24
13251: PPUSH
13252: LD_INT 2
13254: PPUSH
13255: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13259: LD_INT 59
13261: PPUSH
13262: LD_EXP 24
13266: PPUSH
13267: CALL_OW 321
13271: PUSH
13272: LD_INT 2
13274: EQUAL
13275: PUSH
13276: LD_INT 50
13278: PPUSH
13279: LD_EXP 24
13283: PPUSH
13284: CALL_OW 321
13288: PUSH
13289: LD_INT 2
13291: EQUAL
13292: AND
13293: PUSH
13294: LD_INT 53
13296: PPUSH
13297: LD_EXP 24
13301: PPUSH
13302: CALL_OW 321
13306: PUSH
13307: LD_INT 2
13309: EQUAL
13310: AND
13311: PUSH
13312: LD_INT 56
13314: PPUSH
13315: LD_EXP 24
13319: PPUSH
13320: CALL_OW 321
13324: PUSH
13325: LD_INT 2
13327: EQUAL
13328: AND
13329: PUSH
13330: LD_INT 65
13332: PPUSH
13333: LD_EXP 24
13337: PPUSH
13338: CALL_OW 321
13342: PUSH
13343: LD_INT 2
13345: EQUAL
13346: AND
13347: NOT
13348: IFFALSE 13351
// enable ;
13350: ENABLE
// end ; end_of_file
13351: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13352: GO 13354
13354: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13355: LD_ADDR_EXP 63
13359: PUSH
13360: LD_INT 14
13362: PUSH
13363: LD_INT 18
13365: PUSH
13366: LD_INT 19
13368: PUSH
13369: LD_INT 20
13371: PUSH
13372: LD_INT 21
13374: PUSH
13375: LD_INT 22
13377: PUSH
13378: LD_INT 23
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13390: LD_ADDR_EXP 64
13394: PUSH
13395: LD_INT 22
13397: PUSH
13398: LD_EXP 24
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PUSH
13407: LD_INT 21
13409: PUSH
13410: LD_INT 3
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: PUSH
13417: EMPTY
13418: LIST
13419: LIST
13420: PPUSH
13421: CALL_OW 69
13425: PUSH
13426: LD_INT 14
13428: PUSH
13429: LD_INT 15
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: ADD
13436: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13437: LD_ADDR_EXP 65
13441: PUSH
13442: LD_INT 22
13444: PUSH
13445: LD_EXP 24
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 30
13456: PUSH
13457: LD_INT 1
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PPUSH
13468: CALL_OW 69
13472: PUSH
13473: LD_INT 1
13475: ARRAY
13476: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13477: LD_ADDR_EXP 66
13481: PUSH
13482: LD_INT 22
13484: PUSH
13485: LD_EXP 24
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PUSH
13494: LD_INT 30
13496: PUSH
13497: LD_INT 8
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: PPUSH
13508: CALL_OW 69
13512: PUSH
13513: LD_INT 1
13515: ARRAY
13516: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13517: LD_ADDR_EXP 67
13521: PUSH
13522: LD_INT 22
13524: PUSH
13525: LD_EXP 24
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: LD_INT 30
13536: PUSH
13537: LD_INT 31
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: PPUSH
13548: CALL_OW 69
13552: PUSH
13553: LD_INT 1
13555: ARRAY
13556: ST_TO_ADDR
// enable ( 401 ) ;
13557: LD_INT 401
13559: ENABLE_MARKED
// end ;
13560: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13561: GO 13563
13563: DISABLE
13564: LD_INT 0
13566: PPUSH
13567: PPUSH
13568: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13569: LD_EXP 62
13573: PPUSH
13574: CALL_OW 386
13578: NOT
13579: IFFALSE 13634
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13581: LD_ADDR_EXP 62
13585: PUSH
13586: LD_INT 100
13588: PPUSH
13589: LD_EXP 63
13593: PPUSH
13594: LD_EXP 64
13598: PUSH
13599: LD_EXP 63
13603: ADD
13604: PPUSH
13605: LD_INT 1
13607: PUSH
13608: LD_INT 23
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 10
13617: PUSH
13618: LD_INT 22
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: PUSH
13625: EMPTY
13626: LIST
13627: LIST
13628: PPUSH
13629: CALL_OW 414
13633: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13634: LD_EXP 65
13638: PPUSH
13639: CALL_OW 300
13643: PUSH
13644: LD_EXP 66
13648: PPUSH
13649: CALL_OW 300
13653: OR
13654: PUSH
13655: LD_EXP 67
13659: PPUSH
13660: CALL_OW 300
13664: OR
13665: IFFALSE 13891
// begin for un in rus_mcrep_units do
13667: LD_ADDR_VAR 0 1
13671: PUSH
13672: LD_EXP 63
13676: PUSH
13677: FOR_IN
13678: IFFALSE 13889
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13680: LD_VAR 0 1
13684: PPUSH
13685: CALL_OW 388
13689: PUSH
13690: LD_INT 0
13692: EQUAL
13693: PUSH
13694: LD_VAR 0 1
13698: PPUSH
13699: CALL_OW 256
13703: PUSH
13704: LD_INT 1000
13706: EQUAL
13707: AND
13708: IFFALSE 13875
// case GetClass ( un ) of class_engineer :
13710: LD_VAR 0 1
13714: PPUSH
13715: CALL_OW 257
13719: PUSH
13720: LD_INT 2
13722: DOUBLE
13723: EQUAL
13724: IFTRUE 13728
13726: GO 13772
13728: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13729: LD_EXP 65
13733: PPUSH
13734: CALL_OW 300
13738: PUSH
13739: LD_EXP 65
13743: PPUSH
13744: CALL_OW 313
13748: PUSH
13749: LD_INT 6
13751: EQUAL
13752: NOT
13753: AND
13754: IFFALSE 13770
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13756: LD_VAR 0 1
13760: PPUSH
13761: LD_EXP 65
13765: PPUSH
13766: CALL_OW 120
13770: GO 13873
13772: LD_INT 4
13774: DOUBLE
13775: EQUAL
13776: IFTRUE 13780
13778: GO 13824
13780: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13781: LD_EXP 66
13785: PPUSH
13786: CALL_OW 300
13790: PUSH
13791: LD_EXP 66
13795: PPUSH
13796: CALL_OW 313
13800: PUSH
13801: LD_INT 6
13803: EQUAL
13804: NOT
13805: AND
13806: IFFALSE 13822
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13808: LD_VAR 0 1
13812: PPUSH
13813: LD_EXP 66
13817: PPUSH
13818: CALL_OW 120
13822: GO 13873
13824: LD_INT 1
13826: DOUBLE
13827: EQUAL
13828: IFTRUE 13832
13830: GO 13872
13832: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13833: LD_EXP 67
13837: PPUSH
13838: CALL_OW 300
13842: PUSH
13843: LD_EXP 67
13847: PPUSH
13848: CALL_OW 313
13852: NOT
13853: AND
13854: IFFALSE 13870
// ComEnterUnit ( un , rus_breastwork ) ; end else
13856: LD_VAR 0 1
13860: PPUSH
13861: LD_EXP 67
13865: PPUSH
13866: CALL_OW 120
13870: GO 13873
13872: POP
13873: GO 13887
// ComMoveToArea ( un , BluekherRepairArea ) ;
13875: LD_VAR 0 1
13879: PPUSH
13880: LD_INT 23
13882: PPUSH
13883: CALL_OW 113
13887: GO 13677
13889: POP
13890: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
13891: LD_ADDR_VAR 0 3
13895: PUSH
13896: LD_INT 22
13898: PPUSH
13899: LD_INT 22
13901: PUSH
13902: LD_EXP 24
13906: PUSH
13907: EMPTY
13908: LIST
13909: LIST
13910: PUSH
13911: LD_INT 2
13913: PUSH
13914: LD_INT 25
13916: PUSH
13917: LD_INT 2
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: PUSH
13924: LD_INT 25
13926: PUSH
13927: LD_INT 4
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: PUSH
13934: EMPTY
13935: LIST
13936: LIST
13937: LIST
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: PPUSH
13943: CALL_OW 71
13947: ST_TO_ADDR
// if filter then
13948: LD_VAR 0 3
13952: IFFALSE 13969
// ComMoveXY ( filter , 48 , 88 ) ;
13954: LD_VAR 0 3
13958: PPUSH
13959: LD_INT 48
13961: PPUSH
13962: LD_INT 88
13964: PPUSH
13965: CALL_OW 111
// enable ;
13969: ENABLE
// end ; end_of_file
13970: PPOPN 3
13972: END
// every 0 0$2 + 0 0$0.1 do
13973: GO 13975
13975: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
13976: LD_INT 22
13978: PUSH
13979: LD_INT 7
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: PUSH
13986: LD_INT 2
13988: PUSH
13989: LD_INT 25
13991: PUSH
13992: LD_INT 12
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: PUSH
13999: LD_INT 25
14001: PUSH
14002: LD_INT 16
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PUSH
14009: LD_INT 25
14011: PUSH
14012: LD_INT 15
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 25
14021: PUSH
14022: LD_INT 17
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: PUSH
14045: LD_INT 22
14047: PUSH
14048: LD_INT 7
14050: PUSH
14051: EMPTY
14052: LIST
14053: LIST
14054: PUSH
14055: LD_INT 21
14057: PUSH
14058: LD_INT 1
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: PUSH
14065: LD_INT 3
14067: PUSH
14068: LD_INT 2
14070: PUSH
14071: LD_INT 25
14073: PUSH
14074: LD_INT 12
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: PUSH
14081: LD_INT 25
14083: PUSH
14084: LD_INT 16
14086: PUSH
14087: EMPTY
14088: LIST
14089: LIST
14090: PUSH
14091: LD_INT 25
14093: PUSH
14094: LD_INT 15
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: PUSH
14101: LD_INT 25
14103: PUSH
14104: LD_INT 17
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: PUSH
14111: EMPTY
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PUSH
14122: EMPTY
14123: LIST
14124: LIST
14125: LIST
14126: PPUSH
14127: CALL_OW 69
14131: GREATER
14132: IFFALSE 14143
// begin SetAchievement ( ACH_POTA ) ;
14134: LD_STRING ACH_POTA
14136: PPUSH
14137: CALL_OW 543
// exit ;
14141: GO 14144
// end ; enable ;
14143: ENABLE
// end ; end_of_file
14144: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14145: LD_INT 0
14147: PPUSH
14148: PPUSH
// if not missionNumber then
14149: LD_VAR 0 2
14153: NOT
14154: IFFALSE 14158
// exit ;
14156: GO 14288
// achiv := false ;
14158: LD_ADDR_VAR 0 7
14162: PUSH
14163: LD_INT 0
14165: ST_TO_ADDR
// case campaignNumber of 1 :
14166: LD_VAR 0 1
14170: PUSH
14171: LD_INT 1
14173: DOUBLE
14174: EQUAL
14175: IFTRUE 14179
14177: GO 14190
14179: POP
// achiv := ACH_GOTA ; 2 :
14180: LD_ADDR_VAR 0 7
14184: PUSH
14185: LD_STRING ACH_GOTA
14187: ST_TO_ADDR
14188: GO 14240
14190: LD_INT 2
14192: DOUBLE
14193: EQUAL
14194: IFTRUE 14198
14196: GO 14201
14198: POP
// ; 3 :
14199: GO 14240
14201: LD_INT 3
14203: DOUBLE
14204: EQUAL
14205: IFTRUE 14209
14207: GO 14220
14209: POP
// achiv := ACH_MOTSU ; 4 :
14210: LD_ADDR_VAR 0 7
14214: PUSH
14215: LD_STRING ACH_MOTSU
14217: ST_TO_ADDR
14218: GO 14240
14220: LD_INT 4
14222: DOUBLE
14223: EQUAL
14224: IFTRUE 14228
14226: GO 14239
14228: POP
// achiv := ACH_LOP ; end ;
14229: LD_ADDR_VAR 0 7
14233: PUSH
14234: LD_STRING ACH_LOP
14236: ST_TO_ADDR
14237: GO 14240
14239: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14240: LD_OWVAR 67
14244: PUSH
14245: LD_INT 3
14247: EQUAL
14248: PUSH
14249: LD_VAR 0 7
14253: AND
14254: PUSH
14255: LD_VAR 0 3
14259: AND
14260: PUSH
14261: LD_VAR 0 4
14265: AND
14266: PUSH
14267: LD_VAR 0 5
14271: AND
14272: IFFALSE 14288
// SetAchievementEX ( achiv , missionNumber ) ;
14274: LD_VAR 0 7
14278: PPUSH
14279: LD_VAR 0 2
14283: PPUSH
14284: CALL_OW 564
// end ;
14288: LD_VAR 0 6
14292: RET
// export function SA_BehemothConstructed ; begin
14293: LD_INT 0
14295: PPUSH
// SetAchievement ( ACH_SMC ) ;
14296: LD_STRING ACH_SMC
14298: PPUSH
14299: CALL_OW 543
// end ;
14303: LD_VAR 0 1
14307: RET
