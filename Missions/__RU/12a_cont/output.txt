// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 3 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 3
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$45 , 0 0$40 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1575
 345: PUSH
 346: LD_INT 1400
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 4200
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// while scientists > 5 do
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1286
// scientists = Delete ( scientists , scientists + 0 ) ;
1260: LD_ADDR_EXP 40
1264: PUSH
1265: LD_EXP 40
1269: PPUSH
1270: LD_EXP 40
1274: PUSH
1275: LD_INT 0
1277: PLUS
1278: PPUSH
1279: CALL_OW 3
1283: ST_TO_ADDR
1284: GO 1250
// survivors3 = survivors3 diff scientists ;
1286: LD_ADDR_EXP 22
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 40
1300: DIFF
1301: ST_TO_ADDR
// if scientists < 5 then
1302: LD_EXP 40
1306: PUSH
1307: LD_INT 5
1309: LESS
1310: IFFALSE 1401
// for i := 1 to 5 - scientists do
1312: LD_ADDR_VAR 0 3
1316: PUSH
1317: DOUBLE
1318: LD_INT 1
1320: DEC
1321: ST_TO_ADDR
1322: LD_INT 5
1324: PUSH
1325: LD_EXP 40
1329: MINUS
1330: PUSH
1331: FOR_TO
1332: IFFALSE 1399
// begin uc_side = ally ;
1334: LD_ADDR_OWVAR 20
1338: PUSH
1339: LD_EXP 25
1343: ST_TO_ADDR
// uc_nation := nation_russian ;
1344: LD_ADDR_OWVAR 21
1348: PUSH
1349: LD_INT 3
1351: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1352: LD_INT 0
1354: PPUSH
1355: LD_INT 4
1357: PPUSH
1358: LD_INT 5
1360: PPUSH
1361: LD_INT 7
1363: PPUSH
1364: CALL_OW 12
1368: PPUSH
1369: CALL_OW 380
// hc_name :=  ;
1373: LD_ADDR_OWVAR 26
1377: PUSH
1378: LD_STRING 
1380: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1381: LD_ADDR_EXP 40
1385: PUSH
1386: LD_EXP 40
1390: PUSH
1391: CALL_OW 44
1395: ADD
1396: ST_TO_ADDR
// end ;
1397: GO 1331
1399: POP
1400: POP
// for un in scientists do
1401: LD_ADDR_VAR 0 2
1405: PUSH
1406: LD_EXP 40
1410: PUSH
1411: FOR_IN
1412: IFFALSE 1430
// SetSide ( un , ally ) ;
1414: LD_VAR 0 2
1418: PPUSH
1419: LD_EXP 25
1423: PPUSH
1424: CALL_OW 235
1428: GO 1411
1430: POP
1431: POP
// possible := all_possible diff scientists ;
1432: LD_ADDR_EXP 38
1436: PUSH
1437: LD_EXP 39
1441: PUSH
1442: LD_EXP 40
1446: DIFF
1447: ST_TO_ADDR
// if scientists > 5 then
1448: LD_EXP 40
1452: PUSH
1453: LD_INT 5
1455: GREATER
1456: IFFALSE 1500
// for i = scientists downto 5 do
1458: LD_ADDR_VAR 0 3
1462: PUSH
1463: DOUBLE
1464: LD_EXP 40
1468: INC
1469: ST_TO_ADDR
1470: LD_INT 5
1472: PUSH
1473: FOR_DOWNTO
1474: IFFALSE 1498
// scientists := Delete ( scientists , i ) ;
1476: LD_ADDR_EXP 40
1480: PUSH
1481: LD_EXP 40
1485: PPUSH
1486: LD_VAR 0 3
1490: PPUSH
1491: CALL_OW 3
1495: ST_TO_ADDR
1496: GO 1473
1498: POP
1499: POP
// for un in scientists do
1500: LD_ADDR_VAR 0 2
1504: PUSH
1505: LD_EXP 40
1509: PUSH
1510: FOR_IN
1511: IFFALSE 1527
// PlaceHumanInUnit ( un , 2 ) ;
1513: LD_VAR 0 2
1517: PPUSH
1518: LD_INT 2
1520: PPUSH
1521: CALL_OW 52
1525: GO 1510
1527: POP
1528: POP
// new := [ ] ;
1529: LD_ADDR_EXP 36
1533: PUSH
1534: EMPTY
1535: ST_TO_ADDR
// if possible < 10 then
1536: LD_EXP 38
1540: PUSH
1541: LD_INT 10
1543: LESS
1544: IFFALSE 1627
// for i := 1 to 10 - possible do
1546: LD_ADDR_VAR 0 3
1550: PUSH
1551: DOUBLE
1552: LD_INT 1
1554: DEC
1555: ST_TO_ADDR
1556: LD_INT 10
1558: PUSH
1559: LD_EXP 38
1563: MINUS
1564: PUSH
1565: FOR_TO
1566: IFFALSE 1625
// begin uc_side = rus ;
1568: LD_ADDR_OWVAR 20
1572: PUSH
1573: LD_EXP 24
1577: ST_TO_ADDR
// uc_nation := nation_russian ;
1578: LD_ADDR_OWVAR 21
1582: PUSH
1583: LD_INT 3
1585: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1586: LD_INT 0
1588: PPUSH
1589: LD_INT 0
1591: PPUSH
1592: LD_INT 5
1594: PPUSH
1595: CALL_OW 380
// hc_name :=  ;
1599: LD_ADDR_OWVAR 26
1603: PUSH
1604: LD_STRING 
1606: ST_TO_ADDR
// new := new ^ CreateHuman ;
1607: LD_ADDR_EXP 36
1611: PUSH
1612: LD_EXP 36
1616: PUSH
1617: CALL_OW 44
1621: ADD
1622: ST_TO_ADDR
// end ;
1623: GO 1565
1625: POP
1626: POP
// uc_side = rus ;
1627: LD_ADDR_OWVAR 20
1631: PUSH
1632: LD_EXP 24
1636: ST_TO_ADDR
// uc_nation := nation_russian ;
1637: LD_ADDR_OWVAR 21
1641: PUSH
1642: LD_INT 3
1644: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1645: LD_ADDR_EXP 1
1649: PUSH
1650: LD_STRING Burlak
1652: PPUSH
1653: CALL 565 0 1
1657: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1658: LD_EXP 1
1662: PPUSH
1663: LD_INT 3
1665: PPUSH
1666: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1670: LD_ADDR_EXP 20
1674: PUSH
1675: LD_STRING Platonov
1677: PPUSH
1678: CALL_OW 25
1682: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1683: LD_INT 1
1685: PPUSH
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 4
1691: PPUSH
1692: CALL_OW 380
// hc_name :=  ;
1696: LD_ADDR_OWVAR 26
1700: PUSH
1701: LD_STRING 
1703: ST_TO_ADDR
// RSoldier := CreateHuman ;
1704: LD_ADDR_EXP 21
1708: PUSH
1709: CALL_OW 44
1713: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1714: LD_ADDR_VAR 0 3
1718: PUSH
1719: DOUBLE
1720: LD_INT 1
1722: DEC
1723: ST_TO_ADDR
1724: LD_EXP 31
1728: PUSH
1729: LD_INT 3
1731: PUSH
1732: LD_EXP 30
1736: MUL
1737: PLUS
1738: PUSH
1739: FOR_TO
1740: IFFALSE 1832
// begin case Rand ( 1 , 2 ) of 1 :
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: CALL_OW 12
1752: PUSH
1753: LD_INT 1
1755: DOUBLE
1756: EQUAL
1757: IFTRUE 1761
1759: GO 1779
1761: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1762: LD_INT 1
1764: PPUSH
1765: LD_INT 1
1767: PPUSH
1768: LD_EXP 32
1772: PPUSH
1773: CALL_OW 380
1777: GO 1806
1779: LD_INT 2
1781: DOUBLE
1782: EQUAL
1783: IFTRUE 1787
1785: GO 1805
1787: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_EXP 32
1798: PPUSH
1799: CALL_OW 380
1803: GO 1806
1805: POP
// hc_name :=  ;
1806: LD_ADDR_OWVAR 26
1810: PUSH
1811: LD_STRING 
1813: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1814: LD_ADDR_EXP 29
1818: PUSH
1819: LD_EXP 29
1823: PUSH
1824: CALL_OW 44
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1739
1832: POP
1833: POP
// end ;
1834: LD_VAR 0 1
1838: RET
// function select_people ; var units , un ; begin
1839: LD_INT 0
1841: PPUSH
1842: PPUSH
1843: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1844: LD_ADDR_EXP 41
1848: PUSH
1849: LD_STRING 
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 5
1857: PPUSH
1858: LD_INT -1
1860: PUSH
1861: LD_INT -4
1863: PUSH
1864: LD_INT -6
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: PUSH
1872: LD_EXP 1
1876: ADD
1877: PUSH
1878: LD_INT -2
1880: PUSH
1881: LD_INT -4
1883: PUSH
1884: LD_INT -6
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: ADD
1892: PUSH
1893: LD_EXP 20
1897: ADD
1898: PUSH
1899: LD_INT -2
1901: PUSH
1902: LD_INT -5
1904: PUSH
1905: LD_INT -3
1907: PUSH
1908: EMPTY
1909: LIST
1910: LIST
1911: LIST
1912: ADD
1913: PUSH
1914: LD_EXP 38
1918: ADD
1919: PUSH
1920: LD_EXP 22
1924: ADD
1925: PUSH
1926: LD_EXP 36
1930: ADD
1931: PPUSH
1932: LD_INT 1
1934: PUSH
1935: LD_INT 3
1937: PUSH
1938: LD_INT 2
1940: PUSH
1941: LD_INT 4
1943: PUSH
1944: LD_INT 9
1946: PUSH
1947: LD_INT 0
1949: PUSH
1950: LD_INT 2
1952: PUSH
1953: EMPTY
1954: LIST
1955: LIST
1956: LIST
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: LIST
1964: PPUSH
1965: CALL_OW 42
1969: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1970: LD_EXP 41
1974: PUSH
1975: LD_EXP 1
1979: DIFF
1980: PPUSH
1981: LD_EXP 27
1985: PPUSH
1986: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1990: LD_ADDR_VAR 0 3
1994: PUSH
1995: LD_EXP 41
1999: PUSH
2000: LD_EXP 1
2004: DIFF
2005: PUSH
2006: FOR_IN
2007: IFFALSE 2026
// PlaceUnitArea ( un , BaseArea , false ) ;
2009: LD_VAR 0 3
2013: PPUSH
2014: LD_INT 2
2016: PPUSH
2017: LD_INT 0
2019: PPUSH
2020: CALL_OW 49
2024: GO 2006
2026: POP
2027: POP
// end ;
2028: LD_VAR 0 1
2032: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
2033: LD_INT 0
2035: PPUSH
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
2040: LD_ADDR_VAR 0 3
2044: PUSH
2045: LD_STRING EscapeVehicle_12a
2047: PPUSH
2048: LD_INT 1
2050: PUSH
2051: LD_INT 0
2053: PUSH
2054: LD_INT 0
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: LIST
2061: PPUSH
2062: CALL_OW 30
2066: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2067: LD_ADDR_LOC 1
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 1
2079: ARRAY
2080: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 3
2090: PUSH
2091: LD_INT 2
2093: ARRAY
2094: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 3
2104: PUSH
2105: LD_INT 3
2107: ARRAY
2108: ST_TO_ADDR
// if MashaWanted then
2109: LD_LOC 1
2113: IFFALSE 2317
// begin veh := LoadVariable ( Masha , false ) ;
2115: LD_ADDR_VAR 0 2
2119: PUSH
2120: LD_STRING Masha
2122: PPUSH
2123: LD_INT 0
2125: PPUSH
2126: CALL_OW 30
2130: ST_TO_ADDR
// if veh then
2131: LD_VAR 0 2
2135: IFFALSE 2239
// begin uc_side := rus ;
2137: LD_ADDR_OWVAR 20
2141: PUSH
2142: LD_EXP 24
2146: ST_TO_ADDR
// uc_nation := nation_russian ;
2147: LD_ADDR_OWVAR 21
2151: PUSH
2152: LD_INT 3
2154: ST_TO_ADDR
// uc_direction := 2 ;
2155: LD_ADDR_OWVAR 24
2159: PUSH
2160: LD_INT 2
2162: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2163: LD_ADDR_OWVAR 37
2167: PUSH
2168: LD_VAR 0 2
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_VAR 0 2
2186: PUSH
2187: LD_INT 2
2189: ARRAY
2190: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2191: LD_ADDR_OWVAR 38
2195: PUSH
2196: LD_VAR 0 2
2200: PUSH
2201: LD_INT 3
2203: ARRAY
2204: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2205: LD_ADDR_OWVAR 40
2209: PUSH
2210: LD_VAR 0 2
2214: PUSH
2215: LD_INT 4
2217: ARRAY
2218: ST_TO_ADDR
// RealMasha := true ;
2219: LD_ADDR_EXP 42
2223: PUSH
2224: LD_INT 1
2226: ST_TO_ADDR
// Masha := CreateVehicle ;
2227: LD_ADDR_EXP 43
2231: PUSH
2232: CALL_OW 45
2236: ST_TO_ADDR
// end else
2237: GO 2315
// begin uc_side := rus ;
2239: LD_ADDR_OWVAR 20
2243: PUSH
2244: LD_EXP 24
2248: ST_TO_ADDR
// uc_nation := nation_russian ;
2249: LD_ADDR_OWVAR 21
2253: PUSH
2254: LD_INT 3
2256: ST_TO_ADDR
// uc_direction := 2 ;
2257: LD_ADDR_OWVAR 24
2261: PUSH
2262: LD_INT 2
2264: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2265: LD_ADDR_OWVAR 37
2269: PUSH
2270: LD_INT 22
2272: ST_TO_ADDR
// vc_engine := engine_siberite ;
2273: LD_ADDR_OWVAR 39
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2281: LD_ADDR_OWVAR 40
2285: PUSH
2286: LD_INT 43
2288: ST_TO_ADDR
// vc_control := control_manual ;
2289: LD_ADDR_OWVAR 38
2293: PUSH
2294: LD_INT 1
2296: ST_TO_ADDR
// RealMasha := false ;
2297: LD_ADDR_EXP 42
2301: PUSH
2302: LD_INT 0
2304: ST_TO_ADDR
// Masha := CreateVehicle ;
2305: LD_ADDR_EXP 43
2309: PUSH
2310: CALL_OW 45
2314: ST_TO_ADDR
// end ; end else
2315: GO 2397
// begin uc_side := rus ;
2317: LD_ADDR_OWVAR 20
2321: PUSH
2322: LD_EXP 24
2326: ST_TO_ADDR
// uc_nation := nation_russian ;
2327: LD_ADDR_OWVAR 21
2331: PUSH
2332: LD_INT 3
2334: ST_TO_ADDR
// uc_direction := 2 ;
2335: LD_ADDR_OWVAR 24
2339: PUSH
2340: LD_INT 2
2342: ST_TO_ADDR
// vc_chassis := Chassis ;
2343: LD_ADDR_OWVAR 37
2347: PUSH
2348: LD_VAR 0 4
2352: ST_TO_ADDR
// vc_engine := engine_siberite ;
2353: LD_ADDR_OWVAR 39
2357: PUSH
2358: LD_INT 3
2360: ST_TO_ADDR
// vc_weapon := Weapon ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_VAR 0 5
2370: ST_TO_ADDR
// vc_control := control_manual ;
2371: LD_ADDR_OWVAR 38
2375: PUSH
2376: LD_INT 1
2378: ST_TO_ADDR
// RealMasha := false ;
2379: LD_ADDR_EXP 42
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// Masha := CreateVehicle ;
2387: LD_ADDR_EXP 43
2391: PUSH
2392: CALL_OW 45
2396: ST_TO_ADDR
// end ; SetMark ( Masha , 1 ) ;
2397: LD_EXP 43
2401: PPUSH
2402: LD_INT 1
2404: PPUSH
2405: CALL_OW 242
// if GetEngine ( Masha ) <> engine_siberite then
2409: LD_EXP 43
2413: PPUSH
2414: CALL_OW 262
2418: PUSH
2419: LD_INT 3
2421: NONEQUAL
2422: IFFALSE 2444
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2424: LD_EXP 43
2428: PPUSH
2429: LD_INT 70
2431: PPUSH
2432: LD_INT 95
2434: PPUSH
2435: CALL_OW 12
2439: PPUSH
2440: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2444: LD_EXP 43
2448: PPUSH
2449: LD_INT 47
2451: PPUSH
2452: LD_INT 87
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL_OW 48
// end ;
2462: LD_VAR 0 1
2466: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2467: LD_INT 1
2469: PPUSH
2470: LD_STRING bluekher
2472: PPUSH
2473: CALL_OW 500
// IngameOn ;
2477: CALL_OW 8
// Randomize ;
2481: CALL_OW 10
// RandomizeAll ;
2485: CALL_OW 11
// InitBc ;
2489: CALL_OW 21
// InitHc ;
2493: CALL_OW 19
// InitUc ;
2497: CALL_OW 18
// InitVc ;
2501: CALL_OW 20
// disable ( 1 ) ;
2505: LD_INT 1
2507: DISABLE_MARKED
// disable ( 2 ) ;
2508: LD_INT 2
2510: DISABLE_MARKED
// disable ( 3 ) ;
2511: LD_INT 3
2513: DISABLE_MARKED
// disable ( 4 ) ;
2514: LD_INT 4
2516: DISABLE_MARKED
// disable ( 6 ) ;
2517: LD_INT 6
2519: DISABLE_MARKED
// disable ( 7 ) ;
2520: LD_INT 7
2522: DISABLE_MARKED
// disable ( 8 ) ;
2523: LD_INT 8
2525: DISABLE_MARKED
// disable ( 9 ) ;
2526: LD_INT 9
2528: DISABLE_MARKED
// disable ( 333 ) ;
2529: LD_INT 333
2531: DISABLE_MARKED
// disable ( 337 ) ;
2532: LD_INT 337
2534: DISABLE_MARKED
// disable ( 401 ) ;
2535: LD_INT 401
2537: DISABLE_MARKED
// read_parameters ;
2538: CALL 0 0 0
// set_difficulty ;
2542: CALL 257 0 0
// create_people ;
2546: CALL 609 0 0
// select_people ;
2550: CALL 1839 0 0
// place_masha ;
2554: CALL 2033 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2558: LD_INT 53
2560: PPUSH
2561: LD_INT 90
2563: PPUSH
2564: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2568: LD_EXP 1
2572: PPUSH
2573: LD_INT 51
2575: PPUSH
2576: LD_INT 88
2578: PPUSH
2579: LD_INT 0
2581: PPUSH
2582: CALL_OW 48
// ComHold ( Burlak ) ;
2586: LD_EXP 1
2590: PPUSH
2591: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2595: LD_EXP 21
2599: PPUSH
2600: LD_INT 54
2602: PPUSH
2603: LD_INT 90
2605: PPUSH
2606: LD_INT 0
2608: PPUSH
2609: CALL_OW 48
// ComHold ( RSoldier ) ;
2613: LD_EXP 21
2617: PPUSH
2618: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2622: LD_EXP 1
2626: PPUSH
2627: LD_EXP 21
2631: PPUSH
2632: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2636: LD_EXP 21
2640: PPUSH
2641: LD_EXP 1
2645: PPUSH
2646: CALL_OW 119
// D_Platonov ;
2650: CALL 5301 0 0
// IngameOff ;
2654: CALL_OW 9
// SaveForQuickRestart ;
2658: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2662: LD_STRING MRun
2664: PPUSH
2665: CALL_OW 337
// ComMoveXY ( Burlak , 39 , 67 ) ;
2669: LD_EXP 1
2673: PPUSH
2674: LD_INT 39
2676: PPUSH
2677: LD_INT 67
2679: PPUSH
2680: CALL_OW 111
// ChangeSideFog ( you , you ) ;
2684: LD_EXP 23
2688: PPUSH
2689: LD_EXP 23
2693: PPUSH
2694: CALL_OW 343
// SetSide ( Burlak , you ) ;
2698: LD_EXP 1
2702: PPUSH
2703: LD_EXP 23
2707: PPUSH
2708: CALL_OW 235
// SetSide ( Masha , you ) ;
2712: LD_EXP 43
2716: PPUSH
2717: LD_EXP 23
2721: PPUSH
2722: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2726: LD_INT 1
2728: PPUSH
2729: LD_INT 2
2731: PPUSH
2732: CALL_OW 12
2736: PUSH
2737: LD_INT 1
2739: DOUBLE
2740: EQUAL
2741: IFTRUE 2745
2743: GO 2803
2745: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2746: LD_ADDR_LOC 2
2750: PUSH
2751: DOUBLE
2752: LD_EXP 31
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: DEC
2761: ST_TO_ADDR
2762: LD_EXP 31
2766: PUSH
2767: LD_EXP 30
2771: PLUS
2772: PUSH
2773: FOR_TO
2774: IFFALSE 2799
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2776: LD_EXP 29
2780: PUSH
2781: LD_LOC 2
2785: ARRAY
2786: PPUSH
2787: LD_INT 4
2789: PPUSH
2790: LD_INT 0
2792: PPUSH
2793: CALL_OW 49
2797: GO 2773
2799: POP
2800: POP
// end ; 2 :
2801: GO 2870
2803: LD_INT 2
2805: DOUBLE
2806: EQUAL
2807: IFTRUE 2811
2809: GO 2869
2811: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2812: LD_ADDR_LOC 2
2816: PUSH
2817: DOUBLE
2818: LD_EXP 31
2822: PUSH
2823: LD_INT 1
2825: PLUS
2826: DEC
2827: ST_TO_ADDR
2828: LD_EXP 31
2832: PUSH
2833: LD_EXP 30
2837: PLUS
2838: PUSH
2839: FOR_TO
2840: IFFALSE 2865
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2842: LD_EXP 29
2846: PUSH
2847: LD_LOC 2
2851: ARRAY
2852: PPUSH
2853: LD_INT 5
2855: PPUSH
2856: LD_INT 0
2858: PPUSH
2859: CALL_OW 49
2863: GO 2839
2865: POP
2866: POP
// end ; end ;
2867: GO 2870
2869: POP
// case Rand ( 1 , 2 ) of 1 :
2870: LD_INT 1
2872: PPUSH
2873: LD_INT 2
2875: PPUSH
2876: CALL_OW 12
2880: PUSH
2881: LD_INT 1
2883: DOUBLE
2884: EQUAL
2885: IFTRUE 2889
2887: GO 2957
2889: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2890: LD_ADDR_LOC 2
2894: PUSH
2895: DOUBLE
2896: LD_EXP 31
2900: PUSH
2901: LD_INT 1
2903: PLUS
2904: PUSH
2905: LD_EXP 30
2909: PLUS
2910: DEC
2911: ST_TO_ADDR
2912: LD_EXP 31
2916: PUSH
2917: LD_INT 2
2919: PUSH
2920: LD_EXP 30
2924: MUL
2925: PLUS
2926: PUSH
2927: FOR_TO
2928: IFFALSE 2953
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2930: LD_EXP 29
2934: PUSH
2935: LD_LOC 2
2939: ARRAY
2940: PPUSH
2941: LD_INT 8
2943: PPUSH
2944: LD_INT 0
2946: PPUSH
2947: CALL_OW 49
2951: GO 2927
2953: POP
2954: POP
// end ; 2 :
2955: GO 3034
2957: LD_INT 2
2959: DOUBLE
2960: EQUAL
2961: IFTRUE 2965
2963: GO 3033
2965: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2966: LD_ADDR_LOC 2
2970: PUSH
2971: DOUBLE
2972: LD_EXP 31
2976: PUSH
2977: LD_INT 1
2979: PLUS
2980: PUSH
2981: LD_EXP 30
2985: PLUS
2986: DEC
2987: ST_TO_ADDR
2988: LD_EXP 31
2992: PUSH
2993: LD_INT 2
2995: PUSH
2996: LD_EXP 30
3000: MUL
3001: PLUS
3002: PUSH
3003: FOR_TO
3004: IFFALSE 3029
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
3006: LD_EXP 29
3010: PUSH
3011: LD_LOC 2
3015: ARRAY
3016: PPUSH
3017: LD_INT 7
3019: PPUSH
3020: LD_INT 0
3022: PPUSH
3023: CALL_OW 49
3027: GO 3003
3029: POP
3030: POP
// end ; end ;
3031: GO 3034
3033: POP
// case Rand ( 1 , 2 ) of 1 :
3034: LD_INT 1
3036: PPUSH
3037: LD_INT 2
3039: PPUSH
3040: CALL_OW 12
3044: PUSH
3045: LD_INT 1
3047: DOUBLE
3048: EQUAL
3049: IFTRUE 3053
3051: GO 3125
3053: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3054: LD_ADDR_LOC 2
3058: PUSH
3059: DOUBLE
3060: LD_EXP 31
3064: PUSH
3065: LD_INT 1
3067: PLUS
3068: PUSH
3069: LD_INT 2
3071: PUSH
3072: LD_EXP 30
3076: MUL
3077: PLUS
3078: DEC
3079: ST_TO_ADDR
3080: LD_EXP 31
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_EXP 30
3092: MUL
3093: PLUS
3094: PUSH
3095: FOR_TO
3096: IFFALSE 3121
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3098: LD_EXP 29
3102: PUSH
3103: LD_LOC 2
3107: ARRAY
3108: PPUSH
3109: LD_INT 6
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 49
3119: GO 3095
3121: POP
3122: POP
// end ; 2 :
3123: GO 3206
3125: LD_INT 2
3127: DOUBLE
3128: EQUAL
3129: IFTRUE 3133
3131: GO 3205
3133: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3134: LD_ADDR_LOC 2
3138: PUSH
3139: DOUBLE
3140: LD_EXP 31
3144: PUSH
3145: LD_INT 1
3147: PLUS
3148: PUSH
3149: LD_INT 2
3151: PUSH
3152: LD_EXP 30
3156: MUL
3157: PLUS
3158: DEC
3159: ST_TO_ADDR
3160: LD_EXP 31
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_EXP 30
3172: MUL
3173: PLUS
3174: PUSH
3175: FOR_TO
3176: IFFALSE 3201
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3178: LD_EXP 29
3182: PUSH
3183: LD_LOC 2
3187: ARRAY
3188: PPUSH
3189: LD_INT 16
3191: PPUSH
3192: LD_INT 0
3194: PPUSH
3195: CALL_OW 49
3199: GO 3175
3201: POP
3202: POP
// end ; end ;
3203: GO 3206
3205: POP
// Wait ( 1 1$20 ) ;
3206: LD_INT 2800
3208: PPUSH
3209: CALL_OW 67
// for i := 1 to pursuers_base do
3213: LD_ADDR_LOC 2
3217: PUSH
3218: DOUBLE
3219: LD_INT 1
3221: DEC
3222: ST_TO_ADDR
3223: LD_EXP 31
3227: PUSH
3228: FOR_TO
3229: IFFALSE 3298
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3231: LD_EXP 29
3235: PUSH
3236: LD_LOC 2
3240: ARRAY
3241: PPUSH
3242: LD_INT 9
3244: PPUSH
3245: LD_INT 0
3247: PPUSH
3248: CALL_OW 49
3252: NOT
3253: IFFALSE 3276
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3255: LD_EXP 29
3259: PUSH
3260: LD_LOC 2
3264: ARRAY
3265: PPUSH
3266: LD_INT 3
3268: PPUSH
3269: LD_INT 0
3271: PPUSH
3272: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3276: LD_EXP 29
3280: PUSH
3281: LD_LOC 2
3285: ARRAY
3286: PPUSH
3287: LD_EXP 1
3291: PPUSH
3292: CALL_OW 115
// end ;
3296: GO 3228
3298: POP
3299: POP
// Wait ( straz_start ) ;
3300: LD_EXP 35
3304: PPUSH
3305: CALL_OW 67
// enable ( 1 ) ;
3309: LD_INT 1
3311: ENABLE_MARKED
// enable ( 2 ) ;
3312: LD_INT 2
3314: ENABLE_MARKED
// end ;
3315: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3316: LD_INT 0
3318: PPUSH
3319: PPUSH
3320: PPUSH
3321: PPUSH
3322: PPUSH
3323: PPUSH
3324: PPUSH
3325: PPUSH
3326: PPUSH
3327: PPUSH
3328: PPUSH
3329: PPUSH
3330: PPUSH
3331: PPUSH
3332: PPUSH
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
3341: PPUSH
// gained_medals := [ ] ;
3342: LD_ADDR_OWVAR 61
3346: PUSH
3347: EMPTY
3348: ST_TO_ADDR
// missing_medals := [ ] ;
3349: LD_ADDR_OWVAR 62
3353: PUSH
3354: EMPTY
3355: ST_TO_ADDR
// reward_units := [ ] ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: EMPTY
3362: ST_TO_ADDR
// if scientists_dead = 0 then
3363: LD_EXP 49
3367: PUSH
3368: LD_INT 0
3370: EQUAL
3371: IFFALSE 3385
// AddMedal ( Science , 1 ) else
3373: LD_STRING Science
3375: PPUSH
3376: LD_INT 1
3378: PPUSH
3379: CALL_OW 101
3383: GO 3396
// AddMedal ( Science , - 1 ) ;
3385: LD_STRING Science
3387: PPUSH
3388: LD_INT 1
3390: NEG
3391: PPUSH
3392: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3396: LD_ADDR_VAR 0 4
3400: PUSH
3401: LD_INT 22
3403: PUSH
3404: LD_EXP 23
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 30
3418: PUSH
3419: LD_INT 0
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 30
3428: PUSH
3429: LD_INT 1
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: ST_TO_ADDR
// matros := 0 ;
3450: LD_ADDR_VAR 0 2
3454: PUSH
3455: LD_INT 0
3457: ST_TO_ADDR
// if 0 + filter <> 0 then
3458: LD_INT 0
3460: PUSH
3461: LD_VAR 0 4
3465: PLUS
3466: PUSH
3467: LD_INT 0
3469: NONEQUAL
3470: IFFALSE 3518
// for un in filter do
3472: LD_ADDR_VAR 0 3
3476: PUSH
3477: LD_VAR 0 4
3481: PUSH
3482: FOR_IN
3483: IFFALSE 3516
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3485: LD_ADDR_VAR 0 2
3489: PUSH
3490: LD_VAR 0 2
3494: PUSH
3495: LD_VAR 0 3
3499: PPUSH
3500: CALL_OW 274
3504: PPUSH
3505: LD_INT 1
3507: PPUSH
3508: CALL_OW 275
3512: PLUS
3513: ST_TO_ADDR
3514: GO 3482
3516: POP
3517: POP
// if matros > 100 then
3518: LD_VAR 0 2
3522: PUSH
3523: LD_INT 100
3525: GREATER
3526: IFFALSE 3540
// AddMedal ( Effectivity , 1 ) else
3528: LD_STRING Effectivity
3530: PPUSH
3531: LD_INT 1
3533: PPUSH
3534: CALL_OW 101
3538: GO 3551
// AddMedal ( Effectivity , - 1 ) ;
3540: LD_STRING Effectivity
3542: PPUSH
3543: LD_INT 1
3545: NEG
3546: PPUSH
3547: CALL_OW 101
// rus_building_destroyed := false ;
3551: LD_ADDR_VAR 0 7
3555: PUSH
3556: LD_INT 0
3558: ST_TO_ADDR
// for un in rus_mcrep_bui do
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: LD_EXP 64
3568: PUSH
3569: FOR_IN
3570: IFFALSE 3600
// if not IsLive ( un ) then
3572: LD_VAR 0 3
3576: PPUSH
3577: CALL_OW 300
3581: NOT
3582: IFFALSE 3598
// rus_building_destroyed := rus_building_destroyed + 1 ;
3584: LD_ADDR_VAR 0 7
3588: PUSH
3589: LD_VAR 0 7
3593: PUSH
3594: LD_INT 1
3596: PLUS
3597: ST_TO_ADDR
3598: GO 3569
3600: POP
3601: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3602: LD_EXP 53
3606: PUSH
3607: LD_INT 5
3609: GREATEREQUAL
3610: PUSH
3611: LD_VAR 0 7
3615: PUSH
3616: LD_INT 2
3618: GREATEREQUAL
3619: OR
3620: IFFALSE 3635
// AddMedal ( LittleLosses , - 1 ) else
3622: LD_STRING LittleLosses
3624: PPUSH
3625: LD_INT 1
3627: NEG
3628: PPUSH
3629: CALL_OW 101
3633: GO 3645
// AddMedal ( LittleLosses , 1 ) ;
3635: LD_STRING LittleLosses
3637: PPUSH
3638: LD_INT 1
3640: PPUSH
3641: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , not ( killed_russians >= 5 or rus_building_destroyed >= 2 ) ) ;
3645: LD_INT 4
3647: PPUSH
3648: LD_INT 5
3650: PPUSH
3651: LD_EXP 49
3655: PUSH
3656: LD_INT 0
3658: EQUAL
3659: PPUSH
3660: LD_VAR 0 2
3664: PUSH
3665: LD_INT 100
3667: GREATER
3668: PPUSH
3669: LD_EXP 53
3673: PUSH
3674: LD_INT 5
3676: GREATEREQUAL
3677: PUSH
3678: LD_VAR 0 7
3682: PUSH
3683: LD_INT 2
3685: GREATEREQUAL
3686: OR
3687: NOT
3688: PPUSH
3689: CALL 14335 0 5
// GiveMedals ( Main ) ;
3693: LD_STRING Main
3695: PPUSH
3696: CALL_OW 102
// for un in player_units do
3700: LD_ADDR_VAR 0 3
3704: PUSH
3705: LD_EXP 41
3709: PUSH
3710: FOR_IN
3711: IFFALSE 3743
// if not IsDead ( un ) then
3713: LD_VAR 0 3
3717: PPUSH
3718: CALL_OW 301
3722: NOT
3723: IFFALSE 3741
// reward_units := reward_units ^ un ;
3725: LD_ADDR_VAR 0 5
3729: PUSH
3730: LD_VAR 0 5
3734: PUSH
3735: LD_VAR 0 3
3739: ADD
3740: ST_TO_ADDR
3741: GO 3710
3743: POP
3744: POP
// RewardPeople ( reward_units ) ;
3745: LD_VAR 0 5
3749: PPUSH
3750: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3754: LD_EXP 40
3758: PUSH
3759: LD_EXP 39
3763: PUSH
3764: LD_EXP 8
3768: ADD
3769: DIFF
3770: PPUSH
3771: LD_STRING scientists
3773: PPUSH
3774: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3778: LD_ADDR_VAR 0 6
3782: PUSH
3783: LD_EXP 41
3787: PUSH
3788: LD_EXP 39
3792: PUSH
3793: LD_EXP 40
3797: ADD
3798: PUSH
3799: LD_EXP 1
3803: ADD
3804: PUSH
3805: LD_EXP 8
3809: ADD
3810: DIFF
3811: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3812: LD_VAR 0 6
3816: PPUSH
3817: LD_STRING survivors5
3819: PPUSH
3820: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3824: LD_EXP 1
3828: PPUSH
3829: LD_STRING Burlak
3831: PPUSH
3832: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3836: LD_EXP 2
3840: PPUSH
3841: LD_STRING Belkov
3843: PPUSH
3844: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3848: LD_EXP 3
3852: PPUSH
3853: LD_STRING Gnyevko
3855: PPUSH
3856: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3860: LD_EXP 4
3864: PPUSH
3865: LD_STRING Kirilenkova
3867: PPUSH
3868: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3872: LD_EXP 5
3876: PPUSH
3877: LD_STRING Gleb
3879: PPUSH
3880: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3884: LD_EXP 6
3888: PPUSH
3889: LD_STRING Petrosyan
3891: PPUSH
3892: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3896: LD_EXP 7
3900: PPUSH
3901: LD_STRING Titov
3903: PPUSH
3904: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3908: LD_EXP 8
3912: PPUSH
3913: LD_STRING Gossudarov
3915: PPUSH
3916: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3920: LD_EXP 9
3924: PPUSH
3925: LD_STRING Kovalyuk
3927: PPUSH
3928: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3932: LD_EXP 10
3936: PPUSH
3937: LD_STRING Scholtze
3939: PPUSH
3940: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3944: LD_EXP 11
3948: PPUSH
3949: LD_STRING Kuzmov
3951: PPUSH
3952: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3956: LD_EXP 12
3960: PPUSH
3961: LD_STRING Karamazov
3963: PPUSH
3964: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3968: LD_EXP 13
3972: PPUSH
3973: LD_STRING Petrovova
3975: PPUSH
3976: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3980: LD_EXP 14
3984: PPUSH
3985: LD_STRING Lipshchin
3987: PPUSH
3988: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3992: LD_EXP 15
3996: PPUSH
3997: LD_STRING Dolgov
3999: PPUSH
4000: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4004: LD_EXP 16
4008: PPUSH
4009: LD_STRING Xavier
4011: PPUSH
4012: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4016: LD_EXP 17
4020: PPUSH
4021: LD_STRING Oblukov
4023: PPUSH
4024: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4028: LD_EXP 18
4032: PPUSH
4033: LD_STRING Kozlov
4035: PPUSH
4036: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4040: LD_EXP 19
4044: PPUSH
4045: LD_STRING Kapitsova
4047: PPUSH
4048: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
4052: LD_EXP 42
4056: PUSH
4057: LD_EXP 52
4061: AND
4062: PUSH
4063: LD_LOC 1
4067: NOT
4068: OR
4069: IFFALSE 4078
// DeleteVariable ( Masha ) ;
4071: LD_STRING Masha
4073: PPUSH
4074: CALL_OW 41
// if Belkov in scientists then
4078: LD_EXP 2
4082: PUSH
4083: LD_EXP 40
4087: IN
4088: IFFALSE 4100
// belkov_side := 2 else
4090: LD_ADDR_VAR 0 8
4094: PUSH
4095: LD_INT 2
4097: ST_TO_ADDR
4098: GO 4130
// if Belkov in player_units then
4100: LD_EXP 2
4104: PUSH
4105: LD_EXP 41
4109: IN
4110: IFFALSE 4122
// belkov_side := 1 else
4112: LD_ADDR_VAR 0 8
4116: PUSH
4117: LD_INT 1
4119: ST_TO_ADDR
4120: GO 4130
// belkov_side := 0 ;
4122: LD_ADDR_VAR 0 8
4126: PUSH
4127: LD_INT 0
4129: ST_TO_ADDR
// if Gnyevko in scientists then
4130: LD_EXP 3
4134: PUSH
4135: LD_EXP 40
4139: IN
4140: IFFALSE 4152
// gnyevko_side := 2 else
4142: LD_ADDR_VAR 0 9
4146: PUSH
4147: LD_INT 2
4149: ST_TO_ADDR
4150: GO 4182
// if Gnyevko in player_units then
4152: LD_EXP 3
4156: PUSH
4157: LD_EXP 41
4161: IN
4162: IFFALSE 4174
// gnyevko_side := 1 else
4164: LD_ADDR_VAR 0 9
4168: PUSH
4169: LD_INT 1
4171: ST_TO_ADDR
4172: GO 4182
// gnyevko_side := 0 ;
4174: LD_ADDR_VAR 0 9
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// if Kirilenkova in scientists then
4182: LD_EXP 4
4186: PUSH
4187: LD_EXP 40
4191: IN
4192: IFFALSE 4204
// kiril_side := 2 else
4194: LD_ADDR_VAR 0 10
4198: PUSH
4199: LD_INT 2
4201: ST_TO_ADDR
4202: GO 4234
// if Kirilenkova in player_units then
4204: LD_EXP 4
4208: PUSH
4209: LD_EXP 41
4213: IN
4214: IFFALSE 4226
// kiril_side := 1 else
4216: LD_ADDR_VAR 0 10
4220: PUSH
4221: LD_INT 1
4223: ST_TO_ADDR
4224: GO 4234
// kiril_side := 0 ;
4226: LD_ADDR_VAR 0 10
4230: PUSH
4231: LD_INT 0
4233: ST_TO_ADDR
// if Gleb in scientists then
4234: LD_EXP 5
4238: PUSH
4239: LD_EXP 40
4243: IN
4244: IFFALSE 4256
// gleb_side := 2 else
4246: LD_ADDR_VAR 0 16
4250: PUSH
4251: LD_INT 2
4253: ST_TO_ADDR
4254: GO 4286
// if Gleb in player_units then
4256: LD_EXP 5
4260: PUSH
4261: LD_EXP 41
4265: IN
4266: IFFALSE 4278
// gleb_side := 1 else
4268: LD_ADDR_VAR 0 16
4272: PUSH
4273: LD_INT 1
4275: ST_TO_ADDR
4276: GO 4286
// gleb_side := 0 ;
4278: LD_ADDR_VAR 0 16
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// if Petrosyan in scientists then
4286: LD_EXP 6
4290: PUSH
4291: LD_EXP 40
4295: IN
4296: IFFALSE 4308
// petros_side := 2 else
4298: LD_ADDR_VAR 0 15
4302: PUSH
4303: LD_INT 2
4305: ST_TO_ADDR
4306: GO 4338
// if Petrosyan in player_units then
4308: LD_EXP 6
4312: PUSH
4313: LD_EXP 41
4317: IN
4318: IFFALSE 4330
// petros_side := 1 else
4320: LD_ADDR_VAR 0 15
4324: PUSH
4325: LD_INT 1
4327: ST_TO_ADDR
4328: GO 4338
// petros_side := 0 ;
4330: LD_ADDR_VAR 0 15
4334: PUSH
4335: LD_INT 0
4337: ST_TO_ADDR
// if Titov in scientists then
4338: LD_EXP 7
4342: PUSH
4343: LD_EXP 40
4347: IN
4348: IFFALSE 4360
// titov_side := 2 else
4350: LD_ADDR_VAR 0 19
4354: PUSH
4355: LD_INT 2
4357: ST_TO_ADDR
4358: GO 4390
// if Titov in player_units then
4360: LD_EXP 7
4364: PUSH
4365: LD_EXP 41
4369: IN
4370: IFFALSE 4382
// titov_side := 1 else
4372: LD_ADDR_VAR 0 19
4376: PUSH
4377: LD_INT 1
4379: ST_TO_ADDR
4380: GO 4390
// titov_side := 0 ;
4382: LD_ADDR_VAR 0 19
4386: PUSH
4387: LD_INT 0
4389: ST_TO_ADDR
// if Kovalyuk in scientists then
4390: LD_EXP 9
4394: PUSH
4395: LD_EXP 40
4399: IN
4400: IFFALSE 4412
// kovalyuk_side := 2 else
4402: LD_ADDR_VAR 0 11
4406: PUSH
4407: LD_INT 2
4409: ST_TO_ADDR
4410: GO 4442
// if Kovalyuk in player_units then
4412: LD_EXP 9
4416: PUSH
4417: LD_EXP 41
4421: IN
4422: IFFALSE 4434
// kovalyuk_side := 1 else
4424: LD_ADDR_VAR 0 11
4428: PUSH
4429: LD_INT 1
4431: ST_TO_ADDR
4432: GO 4442
// kovalyuk_side := 0 ;
4434: LD_ADDR_VAR 0 11
4438: PUSH
4439: LD_INT 0
4441: ST_TO_ADDR
// if Scholtze in scientists then
4442: LD_EXP 10
4446: PUSH
4447: LD_EXP 40
4451: IN
4452: IFFALSE 4464
// scholtze_side := 2 else
4454: LD_ADDR_VAR 0 12
4458: PUSH
4459: LD_INT 2
4461: ST_TO_ADDR
4462: GO 4494
// if Scholtze in player_units then
4464: LD_EXP 10
4468: PUSH
4469: LD_EXP 41
4473: IN
4474: IFFALSE 4486
// scholtze_side := 1 else
4476: LD_ADDR_VAR 0 12
4480: PUSH
4481: LD_INT 1
4483: ST_TO_ADDR
4484: GO 4494
// scholtze_side := 0 ;
4486: LD_ADDR_VAR 0 12
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// if Kuzmov in scientists then
4494: LD_EXP 11
4498: PUSH
4499: LD_EXP 40
4503: IN
4504: IFFALSE 4516
// kuzmov_side := 2 else
4506: LD_ADDR_VAR 0 13
4510: PUSH
4511: LD_INT 2
4513: ST_TO_ADDR
4514: GO 4546
// if Kuzmov in player_units then
4516: LD_EXP 11
4520: PUSH
4521: LD_EXP 41
4525: IN
4526: IFFALSE 4538
// kuzmov_side := 1 else
4528: LD_ADDR_VAR 0 13
4532: PUSH
4533: LD_INT 1
4535: ST_TO_ADDR
4536: GO 4546
// kuzmov_side := 0 ;
4538: LD_ADDR_VAR 0 13
4542: PUSH
4543: LD_INT 0
4545: ST_TO_ADDR
// if Karamazov in scientists then
4546: LD_EXP 12
4550: PUSH
4551: LD_EXP 40
4555: IN
4556: IFFALSE 4568
// karam_side := 2 else
4558: LD_ADDR_VAR 0 14
4562: PUSH
4563: LD_INT 2
4565: ST_TO_ADDR
4566: GO 4598
// if Karamazov in player_units then
4568: LD_EXP 12
4572: PUSH
4573: LD_EXP 41
4577: IN
4578: IFFALSE 4590
// karam_side := 1 else
4580: LD_ADDR_VAR 0 14
4584: PUSH
4585: LD_INT 1
4587: ST_TO_ADDR
4588: GO 4598
// karam_side := 0 ;
4590: LD_ADDR_VAR 0 14
4594: PUSH
4595: LD_INT 0
4597: ST_TO_ADDR
// if Petrovova in scientists then
4598: LD_EXP 13
4602: PUSH
4603: LD_EXP 40
4607: IN
4608: IFFALSE 4620
// petrov_side := 2 else
4610: LD_ADDR_VAR 0 17
4614: PUSH
4615: LD_INT 2
4617: ST_TO_ADDR
4618: GO 4650
// if Petrovova in player_units then
4620: LD_EXP 13
4624: PUSH
4625: LD_EXP 41
4629: IN
4630: IFFALSE 4642
// petrov_side := 1 else
4632: LD_ADDR_VAR 0 17
4636: PUSH
4637: LD_INT 1
4639: ST_TO_ADDR
4640: GO 4650
// petrov_side := 0 ;
4642: LD_ADDR_VAR 0 17
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// if Lipshchin in scientists then
4650: LD_EXP 14
4654: PUSH
4655: LD_EXP 40
4659: IN
4660: IFFALSE 4672
// lipshchin_side := 2 else
4662: LD_ADDR_VAR 0 18
4666: PUSH
4667: LD_INT 2
4669: ST_TO_ADDR
4670: GO 4702
// if Lipshchin in player_units then
4672: LD_EXP 14
4676: PUSH
4677: LD_EXP 41
4681: IN
4682: IFFALSE 4694
// lipshchin_side := 1 else
4684: LD_ADDR_VAR 0 18
4688: PUSH
4689: LD_INT 1
4691: ST_TO_ADDR
4692: GO 4702
// lipshchin_side := 0 ;
4694: LD_ADDR_VAR 0 18
4698: PUSH
4699: LD_INT 0
4701: ST_TO_ADDR
// if Dolgov in scientists then
4702: LD_EXP 15
4706: PUSH
4707: LD_EXP 40
4711: IN
4712: IFFALSE 4724
// dolgov_side := 2 else
4714: LD_ADDR_VAR 0 20
4718: PUSH
4719: LD_INT 2
4721: ST_TO_ADDR
4722: GO 4754
// if Dolgov in player_units then
4724: LD_EXP 15
4728: PUSH
4729: LD_EXP 41
4733: IN
4734: IFFALSE 4746
// dolgov_side := 1 else
4736: LD_ADDR_VAR 0 20
4740: PUSH
4741: LD_INT 1
4743: ST_TO_ADDR
4744: GO 4754
// dolgov_side := 0 ;
4746: LD_ADDR_VAR 0 20
4750: PUSH
4751: LD_INT 0
4753: ST_TO_ADDR
// if Xavier in scientists then
4754: LD_EXP 16
4758: PUSH
4759: LD_EXP 40
4763: IN
4764: IFFALSE 4776
// xavier_side := 2 else
4766: LD_ADDR_VAR 0 21
4770: PUSH
4771: LD_INT 2
4773: ST_TO_ADDR
4774: GO 4806
// if Xavier in player_units then
4776: LD_EXP 16
4780: PUSH
4781: LD_EXP 41
4785: IN
4786: IFFALSE 4798
// xavier_side := 1 else
4788: LD_ADDR_VAR 0 21
4792: PUSH
4793: LD_INT 1
4795: ST_TO_ADDR
4796: GO 4806
// xavier_side := 0 ;
4798: LD_ADDR_VAR 0 21
4802: PUSH
4803: LD_INT 0
4805: ST_TO_ADDR
// if Oblukov in scientists then
4806: LD_EXP 17
4810: PUSH
4811: LD_EXP 40
4815: IN
4816: IFFALSE 4828
// oblukov_side := 2 else
4818: LD_ADDR_VAR 0 22
4822: PUSH
4823: LD_INT 2
4825: ST_TO_ADDR
4826: GO 4858
// if Oblukov in player_units then
4828: LD_EXP 17
4832: PUSH
4833: LD_EXP 41
4837: IN
4838: IFFALSE 4850
// oblukov_side := 1 else
4840: LD_ADDR_VAR 0 22
4844: PUSH
4845: LD_INT 1
4847: ST_TO_ADDR
4848: GO 4858
// oblukov_side := 0 ;
4850: LD_ADDR_VAR 0 22
4854: PUSH
4855: LD_INT 0
4857: ST_TO_ADDR
// if Kozlov in scientists then
4858: LD_EXP 18
4862: PUSH
4863: LD_EXP 40
4867: IN
4868: IFFALSE 4880
// kozlov_side := 2 else
4870: LD_ADDR_VAR 0 23
4874: PUSH
4875: LD_INT 2
4877: ST_TO_ADDR
4878: GO 4910
// if Kozlov in player_units then
4880: LD_EXP 18
4884: PUSH
4885: LD_EXP 41
4889: IN
4890: IFFALSE 4902
// kozlov_side := 1 else
4892: LD_ADDR_VAR 0 23
4896: PUSH
4897: LD_INT 1
4899: ST_TO_ADDR
4900: GO 4910
// kozlov_side := 0 ;
4902: LD_ADDR_VAR 0 23
4906: PUSH
4907: LD_INT 0
4909: ST_TO_ADDR
// if Kapitsova in scientists then
4910: LD_EXP 19
4914: PUSH
4915: LD_EXP 40
4919: IN
4920: IFFALSE 4932
// kapitsova_side := 2 else
4922: LD_ADDR_VAR 0 24
4926: PUSH
4927: LD_INT 2
4929: ST_TO_ADDR
4930: GO 4962
// if Kapitsova in player_units then
4932: LD_EXP 19
4936: PUSH
4937: LD_EXP 41
4941: IN
4942: IFFALSE 4954
// kapitsova_side := 1 else
4944: LD_ADDR_VAR 0 24
4948: PUSH
4949: LD_INT 1
4951: ST_TO_ADDR
4952: GO 4962
// kapitsova_side := 0 ;
4954: LD_ADDR_VAR 0 24
4958: PUSH
4959: LD_INT 0
4961: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4962: LD_VAR 0 8
4966: PPUSH
4967: LD_STRING belkov_side
4969: PPUSH
4970: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4974: LD_VAR 0 9
4978: PPUSH
4979: LD_STRING gnyevko_side
4981: PPUSH
4982: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4986: LD_VAR 0 10
4990: PPUSH
4991: LD_STRING kiril_side
4993: PPUSH
4994: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4998: LD_VAR 0 16
5002: PPUSH
5003: LD_STRING gleb_side
5005: PPUSH
5006: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
5010: LD_VAR 0 15
5014: PPUSH
5015: LD_STRING petros_side
5017: PPUSH
5018: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
5022: LD_VAR 0 19
5026: PPUSH
5027: LD_STRING titov_side
5029: PPUSH
5030: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
5034: LD_VAR 0 11
5038: PPUSH
5039: LD_STRING kovalyuk_side
5041: PPUSH
5042: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
5046: LD_VAR 0 12
5050: PPUSH
5051: LD_STRING scholtze_side
5053: PPUSH
5054: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5058: LD_VAR 0 13
5062: PPUSH
5063: LD_STRING kuzmov_side
5065: PPUSH
5066: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5070: LD_VAR 0 14
5074: PPUSH
5075: LD_STRING karam_side
5077: PPUSH
5078: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5082: LD_VAR 0 17
5086: PPUSH
5087: LD_STRING petrov_side
5089: PPUSH
5090: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5094: LD_VAR 0 18
5098: PPUSH
5099: LD_STRING lipshchin_side
5101: PPUSH
5102: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5106: LD_VAR 0 20
5110: PPUSH
5111: LD_STRING dolgov_side
5113: PPUSH
5114: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5118: LD_VAR 0 21
5122: PPUSH
5123: LD_STRING xavier_side
5125: PPUSH
5126: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5130: LD_VAR 0 22
5134: PPUSH
5135: LD_STRING oblukov_side
5137: PPUSH
5138: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5142: LD_VAR 0 23
5146: PPUSH
5147: LD_STRING kozlov_side
5149: PPUSH
5150: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5154: LD_VAR 0 24
5158: PPUSH
5159: LD_STRING kapitsova_side
5161: PPUSH
5162: CALL_OW 39
// YouWin ;
5166: CALL_OW 103
// exit ;
5170: GO 5172
// end ; end_of_file
5172: LD_VAR 0 1
5176: RET
// export function D_Start ; begin
5177: LD_INT 0
5179: PPUSH
// DisableExclamations ;
5180: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5184: LD_EXP 8
5188: PPUSH
5189: LD_STRING DStart-Gos-1
5191: PPUSH
5192: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5196: LD_EXP 1
5200: PPUSH
5201: LD_STRING DStart-Bur-1
5203: PPUSH
5204: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5208: LD_EXP 8
5212: PPUSH
5213: LD_STRING DStart-Gos-2
5215: PPUSH
5216: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5220: LD_EXP 1
5224: PPUSH
5225: LD_STRING DStart-Bur-2
5227: PPUSH
5228: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5232: LD_EXP 8
5236: PPUSH
5237: LD_STRING DStart-Gos-3
5239: PPUSH
5240: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5244: LD_EXP 1
5248: PPUSH
5249: LD_STRING DStart-Bur-3
5251: PPUSH
5252: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5256: LD_EXP 8
5260: PPUSH
5261: LD_STRING DStart-Gos-4
5263: PPUSH
5264: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5268: LD_EXP 1
5272: PPUSH
5273: LD_STRING DStart-Bur-4
5275: PPUSH
5276: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5280: LD_EXP 8
5284: PPUSH
5285: LD_STRING DStart-Gos-5
5287: PPUSH
5288: CALL_OW 88
// EnableExclamations ;
5292: CALL_OW 473
// end ;
5296: LD_VAR 0 1
5300: RET
// export function D_Platonov ; begin
5301: LD_INT 0
5303: PPUSH
// DisableExclamations ;
5304: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5308: LD_EXP 21
5312: PPUSH
5313: LD_STRING DPlatonov-Rsol1-1
5315: PPUSH
5316: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5320: LD_EXP 1
5324: PPUSH
5325: LD_STRING DPlatonov-Bur-1
5327: PPUSH
5328: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5332: LD_EXP 21
5336: PPUSH
5337: LD_STRING DPlatonov-Rsol1-2
5339: PPUSH
5340: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5344: LD_EXP 1
5348: PPUSH
5349: LD_STRING DPlatonov-Bur-2
5351: PPUSH
5352: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5356: LD_EXP 1
5360: PPUSH
5361: LD_EXP 43
5365: PPUSH
5366: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5370: LD_EXP 21
5374: PPUSH
5375: LD_STRING DPlatonov-Rsol1-3
5377: PPUSH
5378: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5382: LD_INT 7
5384: PPUSH
5385: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5389: LD_EXP 43
5393: PPUSH
5394: CALL_OW 311
5398: PUSH
5399: LD_EXP 1
5403: EQUAL
5404: IFFALSE 5382
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5406: LD_EXP 1
5410: PPUSH
5411: LD_STRING DPlatonov-Bur-3
5413: PPUSH
5414: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5418: LD_EXP 1
5422: PPUSH
5423: LD_EXP 21
5427: PPUSH
5428: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5432: LD_INT 7
5434: PPUSH
5435: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5439: LD_EXP 43
5443: PPUSH
5444: CALL_OW 320
5448: PUSH
5449: LD_EXP 21
5453: EQUAL
5454: IFFALSE 5432
// Wait ( 0 0$0.5 ) ;
5456: LD_INT 18
5458: PPUSH
5459: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5463: LD_EXP 21
5467: PPUSH
5468: LD_STRING DPlatonov-Rsol1-4
5470: PPUSH
5471: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5475: LD_EXP 21
5479: PPUSH
5480: LD_EXP 43
5484: PPUSH
5485: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5489: LD_EXP 1
5493: PPUSH
5494: LD_EXP 21
5498: PPUSH
5499: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5503: LD_EXP 20
5507: PPUSH
5508: LD_STRING DPlatonov-Pla-4
5510: PPUSH
5511: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5515: LD_EXP 20
5519: PPUSH
5520: LD_STRING DPlatonov-Pla-4a
5522: PPUSH
5523: CALL_OW 88
// EnableExclamations ;
5527: CALL_OW 473
// end ;
5531: LD_VAR 0 1
5535: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5536: LD_INT 0
5538: PPUSH
5539: PPUSH
5540: PPUSH
5541: PPUSH
// DisableExclamations ;
5542: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5546: LD_EXP 2
5550: PPUSH
5551: CALL_OW 302
5555: PUSH
5556: LD_EXP 2
5560: PPUSH
5561: CALL_OW 255
5565: PUSH
5566: LD_EXP 23
5570: EQUAL
5571: AND
5572: IFFALSE 5586
// Say ( Belkov , DGosStart-Bel-1 ) ;
5574: LD_EXP 2
5578: PPUSH
5579: LD_STRING DGosStart-Bel-1
5581: PPUSH
5582: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5586: LD_EXP 3
5590: PPUSH
5591: CALL_OW 302
5595: PUSH
5596: LD_EXP 3
5600: PPUSH
5601: CALL_OW 255
5605: PUSH
5606: LD_EXP 23
5610: EQUAL
5611: AND
5612: IFFALSE 5626
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5614: LD_EXP 3
5618: PPUSH
5619: LD_STRING DGosStart-Gny-1
5621: PPUSH
5622: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5626: LD_EXP 5
5630: PPUSH
5631: CALL_OW 302
5635: PUSH
5636: LD_EXP 5
5640: PPUSH
5641: CALL_OW 255
5645: PUSH
5646: LD_EXP 23
5650: EQUAL
5651: AND
5652: IFFALSE 5666
// Say ( Gleb , DGosStart-Glb-1 ) ;
5654: LD_EXP 5
5658: PPUSH
5659: LD_STRING DGosStart-Glb-1
5661: PPUSH
5662: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5666: LD_EXP 6
5670: PPUSH
5671: CALL_OW 302
5675: PUSH
5676: LD_EXP 6
5680: PPUSH
5681: CALL_OW 255
5685: PUSH
5686: LD_EXP 23
5690: EQUAL
5691: AND
5692: IFFALSE 5706
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5694: LD_EXP 6
5698: PPUSH
5699: LD_STRING DGosStart-Pty-1
5701: PPUSH
5702: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5706: LD_EXP 7
5710: PPUSH
5711: CALL_OW 302
5715: PUSH
5716: LD_EXP 7
5720: PPUSH
5721: CALL_OW 255
5725: PUSH
5726: LD_EXP 23
5730: EQUAL
5731: AND
5732: IFFALSE 5746
// Say ( Titov , DGosStart-Tit-1 ) ;
5734: LD_EXP 7
5738: PPUSH
5739: LD_STRING DGosStart-Tit-1
5741: PPUSH
5742: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5746: LD_EXP 4
5750: PPUSH
5751: CALL_OW 302
5755: PUSH
5756: LD_EXP 4
5760: PPUSH
5761: CALL_OW 255
5765: PUSH
5766: LD_EXP 23
5770: EQUAL
5771: AND
5772: IFFALSE 5786
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5774: LD_EXP 4
5778: PPUSH
5779: LD_STRING DGosStart-Kir-1
5781: PPUSH
5782: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5786: LD_EXP 2
5790: PPUSH
5791: CALL_OW 302
5795: PUSH
5796: LD_EXP 2
5800: PPUSH
5801: CALL_OW 255
5805: PUSH
5806: LD_EXP 23
5810: EQUAL
5811: AND
5812: PUSH
5813: LD_EXP 3
5817: PPUSH
5818: CALL_OW 302
5822: PUSH
5823: LD_EXP 3
5827: PPUSH
5828: CALL_OW 255
5832: PUSH
5833: LD_EXP 23
5837: EQUAL
5838: AND
5839: OR
5840: PUSH
5841: LD_EXP 5
5845: PPUSH
5846: CALL_OW 302
5850: PUSH
5851: LD_EXP 5
5855: PPUSH
5856: CALL_OW 255
5860: PUSH
5861: LD_EXP 23
5865: EQUAL
5866: AND
5867: OR
5868: PUSH
5869: LD_EXP 6
5873: PPUSH
5874: CALL_OW 302
5878: PUSH
5879: LD_EXP 6
5883: PPUSH
5884: CALL_OW 255
5888: PUSH
5889: LD_EXP 23
5893: EQUAL
5894: AND
5895: OR
5896: PUSH
5897: LD_EXP 7
5901: PPUSH
5902: CALL_OW 302
5906: PUSH
5907: LD_EXP 7
5911: PPUSH
5912: CALL_OW 255
5916: PUSH
5917: LD_EXP 23
5921: EQUAL
5922: AND
5923: OR
5924: PUSH
5925: LD_EXP 4
5929: PPUSH
5930: CALL_OW 302
5934: PUSH
5935: LD_EXP 4
5939: PPUSH
5940: CALL_OW 255
5944: PUSH
5945: LD_EXP 23
5949: EQUAL
5950: AND
5951: OR
5952: NOT
5953: IFFALSE 6317
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5955: LD_ADDR_VAR 0 4
5959: PUSH
5960: LD_INT 22
5962: PUSH
5963: LD_EXP 23
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PUSH
5972: LD_INT 26
5974: PUSH
5975: LD_INT 1
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: PUSH
5982: LD_INT 50
5984: PUSH
5985: EMPTY
5986: LIST
5987: PUSH
5988: LD_INT 3
5990: PUSH
5991: LD_INT 23
5993: PUSH
5994: LD_INT 0
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: LIST
6010: PPUSH
6011: CALL_OW 69
6015: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6016: LD_ADDR_VAR 0 4
6020: PUSH
6021: LD_VAR 0 4
6025: PUSH
6026: LD_EXP 1
6030: DIFF
6031: ST_TO_ADDR
// if 0 + filter_all > 0 then
6032: LD_INT 0
6034: PUSH
6035: LD_VAR 0 4
6039: PLUS
6040: PUSH
6041: LD_INT 0
6043: GREATER
6044: IFFALSE 6145
// begin filter := [ ] ;
6046: LD_ADDR_VAR 0 3
6050: PUSH
6051: EMPTY
6052: ST_TO_ADDR
// for un in filter_all do
6053: LD_ADDR_VAR 0 2
6057: PUSH
6058: LD_VAR 0 4
6062: PUSH
6063: FOR_IN
6064: IFFALSE 6097
// if not ( un in all_possible ) then
6066: LD_VAR 0 2
6070: PUSH
6071: LD_EXP 39
6075: IN
6076: NOT
6077: IFFALSE 6095
// filter := filter union un ;
6079: LD_ADDR_VAR 0 3
6083: PUSH
6084: LD_VAR 0 3
6088: PUSH
6089: LD_VAR 0 2
6093: UNION
6094: ST_TO_ADDR
6095: GO 6063
6097: POP
6098: POP
// if filter > 0 then
6099: LD_VAR 0 3
6103: PUSH
6104: LD_INT 0
6106: GREATER
6107: IFFALSE 6127
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6109: LD_VAR 0 3
6113: PUSH
6114: LD_INT 1
6116: ARRAY
6117: PPUSH
6118: LD_STRING DGosStart-Sol1-1
6120: PPUSH
6121: CALL_OW 88
6125: GO 6143
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: ARRAY
6135: PPUSH
6136: LD_STRING DGosStart-Sol1-1
6138: PPUSH
6139: CALL_OW 88
// end else
6143: GO 6317
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6145: LD_ADDR_VAR 0 4
6149: PUSH
6150: LD_INT 22
6152: PUSH
6153: LD_EXP 23
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 26
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: LD_INT 50
6174: PUSH
6175: EMPTY
6176: LIST
6177: PUSH
6178: LD_INT 3
6180: PUSH
6181: LD_INT 23
6183: PUSH
6184: LD_INT 0
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 69
6205: ST_TO_ADDR
// if 0 + filter_all > 0 then
6206: LD_INT 0
6208: PUSH
6209: LD_VAR 0 4
6213: PLUS
6214: PUSH
6215: LD_INT 0
6217: GREATER
6218: IFFALSE 6317
// begin filter := [ ] ;
6220: LD_ADDR_VAR 0 3
6224: PUSH
6225: EMPTY
6226: ST_TO_ADDR
// for un in filter_all do
6227: LD_ADDR_VAR 0 2
6231: PUSH
6232: LD_VAR 0 4
6236: PUSH
6237: FOR_IN
6238: IFFALSE 6271
// if not ( un in all_possible ) then
6240: LD_VAR 0 2
6244: PUSH
6245: LD_EXP 39
6249: IN
6250: NOT
6251: IFFALSE 6269
// filter := filter union un ;
6253: LD_ADDR_VAR 0 3
6257: PUSH
6258: LD_VAR 0 3
6262: PUSH
6263: LD_VAR 0 2
6267: UNION
6268: ST_TO_ADDR
6269: GO 6237
6271: POP
6272: POP
// if filter > 0 then
6273: LD_VAR 0 3
6277: PUSH
6278: LD_INT 0
6280: GREATER
6281: IFFALSE 6301
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 1
6290: ARRAY
6291: PPUSH
6292: LD_STRING DGosStart-FSol1-1
6294: PPUSH
6295: CALL_OW 88
6299: GO 6317
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6301: LD_VAR 0 4
6305: PUSH
6306: LD_INT 1
6308: ARRAY
6309: PPUSH
6310: LD_STRING DGosStart-FSol1-1
6312: PPUSH
6313: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6317: LD_EXP 1
6321: PPUSH
6322: LD_STRING DGosStart-Bur-1
6324: PPUSH
6325: CALL_OW 88
// Wait ( 0 0$20 ) ;
6329: LD_INT 700
6331: PPUSH
6332: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6336: LD_EXP 1
6340: PPUSH
6341: LD_STRING DGosStart-Bur-1a
6343: PPUSH
6344: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6348: LD_EXP 8
6352: PPUSH
6353: LD_STRING DGosStart-Gos-1
6355: PPUSH
6356: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6360: LD_EXP 1
6364: PPUSH
6365: LD_STRING DGosStart-Bur-2
6367: PPUSH
6368: CALL_OW 88
// Hint ( Signal ) ;
6372: LD_STRING Signal
6374: PPUSH
6375: CALL_OW 339
// attackAvalaible = 1 ;
6379: LD_ADDR_EXP 61
6383: PUSH
6384: LD_INT 1
6386: ST_TO_ADDR
// enable ( 6 ) ;
6387: LD_INT 6
6389: ENABLE_MARKED
// EnableExclamations ;
6390: CALL_OW 473
// end ;
6394: LD_VAR 0 1
6398: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6399: LD_INT 0
6401: PPUSH
6402: PPUSH
6403: PPUSH
6404: PPUSH
// DisableExclamations ;
6405: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6409: LD_EXP 1
6413: PPUSH
6414: LD_STRING DSituation-Bur-1
6416: PPUSH
6417: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6421: LD_ADDR_VAR 0 4
6425: PUSH
6426: LD_INT 22
6428: PUSH
6429: LD_EXP 23
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PUSH
6438: LD_INT 26
6440: PUSH
6441: LD_INT 2
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 50
6450: PUSH
6451: EMPTY
6452: LIST
6453: PUSH
6454: LD_INT 3
6456: PUSH
6457: LD_INT 23
6459: PUSH
6460: LD_INT 0
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: PPUSH
6477: CALL_OW 69
6481: ST_TO_ADDR
// if 0 + filter_all > 0 then
6482: LD_INT 0
6484: PUSH
6485: LD_VAR 0 4
6489: PLUS
6490: PUSH
6491: LD_INT 0
6493: GREATER
6494: IFFALSE 6595
// begin filter := [ ] ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: EMPTY
6502: ST_TO_ADDR
// for un in filter_all do
6503: LD_ADDR_VAR 0 2
6507: PUSH
6508: LD_VAR 0 4
6512: PUSH
6513: FOR_IN
6514: IFFALSE 6547
// if not ( un in all_possible ) then
6516: LD_VAR 0 2
6520: PUSH
6521: LD_EXP 39
6525: IN
6526: NOT
6527: IFFALSE 6545
// filter := filter union un ;
6529: LD_ADDR_VAR 0 3
6533: PUSH
6534: LD_VAR 0 3
6538: PUSH
6539: LD_VAR 0 2
6543: UNION
6544: ST_TO_ADDR
6545: GO 6513
6547: POP
6548: POP
// if filter > 0 then
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 0
6556: GREATER
6557: IFFALSE 6577
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6559: LD_VAR 0 3
6563: PUSH
6564: LD_INT 1
6566: ARRAY
6567: PPUSH
6568: LD_STRING DSituation-RFSol1-1
6570: PPUSH
6571: CALL_OW 88
6575: GO 6593
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6577: LD_VAR 0 4
6581: PUSH
6582: LD_INT 1
6584: ARRAY
6585: PPUSH
6586: LD_STRING DSituation-RFSol1-1
6588: PPUSH
6589: CALL_OW 88
// end else
6593: GO 6783
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6595: LD_ADDR_VAR 0 4
6599: PUSH
6600: LD_INT 22
6602: PUSH
6603: LD_EXP 23
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 26
6614: PUSH
6615: LD_INT 1
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PUSH
6622: LD_INT 50
6624: PUSH
6625: EMPTY
6626: LIST
6627: PUSH
6628: LD_INT 3
6630: PUSH
6631: LD_INT 23
6633: PUSH
6634: LD_INT 0
6636: PUSH
6637: EMPTY
6638: LIST
6639: LIST
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PPUSH
6651: CALL_OW 69
6655: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6656: LD_ADDR_VAR 0 4
6660: PUSH
6661: LD_VAR 0 4
6665: PUSH
6666: LD_EXP 1
6670: DIFF
6671: ST_TO_ADDR
// if 0 + filter_all > 0 then
6672: LD_INT 0
6674: PUSH
6675: LD_VAR 0 4
6679: PLUS
6680: PUSH
6681: LD_INT 0
6683: GREATER
6684: IFFALSE 6783
// begin filter := [ ] ;
6686: LD_ADDR_VAR 0 3
6690: PUSH
6691: EMPTY
6692: ST_TO_ADDR
// for un in filter_all do
6693: LD_ADDR_VAR 0 2
6697: PUSH
6698: LD_VAR 0 4
6702: PUSH
6703: FOR_IN
6704: IFFALSE 6737
// if not ( un in all_possible ) then
6706: LD_VAR 0 2
6710: PUSH
6711: LD_EXP 39
6715: IN
6716: NOT
6717: IFFALSE 6735
// filter := filter union un ;
6719: LD_ADDR_VAR 0 3
6723: PUSH
6724: LD_VAR 0 3
6728: PUSH
6729: LD_VAR 0 2
6733: UNION
6734: ST_TO_ADDR
6735: GO 6703
6737: POP
6738: POP
// if filter > 0 then
6739: LD_VAR 0 3
6743: PUSH
6744: LD_INT 0
6746: GREATER
6747: IFFALSE 6767
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6749: LD_VAR 0 3
6753: PUSH
6754: LD_INT 1
6756: ARRAY
6757: PPUSH
6758: LD_STRING DSituation-RSol1-1
6760: PPUSH
6761: CALL_OW 88
6765: GO 6783
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 1
6774: ARRAY
6775: PPUSH
6776: LD_STRING DSituation-RSol1-1
6778: PPUSH
6779: CALL_OW 88
// end ; end ; EnableExclamations ;
6783: CALL_OW 473
// end ;
6787: LD_VAR 0 1
6791: RET
// export function D_GO1 ; begin
6792: LD_INT 0
6794: PPUSH
// DisableExclamations ;
6795: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6799: LD_EXP 1
6803: PPUSH
6804: LD_STRING DGO#1-Bur-1
6806: PPUSH
6807: CALL_OW 88
// EnableExclamations ;
6811: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6815: LD_INT 11
6817: PPUSH
6818: LD_INT 1
6820: PPUSH
6821: CALL_OW 424
// end ;
6825: LD_VAR 0 1
6829: RET
// export function D_SeeYou ; begin
6830: LD_INT 0
6832: PPUSH
// DisableExclamations ;
6833: CALL_OW 474
// DialogueOn ;
6837: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6841: LD_EXP 8
6845: PPUSH
6846: LD_STRING DSeeYou-Gos-1
6848: PPUSH
6849: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6853: LD_EXP 1
6857: PPUSH
6858: LD_STRING DSeeYou-Bur-1
6860: PPUSH
6861: CALL_OW 88
// DialogueOff ;
6865: CALL_OW 7
// EnableExclamations ;
6869: CALL_OW 473
// end ; end_of_file
6873: LD_VAR 0 1
6877: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6878: GO 6880
6880: DISABLE
6881: LD_INT 0
6883: PPUSH
6884: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6885: LD_EXP 1
6889: PPUSH
6890: LD_INT 1
6892: PPUSH
6893: CALL_OW 308
6897: IFFALSE 6963
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_INT 22
6906: PUSH
6907: LD_EXP 27
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for un in filter do
6921: LD_ADDR_VAR 0 2
6925: PUSH
6926: LD_VAR 0 1
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6950
// setside ( un , you ) ;
6934: LD_VAR 0 2
6938: PPUSH
6939: LD_EXP 23
6943: PPUSH
6944: CALL_OW 235
6948: GO 6931
6950: POP
6951: POP
// BurlakReachedBase := true ;
6952: LD_ADDR_EXP 28
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// disable ;
6960: DISABLE
// end else
6961: GO 6964
// enable ;
6963: ENABLE
// end ;
6964: PPOPN 2
6966: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6967: GO 6969
6969: DISABLE
6970: LD_INT 0
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6976: LD_EXP 1
6980: PPUSH
6981: LD_INT 10
6983: PPUSH
6984: CALL_OW 308
6988: IFFALSE 7219
// begin DisableExclamations ;
6990: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6994: LD_ADDR_VAR 0 1
6998: PUSH
6999: LD_INT 22
7001: PUSH
7002: LD_EXP 27
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PPUSH
7011: CALL_OW 69
7015: ST_TO_ADDR
// skill := 0 ;
7016: LD_ADDR_VAR 0 3
7020: PUSH
7021: LD_INT 0
7023: ST_TO_ADDR
// for un in filter do
7024: LD_ADDR_VAR 0 2
7028: PUSH
7029: LD_VAR 0 1
7033: PUSH
7034: FOR_IN
7035: IFFALSE 7069
// if GetSkill ( un , skill_engineering ) >= skill then
7037: LD_VAR 0 2
7041: PPUSH
7042: LD_INT 2
7044: PPUSH
7045: CALL_OW 259
7049: PUSH
7050: LD_VAR 0 3
7054: GREATEREQUAL
7055: IFFALSE 7067
// inzenyr := un ;
7057: LD_ADDR_VAR 0 4
7061: PUSH
7062: LD_VAR 0 2
7066: ST_TO_ADDR
7067: GO 7034
7069: POP
7070: POP
// ComStop ( inzenyr ) ;
7071: LD_VAR 0 4
7075: PPUSH
7076: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7080: LD_VAR 0 4
7084: PPUSH
7085: CALL_OW 257
7089: PUSH
7090: LD_INT 2
7092: NONEQUAL
7093: IFFALSE 7184
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7095: LD_ADDR_VAR 0 1
7099: PUSH
7100: LD_INT 30
7102: PUSH
7103: LD_INT 1
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: PUSH
7110: LD_INT 22
7112: PUSH
7113: LD_EXP 27
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: PPUSH
7126: CALL_OW 69
7130: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7131: LD_VAR 0 4
7135: PPUSH
7136: LD_VAR 0 1
7140: PUSH
7141: LD_INT 1
7143: ARRAY
7144: PPUSH
7145: CALL_OW 120
// Wait ( 10 ) ;
7149: LD_INT 10
7151: PPUSH
7152: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 183
// Wait ( 10 ) ;
7168: LD_INT 10
7170: PPUSH
7171: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7175: LD_VAR 0 4
7179: PPUSH
7180: CALL_OW 182
// end ; Wait ( 10 ) ;
7184: LD_INT 10
7186: PPUSH
7187: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7191: LD_VAR 0 4
7195: PPUSH
7196: LD_INT 26
7198: PPUSH
7199: LD_INT 126
7201: PPUSH
7202: LD_INT 17
7204: PPUSH
7205: LD_INT 5
7207: PPUSH
7208: CALL_OW 205
// EnableExclamations ;
7212: CALL_OW 473
// disable ;
7216: DISABLE
// end else
7217: GO 7220
// enable ;
7219: ENABLE
// end ;
7220: PPOPN 4
7222: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7223: GO 7225
7225: DISABLE
7226: LD_INT 0
7228: PPUSH
7229: PPUSH
// begin if straz < bazooker then
7230: LD_EXP 45
7234: PUSH
7235: LD_EXP 51
7239: LESS
7240: IFFALSE 7388
// begin bazooker := bazooker + 1 ;
7242: LD_ADDR_EXP 51
7246: PUSH
7247: LD_EXP 51
7251: PUSH
7252: LD_INT 1
7254: PLUS
7255: ST_TO_ADDR
// while straz < bazooker do
7256: LD_EXP 45
7260: PUSH
7261: LD_EXP 51
7265: LESS
7266: IFFALSE 7388
// begin uc_side := rus ;
7268: LD_ADDR_OWVAR 20
7272: PUSH
7273: LD_EXP 24
7277: ST_TO_ADDR
// uc_nation := nation_russian ;
7278: LD_ADDR_OWVAR 21
7282: PUSH
7283: LD_INT 3
7285: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 4 + difficulty ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_INT 9
7291: PPUSH
7292: LD_INT 4
7294: PUSH
7295: LD_OWVAR 67
7299: PLUS
7300: PPUSH
7301: CALL_OW 380
// hc_name :=  ;
7305: LD_ADDR_OWVAR 26
7309: PUSH
7310: LD_STRING 
7312: ST_TO_ADDR
// bazukr := CreateHuman ;
7313: LD_ADDR_VAR 0 2
7317: PUSH
7318: CALL_OW 44
7322: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7323: LD_EXP 62
7327: PPUSH
7328: LD_VAR 0 2
7332: PPUSH
7333: LD_INT 1
7335: PPUSH
7336: CALL_OW 394
// straz := straz ^ bazukr ;
7340: LD_ADDR_EXP 45
7344: PUSH
7345: LD_EXP 45
7349: PUSH
7350: LD_VAR 0 2
7354: ADD
7355: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7356: LD_VAR 0 2
7360: PPUSH
7361: LD_INT 9
7363: PPUSH
7364: LD_INT 0
7366: PPUSH
7367: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7371: LD_VAR 0 2
7375: PPUSH
7376: LD_INT 66
7378: PPUSH
7379: LD_INT 48
7381: PPUSH
7382: CALL_OW 114
// end ;
7386: GO 7256
// end ; end ;
7388: PPOPN 2
7390: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7391: GO 7393
7393: DISABLE
7394: LD_INT 0
7396: PPUSH
// begin if ( 0 + straz ) <> 0 then
7397: LD_INT 0
7399: PUSH
7400: LD_EXP 45
7404: PLUS
7405: PUSH
7406: LD_INT 0
7408: NONEQUAL
7409: IFFALSE 7652
// begin for un in straz do
7411: LD_ADDR_VAR 0 1
7415: PUSH
7416: LD_EXP 45
7420: PUSH
7421: FOR_IN
7422: IFFALSE 7650
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7424: LD_VAR 0 1
7428: PPUSH
7429: CALL_OW 314
7433: NOT
7434: PUSH
7435: LD_VAR 0 1
7439: PPUSH
7440: CALL_OW 256
7444: PUSH
7445: LD_INT 601
7447: GREATER
7448: AND
7449: IFFALSE 7648
// begin if GetY ( un ) > 60 then
7451: LD_VAR 0 1
7455: PPUSH
7456: CALL_OW 251
7460: PUSH
7461: LD_INT 60
7463: GREATER
7464: IFFALSE 7558
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7466: LD_VAR 0 1
7470: PPUSH
7471: LD_INT 66
7473: PPUSH
7474: LD_INT 48
7476: PPUSH
7477: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7481: LD_VAR 0 1
7485: PPUSH
7486: LD_INT 63
7488: PPUSH
7489: LD_INT 74
7491: PPUSH
7492: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7496: LD_VAR 0 1
7500: PPUSH
7501: LD_INT 73
7503: PPUSH
7504: LD_INT 90
7506: PPUSH
7507: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7511: LD_VAR 0 1
7515: PPUSH
7516: LD_INT 76
7518: PPUSH
7519: LD_INT 95
7521: PPUSH
7522: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7526: LD_VAR 0 1
7530: PPUSH
7531: LD_INT 72
7533: PPUSH
7534: LD_INT 95
7536: PPUSH
7537: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7541: LD_VAR 0 1
7545: PPUSH
7546: LD_INT 50
7548: PPUSH
7549: LD_INT 73
7551: PPUSH
7552: CALL_OW 174
// end else
7556: GO 7648
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: LD_INT 73
7565: PPUSH
7566: LD_INT 90
7568: PPUSH
7569: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 76
7580: PPUSH
7581: LD_INT 95
7583: PPUSH
7584: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7588: LD_VAR 0 1
7592: PPUSH
7593: LD_INT 72
7595: PPUSH
7596: LD_INT 95
7598: PPUSH
7599: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_INT 50
7610: PPUSH
7611: LD_INT 73
7613: PPUSH
7614: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7618: LD_VAR 0 1
7622: PPUSH
7623: LD_INT 63
7625: PPUSH
7626: LD_INT 74
7628: PPUSH
7629: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7633: LD_VAR 0 1
7637: PPUSH
7638: LD_INT 66
7640: PPUSH
7641: LD_INT 48
7643: PPUSH
7644: CALL_OW 174
// end ; end ; end ;
7648: GO 7421
7650: POP
7651: POP
// end ; enable ;
7652: ENABLE
// end ;
7653: PPOPN 1
7655: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7656: GO 7658
7658: DISABLE
7659: LD_INT 0
7661: PPUSH
7662: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7663: LD_EXP 1
7667: PPUSH
7668: LD_INT 2
7670: PPUSH
7671: CALL_OW 308
7675: IFFALSE 7719
// begin disabled5 := true ;
7677: LD_ADDR_LOC 4
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// D_GosStart ;
7685: CALL 5536 0 0
// Wait ( 0 0$5 ) ;
7689: LD_INT 175
7691: PPUSH
7692: CALL_OW 67
// D_Situation ;
7696: CALL 6399 0 0
// ChangeMissionObjectives ( MHold ) ;
7700: LD_STRING MHold
7702: PPUSH
7703: CALL_OW 337
// disable ;
7707: DISABLE
// enable ( 333 ) ;
7708: LD_INT 333
7710: ENABLE_MARKED
// enable ( 334 ) ;
7711: LD_INT 334
7713: ENABLE_MARKED
// enable ( 337 ) ;
7714: LD_INT 337
7716: ENABLE_MARKED
// end else
7717: GO 7720
// enable ;
7719: ENABLE
// end ;
7720: PPOPN 2
7722: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7723: GO 7725
7725: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7726: LD_EXP 8
7730: PPUSH
7731: CALL_OW 306
7735: PUSH
7736: LD_INT 1
7738: EQUAL
7739: IFFALSE 7765
// begin if WasSelected = false then
7741: LD_EXP 46
7745: PUSH
7746: LD_INT 0
7748: EQUAL
7749: IFFALSE 7763
// begin QueryQGO ;
7751: CALL 7782 0 0
// WasSelected := true ;
7755: LD_ADDR_EXP 46
7759: PUSH
7760: LD_INT 1
7762: ST_TO_ADDR
// end ; end else
7763: GO 7773
// WasSelected := false ;
7765: LD_ADDR_EXP 46
7769: PUSH
7770: LD_INT 0
7772: ST_TO_ADDR
// if not disabled3 then
7773: LD_LOC 3
7777: NOT
7778: IFFALSE 7781
// enable ;
7780: ENABLE
// end ;
7781: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un , t ; begin
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
7787: PPUSH
7788: PPUSH
7789: PPUSH
7790: PPUSH
// res := Query ( QGO ) ;
7791: LD_ADDR_VAR 0 2
7795: PUSH
7796: LD_STRING QGO
7798: PPUSH
7799: CALL_OW 97
7803: ST_TO_ADDR
// if res = 1 then
7804: LD_VAR 0 2
7808: PUSH
7809: LD_INT 1
7811: EQUAL
7812: IFFALSE 8261
// begin disabled3 := true ;
7814: LD_ADDR_LOC 3
7818: PUSH
7819: LD_INT 1
7821: ST_TO_ADDR
// D_GO1 ;
7822: CALL 6792 0 0
// ChangeMissionObjectives ( MGuide ) ;
7826: LD_STRING MGuide
7828: PPUSH
7829: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 3
7840: PPUSH
7841: LD_INT 21
7843: PUSH
7844: LD_INT 2
7846: PUSH
7847: EMPTY
7848: LIST
7849: LIST
7850: PUSH
7851: LD_INT 34
7853: PUSH
7854: LD_INT 51
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PUSH
7861: EMPTY
7862: LIST
7863: LIST
7864: PPUSH
7865: CALL_OW 70
7869: ST_TO_ADDR
// if filter = 0 then
7870: LD_VAR 0 3
7874: PUSH
7875: LD_INT 0
7877: EQUAL
7878: IFFALSE 8029
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7880: LD_EXP 8
7884: PPUSH
7885: LD_INT 57
7887: PPUSH
7888: LD_INT 98
7890: PPUSH
7891: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7902: LD_EXP 8
7906: PPUSH
7907: CALL_OW 314
7911: NOT
7912: IFFALSE 7895
// RemoveUnit ( Gossudarov ) ;
7914: LD_EXP 8
7918: PPUSH
7919: CALL_OW 64
// uc_side := ally ;
7923: LD_ADDR_OWVAR 20
7927: PUSH
7928: LD_EXP 25
7932: ST_TO_ADDR
// uc_nation := nation_russian ;
7933: LD_ADDR_OWVAR 21
7937: PUSH
7938: LD_INT 3
7940: ST_TO_ADDR
// uc_direction := 5 ;
7941: LD_ADDR_OWVAR 24
7945: PUSH
7946: LD_INT 5
7948: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7949: LD_ADDR_OWVAR 37
7953: PUSH
7954: LD_INT 21
7956: ST_TO_ADDR
// vc_engine := engine_combustion ;
7957: LD_ADDR_OWVAR 39
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// vc_control := control_manual ;
7965: LD_ADDR_OWVAR 38
7969: PUSH
7970: LD_INT 1
7972: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7973: LD_ADDR_OWVAR 40
7977: PUSH
7978: LD_INT 51
7980: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7981: LD_ADDR_VAR 0 4
7985: PUSH
7986: CALL_OW 45
7990: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7991: LD_EXP 8
7995: PPUSH
7996: LD_VAR 0 4
8000: PPUSH
8001: CALL_OW 52
// Wait ( 0 0$5 ) ;
8005: LD_INT 175
8007: PPUSH
8008: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
8012: LD_VAR 0 4
8016: PPUSH
8017: LD_INT 9
8019: PPUSH
8020: LD_INT 0
8022: PPUSH
8023: CALL_OW 49
// end else
8027: GO 8047
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
8029: LD_EXP 8
8033: PPUSH
8034: LD_VAR 0 3
8038: PUSH
8039: LD_INT 1
8041: ARRAY
8042: PPUSH
8043: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8047: LD_EXP 8
8051: PPUSH
8052: LD_INT 4
8054: PPUSH
8055: CALL_OW 469
8059: PUSH
8060: LD_INT 1
8062: ARRAY
8063: PPUSH
8064: LD_INT 4
8066: PPUSH
8067: CALL_OW 469
8071: PUSH
8072: LD_INT 2
8074: ARRAY
8075: PPUSH
8076: CALL_OW 220
// Wait ( 0 0$5 ) ;
8080: LD_INT 175
8082: PPUSH
8083: CALL_OW 67
// t := 0 0$50 ;
8087: LD_ADDR_VAR 0 7
8091: PUSH
8092: LD_INT 1750
8094: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8095: LD_INT 35
8097: PPUSH
8098: CALL_OW 67
// t := t - 0 0$1 ;
8102: LD_ADDR_VAR 0 7
8106: PUSH
8107: LD_VAR 0 7
8111: PUSH
8112: LD_INT 35
8114: MINUS
8115: ST_TO_ADDR
// AddComMoveXY ( Gossudarov , 27 , 47 ) ;
8116: LD_EXP 8
8120: PPUSH
8121: LD_INT 27
8123: PPUSH
8124: LD_INT 47
8126: PPUSH
8127: CALL_OW 171
// until not FilterUnitsInArea ( BluekherArea , [ [ f_side , 6 ] , [ f_weapon , ru_cargo_bay ] ] ) or not t ;
8131: LD_INT 22
8133: PPUSH
8134: LD_INT 22
8136: PUSH
8137: LD_INT 6
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: LD_INT 34
8146: PUSH
8147: LD_INT 51
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PPUSH
8158: CALL_OW 70
8162: NOT
8163: PUSH
8164: LD_VAR 0 7
8168: NOT
8169: OR
8170: IFFALSE 8095
// ComExitBuilding ( scientists ) ;
8172: LD_EXP 40
8176: PPUSH
8177: CALL_OW 122
// AddComMoveXY ( scientists , 27 , 47 ) ;
8181: LD_EXP 40
8185: PPUSH
8186: LD_INT 27
8188: PPUSH
8189: LD_INT 47
8191: PPUSH
8192: CALL_OW 171
// for un in scientists do
8196: LD_ADDR_VAR 0 6
8200: PUSH
8201: LD_EXP 40
8205: PUSH
8206: FOR_IN
8207: IFFALSE 8225
// AddComSailEvent ( un , un ) ;
8209: LD_VAR 0 6
8213: PPUSH
8214: LD_VAR 0 6
8218: PPUSH
8219: CALL_OW 224
8223: GO 8206
8225: POP
8226: POP
// player_units := player_units union scientists union Gossudarov ;
8227: LD_ADDR_EXP 41
8231: PUSH
8232: LD_EXP 41
8236: PUSH
8237: LD_EXP 40
8241: UNION
8242: PUSH
8243: LD_EXP 8
8247: UNION
8248: ST_TO_ADDR
// enable ( 4 ) ;
8249: LD_INT 4
8251: ENABLE_MARKED
// enable ( 7 ) ;
8252: LD_INT 7
8254: ENABLE_MARKED
// enable ( 8 ) ;
8255: LD_INT 8
8257: ENABLE_MARKED
// enable ( 9 ) ;
8258: LD_INT 9
8260: ENABLE_MARKED
// end ; end ;
8261: LD_VAR 0 1
8265: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8266: GO 8268
8268: DISABLE
8269: LD_INT 0
8271: PPUSH
// begin for un in scientists do
8272: LD_ADDR_VAR 0 1
8276: PUSH
8277: LD_EXP 40
8281: PUSH
8282: FOR_IN
8283: IFFALSE 8353
// begin if IsInArea ( un , ExitArea ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: LD_INT 11
8292: PPUSH
8293: CALL_OW 308
8297: IFFALSE 8324
// begin scientists_saved := scientists_saved union un ;
8299: LD_ADDR_EXP 48
8303: PUSH
8304: LD_EXP 48
8308: PUSH
8309: LD_VAR 0 1
8313: UNION
8314: ST_TO_ADDR
// RemoveUnit ( un ) ;
8315: LD_VAR 0 1
8319: PPUSH
8320: CALL_OW 64
// end ; if IsDead ( un ) then
8324: LD_VAR 0 1
8328: PPUSH
8329: CALL_OW 301
8333: IFFALSE 8351
// scientists_dead := scientists_dead union un ;
8335: LD_ADDR_EXP 49
8339: PUSH
8340: LD_EXP 49
8344: PUSH
8345: LD_VAR 0 1
8349: UNION
8350: ST_TO_ADDR
// end ;
8351: GO 8282
8353: POP
8354: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8355: LD_EXP 8
8359: PPUSH
8360: LD_INT 11
8362: PPUSH
8363: CALL_OW 308
8367: PUSH
8368: LD_EXP 8
8372: PPUSH
8373: CALL_OW 310
8377: PPUSH
8378: LD_INT 11
8380: PPUSH
8381: CALL_OW 308
8385: OR
8386: PUSH
8387: LD_EXP 48
8391: PUSH
8392: LD_EXP 49
8396: PLUS
8397: PUSH
8398: LD_EXP 40
8402: EQUAL
8403: AND
8404: PUSH
8405: LD_EXP 50
8409: PPUSH
8410: CALL_OW 255
8414: PUSH
8415: LD_EXP 23
8419: EQUAL
8420: AND
8421: PUSH
8422: LD_EXP 50
8426: PPUSH
8427: LD_INT 11
8429: PPUSH
8430: CALL_OW 308
8434: AND
8435: PUSH
8436: LD_EXP 50
8440: PPUSH
8441: LD_INT 4
8443: PPUSH
8444: CALL_OW 289
8448: PUSH
8449: LD_INT 40
8451: EQUAL
8452: AND
8453: IFFALSE 8465
// begin D_SeeYou ;
8455: CALL 6830 0 0
// TheEnd ;
8459: CALL 3316 0 0
// end else
8463: GO 8466
// enable ;
8465: ENABLE
// end ;
8466: PPOPN 1
8468: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8469: GO 8471
8471: DISABLE
8472: LD_INT 0
8474: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8475: LD_EXP 1
8479: PPUSH
8480: LD_INT 18
8482: PPUSH
8483: CALL_OW 308
8487: PUSH
8488: LD_EXP 43
8492: PPUSH
8493: LD_INT 18
8495: PPUSH
8496: CALL_OW 308
8500: OR
8501: IFFALSE 8518
// begin Wait ( 0 0$3 ) ;
8503: LD_INT 105
8505: PPUSH
8506: CALL_OW 67
// Attack1 := true ;
8510: LD_ADDR_LOC 5
8514: PUSH
8515: LD_INT 1
8517: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8518: LD_EXP 1
8522: PPUSH
8523: LD_INT 19
8525: PPUSH
8526: CALL_OW 308
8530: PUSH
8531: LD_EXP 43
8535: PPUSH
8536: LD_INT 19
8538: PPUSH
8539: CALL_OW 308
8543: OR
8544: IFFALSE 8561
// begin Wait ( 0 0$3 ) ;
8546: LD_INT 105
8548: PPUSH
8549: CALL_OW 67
// Attack2 := true ;
8553: LD_ADDR_LOC 6
8557: PUSH
8558: LD_INT 1
8560: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8561: LD_EXP 1
8565: PPUSH
8566: LD_INT 20
8568: PPUSH
8569: CALL_OW 308
8573: PUSH
8574: LD_EXP 43
8578: PPUSH
8579: LD_INT 20
8581: PPUSH
8582: CALL_OW 308
8586: OR
8587: IFFALSE 8604
// begin Wait ( 0 0$3 ) ;
8589: LD_INT 105
8591: PPUSH
8592: CALL_OW 67
// Attack3 := true ;
8596: LD_ADDR_LOC 7
8600: PUSH
8601: LD_INT 1
8603: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8604: LD_LOC 5
8608: PUSH
8609: LD_LOC 6
8613: NOT
8614: AND
8615: PUSH
8616: LD_LOC 7
8620: NOT
8621: AND
8622: IFFALSE 8685
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8624: LD_ADDR_VAR 0 1
8628: PUSH
8629: DOUBLE
8630: LD_EXP 31
8634: PUSH
8635: LD_INT 1
8637: PLUS
8638: DEC
8639: ST_TO_ADDR
8640: LD_EXP 31
8644: PUSH
8645: LD_EXP 30
8649: PLUS
8650: PUSH
8651: FOR_TO
8652: IFFALSE 8683
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8654: LD_EXP 29
8658: PUSH
8659: LD_VAR 0 1
8663: ARRAY
8664: PPUSH
8665: LD_EXP 1
8669: PPUSH
8670: CALL_OW 115
// Wait ( 2 ) ;
8674: LD_INT 2
8676: PPUSH
8677: CALL_OW 67
// end ;
8681: GO 8651
8683: POP
8684: POP
// if Attack1 and Attack2 and not Attack3 then
8685: LD_LOC 5
8689: PUSH
8690: LD_LOC 6
8694: AND
8695: PUSH
8696: LD_LOC 7
8700: NOT
8701: AND
8702: IFFALSE 8769
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8704: LD_ADDR_VAR 0 1
8708: PUSH
8709: DOUBLE
8710: LD_EXP 31
8714: PUSH
8715: LD_INT 1
8717: PLUS
8718: DEC
8719: ST_TO_ADDR
8720: LD_EXP 31
8724: PUSH
8725: LD_INT 2
8727: PUSH
8728: LD_EXP 30
8732: MUL
8733: PLUS
8734: PUSH
8735: FOR_TO
8736: IFFALSE 8767
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8738: LD_EXP 29
8742: PUSH
8743: LD_VAR 0 1
8747: ARRAY
8748: PPUSH
8749: LD_EXP 1
8753: PPUSH
8754: CALL_OW 115
// Wait ( 2 ) ;
8758: LD_INT 2
8760: PPUSH
8761: CALL_OW 67
// end ;
8765: GO 8735
8767: POP
8768: POP
// if Attack1 and Attack2 and Attack3 then
8769: LD_LOC 5
8773: PUSH
8774: LD_LOC 6
8778: AND
8779: PUSH
8780: LD_LOC 7
8784: AND
8785: IFFALSE 8852
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8787: LD_ADDR_VAR 0 1
8791: PUSH
8792: DOUBLE
8793: LD_EXP 31
8797: PUSH
8798: LD_INT 1
8800: PLUS
8801: DEC
8802: ST_TO_ADDR
8803: LD_EXP 31
8807: PUSH
8808: LD_INT 3
8810: PUSH
8811: LD_EXP 30
8815: MUL
8816: PLUS
8817: PUSH
8818: FOR_TO
8819: IFFALSE 8850
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8821: LD_EXP 29
8825: PUSH
8826: LD_VAR 0 1
8830: ARRAY
8831: PPUSH
8832: LD_EXP 1
8836: PPUSH
8837: CALL_OW 115
// Wait ( 2 ) ;
8841: LD_INT 2
8843: PPUSH
8844: CALL_OW 67
// end ;
8848: GO 8818
8850: POP
8851: POP
// for i := 1 to pursuers_base do
8852: LD_ADDR_VAR 0 1
8856: PUSH
8857: DOUBLE
8858: LD_INT 1
8860: DEC
8861: ST_TO_ADDR
8862: LD_EXP 31
8866: PUSH
8867: FOR_TO
8868: IFFALSE 8899
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8870: LD_EXP 29
8874: PUSH
8875: LD_VAR 0 1
8879: ARRAY
8880: PPUSH
8881: LD_EXP 1
8885: PPUSH
8886: CALL_OW 115
// Wait ( 2 ) ;
8890: LD_INT 2
8892: PPUSH
8893: CALL_OW 67
// end ;
8897: GO 8867
8899: POP
8900: POP
// if not disabled5 then
8901: LD_LOC 4
8905: NOT
8906: IFFALSE 8909
// enable ;
8908: ENABLE
// end ;
8909: PPOPN 1
8911: END
// every 0 0$1 marked 6 do
8912: GO 8914
8914: DISABLE
// begin if Goss_time > 0 then
8915: LD_EXP 47
8919: PUSH
8920: LD_INT 0
8922: GREATER
8923: IFFALSE 8959
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8925: LD_ADDR_OWVAR 47
8929: PUSH
8930: LD_STRING #Ru12a-1
8932: PUSH
8933: LD_EXP 47
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8942: LD_ADDR_EXP 47
8946: PUSH
8947: LD_EXP 47
8951: PUSH
8952: LD_INT 35
8954: MINUS
8955: ST_TO_ADDR
// enable ;
8956: ENABLE
// end else
8957: GO 8970
// begin display_strings :=  ;
8959: LD_ADDR_OWVAR 47
8963: PUSH
8964: LD_STRING 
8966: ST_TO_ADDR
// enable ( 3 ) ;
8967: LD_INT 3
8969: ENABLE_MARKED
// end ; end ;
8970: END
// every 0 0$1 marked 7 do
8971: GO 8973
8973: DISABLE
// begin if FindArtifact ( 4 ) then
8974: LD_INT 4
8976: PPUSH
8977: CALL_OW 469
8981: IFFALSE 9035
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8983: LD_LOC 8
8987: PPUSH
8988: LD_INT 4
8990: PPUSH
8991: CALL_OW 469
8995: PUSH
8996: LD_INT 1
8998: ARRAY
8999: PPUSH
9000: LD_INT 4
9002: PPUSH
9003: CALL_OW 469
9007: PUSH
9008: LD_INT 2
9010: ARRAY
9011: PPUSH
9012: CALL_OW 160
// Wait ( 3 ) ;
9016: LD_INT 3
9018: PPUSH
9019: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
9023: LD_LOC 8
9027: PPUSH
9028: LD_INT 9
9030: PPUSH
9031: CALL_OW 173
// end ; enable ;
9035: ENABLE
// end ;
9036: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
9037: GO 9039
9039: DISABLE
9040: LD_INT 0
9042: PPUSH
9043: PPUSH
9044: PPUSH
9045: PPUSH
// begin Wait ( pausa ) ;
9046: LD_EXP 37
9050: PPUSH
9051: CALL_OW 67
// sc_utok := [ ] ;
9055: LD_ADDR_VAR 0 3
9059: PUSH
9060: EMPTY
9061: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
9062: LD_ADDR_VAR 0 1
9066: PUSH
9067: DOUBLE
9068: LD_INT 1
9070: DEC
9071: ST_TO_ADDR
9072: LD_INT 2
9074: PUSH
9075: LD_OWVAR 67
9079: PLUS
9080: PUSH
9081: FOR_TO
9082: IFFALSE 9286
// begin uc_side := rus ;
9084: LD_ADDR_OWVAR 20
9088: PUSH
9089: LD_EXP 24
9093: ST_TO_ADDR
// uc_nation := nation_russian ;
9094: LD_ADDR_OWVAR 21
9098: PUSH
9099: LD_INT 3
9101: ST_TO_ADDR
// uc_direction := 5 ;
9102: LD_ADDR_OWVAR 24
9106: PUSH
9107: LD_INT 5
9109: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
9110: LD_INT 1
9112: PPUSH
9113: LD_INT 3
9115: PPUSH
9116: CALL_OW 12
9120: PUSH
9121: LD_INT 1
9123: DOUBLE
9124: EQUAL
9125: IFTRUE 9129
9127: GO 9153
9129: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9130: LD_INT 1
9132: PPUSH
9133: LD_INT 1
9135: PPUSH
9136: LD_INT 4
9138: PPUSH
9139: LD_INT 8
9141: PPUSH
9142: CALL_OW 12
9146: PPUSH
9147: CALL_OW 380
9151: GO 9192
9153: LD_INT 2
9155: DOUBLE
9156: GREATEREQUAL
9157: IFFALSE 9165
9159: LD_INT 3
9161: DOUBLE
9162: LESSEQUAL
9163: IFTRUE 9167
9165: GO 9191
9167: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9168: LD_INT 1
9170: PPUSH
9171: LD_INT 9
9173: PPUSH
9174: LD_INT 3
9176: PPUSH
9177: LD_INT 7
9179: PPUSH
9180: CALL_OW 12
9184: PPUSH
9185: CALL_OW 380
9189: GO 9192
9191: POP
// hc_name :=  ;
9192: LD_ADDR_OWVAR 26
9196: PUSH
9197: LD_STRING 
9199: ST_TO_ADDR
// clovek := CreateHuman ;
9200: LD_ADDR_VAR 0 2
9204: PUSH
9205: CALL_OW 44
9209: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9210: LD_VAR 0 2
9214: PPUSH
9215: LD_INT 9
9217: PPUSH
9218: LD_INT 0
9220: PPUSH
9221: CALL_OW 49
// Wait ( 0 0$2 ) ;
9225: LD_INT 70
9227: PPUSH
9228: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9232: LD_VAR 0 2
9236: PPUSH
9237: LD_INT 50
9239: PPUSH
9240: LD_INT 84
9242: PPUSH
9243: CALL_OW 111
// Wait ( 2 ) ;
9247: LD_INT 2
9249: PPUSH
9250: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9254: LD_VAR 0 2
9258: PPUSH
9259: LD_EXP 50
9263: PPUSH
9264: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9268: LD_ADDR_VAR 0 3
9272: PUSH
9273: LD_VAR 0 3
9277: PUSH
9278: LD_VAR 0 2
9282: ADD
9283: ST_TO_ADDR
// end ;
9284: GO 9081
9286: POP
9287: POP
// Wait ( 0 0$10 ) ;
9288: LD_INT 350
9290: PPUSH
9291: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9295: LD_LOC 8
9299: PPUSH
9300: CALL_OW 302
9304: NOT
9305: IFFALSE 9412
// begin uc_side := rus ;
9307: LD_ADDR_OWVAR 20
9311: PUSH
9312: LD_EXP 24
9316: ST_TO_ADDR
// uc_nation := nation_russian ;
9317: LD_ADDR_OWVAR 21
9321: PUSH
9322: LD_INT 3
9324: ST_TO_ADDR
// uc_direction := 5 ;
9325: LD_ADDR_OWVAR 24
9329: PUSH
9330: LD_INT 5
9332: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9333: LD_ADDR_OWVAR 37
9337: PUSH
9338: LD_INT 22
9340: ST_TO_ADDR
// vc_control := control_computer ;
9341: LD_ADDR_OWVAR 38
9345: PUSH
9346: LD_INT 3
9348: ST_TO_ADDR
// vc_engine := engine_siberite ;
9349: LD_ADDR_OWVAR 39
9353: PUSH
9354: LD_INT 3
9356: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9357: LD_ADDR_OWVAR 40
9361: PUSH
9362: LD_INT 51
9364: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9365: LD_ADDR_LOC 8
9369: PUSH
9370: CALL_OW 45
9374: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9375: LD_LOC 8
9379: PPUSH
9380: LD_INT 9
9382: PPUSH
9383: LD_INT 0
9385: PPUSH
9386: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9390: LD_INT 18
9392: PPUSH
9393: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9397: LD_LOC 8
9401: PPUSH
9402: LD_INT 55
9404: PPUSH
9405: LD_INT 84
9407: PPUSH
9408: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9412: LD_VAR 0 3
9416: PUSH
9417: LD_LOC 8
9421: PPUSH
9422: CALL_OW 302
9426: AND
9427: IFFALSE 9497
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9429: LD_VAR 0 3
9433: PPUSH
9434: LD_EXP 50
9438: PPUSH
9439: CALL_OW 115
// Wait ( 0 0$2 ) ;
9443: LD_INT 70
9445: PPUSH
9446: CALL_OW 67
// for un in sc_utok do
9450: LD_ADDR_VAR 0 4
9454: PUSH
9455: LD_VAR 0 3
9459: PUSH
9460: FOR_IN
9461: IFFALSE 9493
// if not IsOK ( un ) then
9463: LD_VAR 0 4
9467: PPUSH
9468: CALL_OW 302
9472: NOT
9473: IFFALSE 9491
// sc_utok := sc_utok diff un ;
9475: LD_ADDR_VAR 0 3
9479: PUSH
9480: LD_VAR 0 3
9484: PUSH
9485: LD_VAR 0 4
9489: DIFF
9490: ST_TO_ADDR
9491: GO 9460
9493: POP
9494: POP
// end ;
9495: GO 9412
// Wait ( 0 0$5 ) ;
9497: LD_INT 175
9499: PPUSH
9500: CALL_OW 67
// enable ;
9504: ENABLE
// end ;
9505: PPOPN 4
9507: END
// every 0 0$3 marked 9 do
9508: GO 9510
9510: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9511: LD_LOC 8
9515: PPUSH
9516: LD_INT 3
9518: PPUSH
9519: CALL_OW 308
9523: PUSH
9524: LD_LOC 8
9528: PPUSH
9529: LD_INT 4
9531: PPUSH
9532: CALL_OW 289
9536: PUSH
9537: LD_INT 40
9539: EQUAL
9540: AND
9541: IFFALSE 9550
// YouLost ( Artefact ) ;
9543: LD_STRING Artefact
9545: PPUSH
9546: CALL_OW 104
// enable ;
9550: ENABLE
// end ;
9551: END
// on UnitDestroyed ( human ) do var i , un ;
9552: LD_INT 0
9554: PPUSH
9555: PPUSH
// begin if human = Burlak then
9556: LD_VAR 0 1
9560: PUSH
9561: LD_EXP 1
9565: EQUAL
9566: IFFALSE 9575
// YouLost ( Burlak ) ;
9568: LD_STRING Burlak
9570: PPUSH
9571: CALL_OW 104
// if human = Gossudarov then
9575: LD_VAR 0 1
9579: PUSH
9580: LD_EXP 8
9584: EQUAL
9585: IFFALSE 9594
// YouLost ( Gossudarov ) ;
9587: LD_STRING Gossudarov
9589: PPUSH
9590: CALL_OW 104
// if human = Masha then
9594: LD_VAR 0 1
9598: PUSH
9599: LD_EXP 43
9603: EQUAL
9604: IFFALSE 9614
// lost_masha := true ;
9606: LD_ADDR_EXP 52
9610: PUSH
9611: LD_INT 1
9613: ST_TO_ADDR
// if human in straz then
9614: LD_VAR 0 1
9618: PUSH
9619: LD_EXP 45
9623: IN
9624: IFFALSE 9673
// begin straz := straz diff human ;
9626: LD_ADDR_EXP 45
9630: PUSH
9631: LD_EXP 45
9635: PUSH
9636: LD_VAR 0 1
9640: DIFF
9641: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9642: LD_EXP 62
9646: PPUSH
9647: LD_VAR 0 1
9651: PPUSH
9652: LD_INT 1
9654: PPUSH
9655: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9659: LD_ADDR_EXP 53
9663: PUSH
9664: LD_EXP 53
9668: PUSH
9669: LD_INT 1
9671: PLUS
9672: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9673: LD_VAR 0 1
9677: PPUSH
9678: CALL_OW 255
9682: PUSH
9683: LD_INT 3
9685: EQUAL
9686: PUSH
9687: LD_VAR 0 1
9691: PUSH
9692: LD_EXP 60
9696: IN
9697: AND
9698: IFFALSE 9745
// begin for i in attackGroup do
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_EXP 60
9709: PUSH
9710: FOR_IN
9711: IFFALSE 9743
// if i = human then
9713: LD_VAR 0 2
9717: PUSH
9718: LD_VAR 0 1
9722: EQUAL
9723: IFFALSE 9741
// attackGroup = attackGroup diff i ;
9725: LD_ADDR_EXP 60
9729: PUSH
9730: LD_EXP 60
9734: PUSH
9735: LD_VAR 0 2
9739: DIFF
9740: ST_TO_ADDR
9741: GO 9710
9743: POP
9744: POP
// end ; end ;
9745: PPOPN 3
9747: END
// on SailEvent ( num ) do begin SetSide ( num , you ) ;
9748: LD_VAR 0 1
9752: PPUSH
9753: LD_EXP 23
9757: PPUSH
9758: CALL_OW 235
// end ;
9762: PPOPN 1
9764: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9765: LD_VAR 0 1
9769: PPUSH
9770: CALL_OW 255
9774: PUSH
9775: LD_EXP 24
9779: NONEQUAL
9780: IFFALSE 9792
// Artifact_cargo := un ;
9782: LD_ADDR_EXP 50
9786: PUSH
9787: LD_VAR 0 1
9791: ST_TO_ADDR
// end ;
9792: PPOPN 2
9794: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_distxy , 27 , 47 , 6 ] ] ) do
9795: LD_INT 22
9797: PUSH
9798: LD_INT 6
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PUSH
9805: LD_INT 21
9807: PUSH
9808: LD_INT 2
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PUSH
9815: LD_INT 92
9817: PUSH
9818: LD_INT 27
9820: PUSH
9821: LD_INT 47
9823: PUSH
9824: LD_INT 6
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: PUSH
9833: EMPTY
9834: LIST
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 69
9842: IFFALSE 9876
9844: GO 9846
9846: DISABLE
// begin SetSide ( Gossudarov , 7 ) ;
9847: LD_EXP 8
9851: PPUSH
9852: LD_INT 7
9854: PPUSH
9855: CALL_OW 235
// SetSide ( IsInUnit ( Gossudarov ) , 7 ) ;
9859: LD_EXP 8
9863: PPUSH
9864: CALL_OW 310
9868: PPUSH
9869: LD_INT 7
9871: PPUSH
9872: CALL_OW 235
// end ; end_of_file
9876: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9877: GO 9879
9879: DISABLE
9880: LD_INT 0
9882: PPUSH
9883: PPUSH
9884: PPUSH
9885: PPUSH
9886: PPUSH
9887: PPUSH
9888: PPUSH
// begin case tick of 0 .. 30000 :
9889: LD_OWVAR 1
9893: PUSH
9894: LD_INT 0
9896: DOUBLE
9897: GREATEREQUAL
9898: IFFALSE 9906
9900: LD_INT 30000
9902: DOUBLE
9903: LESSEQUAL
9904: IFTRUE 9908
9906: GO 9918
9908: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9909: LD_INT 1050
9911: PPUSH
9912: CALL_OW 67
9916: GO 10094
9918: LD_INT 30001
9920: DOUBLE
9921: GREATEREQUAL
9922: IFFALSE 9930
9924: LD_INT 50000
9926: DOUBLE
9927: LESSEQUAL
9928: IFTRUE 9932
9930: GO 9942
9932: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9933: LD_INT 1575
9935: PPUSH
9936: CALL_OW 67
9940: GO 10094
9942: LD_INT 50001
9944: DOUBLE
9945: GREATEREQUAL
9946: IFFALSE 9954
9948: LD_INT 70000
9950: DOUBLE
9951: LESSEQUAL
9952: IFTRUE 9956
9954: GO 9966
9956: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9957: LD_INT 2100
9959: PPUSH
9960: CALL_OW 67
9964: GO 10094
9966: LD_INT 70001
9968: DOUBLE
9969: GREATEREQUAL
9970: IFFALSE 9978
9972: LD_INT 90000
9974: DOUBLE
9975: LESSEQUAL
9976: IFTRUE 9980
9978: GO 9990
9980: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9981: LD_INT 2625
9983: PPUSH
9984: CALL_OW 67
9988: GO 10094
9990: LD_INT 70001
9992: DOUBLE
9993: GREATEREQUAL
9994: IFFALSE 10002
9996: LD_INT 90000
9998: DOUBLE
9999: LESSEQUAL
10000: IFTRUE 10004
10002: GO 10014
10004: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
10005: LD_INT 3150
10007: PPUSH
10008: CALL_OW 67
10012: GO 10094
10014: LD_INT 90001
10016: DOUBLE
10017: GREATEREQUAL
10018: IFFALSE 10026
10020: LD_INT 110000
10022: DOUBLE
10023: LESSEQUAL
10024: IFTRUE 10028
10026: GO 10038
10028: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
10029: LD_INT 3675
10031: PPUSH
10032: CALL_OW 67
10036: GO 10094
10038: LD_INT 110001
10040: DOUBLE
10041: GREATEREQUAL
10042: IFFALSE 10050
10044: LD_INT 130000
10046: DOUBLE
10047: LESSEQUAL
10048: IFTRUE 10052
10050: GO 10062
10052: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
10053: LD_INT 4200
10055: PPUSH
10056: CALL_OW 67
10060: GO 10094
10062: LD_INT 130001
10064: DOUBLE
10065: GREATEREQUAL
10066: IFFALSE 10074
10068: LD_INT 150000
10070: DOUBLE
10071: LESSEQUAL
10072: IFTRUE 10076
10074: GO 10086
10076: POP
// Wait ( 2 2$15 ) ; else
10077: LD_INT 4725
10079: PPUSH
10080: CALL_OW 67
10084: GO 10094
10086: POP
// Wait ( 2 2$30 ) ; end ;
10087: LD_INT 5250
10089: PPUSH
10090: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
10094: LD_ADDR_LOC 9
10098: PUSH
10099: LD_INT 22
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: LD_INT 1
10107: PUSH
10108: LD_INT 43
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: PUSH
10117: LD_INT 23
10119: PUSH
10120: LD_INT 3
10122: PUSH
10123: LD_INT 1
10125: PUSH
10126: LD_INT 45
10128: PUSH
10129: EMPTY
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 21
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: LD_INT 1
10143: PUSH
10144: LD_INT 43
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: PUSH
10153: LD_INT 24
10155: PUSH
10156: LD_INT 3
10158: PUSH
10159: LD_INT 1
10161: PUSH
10162: LD_INT 45
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 21
10173: PUSH
10174: LD_INT 3
10176: PUSH
10177: LD_INT 1
10179: PUSH
10180: LD_INT 45
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_INT 22
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 1
10197: PUSH
10198: LD_INT 44
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 24
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 46
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 23
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 46
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 46
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 23
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 47
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 49
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: LD_INT 23
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 1
10305: PUSH
10306: LD_INT 49
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: EMPTY
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10329: LD_ADDR_VAR 0 1
10333: PUSH
10334: LD_INT 22
10336: PUSH
10337: LD_EXP 23
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PUSH
10346: LD_INT 21
10348: PUSH
10349: LD_INT 2
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PPUSH
10360: CALL_OW 69
10364: ST_TO_ADDR
// if filter < 3 then
10365: LD_VAR 0 1
10369: PUSH
10370: LD_INT 3
10372: LESS
10373: IFFALSE 10383
// filter := 3 ;
10375: LD_ADDR_VAR 0 1
10379: PUSH
10380: LD_INT 3
10382: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10383: LD_INT 22
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: PUSH
10393: LD_INT 21
10395: PUSH
10396: LD_INT 2
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: PUSH
10403: LD_INT 50
10405: PUSH
10406: EMPTY
10407: LIST
10408: PUSH
10409: LD_INT 2
10411: PUSH
10412: LD_INT 34
10414: PUSH
10415: LD_INT 43
10417: PUSH
10418: EMPTY
10419: LIST
10420: LIST
10421: PUSH
10422: LD_INT 34
10424: PUSH
10425: LD_INT 45
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: PUSH
10432: LD_INT 34
10434: PUSH
10435: LD_INT 44
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: PUSH
10442: LD_INT 34
10444: PUSH
10445: LD_INT 46
10447: PUSH
10448: EMPTY
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 34
10454: PUSH
10455: LD_INT 47
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 34
10464: PUSH
10465: LD_INT 49
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 69
10491: PUSH
10492: LD_INT 6
10494: LESSEQUAL
10495: IFFALSE 11026
// for i := 1 to ( filter div 3 ) do
10497: LD_ADDR_VAR 0 2
10501: PUSH
10502: DOUBLE
10503: LD_INT 1
10505: DEC
10506: ST_TO_ADDR
10507: LD_VAR 0 1
10511: PUSH
10512: LD_INT 3
10514: DIV
10515: PUSH
10516: FOR_TO
10517: IFFALSE 11024
// begin uc_side := rus ;
10519: LD_ADDR_OWVAR 20
10523: PUSH
10524: LD_EXP 24
10528: ST_TO_ADDR
// uc_nation := nation_russian ;
10529: LD_ADDR_OWVAR 21
10533: PUSH
10534: LD_INT 3
10536: ST_TO_ADDR
// uc_direction := 5 ;
10537: LD_ADDR_OWVAR 24
10541: PUSH
10542: LD_INT 5
10544: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10545: LD_OWVAR 1
10549: PUSH
10550: LD_INT 60000
10552: LESS
10553: PUSH
10554: LD_INT 28
10556: PPUSH
10557: LD_EXP 23
10561: PPUSH
10562: CALL_OW 321
10566: PUSH
10567: LD_INT 2
10569: EQUAL
10570: OR
10571: IFFALSE 10597
// typ := rand ( 1 , vehicles - 2 ) else
10573: LD_ADDR_VAR 0 4
10577: PUSH
10578: LD_INT 1
10580: PPUSH
10581: LD_LOC 9
10585: PUSH
10586: LD_INT 2
10588: MINUS
10589: PPUSH
10590: CALL_OW 12
10594: ST_TO_ADDR
10595: GO 10615
// typ := rand ( 1 , vehicles ) ;
10597: LD_ADDR_VAR 0 4
10601: PUSH
10602: LD_INT 1
10604: PPUSH
10605: LD_LOC 9
10609: PPUSH
10610: CALL_OW 12
10614: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10615: LD_ADDR_OWVAR 37
10619: PUSH
10620: LD_LOC 9
10624: PUSH
10625: LD_VAR 0 4
10629: ARRAY
10630: PUSH
10631: LD_INT 1
10633: ARRAY
10634: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10635: LD_ADDR_OWVAR 38
10639: PUSH
10640: LD_LOC 9
10644: PUSH
10645: LD_VAR 0 4
10649: ARRAY
10650: PUSH
10651: LD_INT 2
10653: ARRAY
10654: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10655: LD_ADDR_OWVAR 39
10659: PUSH
10660: LD_LOC 9
10664: PUSH
10665: LD_VAR 0 4
10669: ARRAY
10670: PUSH
10671: LD_INT 3
10673: ARRAY
10674: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10675: LD_ADDR_OWVAR 40
10679: PUSH
10680: LD_LOC 9
10684: PUSH
10685: LD_VAR 0 4
10689: ARRAY
10690: PUSH
10691: LD_INT 4
10693: ARRAY
10694: ST_TO_ADDR
// auto := CreateVehicle ;
10695: LD_ADDR_VAR 0 5
10699: PUSH
10700: CALL_OW 45
10704: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10705: LD_VAR 0 5
10709: PPUSH
10710: LD_INT 9
10712: PPUSH
10713: LD_INT 0
10715: PPUSH
10716: CALL_OW 49
// attack := attack ^ auto ;
10720: LD_ADDR_LOC 10
10724: PUSH
10725: LD_LOC 10
10729: PUSH
10730: LD_VAR 0 5
10734: ADD
10735: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10736: LD_VAR 0 5
10740: PPUSH
10741: LD_INT 52
10743: PPUSH
10744: LD_INT 61
10746: PPUSH
10747: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 52
10758: PPUSH
10759: LD_INT 61
10761: PPUSH
10762: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10766: LD_INT 1
10768: PPUSH
10769: LD_INT 2
10771: PPUSH
10772: CALL_OW 12
10776: PUSH
10777: LD_INT 1
10779: DOUBLE
10780: EQUAL
10781: IFTRUE 10785
10783: GO 10803
10785: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10786: LD_VAR 0 5
10790: PPUSH
10791: LD_INT 35
10793: PPUSH
10794: LD_INT 30
10796: PPUSH
10797: CALL_OW 174
10801: GO 10830
10803: LD_INT 2
10805: DOUBLE
10806: EQUAL
10807: IFTRUE 10811
10809: GO 10829
10811: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10812: LD_VAR 0 5
10816: PPUSH
10817: LD_INT 17
10819: PPUSH
10820: LD_INT 29
10822: PPUSH
10823: CALL_OW 174
10827: GO 10830
10829: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10830: LD_VAR 0 5
10834: PPUSH
10835: LD_INT 29
10837: PPUSH
10838: LD_INT 5
10840: PPUSH
10841: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10845: LD_INT 1
10847: PPUSH
10848: LD_INT 2
10850: PPUSH
10851: CALL_OW 12
10855: PUSH
10856: LD_INT 1
10858: DOUBLE
10859: EQUAL
10860: IFTRUE 10864
10862: GO 10882
10864: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10865: LD_VAR 0 5
10869: PPUSH
10870: LD_INT 60
10872: PPUSH
10873: LD_INT 30
10875: PPUSH
10876: CALL_OW 174
10880: GO 10909
10882: LD_INT 2
10884: DOUBLE
10885: EQUAL
10886: IFTRUE 10890
10888: GO 10908
10890: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10891: LD_VAR 0 5
10895: PPUSH
10896: LD_INT 84
10898: PPUSH
10899: LD_INT 30
10901: PPUSH
10902: CALL_OW 174
10906: GO 10909
10908: POP
// case Rand ( 1 , 2 ) of 1 :
10909: LD_INT 1
10911: PPUSH
10912: LD_INT 2
10914: PPUSH
10915: CALL_OW 12
10919: PUSH
10920: LD_INT 1
10922: DOUBLE
10923: EQUAL
10924: IFTRUE 10928
10926: GO 10946
10928: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10929: LD_VAR 0 5
10933: PPUSH
10934: LD_INT 71
10936: PPUSH
10937: LD_INT 59
10939: PPUSH
10940: CALL_OW 174
10944: GO 10973
10946: LD_INT 2
10948: DOUBLE
10949: EQUAL
10950: IFTRUE 10954
10952: GO 10972
10954: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10955: LD_VAR 0 5
10959: PPUSH
10960: LD_INT 92
10962: PPUSH
10963: LD_INT 66
10965: PPUSH
10966: CALL_OW 174
10970: GO 10973
10972: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10973: LD_VAR 0 5
10977: PPUSH
10978: LD_INT 78
10980: PPUSH
10981: LD_INT 88
10983: PPUSH
10984: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10988: LD_VAR 0 5
10992: PPUSH
10993: LD_INT 117
10995: PPUSH
10996: LD_INT 90
10998: PPUSH
10999: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
11003: LD_VAR 0 5
11007: PPUSH
11008: LD_INT 15
11010: PPUSH
11011: CALL_OW 173
// Wait ( 0 0$4 ) ;
11015: LD_INT 140
11017: PPUSH
11018: CALL_OW 67
// end ;
11022: GO 10516
11024: POP
11025: POP
// enable ;
11026: ENABLE
// end ;
11027: PPOPN 7
11029: END
// export function PrepareInfantry ; var i , clovek ; begin
11030: LD_INT 0
11032: PPUSH
11033: PPUSH
11034: PPUSH
// for i = 1 to 6 do
11035: LD_ADDR_VAR 0 2
11039: PUSH
11040: DOUBLE
11041: LD_INT 1
11043: DEC
11044: ST_TO_ADDR
11045: LD_INT 6
11047: PUSH
11048: FOR_TO
11049: IFFALSE 11226
// begin uc_side = 3 ;
11051: LD_ADDR_OWVAR 20
11055: PUSH
11056: LD_INT 3
11058: ST_TO_ADDR
// uc_nation = 3 ;
11059: LD_ADDR_OWVAR 21
11063: PUSH
11064: LD_INT 3
11066: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
11067: LD_INT 1
11069: PPUSH
11070: LD_INT 3
11072: PPUSH
11073: CALL_OW 12
11077: PUSH
11078: LD_INT 1
11080: DOUBLE
11081: EQUAL
11082: IFTRUE 11086
11084: GO 11116
11086: POP
// PrepareHuman ( sex_male , class_soldier , rand ( 3 , 5 + Difficulty ) ) ; 2 .. 3 :
11087: LD_INT 1
11089: PPUSH
11090: LD_INT 1
11092: PPUSH
11093: LD_INT 3
11095: PPUSH
11096: LD_INT 5
11098: PUSH
11099: LD_OWVAR 67
11103: PLUS
11104: PPUSH
11105: CALL_OW 12
11109: PPUSH
11110: CALL_OW 380
11114: GO 11161
11116: LD_INT 2
11118: DOUBLE
11119: GREATEREQUAL
11120: IFFALSE 11128
11122: LD_INT 3
11124: DOUBLE
11125: LESSEQUAL
11126: IFTRUE 11130
11128: GO 11160
11130: POP
// PrepareHuman ( sex_male , class_bazooker , rand ( 3 , 4 + Difficulty ) ) ; end ;
11131: LD_INT 1
11133: PPUSH
11134: LD_INT 9
11136: PPUSH
11137: LD_INT 3
11139: PPUSH
11140: LD_INT 4
11142: PUSH
11143: LD_OWVAR 67
11147: PLUS
11148: PPUSH
11149: CALL_OW 12
11153: PPUSH
11154: CALL_OW 380
11158: GO 11161
11160: POP
// hc_name :=  ;
11161: LD_ADDR_OWVAR 26
11165: PUSH
11166: LD_STRING 
11168: ST_TO_ADDR
// clovek := CreateHuman ;
11169: LD_ADDR_VAR 0 3
11173: PUSH
11174: CALL_OW 44
11178: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
11179: LD_VAR 0 3
11183: PPUSH
11184: LD_INT 9
11186: PPUSH
11187: LD_INT 0
11189: PPUSH
11190: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11194: LD_ADDR_EXP 59
11198: PUSH
11199: LD_EXP 59
11203: PUSH
11204: LD_INT 1
11206: MINUS
11207: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11208: LD_ADDR_EXP 60
11212: PUSH
11213: LD_EXP 60
11217: PUSH
11218: LD_VAR 0 3
11222: ADD
11223: ST_TO_ADDR
// end ;
11224: GO 11048
11226: POP
11227: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11228: LD_EXP 60
11232: PPUSH
11233: LD_INT 52
11235: PPUSH
11236: LD_INT 61
11238: PPUSH
11239: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11243: LD_INT 1
11245: PPUSH
11246: LD_INT 2
11248: PPUSH
11249: CALL_OW 12
11253: PUSH
11254: LD_INT 1
11256: DOUBLE
11257: EQUAL
11258: IFTRUE 11262
11260: GO 11280
11262: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11263: LD_EXP 60
11267: PPUSH
11268: LD_INT 35
11270: PPUSH
11271: LD_INT 30
11273: PPUSH
11274: CALL_OW 174
11278: GO 11307
11280: LD_INT 2
11282: DOUBLE
11283: EQUAL
11284: IFTRUE 11288
11286: GO 11306
11288: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11289: LD_EXP 60
11293: PPUSH
11294: LD_INT 17
11296: PPUSH
11297: LD_INT 29
11299: PPUSH
11300: CALL_OW 174
11304: GO 11307
11306: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11307: LD_EXP 60
11311: PPUSH
11312: LD_INT 29
11314: PPUSH
11315: LD_INT 5
11317: PPUSH
11318: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11322: LD_INT 1
11324: PPUSH
11325: LD_INT 2
11327: PPUSH
11328: CALL_OW 12
11332: PUSH
11333: LD_INT 1
11335: DOUBLE
11336: EQUAL
11337: IFTRUE 11341
11339: GO 11359
11341: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11342: LD_EXP 60
11346: PPUSH
11347: LD_INT 60
11349: PPUSH
11350: LD_INT 30
11352: PPUSH
11353: CALL_OW 174
11357: GO 11386
11359: LD_INT 2
11361: DOUBLE
11362: EQUAL
11363: IFTRUE 11367
11365: GO 11385
11367: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11368: LD_EXP 60
11372: PPUSH
11373: LD_INT 84
11375: PPUSH
11376: LD_INT 30
11378: PPUSH
11379: CALL_OW 174
11383: GO 11386
11385: POP
// case Rand ( 1 , 2 ) of 1 :
11386: LD_INT 1
11388: PPUSH
11389: LD_INT 2
11391: PPUSH
11392: CALL_OW 12
11396: PUSH
11397: LD_INT 1
11399: DOUBLE
11400: EQUAL
11401: IFTRUE 11405
11403: GO 11423
11405: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11406: LD_EXP 60
11410: PPUSH
11411: LD_INT 71
11413: PPUSH
11414: LD_INT 59
11416: PPUSH
11417: CALL_OW 174
11421: GO 11450
11423: LD_INT 2
11425: DOUBLE
11426: EQUAL
11427: IFTRUE 11431
11429: GO 11449
11431: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11432: LD_EXP 60
11436: PPUSH
11437: LD_INT 92
11439: PPUSH
11440: LD_INT 66
11442: PPUSH
11443: CALL_OW 174
11447: GO 11450
11449: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11450: LD_EXP 60
11454: PPUSH
11455: LD_INT 78
11457: PPUSH
11458: LD_INT 88
11460: PPUSH
11461: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11465: LD_EXP 60
11469: PPUSH
11470: LD_INT 117
11472: PPUSH
11473: LD_INT 90
11475: PPUSH
11476: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11480: LD_EXP 60
11484: PPUSH
11485: LD_INT 15
11487: PPUSH
11488: CALL_OW 173
// end ;
11492: LD_VAR 0 1
11496: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11497: LD_EXP 60
11501: PUSH
11502: EMPTY
11503: EQUAL
11504: PUSH
11505: LD_EXP 61
11509: PUSH
11510: LD_INT 1
11512: EQUAL
11513: AND
11514: IFFALSE 11524
11516: GO 11518
11518: DISABLE
// begin enable ;
11519: ENABLE
// PrepareInfantry ;
11520: CALL 11030 0 0
// end ;
11524: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11525: GO 11527
11527: DISABLE
11528: LD_INT 0
11530: PPUSH
11531: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11532: LD_ADDR_VAR 0 1
11536: PUSH
11537: LD_INT 15
11539: PPUSH
11540: LD_INT 22
11542: PUSH
11543: LD_EXP 24
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 50
11554: PUSH
11555: EMPTY
11556: LIST
11557: PUSH
11558: LD_INT 2
11560: PUSH
11561: LD_INT 21
11563: PUSH
11564: LD_INT 2
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 21
11573: PUSH
11574: LD_INT 1
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PUSH
11581: EMPTY
11582: LIST
11583: LIST
11584: LIST
11585: PUSH
11586: EMPTY
11587: LIST
11588: LIST
11589: LIST
11590: PPUSH
11591: CALL_OW 70
11595: ST_TO_ADDR
// case tick of 0 .. 30000 :
11596: LD_OWVAR 1
11600: PUSH
11601: LD_INT 0
11603: DOUBLE
11604: GREATEREQUAL
11605: IFFALSE 11613
11607: LD_INT 30000
11609: DOUBLE
11610: LESSEQUAL
11611: IFTRUE 11615
11613: GO 11632
11615: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11616: LD_ADDR_VAR 0 2
11620: PUSH
11621: LD_EXP 34
11625: PUSH
11626: LD_INT 4
11628: MINUS
11629: ST_TO_ADDR
11630: GO 11736
11632: LD_INT 30001
11634: DOUBLE
11635: GREATEREQUAL
11636: IFFALSE 11644
11638: LD_INT 50000
11640: DOUBLE
11641: LESSEQUAL
11642: IFTRUE 11646
11644: GO 11663
11646: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11647: LD_ADDR_VAR 0 2
11651: PUSH
11652: LD_EXP 34
11656: PUSH
11657: LD_INT 3
11659: MINUS
11660: ST_TO_ADDR
11661: GO 11736
11663: LD_INT 50001
11665: DOUBLE
11666: GREATEREQUAL
11667: IFFALSE 11675
11669: LD_INT 70000
11671: DOUBLE
11672: LESSEQUAL
11673: IFTRUE 11677
11675: GO 11694
11677: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11678: LD_ADDR_VAR 0 2
11682: PUSH
11683: LD_EXP 34
11687: PUSH
11688: LD_INT 2
11690: MINUS
11691: ST_TO_ADDR
11692: GO 11736
11694: LD_INT 70001
11696: DOUBLE
11697: GREATEREQUAL
11698: IFFALSE 11706
11700: LD_INT 90000
11702: DOUBLE
11703: LESSEQUAL
11704: IFTRUE 11708
11706: GO 11725
11708: POP
// mnozstvi := maxaut - 1 ; else
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_EXP 34
11718: PUSH
11719: LD_INT 1
11721: MINUS
11722: ST_TO_ADDR
11723: GO 11736
11725: POP
// mnozstvi := maxaut ; end ;
11726: LD_ADDR_VAR 0 2
11730: PUSH
11731: LD_EXP 34
11735: ST_TO_ADDR
// if filter >= mnozstvi then
11736: LD_VAR 0 1
11740: PUSH
11741: LD_VAR 0 2
11745: GREATEREQUAL
11746: IFFALSE 11763
// ComMoveXY ( filter , 138 , 69 ) ;
11748: LD_VAR 0 1
11752: PPUSH
11753: LD_INT 138
11755: PPUSH
11756: LD_INT 69
11758: PPUSH
11759: CALL_OW 111
// enable ;
11763: ENABLE
// end ;
11764: PPOPN 2
11766: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11767: GO 11769
11769: DISABLE
11770: LD_INT 0
11772: PPUSH
11773: PPUSH
11774: PPUSH
11775: PPUSH
11776: PPUSH
11777: PPUSH
// begin enable ;
11778: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11779: LD_ADDR_VAR 0 1
11783: PUSH
11784: LD_INT 12
11786: PPUSH
11787: LD_INT 22
11789: PUSH
11790: LD_EXP 24
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PUSH
11799: LD_INT 50
11801: PUSH
11802: EMPTY
11803: LIST
11804: PUSH
11805: LD_INT 3
11807: PUSH
11808: LD_INT 34
11810: PUSH
11811: LD_INT 49
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: LIST
11826: PPUSH
11827: CALL_OW 70
11831: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11832: LD_INT 33
11834: PPUSH
11835: LD_EXP 23
11839: PPUSH
11840: CALL_OW 321
11844: PUSH
11845: LD_INT 2
11847: EQUAL
11848: IFFALSE 11902
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11850: LD_ADDR_VAR 0 2
11854: PUSH
11855: LD_INT 12
11857: PPUSH
11858: LD_INT 22
11860: PUSH
11861: LD_EXP 23
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: LD_INT 25
11872: PUSH
11873: LD_INT 4
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 101
11882: PUSH
11883: LD_EXP 24
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: LIST
11896: PPUSH
11897: CALL_OW 70
11901: ST_TO_ADDR
// if filter_you = 0 then
11902: LD_VAR 0 2
11906: PUSH
11907: LD_INT 0
11909: EQUAL
11910: IFFALSE 12019
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11912: LD_ADDR_VAR 0 2
11916: PUSH
11917: LD_INT 22
11919: PUSH
11920: LD_EXP 23
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PUSH
11929: LD_INT 50
11931: PUSH
11932: EMPTY
11933: LIST
11934: PUSH
11935: LD_INT 2
11937: PUSH
11938: LD_INT 21
11940: PUSH
11941: LD_INT 1
11943: PUSH
11944: EMPTY
11945: LIST
11946: LIST
11947: PUSH
11948: LD_INT 21
11950: PUSH
11951: LD_INT 2
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 21
11960: PUSH
11961: LD_INT 3
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: LIST
11978: PPUSH
11979: CALL_OW 69
11983: ST_TO_ADDR
// if filter_you = 0 then
11984: LD_VAR 0 2
11988: PUSH
11989: LD_INT 0
11991: EQUAL
11992: IFFALSE 12019
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11994: LD_ADDR_VAR 0 2
11998: PUSH
11999: LD_INT 12
12001: PPUSH
12002: LD_INT 22
12004: PUSH
12005: LD_EXP 23
12009: PUSH
12010: EMPTY
12011: LIST
12012: LIST
12013: PPUSH
12014: CALL_OW 70
12018: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12019: LD_VAR 0 1
12023: PUSH
12024: LD_INT 0
12026: GREATER
12027: PUSH
12028: LD_VAR 0 2
12032: PUSH
12033: LD_INT 0
12035: GREATER
12036: AND
12037: IFFALSE 12428
// begin for un_rus in filter_rus do
12039: LD_ADDR_VAR 0 3
12043: PUSH
12044: LD_VAR 0 1
12048: PUSH
12049: FOR_IN
12050: IFFALSE 12426
// begin Wait ( 5 ) ;
12052: LD_INT 5
12054: PPUSH
12055: CALL_OW 67
// min := 99999 ;
12059: LD_ADDR_VAR 0 5
12063: PUSH
12064: LD_INT 99999
12066: ST_TO_ADDR
// cil := 0 ;
12067: LD_ADDR_VAR 0 6
12071: PUSH
12072: LD_INT 0
12074: ST_TO_ADDR
// for un_you in filter_you do
12075: LD_ADDR_VAR 0 4
12079: PUSH
12080: LD_VAR 0 2
12084: PUSH
12085: FOR_IN
12086: IFFALSE 12282
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12088: LD_VAR 0 4
12092: PPUSH
12093: CALL_OW 320
12097: PUSH
12098: LD_VAR 0 4
12102: PPUSH
12103: CALL_OW 256
12107: PUSH
12108: LD_VAR 0 5
12112: LESS
12113: AND
12114: PUSH
12115: LD_VAR 0 3
12119: PPUSH
12120: LD_VAR 0 4
12124: PPUSH
12125: CALL_OW 296
12129: PUSH
12130: LD_INT 2
12132: PUSH
12133: LD_INT 2
12135: PUSH
12136: LD_INT 4
12138: PUSH
12139: LD_INT 6
12141: PUSH
12142: LD_INT 5
12144: PUSH
12145: LD_INT 9
12147: PUSH
12148: LD_INT 0
12150: PUSH
12151: LD_INT 2
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: PUSH
12164: LD_VAR 0 3
12168: PPUSH
12169: CALL_OW 264
12173: PUSH
12174: LD_INT 41
12176: MINUS
12177: ARRAY
12178: GREATEREQUAL
12179: AND
12180: PUSH
12181: LD_VAR 0 3
12185: PPUSH
12186: LD_VAR 0 4
12190: PPUSH
12191: CALL_OW 296
12195: PUSH
12196: LD_INT 15
12198: PUSH
12199: LD_INT 16
12201: PUSH
12202: LD_INT 17
12204: PUSH
12205: LD_INT 22
12207: PUSH
12208: LD_INT 20
12210: PUSH
12211: LD_INT 28
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: LD_INT 51
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: LIST
12224: LIST
12225: LIST
12226: LIST
12227: LIST
12228: LIST
12229: PUSH
12230: LD_VAR 0 3
12234: PPUSH
12235: CALL_OW 264
12239: PUSH
12240: LD_INT 41
12242: MINUS
12243: ARRAY
12244: LESSEQUAL
12245: AND
12246: IFFALSE 12273
// begin min := GetLives ( un_you ) ;
12248: LD_ADDR_VAR 0 5
12252: PUSH
12253: LD_VAR 0 4
12257: PPUSH
12258: CALL_OW 256
12262: ST_TO_ADDR
// cil := un_you ;
12263: LD_ADDR_VAR 0 6
12267: PUSH
12268: LD_VAR 0 4
12272: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12273: LD_INT 5
12275: PPUSH
12276: CALL_OW 67
// end ;
12280: GO 12085
12282: POP
12283: POP
// if cil <> 0 then
12284: LD_VAR 0 6
12288: PUSH
12289: LD_INT 0
12291: NONEQUAL
12292: IFFALSE 12310
// ComAttackUnit ( un_rus , cil ) else
12294: LD_VAR 0 3
12298: PPUSH
12299: LD_VAR 0 6
12303: PPUSH
12304: CALL_OW 115
12308: GO 12424
// begin for un_you in filter_you do
12310: LD_ADDR_VAR 0 4
12314: PUSH
12315: LD_VAR 0 2
12319: PUSH
12320: FOR_IN
12321: IFFALSE 12408
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12323: LD_VAR 0 4
12327: PPUSH
12328: CALL_OW 266
12332: PUSH
12333: LD_INT 0
12335: PUSH
12336: LD_INT 1
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: IN
12343: IFFALSE 12357
// cil := un_you else
12345: LD_ADDR_VAR 0 6
12349: PUSH
12350: LD_VAR 0 4
12354: ST_TO_ADDR
12355: GO 12399
// if GetLives ( un_you ) < min then
12357: LD_VAR 0 4
12361: PPUSH
12362: CALL_OW 256
12366: PUSH
12367: LD_VAR 0 5
12371: LESS
12372: IFFALSE 12399
// begin min := GetLives ( un_you ) ;
12374: LD_ADDR_VAR 0 5
12378: PUSH
12379: LD_VAR 0 4
12383: PPUSH
12384: CALL_OW 256
12388: ST_TO_ADDR
// cil := un_you ;
12389: LD_ADDR_VAR 0 6
12393: PUSH
12394: LD_VAR 0 4
12398: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12399: LD_INT 5
12401: PPUSH
12402: CALL_OW 67
// end ;
12406: GO 12320
12408: POP
12409: POP
// ComAttackUnit ( un_rus , cil ) end ;
12410: LD_VAR 0 3
12414: PPUSH
12415: LD_VAR 0 6
12419: PPUSH
12420: CALL_OW 115
// end ;
12424: GO 12049
12426: POP
12427: POP
// end ; end ;
12428: PPOPN 6
12430: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12431: GO 12433
12433: DISABLE
12434: LD_INT 0
12436: PPUSH
12437: PPUSH
12438: PPUSH
12439: PPUSH
12440: PPUSH
12441: PPUSH
// begin enable ;
12442: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12443: LD_ADDR_VAR 0 1
12447: PUSH
12448: LD_INT 21
12450: PPUSH
12451: LD_INT 22
12453: PUSH
12454: LD_EXP 24
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: PUSH
12463: LD_INT 3
12465: PUSH
12466: LD_INT 2
12468: PUSH
12469: LD_INT 21
12471: PUSH
12472: LD_INT 3
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: PUSH
12479: LD_INT 34
12481: PUSH
12482: LD_INT 49
12484: PUSH
12485: EMPTY
12486: LIST
12487: LIST
12488: PUSH
12489: LD_INT 34
12491: PUSH
12492: LD_INT 51
12494: PUSH
12495: EMPTY
12496: LIST
12497: LIST
12498: PUSH
12499: LD_INT 25
12501: PUSH
12502: LD_INT 4
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: PUSH
12509: LD_INT 25
12511: PUSH
12512: LD_INT 2
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: PUSH
12519: LD_INT 54
12521: PUSH
12522: EMPTY
12523: LIST
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: LIST
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: LIST
12538: PPUSH
12539: CALL_OW 70
12543: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12544: LD_ADDR_VAR 0 1
12548: PUSH
12549: LD_VAR 0 1
12553: PUSH
12554: LD_EXP 45
12558: DIFF
12559: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12560: LD_ADDR_VAR 0 2
12564: PUSH
12565: LD_INT 21
12567: PPUSH
12568: LD_INT 22
12570: PUSH
12571: LD_EXP 23
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PUSH
12580: LD_INT 21
12582: PUSH
12583: LD_INT 2
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PPUSH
12594: CALL_OW 70
12598: ST_TO_ADDR
// if not filter_you then
12599: LD_VAR 0 2
12603: NOT
12604: IFFALSE 12677
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12606: LD_ADDR_VAR 0 2
12610: PUSH
12611: LD_INT 21
12613: PPUSH
12614: LD_INT 22
12616: PUSH
12617: LD_EXP 23
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 25
12628: PUSH
12629: LD_INT 4
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: PPUSH
12640: CALL_OW 70
12644: ST_TO_ADDR
// if not filter_you then
12645: LD_VAR 0 2
12649: NOT
12650: IFFALSE 12677
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12652: LD_ADDR_VAR 0 2
12656: PUSH
12657: LD_INT 21
12659: PPUSH
12660: LD_INT 22
12662: PUSH
12663: LD_EXP 23
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PPUSH
12672: CALL_OW 70
12676: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12677: LD_VAR 0 1
12681: PUSH
12682: LD_INT 0
12684: GREATER
12685: PUSH
12686: LD_VAR 0 2
12690: PUSH
12691: LD_INT 0
12693: GREATER
12694: AND
12695: IFFALSE 13086
// begin for un_rus in filter_rus do
12697: LD_ADDR_VAR 0 3
12701: PUSH
12702: LD_VAR 0 1
12706: PUSH
12707: FOR_IN
12708: IFFALSE 13084
// begin Wait ( 5 ) ;
12710: LD_INT 5
12712: PPUSH
12713: CALL_OW 67
// min := 99999 ;
12717: LD_ADDR_VAR 0 5
12721: PUSH
12722: LD_INT 99999
12724: ST_TO_ADDR
// cil := 0 ;
12725: LD_ADDR_VAR 0 6
12729: PUSH
12730: LD_INT 0
12732: ST_TO_ADDR
// for un_you in filter_you do
12733: LD_ADDR_VAR 0 4
12737: PUSH
12738: LD_VAR 0 2
12742: PUSH
12743: FOR_IN
12744: IFFALSE 12940
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12746: LD_VAR 0 4
12750: PPUSH
12751: CALL_OW 302
12755: PUSH
12756: LD_VAR 0 4
12760: PPUSH
12761: CALL_OW 256
12765: PUSH
12766: LD_VAR 0 5
12770: LESS
12771: AND
12772: PUSH
12773: LD_VAR 0 3
12777: PPUSH
12778: LD_VAR 0 4
12782: PPUSH
12783: CALL_OW 296
12787: PUSH
12788: LD_INT 2
12790: PUSH
12791: LD_INT 2
12793: PUSH
12794: LD_INT 4
12796: PUSH
12797: LD_INT 6
12799: PUSH
12800: LD_INT 5
12802: PUSH
12803: LD_INT 9
12805: PUSH
12806: LD_INT 0
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: LD_VAR 0 3
12826: PPUSH
12827: CALL_OW 264
12831: PUSH
12832: LD_INT 41
12834: MINUS
12835: ARRAY
12836: GREATEREQUAL
12837: AND
12838: PUSH
12839: LD_VAR 0 3
12843: PPUSH
12844: LD_VAR 0 4
12848: PPUSH
12849: CALL_OW 296
12853: PUSH
12854: LD_INT 15
12856: PUSH
12857: LD_INT 16
12859: PUSH
12860: LD_INT 17
12862: PUSH
12863: LD_INT 22
12865: PUSH
12866: LD_INT 20
12868: PUSH
12869: LD_INT 28
12871: PUSH
12872: LD_INT 0
12874: PUSH
12875: LD_INT 51
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: PUSH
12888: LD_VAR 0 3
12892: PPUSH
12893: CALL_OW 264
12897: PUSH
12898: LD_INT 41
12900: MINUS
12901: ARRAY
12902: LESSEQUAL
12903: AND
12904: IFFALSE 12931
// begin min := GetLives ( un_you ) ;
12906: LD_ADDR_VAR 0 5
12910: PUSH
12911: LD_VAR 0 4
12915: PPUSH
12916: CALL_OW 256
12920: ST_TO_ADDR
// cil := un_you ;
12921: LD_ADDR_VAR 0 6
12925: PUSH
12926: LD_VAR 0 4
12930: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12931: LD_INT 5
12933: PPUSH
12934: CALL_OW 67
// end ;
12938: GO 12743
12940: POP
12941: POP
// if cil <> 0 then
12942: LD_VAR 0 6
12946: PUSH
12947: LD_INT 0
12949: NONEQUAL
12950: IFFALSE 12968
// ComAttackUnit ( un_rus , cil ) else
12952: LD_VAR 0 3
12956: PPUSH
12957: LD_VAR 0 6
12961: PPUSH
12962: CALL_OW 115
12966: GO 13082
// begin for un_you in filter_you do
12968: LD_ADDR_VAR 0 4
12972: PUSH
12973: LD_VAR 0 2
12977: PUSH
12978: FOR_IN
12979: IFFALSE 13066
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12981: LD_VAR 0 4
12985: PPUSH
12986: CALL_OW 266
12990: PUSH
12991: LD_INT 0
12993: PUSH
12994: LD_INT 1
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: IN
13001: IFFALSE 13015
// cil := un_you else
13003: LD_ADDR_VAR 0 6
13007: PUSH
13008: LD_VAR 0 4
13012: ST_TO_ADDR
13013: GO 13057
// if GetLives ( un_you ) < min then
13015: LD_VAR 0 4
13019: PPUSH
13020: CALL_OW 256
13024: PUSH
13025: LD_VAR 0 5
13029: LESS
13030: IFFALSE 13057
// begin min := GetLives ( un_you ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 4
13041: PPUSH
13042: CALL_OW 256
13046: ST_TO_ADDR
// cil := un_you ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_VAR 0 4
13056: ST_TO_ADDR
// end ; Wait ( 5 ) ;
13057: LD_INT 5
13059: PPUSH
13060: CALL_OW 67
// end ;
13064: GO 12978
13066: POP
13067: POP
// ComAttackUnit ( un_rus , cil ) end ;
13068: LD_VAR 0 3
13072: PPUSH
13073: LD_VAR 0 6
13077: PPUSH
13078: CALL_OW 115
// end ;
13082: GO 12707
13084: POP
13085: POP
// end ; end ;
13086: PPOPN 6
13088: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
13089: GO 13091
13091: DISABLE
13092: LD_INT 0
13094: PPUSH
13095: PPUSH
13096: PPUSH
13097: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
13098: LD_INT 28
13100: PPUSH
13101: LD_EXP 23
13105: PPUSH
13106: CALL_OW 321
13110: PUSH
13111: LD_INT 2
13113: EQUAL
13114: NOT
13115: IFFALSE 13118
// enable ;
13117: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
13118: LD_ADDR_VAR 0 1
13122: PUSH
13123: LD_INT 12
13125: PPUSH
13126: LD_INT 22
13128: PUSH
13129: LD_EXP 24
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 50
13140: PUSH
13141: EMPTY
13142: LIST
13143: PUSH
13144: LD_INT 34
13146: PUSH
13147: LD_INT 49
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: PPUSH
13159: CALL_OW 70
13163: ST_TO_ADDR
// if filter_rus > 0 then
13164: LD_VAR 0 1
13168: PUSH
13169: LD_INT 0
13171: GREATER
13172: IFFALSE 13213
// for un_rus in filter_rus do
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_VAR 0 1
13183: PUSH
13184: FOR_IN
13185: IFFALSE 13211
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
13187: LD_VAR 0 3
13191: PPUSH
13192: LD_INT 122
13194: PPUSH
13195: LD_INT 27
13197: PPUSH
13198: CALL_OW 111
// Wait ( 5 ) ;
13202: LD_INT 5
13204: PPUSH
13205: CALL_OW 67
// end ;
13209: GO 13184
13211: POP
13212: POP
// end ;
13213: PPOPN 4
13215: END
// every 1 1$0 + 0 0$5.5 do
13216: GO 13218
13218: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13219: LD_INT 59
13221: PPUSH
13222: LD_EXP 24
13226: PPUSH
13227: CALL_OW 321
13231: PUSH
13232: LD_INT 2
13234: EQUAL
13235: NOT
13236: PUSH
13237: LD_OWVAR 1
13241: PUSH
13242: LD_EXP 54
13246: GREATEREQUAL
13247: AND
13248: IFFALSE 13265
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13250: LD_INT 59
13252: PPUSH
13253: LD_EXP 24
13257: PPUSH
13258: LD_INT 2
13260: PPUSH
13261: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13265: LD_INT 50
13267: PPUSH
13268: LD_EXP 24
13272: PPUSH
13273: CALL_OW 321
13277: PUSH
13278: LD_INT 2
13280: EQUAL
13281: NOT
13282: PUSH
13283: LD_OWVAR 1
13287: PUSH
13288: LD_EXP 55
13292: GREATEREQUAL
13293: AND
13294: IFFALSE 13311
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13296: LD_INT 50
13298: PPUSH
13299: LD_EXP 24
13303: PPUSH
13304: LD_INT 2
13306: PPUSH
13307: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13311: LD_INT 53
13313: PPUSH
13314: LD_EXP 24
13318: PPUSH
13319: CALL_OW 321
13323: PUSH
13324: LD_INT 2
13326: EQUAL
13327: NOT
13328: PUSH
13329: LD_OWVAR 1
13333: PUSH
13334: LD_EXP 56
13338: GREATEREQUAL
13339: AND
13340: IFFALSE 13357
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13342: LD_INT 53
13344: PPUSH
13345: LD_EXP 24
13349: PPUSH
13350: LD_INT 2
13352: PPUSH
13353: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13357: LD_INT 56
13359: PPUSH
13360: LD_EXP 24
13364: PPUSH
13365: CALL_OW 321
13369: PUSH
13370: LD_INT 2
13372: EQUAL
13373: NOT
13374: PUSH
13375: LD_OWVAR 1
13379: PUSH
13380: LD_EXP 57
13384: GREATEREQUAL
13385: AND
13386: IFFALSE 13403
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13388: LD_INT 56
13390: PPUSH
13391: LD_EXP 24
13395: PPUSH
13396: LD_INT 2
13398: PPUSH
13399: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13403: LD_INT 65
13405: PPUSH
13406: LD_EXP 24
13410: PPUSH
13411: CALL_OW 321
13415: PUSH
13416: LD_INT 2
13418: EQUAL
13419: NOT
13420: PUSH
13421: LD_OWVAR 1
13425: PUSH
13426: LD_EXP 58
13430: GREATEREQUAL
13431: AND
13432: IFFALSE 13449
// SetTech ( tech_ST3 , rus , state_researched ) ;
13434: LD_INT 65
13436: PPUSH
13437: LD_EXP 24
13441: PPUSH
13442: LD_INT 2
13444: PPUSH
13445: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13449: LD_INT 59
13451: PPUSH
13452: LD_EXP 24
13456: PPUSH
13457: CALL_OW 321
13461: PUSH
13462: LD_INT 2
13464: EQUAL
13465: PUSH
13466: LD_INT 50
13468: PPUSH
13469: LD_EXP 24
13473: PPUSH
13474: CALL_OW 321
13478: PUSH
13479: LD_INT 2
13481: EQUAL
13482: AND
13483: PUSH
13484: LD_INT 53
13486: PPUSH
13487: LD_EXP 24
13491: PPUSH
13492: CALL_OW 321
13496: PUSH
13497: LD_INT 2
13499: EQUAL
13500: AND
13501: PUSH
13502: LD_INT 56
13504: PPUSH
13505: LD_EXP 24
13509: PPUSH
13510: CALL_OW 321
13514: PUSH
13515: LD_INT 2
13517: EQUAL
13518: AND
13519: PUSH
13520: LD_INT 65
13522: PPUSH
13523: LD_EXP 24
13527: PPUSH
13528: CALL_OW 321
13532: PUSH
13533: LD_INT 2
13535: EQUAL
13536: AND
13537: NOT
13538: IFFALSE 13541
// enable ;
13540: ENABLE
// end ; end_of_file
13541: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13542: GO 13544
13544: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13545: LD_ADDR_EXP 63
13549: PUSH
13550: LD_INT 14
13552: PUSH
13553: LD_INT 18
13555: PUSH
13556: LD_INT 19
13558: PUSH
13559: LD_INT 20
13561: PUSH
13562: LD_INT 21
13564: PUSH
13565: LD_INT 22
13567: PUSH
13568: LD_INT 23
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13580: LD_ADDR_EXP 64
13584: PUSH
13585: LD_INT 22
13587: PUSH
13588: LD_EXP 24
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: LD_INT 21
13599: PUSH
13600: LD_INT 3
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: PUSH
13616: LD_INT 14
13618: PUSH
13619: LD_INT 15
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: ADD
13626: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13627: LD_ADDR_EXP 65
13631: PUSH
13632: LD_INT 22
13634: PUSH
13635: LD_EXP 24
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PUSH
13644: LD_INT 30
13646: PUSH
13647: LD_INT 1
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PPUSH
13658: CALL_OW 69
13662: PUSH
13663: LD_INT 1
13665: ARRAY
13666: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13667: LD_ADDR_EXP 66
13671: PUSH
13672: LD_INT 22
13674: PUSH
13675: LD_EXP 24
13679: PUSH
13680: EMPTY
13681: LIST
13682: LIST
13683: PUSH
13684: LD_INT 30
13686: PUSH
13687: LD_INT 8
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PPUSH
13698: CALL_OW 69
13702: PUSH
13703: LD_INT 1
13705: ARRAY
13706: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13707: LD_ADDR_EXP 67
13711: PUSH
13712: LD_INT 22
13714: PUSH
13715: LD_EXP 24
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: PUSH
13724: LD_INT 30
13726: PUSH
13727: LD_INT 31
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PPUSH
13738: CALL_OW 69
13742: PUSH
13743: LD_INT 1
13745: ARRAY
13746: ST_TO_ADDR
// enable ( 401 ) ;
13747: LD_INT 401
13749: ENABLE_MARKED
// end ;
13750: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
13757: PPUSH
13758: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13759: LD_EXP 62
13763: PPUSH
13764: CALL_OW 386
13768: NOT
13769: IFFALSE 13824
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13771: LD_ADDR_EXP 62
13775: PUSH
13776: LD_INT 100
13778: PPUSH
13779: LD_EXP 63
13783: PPUSH
13784: LD_EXP 64
13788: PUSH
13789: LD_EXP 63
13793: ADD
13794: PPUSH
13795: LD_INT 1
13797: PUSH
13798: LD_INT 23
13800: PUSH
13801: EMPTY
13802: LIST
13803: LIST
13804: PUSH
13805: LD_INT 10
13807: PUSH
13808: LD_INT 22
13810: PUSH
13811: EMPTY
13812: LIST
13813: LIST
13814: PUSH
13815: EMPTY
13816: LIST
13817: LIST
13818: PPUSH
13819: CALL_OW 414
13823: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13824: LD_EXP 65
13828: PPUSH
13829: CALL_OW 300
13833: PUSH
13834: LD_EXP 66
13838: PPUSH
13839: CALL_OW 300
13843: OR
13844: PUSH
13845: LD_EXP 67
13849: PPUSH
13850: CALL_OW 300
13854: OR
13855: IFFALSE 14081
// begin for un in rus_mcrep_units do
13857: LD_ADDR_VAR 0 1
13861: PUSH
13862: LD_EXP 63
13866: PUSH
13867: FOR_IN
13868: IFFALSE 14079
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13870: LD_VAR 0 1
13874: PPUSH
13875: CALL_OW 388
13879: PUSH
13880: LD_INT 0
13882: EQUAL
13883: PUSH
13884: LD_VAR 0 1
13888: PPUSH
13889: CALL_OW 256
13893: PUSH
13894: LD_INT 1000
13896: EQUAL
13897: AND
13898: IFFALSE 14065
// case GetClass ( un ) of class_engineer :
13900: LD_VAR 0 1
13904: PPUSH
13905: CALL_OW 257
13909: PUSH
13910: LD_INT 2
13912: DOUBLE
13913: EQUAL
13914: IFTRUE 13918
13916: GO 13962
13918: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13919: LD_EXP 65
13923: PPUSH
13924: CALL_OW 300
13928: PUSH
13929: LD_EXP 65
13933: PPUSH
13934: CALL_OW 313
13938: PUSH
13939: LD_INT 6
13941: EQUAL
13942: NOT
13943: AND
13944: IFFALSE 13960
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13946: LD_VAR 0 1
13950: PPUSH
13951: LD_EXP 65
13955: PPUSH
13956: CALL_OW 120
13960: GO 14063
13962: LD_INT 4
13964: DOUBLE
13965: EQUAL
13966: IFTRUE 13970
13968: GO 14014
13970: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13971: LD_EXP 66
13975: PPUSH
13976: CALL_OW 300
13980: PUSH
13981: LD_EXP 66
13985: PPUSH
13986: CALL_OW 313
13990: PUSH
13991: LD_INT 6
13993: EQUAL
13994: NOT
13995: AND
13996: IFFALSE 14012
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13998: LD_VAR 0 1
14002: PPUSH
14003: LD_EXP 66
14007: PPUSH
14008: CALL_OW 120
14012: GO 14063
14014: LD_INT 1
14016: DOUBLE
14017: EQUAL
14018: IFTRUE 14022
14020: GO 14062
14022: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
14023: LD_EXP 67
14027: PPUSH
14028: CALL_OW 300
14032: PUSH
14033: LD_EXP 67
14037: PPUSH
14038: CALL_OW 313
14042: NOT
14043: AND
14044: IFFALSE 14060
// ComEnterUnit ( un , rus_breastwork ) ; end else
14046: LD_VAR 0 1
14050: PPUSH
14051: LD_EXP 67
14055: PPUSH
14056: CALL_OW 120
14060: GO 14063
14062: POP
14063: GO 14077
// ComMoveToArea ( un , BluekherRepairArea ) ;
14065: LD_VAR 0 1
14069: PPUSH
14070: LD_INT 23
14072: PPUSH
14073: CALL_OW 113
14077: GO 13867
14079: POP
14080: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
14081: LD_ADDR_VAR 0 3
14085: PUSH
14086: LD_INT 22
14088: PPUSH
14089: LD_INT 22
14091: PUSH
14092: LD_EXP 24
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: PUSH
14101: LD_INT 2
14103: PUSH
14104: LD_INT 25
14106: PUSH
14107: LD_INT 2
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: PUSH
14114: LD_INT 25
14116: PUSH
14117: LD_INT 4
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: PUSH
14124: EMPTY
14125: LIST
14126: LIST
14127: LIST
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: PPUSH
14133: CALL_OW 71
14137: ST_TO_ADDR
// if filter then
14138: LD_VAR 0 3
14142: IFFALSE 14159
// ComMoveXY ( filter , 48 , 88 ) ;
14144: LD_VAR 0 3
14148: PPUSH
14149: LD_INT 48
14151: PPUSH
14152: LD_INT 88
14154: PPUSH
14155: CALL_OW 111
// enable ;
14159: ENABLE
// end ; end_of_file
14160: PPOPN 3
14162: END
// every 0 0$2 + 0 0$0.1 do
14163: GO 14165
14165: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
14166: LD_INT 22
14168: PUSH
14169: LD_INT 7
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: PUSH
14176: LD_INT 2
14178: PUSH
14179: LD_INT 25
14181: PUSH
14182: LD_INT 12
14184: PUSH
14185: EMPTY
14186: LIST
14187: LIST
14188: PUSH
14189: LD_INT 25
14191: PUSH
14192: LD_INT 16
14194: PUSH
14195: EMPTY
14196: LIST
14197: LIST
14198: PUSH
14199: LD_INT 25
14201: PUSH
14202: LD_INT 15
14204: PUSH
14205: EMPTY
14206: LIST
14207: LIST
14208: PUSH
14209: LD_INT 25
14211: PUSH
14212: LD_INT 17
14214: PUSH
14215: EMPTY
14216: LIST
14217: LIST
14218: PUSH
14219: EMPTY
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: PPUSH
14230: CALL_OW 69
14234: PUSH
14235: LD_INT 22
14237: PUSH
14238: LD_INT 7
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PUSH
14245: LD_INT 21
14247: PUSH
14248: LD_INT 1
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: PUSH
14255: LD_INT 3
14257: PUSH
14258: LD_INT 2
14260: PUSH
14261: LD_INT 25
14263: PUSH
14264: LD_INT 12
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: LD_INT 25
14273: PUSH
14274: LD_INT 16
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_INT 25
14283: PUSH
14284: LD_INT 15
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: PUSH
14291: LD_INT 25
14293: PUSH
14294: LD_INT 17
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: PUSH
14301: EMPTY
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: LIST
14316: PPUSH
14317: CALL_OW 69
14321: GREATER
14322: IFFALSE 14333
// begin SetAchievement ( ACH_POTA ) ;
14324: LD_STRING ACH_POTA
14326: PPUSH
14327: CALL_OW 543
// exit ;
14331: GO 14334
// end ; enable ;
14333: ENABLE
// end ; end_of_file
14334: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14335: LD_INT 0
14337: PPUSH
14338: PPUSH
// if not missionNumber then
14339: LD_VAR 0 2
14343: NOT
14344: IFFALSE 14348
// exit ;
14346: GO 14478
// achiv := false ;
14348: LD_ADDR_VAR 0 7
14352: PUSH
14353: LD_INT 0
14355: ST_TO_ADDR
// case campaignNumber of 1 :
14356: LD_VAR 0 1
14360: PUSH
14361: LD_INT 1
14363: DOUBLE
14364: EQUAL
14365: IFTRUE 14369
14367: GO 14380
14369: POP
// achiv := ACH_GOTA ; 2 :
14370: LD_ADDR_VAR 0 7
14374: PUSH
14375: LD_STRING ACH_GOTA
14377: ST_TO_ADDR
14378: GO 14430
14380: LD_INT 2
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14391
14388: POP
// ; 3 :
14389: GO 14430
14391: LD_INT 3
14393: DOUBLE
14394: EQUAL
14395: IFTRUE 14399
14397: GO 14410
14399: POP
// achiv := ACH_MOTSU ; 4 :
14400: LD_ADDR_VAR 0 7
14404: PUSH
14405: LD_STRING ACH_MOTSU
14407: ST_TO_ADDR
14408: GO 14430
14410: LD_INT 4
14412: DOUBLE
14413: EQUAL
14414: IFTRUE 14418
14416: GO 14429
14418: POP
// achiv := ACH_LOP ; end ;
14419: LD_ADDR_VAR 0 7
14423: PUSH
14424: LD_STRING ACH_LOP
14426: ST_TO_ADDR
14427: GO 14430
14429: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14430: LD_OWVAR 67
14434: PUSH
14435: LD_INT 3
14437: EQUAL
14438: PUSH
14439: LD_VAR 0 7
14443: AND
14444: PUSH
14445: LD_VAR 0 3
14449: AND
14450: PUSH
14451: LD_VAR 0 4
14455: AND
14456: PUSH
14457: LD_VAR 0 5
14461: AND
14462: IFFALSE 14478
// SetAchievementEX ( achiv , missionNumber ) ;
14464: LD_VAR 0 7
14468: PPUSH
14469: LD_VAR 0 2
14473: PPUSH
14474: CALL_OW 564
// end ;
14478: LD_VAR 0 6
14482: RET
// export function SA_BehemothConstructed ; begin
14483: LD_INT 0
14485: PPUSH
// SetAchievement ( ACH_SMC ) ;
14486: LD_STRING ACH_SMC
14488: PPUSH
14489: CALL_OW 543
// end ;
14493: LD_VAR 0 1
14497: RET
