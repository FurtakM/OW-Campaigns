// export Burlak , Belkov , Gnyevko , Kirilenkova , Gleb , Petrosyan , Titov , Gossudarov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova , Platonov , RSoldier , survivors3 , you , rus , ally , usa , neutral , BurlakReachedBase , Pursuer , pursuers , pursuers_base , pursuers_skill , time , maxaut , straz_start , new , pausa , possible , all_possible , scientists , Player_units , RealMasha , Masha , RndArea , Straz , WasSelected , Goss_time , scientists_saved , scientists_dead , Artifact_cargo , bazooker , lost_masha , killed_russians , tick_tech_comp3 , tick_tech_tech3 , tick_tech_weap3 , tick_tech_sib3 , tick_tech_st3 ; export infantryCounter ; export attackGroup ; export attackAvalaible ; function read_parameters ; begin
   0: LD_INT 0
   2: PPUSH
// you := 7 ;
   3: LD_ADDR_EXP 23
   7: PUSH
   8: LD_INT 7
  10: ST_TO_ADDR
// rus := 3 ;
  11: LD_ADDR_EXP 24
  15: PUSH
  16: LD_INT 3
  18: ST_TO_ADDR
// ally := 6 ;
  19: LD_ADDR_EXP 25
  23: PUSH
  24: LD_INT 6
  26: ST_TO_ADDR
// usa := 1 ;
  27: LD_ADDR_EXP 26
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// neutral := 0 ;
  35: LD_ADDR_EXP 27
  39: PUSH
  40: LD_INT 0
  42: ST_TO_ADDR
// attackAvalaible = 0 ;
  43: LD_ADDR_EXP 61
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// infantryCounter = [ 24 , 30 , 36 ] [ Difficulty ] ;
  51: LD_ADDR_EXP 59
  55: PUSH
  56: LD_INT 24
  58: PUSH
  59: LD_INT 30
  61: PUSH
  62: LD_INT 36
  64: PUSH
  65: EMPTY
  66: LIST
  67: LIST
  68: LIST
  69: PUSH
  70: LD_OWVAR 67
  74: ARRAY
  75: ST_TO_ADDR
// attackGroup = [ ] ;
  76: LD_ADDR_EXP 60
  80: PUSH
  81: EMPTY
  82: ST_TO_ADDR
// SetAttitude ( you , rus , att_enemy , true ) ;
  83: LD_EXP 23
  87: PPUSH
  88: LD_EXP 24
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 1
  98: PPUSH
  99: CALL_OW 80
// SetAttitude ( you , ally , att_friend , true ) ;
 103: LD_EXP 23
 107: PPUSH
 108: LD_EXP 25
 112: PPUSH
 113: LD_INT 1
 115: PPUSH
 116: LD_INT 1
 118: PPUSH
 119: CALL_OW 80
// SetAttitude ( rus , ally , att_friend , true ) ;
 123: LD_EXP 24
 127: PPUSH
 128: LD_EXP 25
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: LD_INT 1
 138: PPUSH
 139: CALL_OW 80
// SetAttitude ( usa , you , att_friend , true ) ;
 143: LD_EXP 26
 147: PPUSH
 148: LD_EXP 23
 152: PPUSH
 153: LD_INT 1
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 80
// ChangeSideFog ( ally , you ) ;
 163: LD_EXP 25
 167: PPUSH
 168: LD_EXP 23
 172: PPUSH
 173: CALL_OW 343
// ChangeSideFog ( you , rus ) ;
 177: LD_EXP 23
 181: PPUSH
 182: LD_EXP 24
 186: PPUSH
 187: CALL_OW 343
// FogOff ( false ) ;
 191: LD_INT 0
 193: PPUSH
 194: CALL_OW 344
// Goss_time := 5 5$0 ;
 198: LD_ADDR_EXP 47
 202: PUSH
 203: LD_INT 10500
 205: ST_TO_ADDR
// scientists_saved := [ ] ;
 206: LD_ADDR_EXP 48
 210: PUSH
 211: EMPTY
 212: ST_TO_ADDR
// scientists_dead := [ ] ;
 213: LD_ADDR_EXP 49
 217: PUSH
 218: EMPTY
 219: ST_TO_ADDR
// bazooker := 3 ;
 220: LD_ADDR_EXP 51
 224: PUSH
 225: LD_INT 3
 227: ST_TO_ADDR
// BurlakReachedBase := false ;
 228: LD_ADDR_EXP 28
 232: PUSH
 233: LD_INT 0
 235: ST_TO_ADDR
// lost_masha := false ;
 236: LD_ADDR_EXP 52
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// killed_russians := 0 ;
 244: LD_ADDR_EXP 53
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// end ;
 252: LD_VAR 0 1
 256: RET
// function set_difficulty ; begin
 257: LD_INT 0
 259: PPUSH
// pursuers := [ 2 , 3 , 3 ] [ difficulty ] ;
 260: LD_ADDR_EXP 30
 264: PUSH
 265: LD_INT 2
 267: PUSH
 268: LD_INT 3
 270: PUSH
 271: LD_INT 3
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: ST_TO_ADDR
// pursuers_base := [ 4 , 3 , 2 ] [ difficulty ] ;
 285: LD_ADDR_EXP 31
 289: PUSH
 290: LD_INT 4
 292: PUSH
 293: LD_INT 3
 295: PUSH
 296: LD_INT 2
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: PUSH
 304: LD_OWVAR 67
 308: ARRAY
 309: ST_TO_ADDR
// pursuers_skill := [ 3 , 4 , 5 ] [ difficulty ] ;
 310: LD_ADDR_EXP 32
 314: PUSH
 315: LD_INT 3
 317: PUSH
 318: LD_INT 4
 320: PUSH
 321: LD_INT 5
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: PUSH
 329: LD_OWVAR 67
 333: ARRAY
 334: ST_TO_ADDR
// pausa := [ 0 0$50 , 0 0$45 , 0 0$40 ] [ difficulty ] ;
 335: LD_ADDR_EXP 37
 339: PUSH
 340: LD_INT 1750
 342: PUSH
 343: LD_INT 1575
 345: PUSH
 346: LD_INT 1400
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: LIST
 353: PUSH
 354: LD_OWVAR 67
 358: ARRAY
 359: ST_TO_ADDR
// time := [ 12 12$0 , 10 10$0 , 8 8$0 ] [ difficulty ] ;
 360: LD_ADDR_EXP 33
 364: PUSH
 365: LD_INT 25200
 367: PUSH
 368: LD_INT 21000
 370: PUSH
 371: LD_INT 16800
 373: PUSH
 374: EMPTY
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_OWVAR 67
 383: ARRAY
 384: ST_TO_ADDR
// maxaut := [ 4 , 6 , 9 ] [ difficulty ] ;
 385: LD_ADDR_EXP 34
 389: PUSH
 390: LD_INT 4
 392: PUSH
 393: LD_INT 6
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: ST_TO_ADDR
// straz_start := [ 7 7$0 , 4 4$0 , 2 2$0 ] [ difficulty ] ;
 410: LD_ADDR_EXP 35
 414: PUSH
 415: LD_INT 14700
 417: PUSH
 418: LD_INT 8400
 420: PUSH
 421: LD_INT 4200
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_OWVAR 67
 433: ARRAY
 434: ST_TO_ADDR
// tick_tech_sib3 := [ 60 60$0 , 50 50$0 , 40 40$0 ] [ difficulty ] ;
 435: LD_ADDR_EXP 57
 439: PUSH
 440: LD_INT 126000
 442: PUSH
 443: LD_INT 105000
 445: PUSH
 446: LD_INT 84000
 448: PUSH
 449: EMPTY
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_OWVAR 67
 458: ARRAY
 459: ST_TO_ADDR
// tick_tech_st3 := [ 55 55$0 , 45 45$0 , 35 35$0 ] [ difficulty ] ;
 460: LD_ADDR_EXP 58
 464: PUSH
 465: LD_INT 115500
 467: PUSH
 468: LD_INT 94500
 470: PUSH
 471: LD_INT 73500
 473: PUSH
 474: EMPTY
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_OWVAR 67
 483: ARRAY
 484: ST_TO_ADDR
// tick_tech_weap3 := [ 50 50$0 , 40 40$0 , 30 30$0 ] [ difficulty ] ;
 485: LD_ADDR_EXP 56
 489: PUSH
 490: LD_INT 105000
 492: PUSH
 493: LD_INT 84000
 495: PUSH
 496: LD_INT 63000
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_OWVAR 67
 508: ARRAY
 509: ST_TO_ADDR
// tick_tech_comp3 := [ 45 45$0 , 35 35$0 , 25 25$0 ] [ difficulty ] ;
 510: LD_ADDR_EXP 54
 514: PUSH
 515: LD_INT 94500
 517: PUSH
 518: LD_INT 73500
 520: PUSH
 521: LD_INT 52500
 523: PUSH
 524: EMPTY
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_OWVAR 67
 533: ARRAY
 534: ST_TO_ADDR
// tick_tech_tech3 := [ 40 40$0 , 30 30$0 , 20 20$0 ] [ difficulty ] ;
 535: LD_ADDR_EXP 55
 539: PUSH
 540: LD_INT 84000
 542: PUSH
 543: LD_INT 63000
 545: PUSH
 546: LD_INT 42000
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: PUSH
 554: LD_OWVAR 67
 558: ARRAY
 559: ST_TO_ADDR
// end ;
 560: LD_VAR 0 1
 564: RET
// function read_people ( ident ) ; begin
 565: LD_INT 0
 567: PPUSH
// if CheckCharacterSet ( ident ) then
 568: LD_VAR 0 1
 572: PPUSH
 573: CALL_OW 29
 577: IFFALSE 596
// result := CreateCharacter ( ident ) else
 579: LD_ADDR_VAR 0 2
 583: PUSH
 584: LD_VAR 0 1
 588: PPUSH
 589: CALL_OW 34
 593: ST_TO_ADDR
 594: GO 604
// result := 0 ;
 596: LD_ADDR_VAR 0 2
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 2
 608: RET
// function create_people ; var un , i , j , skill ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
 613: PPUSH
 614: PPUSH
 615: PPUSH
// uc_side = ally ;
 616: LD_ADDR_OWVAR 20
 620: PUSH
 621: LD_EXP 25
 625: ST_TO_ADDR
// uc_nation := nation_russian ;
 626: LD_ADDR_OWVAR 21
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// Gossudarov := read_people ( Gossudarov ) ;
 634: LD_ADDR_EXP 8
 638: PUSH
 639: LD_STRING Gossudarov
 641: PPUSH
 642: CALL 565 0 1
 646: ST_TO_ADDR
// PlaceUnitXY ( Gossudarov , 55 , 89 , false ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_INT 55
 654: PPUSH
 655: LD_INT 89
 657: PPUSH
 658: LD_INT 0
 660: PPUSH
 661: CALL_OW 48
// ComHold ( Gossudarov ) ;
 665: LD_EXP 8
 669: PPUSH
 670: CALL_OW 140
// uc_side = rus ;
 674: LD_ADDR_OWVAR 20
 678: PUSH
 679: LD_EXP 24
 683: ST_TO_ADDR
// uc_nation := nation_russian ;
 684: LD_ADDR_OWVAR 21
 688: PUSH
 689: LD_INT 3
 691: ST_TO_ADDR
// Belkov := read_people ( Belkov ) ;
 692: LD_ADDR_EXP 2
 696: PUSH
 697: LD_STRING Belkov
 699: PPUSH
 700: CALL 565 0 1
 704: ST_TO_ADDR
// Gnyevko := read_people ( Gnyevko ) ;
 705: LD_ADDR_EXP 3
 709: PUSH
 710: LD_STRING Gnyevko
 712: PPUSH
 713: CALL 565 0 1
 717: ST_TO_ADDR
// Kirilenkova := read_people ( Kirilenkova ) ;
 718: LD_ADDR_EXP 4
 722: PUSH
 723: LD_STRING Kirilenkova
 725: PPUSH
 726: CALL 565 0 1
 730: ST_TO_ADDR
// Gleb := read_people ( Gleb ) ;
 731: LD_ADDR_EXP 5
 735: PUSH
 736: LD_STRING Gleb
 738: PPUSH
 739: CALL 565 0 1
 743: ST_TO_ADDR
// Petrosyan := read_people ( Petrosyan ) ;
 744: LD_ADDR_EXP 6
 748: PUSH
 749: LD_STRING Petrosyan
 751: PPUSH
 752: CALL 565 0 1
 756: ST_TO_ADDR
// Titov := read_people ( Titov ) ;
 757: LD_ADDR_EXP 7
 761: PUSH
 762: LD_STRING Titov
 764: PPUSH
 765: CALL 565 0 1
 769: ST_TO_ADDR
// Kovalyuk := read_people ( Kovalyuk ) ;
 770: LD_ADDR_EXP 9
 774: PUSH
 775: LD_STRING Kovalyuk
 777: PPUSH
 778: CALL 565 0 1
 782: ST_TO_ADDR
// Scholtze := read_people ( Scholtze ) ;
 783: LD_ADDR_EXP 10
 787: PUSH
 788: LD_STRING Scholtze
 790: PPUSH
 791: CALL 565 0 1
 795: ST_TO_ADDR
// Kuzmov := read_people ( Kuzmov ) ;
 796: LD_ADDR_EXP 11
 800: PUSH
 801: LD_STRING Kuzmov
 803: PPUSH
 804: CALL 565 0 1
 808: ST_TO_ADDR
// Karamazov := read_people ( Karamazov ) ;
 809: LD_ADDR_EXP 12
 813: PUSH
 814: LD_STRING Karamazov
 816: PPUSH
 817: CALL 565 0 1
 821: ST_TO_ADDR
// Petrovova := read_people ( Petrovova ) ;
 822: LD_ADDR_EXP 13
 826: PUSH
 827: LD_STRING Petrovova
 829: PPUSH
 830: CALL 565 0 1
 834: ST_TO_ADDR
// Lipshchin := read_people ( Lipschin ) ;
 835: LD_ADDR_EXP 14
 839: PUSH
 840: LD_STRING Lipschin
 842: PPUSH
 843: CALL 565 0 1
 847: ST_TO_ADDR
// Dolgov := read_people ( Dolgov ) ;
 848: LD_ADDR_EXP 15
 852: PUSH
 853: LD_STRING Dolgov
 855: PPUSH
 856: CALL 565 0 1
 860: ST_TO_ADDR
// Xavier := read_people ( Xavier ) ;
 861: LD_ADDR_EXP 16
 865: PUSH
 866: LD_STRING Xavier
 868: PPUSH
 869: CALL 565 0 1
 873: ST_TO_ADDR
// Oblukov := read_people ( Oblukov ) ;
 874: LD_ADDR_EXP 17
 878: PUSH
 879: LD_STRING Oblukov
 881: PPUSH
 882: CALL 565 0 1
 886: ST_TO_ADDR
// Kozlov := read_people ( Kozlov ) ;
 887: LD_ADDR_EXP 18
 891: PUSH
 892: LD_STRING Kozlov
 894: PPUSH
 895: CALL 565 0 1
 899: ST_TO_ADDR
// Kapitsova := read_people ( Kapitsova ) ;
 900: LD_ADDR_EXP 19
 904: PUSH
 905: LD_STRING Kapitsova
 907: PPUSH
 908: CALL 565 0 1
 912: ST_TO_ADDR
// all_possible := [ Gnyevko , Belkov , Kirilenkova , Gleb , Petrosyan , Titov , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Lipshchin , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] diff 0 ;
 913: LD_ADDR_EXP 39
 917: PUSH
 918: LD_EXP 3
 922: PUSH
 923: LD_EXP 2
 927: PUSH
 928: LD_EXP 4
 932: PUSH
 933: LD_EXP 5
 937: PUSH
 938: LD_EXP 6
 942: PUSH
 943: LD_EXP 7
 947: PUSH
 948: LD_EXP 9
 952: PUSH
 953: LD_EXP 10
 957: PUSH
 958: LD_EXP 11
 962: PUSH
 963: LD_EXP 12
 967: PUSH
 968: LD_EXP 13
 972: PUSH
 973: LD_EXP 14
 977: PUSH
 978: LD_EXP 15
 982: PUSH
 983: LD_EXP 16
 987: PUSH
 988: LD_EXP 17
 992: PUSH
 993: LD_EXP 18
 997: PUSH
 998: LD_EXP 19
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 0
1024: DIFF
1025: ST_TO_ADDR
// survivors3 = [ ] ;
1026: LD_ADDR_EXP 22
1030: PUSH
1031: EMPTY
1032: ST_TO_ADDR
// if CheckCharacterSet ( survivors3 ) then
1033: LD_STRING survivors3
1035: PPUSH
1036: CALL_OW 29
1040: IFFALSE 1055
// survivors3 = CreateCharacterSet ( survivors3 ) ;
1042: LD_ADDR_EXP 22
1046: PUSH
1047: LD_STRING survivors3
1049: PPUSH
1050: CALL_OW 31
1054: ST_TO_ADDR
// for i in all_possible ^ survivors3 do
1055: LD_ADDR_VAR 0 3
1059: PUSH
1060: LD_EXP 39
1064: PUSH
1065: LD_EXP 22
1069: ADD
1070: PUSH
1071: FOR_IN
1072: IFFALSE 1217
// begin skill = 0 ;
1074: LD_ADDR_VAR 0 5
1078: PUSH
1079: LD_INT 0
1081: ST_TO_ADDR
// for j = 1 to 4 do
1082: LD_ADDR_VAR 0 4
1086: PUSH
1087: DOUBLE
1088: LD_INT 1
1090: DEC
1091: ST_TO_ADDR
1092: LD_INT 4
1094: PUSH
1095: FOR_TO
1096: IFFALSE 1213
// if GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) >= skill then
1098: LD_VAR 0 3
1102: PPUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: LD_INT 3
1111: PUSH
1112: LD_INT 4
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: PUSH
1121: LD_VAR 0 4
1125: ARRAY
1126: PPUSH
1127: CALL_OW 259
1131: PUSH
1132: LD_VAR 0 5
1136: GREATEREQUAL
1137: IFFALSE 1211
// begin skill = GetSkill ( i , [ skill_combat , skill_engineering , skill_mechanical , skill_scientistic ] [ j ] ) ;
1139: LD_ADDR_VAR 0 5
1143: PUSH
1144: LD_VAR 0 3
1148: PPUSH
1149: LD_INT 1
1151: PUSH
1152: LD_INT 2
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 4
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: PUSH
1167: LD_VAR 0 4
1171: ARRAY
1172: PPUSH
1173: CALL_OW 259
1177: ST_TO_ADDR
// SetClass ( i , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] [ j ] ) ;
1178: LD_VAR 0 3
1182: PPUSH
1183: LD_INT 1
1185: PUSH
1186: LD_INT 2
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: LD_INT 4
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_VAR 0 4
1205: ARRAY
1206: PPUSH
1207: CALL_OW 336
// end ;
1211: GO 1095
1213: POP
1214: POP
// end ;
1215: GO 1071
1217: POP
1218: POP
// scientists := UnitFilter ( all_possible ^ survivors3 , [ f_class , class_scientistic ] ) ;
1219: LD_ADDR_EXP 40
1223: PUSH
1224: LD_EXP 39
1228: PUSH
1229: LD_EXP 22
1233: ADD
1234: PPUSH
1235: LD_INT 25
1237: PUSH
1238: LD_INT 4
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: PPUSH
1245: CALL_OW 72
1249: ST_TO_ADDR
// while scientists > 5 do
1250: LD_EXP 40
1254: PUSH
1255: LD_INT 5
1257: GREATER
1258: IFFALSE 1286
// scientists = Delete ( scientists , scientists + 0 ) ;
1260: LD_ADDR_EXP 40
1264: PUSH
1265: LD_EXP 40
1269: PPUSH
1270: LD_EXP 40
1274: PUSH
1275: LD_INT 0
1277: PLUS
1278: PPUSH
1279: CALL_OW 3
1283: ST_TO_ADDR
1284: GO 1250
// survivors3 = survivors3 diff scientists ;
1286: LD_ADDR_EXP 22
1290: PUSH
1291: LD_EXP 22
1295: PUSH
1296: LD_EXP 40
1300: DIFF
1301: ST_TO_ADDR
// if scientists < 5 then
1302: LD_EXP 40
1306: PUSH
1307: LD_INT 5
1309: LESS
1310: IFFALSE 1401
// for i := 1 to 5 - scientists do
1312: LD_ADDR_VAR 0 3
1316: PUSH
1317: DOUBLE
1318: LD_INT 1
1320: DEC
1321: ST_TO_ADDR
1322: LD_INT 5
1324: PUSH
1325: LD_EXP 40
1329: MINUS
1330: PUSH
1331: FOR_TO
1332: IFFALSE 1399
// begin uc_side = ally ;
1334: LD_ADDR_OWVAR 20
1338: PUSH
1339: LD_EXP 25
1343: ST_TO_ADDR
// uc_nation := nation_russian ;
1344: LD_ADDR_OWVAR 21
1348: PUSH
1349: LD_INT 3
1351: ST_TO_ADDR
// PrepareHuman ( 0 , class_scientistic , Rand ( 5 , 7 ) ) ;
1352: LD_INT 0
1354: PPUSH
1355: LD_INT 4
1357: PPUSH
1358: LD_INT 5
1360: PPUSH
1361: LD_INT 7
1363: PPUSH
1364: CALL_OW 12
1368: PPUSH
1369: CALL_OW 380
// hc_name :=  ;
1373: LD_ADDR_OWVAR 26
1377: PUSH
1378: LD_STRING 
1380: ST_TO_ADDR
// scientists := scientists ^ CreateHuman ;
1381: LD_ADDR_EXP 40
1385: PUSH
1386: LD_EXP 40
1390: PUSH
1391: CALL_OW 44
1395: ADD
1396: ST_TO_ADDR
// end ;
1397: GO 1331
1399: POP
1400: POP
// for un in scientists do
1401: LD_ADDR_VAR 0 2
1405: PUSH
1406: LD_EXP 40
1410: PUSH
1411: FOR_IN
1412: IFFALSE 1430
// SetSide ( un , ally ) ;
1414: LD_VAR 0 2
1418: PPUSH
1419: LD_EXP 25
1423: PPUSH
1424: CALL_OW 235
1428: GO 1411
1430: POP
1431: POP
// possible := all_possible diff scientists ;
1432: LD_ADDR_EXP 38
1436: PUSH
1437: LD_EXP 39
1441: PUSH
1442: LD_EXP 40
1446: DIFF
1447: ST_TO_ADDR
// if scientists > 5 then
1448: LD_EXP 40
1452: PUSH
1453: LD_INT 5
1455: GREATER
1456: IFFALSE 1500
// for i = scientists downto 5 do
1458: LD_ADDR_VAR 0 3
1462: PUSH
1463: DOUBLE
1464: LD_EXP 40
1468: INC
1469: ST_TO_ADDR
1470: LD_INT 5
1472: PUSH
1473: FOR_DOWNTO
1474: IFFALSE 1498
// scientists := Delete ( scientists , i ) ;
1476: LD_ADDR_EXP 40
1480: PUSH
1481: LD_EXP 40
1485: PPUSH
1486: LD_VAR 0 3
1490: PPUSH
1491: CALL_OW 3
1495: ST_TO_ADDR
1496: GO 1473
1498: POP
1499: POP
// for un in scientists do
1500: LD_ADDR_VAR 0 2
1504: PUSH
1505: LD_EXP 40
1509: PUSH
1510: FOR_IN
1511: IFFALSE 1527
// PlaceHumanInUnit ( un , 2 ) ;
1513: LD_VAR 0 2
1517: PPUSH
1518: LD_INT 2
1520: PPUSH
1521: CALL_OW 52
1525: GO 1510
1527: POP
1528: POP
// new := [ ] ;
1529: LD_ADDR_EXP 36
1533: PUSH
1534: EMPTY
1535: ST_TO_ADDR
// if possible < 10 then
1536: LD_EXP 38
1540: PUSH
1541: LD_INT 10
1543: LESS
1544: IFFALSE 1627
// for i := 1 to 10 - possible do
1546: LD_ADDR_VAR 0 3
1550: PUSH
1551: DOUBLE
1552: LD_INT 1
1554: DEC
1555: ST_TO_ADDR
1556: LD_INT 10
1558: PUSH
1559: LD_EXP 38
1563: MINUS
1564: PUSH
1565: FOR_TO
1566: IFFALSE 1625
// begin uc_side = rus ;
1568: LD_ADDR_OWVAR 20
1572: PUSH
1573: LD_EXP 24
1577: ST_TO_ADDR
// uc_nation := nation_russian ;
1578: LD_ADDR_OWVAR 21
1582: PUSH
1583: LD_INT 3
1585: ST_TO_ADDR
// PrepareHuman ( 0 , 0 , 5 ) ;
1586: LD_INT 0
1588: PPUSH
1589: LD_INT 0
1591: PPUSH
1592: LD_INT 5
1594: PPUSH
1595: CALL_OW 380
// hc_name :=  ;
1599: LD_ADDR_OWVAR 26
1603: PUSH
1604: LD_STRING 
1606: ST_TO_ADDR
// new := new ^ CreateHuman ;
1607: LD_ADDR_EXP 36
1611: PUSH
1612: LD_EXP 36
1616: PUSH
1617: CALL_OW 44
1621: ADD
1622: ST_TO_ADDR
// end ;
1623: GO 1565
1625: POP
1626: POP
// uc_side = rus ;
1627: LD_ADDR_OWVAR 20
1631: PUSH
1632: LD_EXP 24
1636: ST_TO_ADDR
// uc_nation := nation_russian ;
1637: LD_ADDR_OWVAR 21
1641: PUSH
1642: LD_INT 3
1644: ST_TO_ADDR
// Burlak := read_people ( Burlak ) ;
1645: LD_ADDR_EXP 1
1649: PUSH
1650: LD_STRING Burlak
1652: PPUSH
1653: CALL 565 0 1
1657: ST_TO_ADDR
// SetClass ( Burlak , 3 ) ;
1658: LD_EXP 1
1662: PPUSH
1663: LD_INT 3
1665: PPUSH
1666: CALL_OW 336
// Platonov := NewCharacter ( Platonov ) ;
1670: LD_ADDR_EXP 20
1674: PUSH
1675: LD_STRING Platonov
1677: PPUSH
1678: CALL_OW 25
1682: ST_TO_ADDR
// PrepareHuman ( sex_male , class_soldier , 4 ) ;
1683: LD_INT 1
1685: PPUSH
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 4
1691: PPUSH
1692: CALL_OW 380
// hc_name :=  ;
1696: LD_ADDR_OWVAR 26
1700: PUSH
1701: LD_STRING 
1703: ST_TO_ADDR
// RSoldier := CreateHuman ;
1704: LD_ADDR_EXP 21
1708: PUSH
1709: CALL_OW 44
1713: ST_TO_ADDR
// for i := 1 to pursuers_base + 3 * pursuers do
1714: LD_ADDR_VAR 0 3
1718: PUSH
1719: DOUBLE
1720: LD_INT 1
1722: DEC
1723: ST_TO_ADDR
1724: LD_EXP 31
1728: PUSH
1729: LD_INT 3
1731: PUSH
1732: LD_EXP 30
1736: MUL
1737: PLUS
1738: PUSH
1739: FOR_TO
1740: IFFALSE 1832
// begin case Rand ( 1 , 2 ) of 1 :
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: CALL_OW 12
1752: PUSH
1753: LD_INT 1
1755: DOUBLE
1756: EQUAL
1757: IFTRUE 1761
1759: GO 1779
1761: POP
// PrepareHuman ( sex_male , class_soldier , pursuers_skill ) ; 2 :
1762: LD_INT 1
1764: PPUSH
1765: LD_INT 1
1767: PPUSH
1768: LD_EXP 32
1772: PPUSH
1773: CALL_OW 380
1777: GO 1806
1779: LD_INT 2
1781: DOUBLE
1782: EQUAL
1783: IFTRUE 1787
1785: GO 1805
1787: POP
// PrepareHuman ( sex_male , class_bazooker , pursuers_skill ) ; end ;
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_EXP 32
1798: PPUSH
1799: CALL_OW 380
1803: GO 1806
1805: POP
// hc_name :=  ;
1806: LD_ADDR_OWVAR 26
1810: PUSH
1811: LD_STRING 
1813: ST_TO_ADDR
// Pursuer := Pursuer ^ CreateHuman ;
1814: LD_ADDR_EXP 29
1818: PUSH
1819: LD_EXP 29
1823: PUSH
1824: CALL_OW 44
1828: ADD
1829: ST_TO_ADDR
// end ;
1830: GO 1739
1832: POP
1833: POP
// end ;
1834: LD_VAR 0 1
1838: RET
// function select_people ; var units , un ; begin
1839: LD_INT 0
1841: PPUSH
1842: PPUSH
1843: PPUSH
// player_units = CharacterSelection (  , 5 , 5 , [ sel_hired , sel_not_changeable , sel_dont_change_class ] ^ Burlak ^ [ sel_not_hired , sel_not_changeable , sel_dont_change_class ] ^ Platonov ^ [ sel_not_hired , sel_change_class , sel_changeable ] ^ possible ^ survivors3 ^ new , [ class_soldier , class_mechanic , class_engineer , class_scientistic , [ class_bazooker , 0 , 2 ] ] ) ;
1844: LD_ADDR_EXP 41
1848: PUSH
1849: LD_STRING 
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 5
1857: PPUSH
1858: LD_INT -1
1860: PUSH
1861: LD_INT -4
1863: PUSH
1864: LD_INT -6
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: PUSH
1872: LD_EXP 1
1876: ADD
1877: PUSH
1878: LD_INT -2
1880: PUSH
1881: LD_INT -4
1883: PUSH
1884: LD_INT -6
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: LIST
1891: ADD
1892: PUSH
1893: LD_EXP 20
1897: ADD
1898: PUSH
1899: LD_INT -2
1901: PUSH
1902: LD_INT -5
1904: PUSH
1905: LD_INT -3
1907: PUSH
1908: EMPTY
1909: LIST
1910: LIST
1911: LIST
1912: ADD
1913: PUSH
1914: LD_EXP 38
1918: ADD
1919: PUSH
1920: LD_EXP 22
1924: ADD
1925: PUSH
1926: LD_EXP 36
1930: ADD
1931: PPUSH
1932: LD_INT 1
1934: PUSH
1935: LD_INT 3
1937: PUSH
1938: LD_INT 2
1940: PUSH
1941: LD_INT 4
1943: PUSH
1944: LD_INT 9
1946: PUSH
1947: LD_INT 0
1949: PUSH
1950: LD_INT 2
1952: PUSH
1953: EMPTY
1954: LIST
1955: LIST
1956: LIST
1957: PUSH
1958: EMPTY
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: LIST
1964: PPUSH
1965: CALL_OW 42
1969: ST_TO_ADDR
// SetSide ( ( player_units diff Burlak ) , neutral ) ;
1970: LD_EXP 41
1974: PUSH
1975: LD_EXP 1
1979: DIFF
1980: PPUSH
1981: LD_EXP 27
1985: PPUSH
1986: CALL_OW 235
// for un in ( player_units diff Burlak ) do
1990: LD_ADDR_VAR 0 3
1994: PUSH
1995: LD_EXP 41
1999: PUSH
2000: LD_EXP 1
2004: DIFF
2005: PUSH
2006: FOR_IN
2007: IFFALSE 2026
// PlaceUnitArea ( un , BaseArea , false ) ;
2009: LD_VAR 0 3
2013: PPUSH
2014: LD_INT 2
2016: PPUSH
2017: LD_INT 0
2019: PPUSH
2020: CALL_OW 49
2024: GO 2006
2026: POP
2027: POP
// end ;
2028: LD_VAR 0 1
2032: RET
// var MashaWanted ; function place_masha ; var veh , esc , Chassis , Weapon ; begin
2033: LD_INT 0
2035: PPUSH
2036: PPUSH
2037: PPUSH
2038: PPUSH
2039: PPUSH
// esc := LoadVariable ( EscapeVehicle_12a , [ 1 , 0 , 0 ] ) ;
2040: LD_ADDR_VAR 0 3
2044: PUSH
2045: LD_STRING EscapeVehicle_12a
2047: PPUSH
2048: LD_INT 1
2050: PUSH
2051: LD_INT 0
2053: PUSH
2054: LD_INT 0
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: LIST
2061: PPUSH
2062: CALL_OW 30
2066: ST_TO_ADDR
// MashaWanted := esc [ 1 ] ;
2067: LD_ADDR_LOC 1
2071: PUSH
2072: LD_VAR 0 3
2076: PUSH
2077: LD_INT 1
2079: ARRAY
2080: ST_TO_ADDR
// Chassis := esc [ 2 ] ;
2081: LD_ADDR_VAR 0 4
2085: PUSH
2086: LD_VAR 0 3
2090: PUSH
2091: LD_INT 2
2093: ARRAY
2094: ST_TO_ADDR
// Weapon := esc [ 3 ] ;
2095: LD_ADDR_VAR 0 5
2099: PUSH
2100: LD_VAR 0 3
2104: PUSH
2105: LD_INT 3
2107: ARRAY
2108: ST_TO_ADDR
// if MashaWanted then
2109: LD_LOC 1
2113: IFFALSE 2317
// begin veh := LoadVariable ( Masha , false ) ;
2115: LD_ADDR_VAR 0 2
2119: PUSH
2120: LD_STRING Masha
2122: PPUSH
2123: LD_INT 0
2125: PPUSH
2126: CALL_OW 30
2130: ST_TO_ADDR
// if veh then
2131: LD_VAR 0 2
2135: IFFALSE 2239
// begin uc_side := rus ;
2137: LD_ADDR_OWVAR 20
2141: PUSH
2142: LD_EXP 24
2146: ST_TO_ADDR
// uc_nation := nation_russian ;
2147: LD_ADDR_OWVAR 21
2151: PUSH
2152: LD_INT 3
2154: ST_TO_ADDR
// uc_direction := 2 ;
2155: LD_ADDR_OWVAR 24
2159: PUSH
2160: LD_INT 2
2162: ST_TO_ADDR
// vc_chassis := veh [ 1 ] ;
2163: LD_ADDR_OWVAR 37
2167: PUSH
2168: LD_VAR 0 2
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: ST_TO_ADDR
// vc_engine := veh [ 2 ] ;
2177: LD_ADDR_OWVAR 39
2181: PUSH
2182: LD_VAR 0 2
2186: PUSH
2187: LD_INT 2
2189: ARRAY
2190: ST_TO_ADDR
// vc_control := veh [ 3 ] ;
2191: LD_ADDR_OWVAR 38
2195: PUSH
2196: LD_VAR 0 2
2200: PUSH
2201: LD_INT 3
2203: ARRAY
2204: ST_TO_ADDR
// vc_weapon := veh [ 4 ] ;
2205: LD_ADDR_OWVAR 40
2209: PUSH
2210: LD_VAR 0 2
2214: PUSH
2215: LD_INT 4
2217: ARRAY
2218: ST_TO_ADDR
// RealMasha := true ;
2219: LD_ADDR_EXP 42
2223: PUSH
2224: LD_INT 1
2226: ST_TO_ADDR
// Masha := CreateVehicle ;
2227: LD_ADDR_EXP 43
2231: PUSH
2232: CALL_OW 45
2236: ST_TO_ADDR
// end else
2237: GO 2315
// begin uc_side := rus ;
2239: LD_ADDR_OWVAR 20
2243: PUSH
2244: LD_EXP 24
2248: ST_TO_ADDR
// uc_nation := nation_russian ;
2249: LD_ADDR_OWVAR 21
2253: PUSH
2254: LD_INT 3
2256: ST_TO_ADDR
// uc_direction := 2 ;
2257: LD_ADDR_OWVAR 24
2261: PUSH
2262: LD_INT 2
2264: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
2265: LD_ADDR_OWVAR 37
2269: PUSH
2270: LD_INT 22
2272: ST_TO_ADDR
// vc_engine := engine_siberite ;
2273: LD_ADDR_OWVAR 39
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
2281: LD_ADDR_OWVAR 40
2285: PUSH
2286: LD_INT 43
2288: ST_TO_ADDR
// vc_control := control_manual ;
2289: LD_ADDR_OWVAR 38
2293: PUSH
2294: LD_INT 1
2296: ST_TO_ADDR
// RealMasha := false ;
2297: LD_ADDR_EXP 42
2301: PUSH
2302: LD_INT 0
2304: ST_TO_ADDR
// Masha := CreateVehicle ;
2305: LD_ADDR_EXP 43
2309: PUSH
2310: CALL_OW 45
2314: ST_TO_ADDR
// end ; end else
2315: GO 2397
// begin uc_side := rus ;
2317: LD_ADDR_OWVAR 20
2321: PUSH
2322: LD_EXP 24
2326: ST_TO_ADDR
// uc_nation := nation_russian ;
2327: LD_ADDR_OWVAR 21
2331: PUSH
2332: LD_INT 3
2334: ST_TO_ADDR
// uc_direction := 2 ;
2335: LD_ADDR_OWVAR 24
2339: PUSH
2340: LD_INT 2
2342: ST_TO_ADDR
// vc_chassis := Chassis ;
2343: LD_ADDR_OWVAR 37
2347: PUSH
2348: LD_VAR 0 4
2352: ST_TO_ADDR
// vc_engine := engine_siberite ;
2353: LD_ADDR_OWVAR 39
2357: PUSH
2358: LD_INT 3
2360: ST_TO_ADDR
// vc_weapon := Weapon ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_VAR 0 5
2370: ST_TO_ADDR
// vc_control := control_manual ;
2371: LD_ADDR_OWVAR 38
2375: PUSH
2376: LD_INT 1
2378: ST_TO_ADDR
// RealMasha := false ;
2379: LD_ADDR_EXP 42
2383: PUSH
2384: LD_INT 0
2386: ST_TO_ADDR
// Masha := CreateVehicle ;
2387: LD_ADDR_EXP 43
2391: PUSH
2392: CALL_OW 45
2396: ST_TO_ADDR
// end ; SetMark ( Masha , 1 ) ;
2397: LD_EXP 43
2401: PPUSH
2402: LD_INT 1
2404: PPUSH
2405: CALL_OW 242
// if GetEngine ( Masha ) <> engine_siberite then
2409: LD_EXP 43
2413: PPUSH
2414: CALL_OW 262
2418: PUSH
2419: LD_INT 3
2421: NONEQUAL
2422: IFFALSE 2444
// SetFuel ( Masha , Rand ( 70 , 95 ) ) ;
2424: LD_EXP 43
2428: PPUSH
2429: LD_INT 70
2431: PPUSH
2432: LD_INT 95
2434: PPUSH
2435: CALL_OW 12
2439: PPUSH
2440: CALL_OW 240
// PlaceUnitXY ( Masha , 47 , 87 , false ) ;
2444: LD_EXP 43
2448: PPUSH
2449: LD_INT 47
2451: PPUSH
2452: LD_INT 87
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL_OW 48
// end ;
2462: LD_VAR 0 1
2466: RET
// var i ; starting begin SetBName ( 1 , bluekher ) ;
2467: LD_INT 1
2469: PPUSH
2470: LD_STRING bluekher
2472: PPUSH
2473: CALL_OW 500
// IngameOn ;
2477: CALL_OW 8
// Randomize ;
2481: CALL_OW 10
// RandomizeAll ;
2485: CALL_OW 11
// InitBc ;
2489: CALL_OW 21
// InitHc ;
2493: CALL_OW 19
// InitUc ;
2497: CALL_OW 18
// InitVc ;
2501: CALL_OW 20
// disable ( 1 ) ;
2505: LD_INT 1
2507: DISABLE_MARKED
// disable ( 2 ) ;
2508: LD_INT 2
2510: DISABLE_MARKED
// disable ( 3 ) ;
2511: LD_INT 3
2513: DISABLE_MARKED
// disable ( 4 ) ;
2514: LD_INT 4
2516: DISABLE_MARKED
// disable ( 6 ) ;
2517: LD_INT 6
2519: DISABLE_MARKED
// disable ( 7 ) ;
2520: LD_INT 7
2522: DISABLE_MARKED
// disable ( 8 ) ;
2523: LD_INT 8
2525: DISABLE_MARKED
// disable ( 9 ) ;
2526: LD_INT 9
2528: DISABLE_MARKED
// disable ( 333 ) ;
2529: LD_INT 333
2531: DISABLE_MARKED
// disable ( 337 ) ;
2532: LD_INT 337
2534: DISABLE_MARKED
// disable ( 401 ) ;
2535: LD_INT 401
2537: DISABLE_MARKED
// read_parameters ;
2538: CALL 0 0 0
// set_difficulty ;
2542: CALL 257 0 0
// create_people ;
2546: CALL 609 0 0
// select_people ;
2550: CALL 1839 0 0
// place_masha ;
2554: CALL 2033 0 0
// CenterNowOnXY ( 53 , 90 ) ;
2558: LD_INT 53
2560: PPUSH
2561: LD_INT 90
2563: PPUSH
2564: CALL_OW 86
// PlaceUnitXY ( Burlak , 51 , 88 , false ) ;
2568: LD_EXP 1
2572: PPUSH
2573: LD_INT 51
2575: PPUSH
2576: LD_INT 88
2578: PPUSH
2579: LD_INT 0
2581: PPUSH
2582: CALL_OW 48
// ComHold ( Burlak ) ;
2586: LD_EXP 1
2590: PPUSH
2591: CALL_OW 140
// PlaceUnitXY ( RSoldier , 54 , 90 , false ) ;
2595: LD_EXP 21
2599: PPUSH
2600: LD_INT 54
2602: PPUSH
2603: LD_INT 90
2605: PPUSH
2606: LD_INT 0
2608: PPUSH
2609: CALL_OW 48
// ComHold ( RSoldier ) ;
2613: LD_EXP 21
2617: PPUSH
2618: CALL_OW 140
// ComTurnUnit ( Burlak , RSoldier ) ;
2622: LD_EXP 1
2626: PPUSH
2627: LD_EXP 21
2631: PPUSH
2632: CALL_OW 119
// ComTurnUnit ( RSoldier , Burlak ) ;
2636: LD_EXP 21
2640: PPUSH
2641: LD_EXP 1
2645: PPUSH
2646: CALL_OW 119
// D_Platonov ;
2650: CALL 5301 0 0
// IngameOff ;
2654: CALL_OW 9
// SaveForQuickRestart ;
2658: CALL_OW 22
// ChangeMissionObjectives ( MRun ) ;
2662: LD_STRING MRun
2664: PPUSH
2665: CALL_OW 337
// ComMoveXY ( Burlak , 39 , 67 ) ;
2669: LD_EXP 1
2673: PPUSH
2674: LD_INT 39
2676: PPUSH
2677: LD_INT 67
2679: PPUSH
2680: CALL_OW 111
// ChangeSideFog ( you , you ) ;
2684: LD_EXP 23
2688: PPUSH
2689: LD_EXP 23
2693: PPUSH
2694: CALL_OW 343
// SetSide ( Burlak , you ) ;
2698: LD_EXP 1
2702: PPUSH
2703: LD_EXP 23
2707: PPUSH
2708: CALL_OW 235
// SetSide ( Masha , you ) ;
2712: LD_EXP 43
2716: PPUSH
2717: LD_EXP 23
2721: PPUSH
2722: CALL_OW 235
// case Rand ( 1 , 2 ) of 1 :
2726: LD_INT 1
2728: PPUSH
2729: LD_INT 2
2731: PPUSH
2732: CALL_OW 12
2736: PUSH
2737: LD_INT 1
2739: DOUBLE
2740: EQUAL
2741: IFTRUE 2745
2743: GO 2803
2745: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2746: LD_ADDR_LOC 2
2750: PUSH
2751: DOUBLE
2752: LD_EXP 31
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: DEC
2761: ST_TO_ADDR
2762: LD_EXP 31
2766: PUSH
2767: LD_EXP 30
2771: PLUS
2772: PUSH
2773: FOR_TO
2774: IFFALSE 2799
// PlaceUnitArea ( pursuer [ i ] , Marsh1aArea , false ) ;
2776: LD_EXP 29
2780: PUSH
2781: LD_LOC 2
2785: ARRAY
2786: PPUSH
2787: LD_INT 4
2789: PPUSH
2790: LD_INT 0
2792: PPUSH
2793: CALL_OW 49
2797: GO 2773
2799: POP
2800: POP
// end ; 2 :
2801: GO 2870
2803: LD_INT 2
2805: DOUBLE
2806: EQUAL
2807: IFTRUE 2811
2809: GO 2869
2811: POP
// begin for i := pursuers_base + 1 to pursuers_base + pursuers do
2812: LD_ADDR_LOC 2
2816: PUSH
2817: DOUBLE
2818: LD_EXP 31
2822: PUSH
2823: LD_INT 1
2825: PLUS
2826: DEC
2827: ST_TO_ADDR
2828: LD_EXP 31
2832: PUSH
2833: LD_EXP 30
2837: PLUS
2838: PUSH
2839: FOR_TO
2840: IFFALSE 2865
// PlaceUnitArea ( pursuer [ i ] , Marsh1bArea , false ) ;
2842: LD_EXP 29
2846: PUSH
2847: LD_LOC 2
2851: ARRAY
2852: PPUSH
2853: LD_INT 5
2855: PPUSH
2856: LD_INT 0
2858: PPUSH
2859: CALL_OW 49
2863: GO 2839
2865: POP
2866: POP
// end ; end ;
2867: GO 2870
2869: POP
// case Rand ( 1 , 2 ) of 1 :
2870: LD_INT 1
2872: PPUSH
2873: LD_INT 2
2875: PPUSH
2876: CALL_OW 12
2880: PUSH
2881: LD_INT 1
2883: DOUBLE
2884: EQUAL
2885: IFTRUE 2889
2887: GO 2957
2889: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2890: LD_ADDR_LOC 2
2894: PUSH
2895: DOUBLE
2896: LD_EXP 31
2900: PUSH
2901: LD_INT 1
2903: PLUS
2904: PUSH
2905: LD_EXP 30
2909: PLUS
2910: DEC
2911: ST_TO_ADDR
2912: LD_EXP 31
2916: PUSH
2917: LD_INT 2
2919: PUSH
2920: LD_EXP 30
2924: MUL
2925: PLUS
2926: PUSH
2927: FOR_TO
2928: IFFALSE 2953
// PlaceUnitArea ( pursuer [ i ] , Marsh2aArea , false ) ;
2930: LD_EXP 29
2934: PUSH
2935: LD_LOC 2
2939: ARRAY
2940: PPUSH
2941: LD_INT 8
2943: PPUSH
2944: LD_INT 0
2946: PPUSH
2947: CALL_OW 49
2951: GO 2927
2953: POP
2954: POP
// end ; 2 :
2955: GO 3034
2957: LD_INT 2
2959: DOUBLE
2960: EQUAL
2961: IFTRUE 2965
2963: GO 3033
2965: POP
// begin for i := pursuers_base + 1 + pursuers to pursuers_base + 2 * pursuers do
2966: LD_ADDR_LOC 2
2970: PUSH
2971: DOUBLE
2972: LD_EXP 31
2976: PUSH
2977: LD_INT 1
2979: PLUS
2980: PUSH
2981: LD_EXP 30
2985: PLUS
2986: DEC
2987: ST_TO_ADDR
2988: LD_EXP 31
2992: PUSH
2993: LD_INT 2
2995: PUSH
2996: LD_EXP 30
3000: MUL
3001: PLUS
3002: PUSH
3003: FOR_TO
3004: IFFALSE 3029
// PlaceUnitArea ( pursuer [ i ] , Marsh2bArea , false ) ;
3006: LD_EXP 29
3010: PUSH
3011: LD_LOC 2
3015: ARRAY
3016: PPUSH
3017: LD_INT 7
3019: PPUSH
3020: LD_INT 0
3022: PPUSH
3023: CALL_OW 49
3027: GO 3003
3029: POP
3030: POP
// end ; end ;
3031: GO 3034
3033: POP
// case Rand ( 1 , 2 ) of 1 :
3034: LD_INT 1
3036: PPUSH
3037: LD_INT 2
3039: PPUSH
3040: CALL_OW 12
3044: PUSH
3045: LD_INT 1
3047: DOUBLE
3048: EQUAL
3049: IFTRUE 3053
3051: GO 3125
3053: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3054: LD_ADDR_LOC 2
3058: PUSH
3059: DOUBLE
3060: LD_EXP 31
3064: PUSH
3065: LD_INT 1
3067: PLUS
3068: PUSH
3069: LD_INT 2
3071: PUSH
3072: LD_EXP 30
3076: MUL
3077: PLUS
3078: DEC
3079: ST_TO_ADDR
3080: LD_EXP 31
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_EXP 30
3092: MUL
3093: PLUS
3094: PUSH
3095: FOR_TO
3096: IFFALSE 3121
// PlaceUnitArea ( pursuer [ i ] , Marsh3aArea , false ) ;
3098: LD_EXP 29
3102: PUSH
3103: LD_LOC 2
3107: ARRAY
3108: PPUSH
3109: LD_INT 6
3111: PPUSH
3112: LD_INT 0
3114: PPUSH
3115: CALL_OW 49
3119: GO 3095
3121: POP
3122: POP
// end ; 2 :
3123: GO 3206
3125: LD_INT 2
3127: DOUBLE
3128: EQUAL
3129: IFTRUE 3133
3131: GO 3205
3133: POP
// begin for i := pursuers_base + 1 + 2 * pursuers to pursuers_base + 3 * pursuers do
3134: LD_ADDR_LOC 2
3138: PUSH
3139: DOUBLE
3140: LD_EXP 31
3144: PUSH
3145: LD_INT 1
3147: PLUS
3148: PUSH
3149: LD_INT 2
3151: PUSH
3152: LD_EXP 30
3156: MUL
3157: PLUS
3158: DEC
3159: ST_TO_ADDR
3160: LD_EXP 31
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_EXP 30
3172: MUL
3173: PLUS
3174: PUSH
3175: FOR_TO
3176: IFFALSE 3201
// PlaceUnitArea ( pursuer [ i ] , Marsh3bArea , false ) ;
3178: LD_EXP 29
3182: PUSH
3183: LD_LOC 2
3187: ARRAY
3188: PPUSH
3189: LD_INT 16
3191: PPUSH
3192: LD_INT 0
3194: PPUSH
3195: CALL_OW 49
3199: GO 3175
3201: POP
3202: POP
// end ; end ;
3203: GO 3206
3205: POP
// Wait ( 1 1$20 ) ;
3206: LD_INT 2800
3208: PPUSH
3209: CALL_OW 67
// for i := 1 to pursuers_base do
3213: LD_ADDR_LOC 2
3217: PUSH
3218: DOUBLE
3219: LD_INT 1
3221: DEC
3222: ST_TO_ADDR
3223: LD_EXP 31
3227: PUSH
3228: FOR_TO
3229: IFFALSE 3298
// begin if not PlaceUnitArea ( pursuer [ i ] , EnterArea , false ) then
3231: LD_EXP 29
3235: PUSH
3236: LD_LOC 2
3240: ARRAY
3241: PPUSH
3242: LD_INT 9
3244: PPUSH
3245: LD_INT 0
3247: PPUSH
3248: CALL_OW 49
3252: NOT
3253: IFFALSE 3276
// PlaceUnitArea ( pursuer [ i ] , BluekherCenterArea , false ) ;
3255: LD_EXP 29
3259: PUSH
3260: LD_LOC 2
3264: ARRAY
3265: PPUSH
3266: LD_INT 3
3268: PPUSH
3269: LD_INT 0
3271: PPUSH
3272: CALL_OW 49
// ComAttackUnit ( pursuer [ i ] , Burlak ) ;
3276: LD_EXP 29
3280: PUSH
3281: LD_LOC 2
3285: ARRAY
3286: PPUSH
3287: LD_EXP 1
3291: PPUSH
3292: CALL_OW 115
// end ;
3296: GO 3228
3298: POP
3299: POP
// Wait ( straz_start ) ;
3300: LD_EXP 35
3304: PPUSH
3305: CALL_OW 67
// enable ( 1 ) ;
3309: LD_INT 1
3311: ENABLE_MARKED
// enable ( 2 ) ;
3312: LD_INT 2
3314: ENABLE_MARKED
// end ;
3315: END
// export function TheEnd ; var matros , un , filter , reward_units , survivors5 , rus_building_destroyed , belkov_side , gnyevko_side , kiril_side , kovalyuk_side , scholtze_side , kuzmov_side , karam_side , petros_side , gleb_side , petrov_side , lipshchin_side , titov_side , dolgov_side , xavier_side , oblukov_side , kozlov_side , kapitsova_side ; begin
3316: LD_INT 0
3318: PPUSH
3319: PPUSH
3320: PPUSH
3321: PPUSH
3322: PPUSH
3323: PPUSH
3324: PPUSH
3325: PPUSH
3326: PPUSH
3327: PPUSH
3328: PPUSH
3329: PPUSH
3330: PPUSH
3331: PPUSH
3332: PPUSH
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
3341: PPUSH
// gained_medals := [ ] ;
3342: LD_ADDR_OWVAR 61
3346: PUSH
3347: EMPTY
3348: ST_TO_ADDR
// missing_medals := [ ] ;
3349: LD_ADDR_OWVAR 62
3353: PUSH
3354: EMPTY
3355: ST_TO_ADDR
// reward_units := [ ] ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: EMPTY
3362: ST_TO_ADDR
// if scientists_dead = 0 then
3363: LD_EXP 49
3367: PUSH
3368: LD_INT 0
3370: EQUAL
3371: IFFALSE 3385
// AddMedal ( Science , 1 ) else
3373: LD_STRING Science
3375: PPUSH
3376: LD_INT 1
3378: PPUSH
3379: CALL_OW 101
3383: GO 3396
// AddMedal ( Science , - 1 ) ;
3385: LD_STRING Science
3387: PPUSH
3388: LD_INT 1
3390: NEG
3391: PPUSH
3392: CALL_OW 101
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3396: LD_ADDR_VAR 0 4
3400: PUSH
3401: LD_INT 22
3403: PUSH
3404: LD_EXP 23
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 30
3418: PUSH
3419: LD_INT 0
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: PUSH
3426: LD_INT 30
3428: PUSH
3429: LD_INT 1
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: PUSH
3436: EMPTY
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: ST_TO_ADDR
// matros := 0 ;
3450: LD_ADDR_VAR 0 2
3454: PUSH
3455: LD_INT 0
3457: ST_TO_ADDR
// if 0 + filter <> 0 then
3458: LD_INT 0
3460: PUSH
3461: LD_VAR 0 4
3465: PLUS
3466: PUSH
3467: LD_INT 0
3469: NONEQUAL
3470: IFFALSE 3518
// for un in filter do
3472: LD_ADDR_VAR 0 3
3476: PUSH
3477: LD_VAR 0 4
3481: PUSH
3482: FOR_IN
3483: IFFALSE 3516
// matros := matros + GetResourceType ( GetBase ( un ) , mat_cans ) ;
3485: LD_ADDR_VAR 0 2
3489: PUSH
3490: LD_VAR 0 2
3494: PUSH
3495: LD_VAR 0 3
3499: PPUSH
3500: CALL_OW 274
3504: PPUSH
3505: LD_INT 1
3507: PPUSH
3508: CALL_OW 275
3512: PLUS
3513: ST_TO_ADDR
3514: GO 3482
3516: POP
3517: POP
// if matros > 100 then
3518: LD_VAR 0 2
3522: PUSH
3523: LD_INT 100
3525: GREATER
3526: IFFALSE 3540
// AddMedal ( Effectivity , 1 ) else
3528: LD_STRING Effectivity
3530: PPUSH
3531: LD_INT 1
3533: PPUSH
3534: CALL_OW 101
3538: GO 3551
// AddMedal ( Effectivity , - 1 ) ;
3540: LD_STRING Effectivity
3542: PPUSH
3543: LD_INT 1
3545: NEG
3546: PPUSH
3547: CALL_OW 101
// rus_building_destroyed := false ;
3551: LD_ADDR_VAR 0 7
3555: PUSH
3556: LD_INT 0
3558: ST_TO_ADDR
// for un in rus_mcrep_bui do
3559: LD_ADDR_VAR 0 3
3563: PUSH
3564: LD_EXP 64
3568: PUSH
3569: FOR_IN
3570: IFFALSE 3600
// if not IsLive ( un ) then
3572: LD_VAR 0 3
3576: PPUSH
3577: CALL_OW 300
3581: NOT
3582: IFFALSE 3598
// rus_building_destroyed := rus_building_destroyed + 1 ;
3584: LD_ADDR_VAR 0 7
3588: PUSH
3589: LD_VAR 0 7
3593: PUSH
3594: LD_INT 1
3596: PLUS
3597: ST_TO_ADDR
3598: GO 3569
3600: POP
3601: POP
// if killed_russians >= 5 or rus_building_destroyed >= 2 then
3602: LD_EXP 53
3606: PUSH
3607: LD_INT 5
3609: GREATEREQUAL
3610: PUSH
3611: LD_VAR 0 7
3615: PUSH
3616: LD_INT 2
3618: GREATEREQUAL
3619: OR
3620: IFFALSE 3635
// AddMedal ( LittleLosses , - 1 ) else
3622: LD_STRING LittleLosses
3624: PPUSH
3625: LD_INT 1
3627: NEG
3628: PPUSH
3629: CALL_OW 101
3633: GO 3645
// AddMedal ( LittleLosses , 1 ) ;
3635: LD_STRING LittleLosses
3637: PPUSH
3638: LD_INT 1
3640: PPUSH
3641: CALL_OW 101
// SA_EndMission ( 4 , 5 , scientists_dead = 0 , matros > 100 , not ( killed_russians >= 5 or rus_building_destroyed >= 2 ) ) ;
3645: LD_INT 4
3647: PPUSH
3648: LD_INT 5
3650: PPUSH
3651: LD_EXP 49
3655: PUSH
3656: LD_INT 0
3658: EQUAL
3659: PPUSH
3660: LD_VAR 0 2
3664: PUSH
3665: LD_INT 100
3667: GREATER
3668: PPUSH
3669: LD_EXP 53
3673: PUSH
3674: LD_INT 5
3676: GREATEREQUAL
3677: PUSH
3678: LD_VAR 0 7
3682: PUSH
3683: LD_INT 2
3685: GREATEREQUAL
3686: OR
3687: NOT
3688: PPUSH
3689: CALL 14294 0 5
// GiveMedals ( Main ) ;
3693: LD_STRING Main
3695: PPUSH
3696: CALL_OW 102
// for un in player_units do
3700: LD_ADDR_VAR 0 3
3704: PUSH
3705: LD_EXP 41
3709: PUSH
3710: FOR_IN
3711: IFFALSE 3743
// if not IsDead ( un ) then
3713: LD_VAR 0 3
3717: PPUSH
3718: CALL_OW 301
3722: NOT
3723: IFFALSE 3741
// reward_units := reward_units ^ un ;
3725: LD_ADDR_VAR 0 5
3729: PUSH
3730: LD_VAR 0 5
3734: PUSH
3735: LD_VAR 0 3
3739: ADD
3740: ST_TO_ADDR
3741: GO 3710
3743: POP
3744: POP
// RewardPeople ( reward_units ) ;
3745: LD_VAR 0 5
3749: PPUSH
3750: CALL_OW 43
// SaveCharacters ( scientists diff ( all_possible ^ Gossudarov ) , scientists ) ;
3754: LD_EXP 40
3758: PUSH
3759: LD_EXP 39
3763: PUSH
3764: LD_EXP 8
3768: ADD
3769: DIFF
3770: PPUSH
3771: LD_STRING scientists
3773: PPUSH
3774: CALL_OW 38
// survivors5 := player_units diff all_possible ^ scientists ^ Burlak ^ Gossudarov ;
3778: LD_ADDR_VAR 0 6
3782: PUSH
3783: LD_EXP 41
3787: PUSH
3788: LD_EXP 39
3792: PUSH
3793: LD_EXP 40
3797: ADD
3798: PUSH
3799: LD_EXP 1
3803: ADD
3804: PUSH
3805: LD_EXP 8
3809: ADD
3810: DIFF
3811: ST_TO_ADDR
// SaveCharacters ( survivors5 , survivors5 ) ;
3812: LD_VAR 0 6
3816: PPUSH
3817: LD_STRING survivors5
3819: PPUSH
3820: CALL_OW 38
// SaveCharacters ( Burlak , Burlak ) ;
3824: LD_EXP 1
3828: PPUSH
3829: LD_STRING Burlak
3831: PPUSH
3832: CALL_OW 38
// SaveCharacters ( Belkov , Belkov ) ;
3836: LD_EXP 2
3840: PPUSH
3841: LD_STRING Belkov
3843: PPUSH
3844: CALL_OW 38
// SaveCharacters ( Gnyevko , Gnyevko ) ;
3848: LD_EXP 3
3852: PPUSH
3853: LD_STRING Gnyevko
3855: PPUSH
3856: CALL_OW 38
// SaveCharacters ( Kirilenkova , Kirilenkova ) ;
3860: LD_EXP 4
3864: PPUSH
3865: LD_STRING Kirilenkova
3867: PPUSH
3868: CALL_OW 38
// SaveCharacters ( Gleb , Gleb ) ;
3872: LD_EXP 5
3876: PPUSH
3877: LD_STRING Gleb
3879: PPUSH
3880: CALL_OW 38
// SaveCharacters ( Petrosyan , Petrosyan ) ;
3884: LD_EXP 6
3888: PPUSH
3889: LD_STRING Petrosyan
3891: PPUSH
3892: CALL_OW 38
// SaveCharacters ( Titov , Titov ) ;
3896: LD_EXP 7
3900: PPUSH
3901: LD_STRING Titov
3903: PPUSH
3904: CALL_OW 38
// SaveCharacters ( Gossudarov , Gossudarov ) ;
3908: LD_EXP 8
3912: PPUSH
3913: LD_STRING Gossudarov
3915: PPUSH
3916: CALL_OW 38
// SaveCharacters ( Kovalyuk , Kovalyuk ) ;
3920: LD_EXP 9
3924: PPUSH
3925: LD_STRING Kovalyuk
3927: PPUSH
3928: CALL_OW 38
// SaveCharacters ( Scholtze , Scholtze ) ;
3932: LD_EXP 10
3936: PPUSH
3937: LD_STRING Scholtze
3939: PPUSH
3940: CALL_OW 38
// SaveCharacters ( Kuzmov , Kuzmov ) ;
3944: LD_EXP 11
3948: PPUSH
3949: LD_STRING Kuzmov
3951: PPUSH
3952: CALL_OW 38
// SaveCharacters ( Karamazov , Karamazov ) ;
3956: LD_EXP 12
3960: PPUSH
3961: LD_STRING Karamazov
3963: PPUSH
3964: CALL_OW 38
// SaveCharacters ( Petrovova , Petrovova ) ;
3968: LD_EXP 13
3972: PPUSH
3973: LD_STRING Petrovova
3975: PPUSH
3976: CALL_OW 38
// SaveCharacters ( Lipshchin , Lipshchin ) ;
3980: LD_EXP 14
3984: PPUSH
3985: LD_STRING Lipshchin
3987: PPUSH
3988: CALL_OW 38
// SaveCharacters ( Dolgov , Dolgov ) ;
3992: LD_EXP 15
3996: PPUSH
3997: LD_STRING Dolgov
3999: PPUSH
4000: CALL_OW 38
// SaveCharacters ( Xavier , Xavier ) ;
4004: LD_EXP 16
4008: PPUSH
4009: LD_STRING Xavier
4011: PPUSH
4012: CALL_OW 38
// SaveCharacters ( Oblukov , Oblukov ) ;
4016: LD_EXP 17
4020: PPUSH
4021: LD_STRING Oblukov
4023: PPUSH
4024: CALL_OW 38
// SaveCharacters ( Kozlov , Kozlov ) ;
4028: LD_EXP 18
4032: PPUSH
4033: LD_STRING Kozlov
4035: PPUSH
4036: CALL_OW 38
// SaveCharacters ( Kapitsova , Kapitsova ) ;
4040: LD_EXP 19
4044: PPUSH
4045: LD_STRING Kapitsova
4047: PPUSH
4048: CALL_OW 38
// if ( RealMasha and lost_masha ) or not MashaWanted then
4052: LD_EXP 42
4056: PUSH
4057: LD_EXP 52
4061: AND
4062: PUSH
4063: LD_LOC 1
4067: NOT
4068: OR
4069: IFFALSE 4078
// DeleteVariable ( Masha ) ;
4071: LD_STRING Masha
4073: PPUSH
4074: CALL_OW 41
// if Belkov in scientists then
4078: LD_EXP 2
4082: PUSH
4083: LD_EXP 40
4087: IN
4088: IFFALSE 4100
// belkov_side := 2 else
4090: LD_ADDR_VAR 0 8
4094: PUSH
4095: LD_INT 2
4097: ST_TO_ADDR
4098: GO 4130
// if Belkov in player_units then
4100: LD_EXP 2
4104: PUSH
4105: LD_EXP 41
4109: IN
4110: IFFALSE 4122
// belkov_side := 1 else
4112: LD_ADDR_VAR 0 8
4116: PUSH
4117: LD_INT 1
4119: ST_TO_ADDR
4120: GO 4130
// belkov_side := 0 ;
4122: LD_ADDR_VAR 0 8
4126: PUSH
4127: LD_INT 0
4129: ST_TO_ADDR
// if Gnyevko in scientists then
4130: LD_EXP 3
4134: PUSH
4135: LD_EXP 40
4139: IN
4140: IFFALSE 4152
// gnyevko_side := 2 else
4142: LD_ADDR_VAR 0 9
4146: PUSH
4147: LD_INT 2
4149: ST_TO_ADDR
4150: GO 4182
// if Gnyevko in player_units then
4152: LD_EXP 3
4156: PUSH
4157: LD_EXP 41
4161: IN
4162: IFFALSE 4174
// gnyevko_side := 1 else
4164: LD_ADDR_VAR 0 9
4168: PUSH
4169: LD_INT 1
4171: ST_TO_ADDR
4172: GO 4182
// gnyevko_side := 0 ;
4174: LD_ADDR_VAR 0 9
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// if Kirilenkova in scientists then
4182: LD_EXP 4
4186: PUSH
4187: LD_EXP 40
4191: IN
4192: IFFALSE 4204
// kiril_side := 2 else
4194: LD_ADDR_VAR 0 10
4198: PUSH
4199: LD_INT 2
4201: ST_TO_ADDR
4202: GO 4234
// if Kirilenkova in player_units then
4204: LD_EXP 4
4208: PUSH
4209: LD_EXP 41
4213: IN
4214: IFFALSE 4226
// kiril_side := 1 else
4216: LD_ADDR_VAR 0 10
4220: PUSH
4221: LD_INT 1
4223: ST_TO_ADDR
4224: GO 4234
// kiril_side := 0 ;
4226: LD_ADDR_VAR 0 10
4230: PUSH
4231: LD_INT 0
4233: ST_TO_ADDR
// if Gleb in scientists then
4234: LD_EXP 5
4238: PUSH
4239: LD_EXP 40
4243: IN
4244: IFFALSE 4256
// gleb_side := 2 else
4246: LD_ADDR_VAR 0 16
4250: PUSH
4251: LD_INT 2
4253: ST_TO_ADDR
4254: GO 4286
// if Gleb in player_units then
4256: LD_EXP 5
4260: PUSH
4261: LD_EXP 41
4265: IN
4266: IFFALSE 4278
// gleb_side := 1 else
4268: LD_ADDR_VAR 0 16
4272: PUSH
4273: LD_INT 1
4275: ST_TO_ADDR
4276: GO 4286
// gleb_side := 0 ;
4278: LD_ADDR_VAR 0 16
4282: PUSH
4283: LD_INT 0
4285: ST_TO_ADDR
// if Petrosyan in scientists then
4286: LD_EXP 6
4290: PUSH
4291: LD_EXP 40
4295: IN
4296: IFFALSE 4308
// petros_side := 2 else
4298: LD_ADDR_VAR 0 15
4302: PUSH
4303: LD_INT 2
4305: ST_TO_ADDR
4306: GO 4338
// if Petrosyan in player_units then
4308: LD_EXP 6
4312: PUSH
4313: LD_EXP 41
4317: IN
4318: IFFALSE 4330
// petros_side := 1 else
4320: LD_ADDR_VAR 0 15
4324: PUSH
4325: LD_INT 1
4327: ST_TO_ADDR
4328: GO 4338
// petros_side := 0 ;
4330: LD_ADDR_VAR 0 15
4334: PUSH
4335: LD_INT 0
4337: ST_TO_ADDR
// if Titov in scientists then
4338: LD_EXP 7
4342: PUSH
4343: LD_EXP 40
4347: IN
4348: IFFALSE 4360
// titov_side := 2 else
4350: LD_ADDR_VAR 0 19
4354: PUSH
4355: LD_INT 2
4357: ST_TO_ADDR
4358: GO 4390
// if Titov in player_units then
4360: LD_EXP 7
4364: PUSH
4365: LD_EXP 41
4369: IN
4370: IFFALSE 4382
// titov_side := 1 else
4372: LD_ADDR_VAR 0 19
4376: PUSH
4377: LD_INT 1
4379: ST_TO_ADDR
4380: GO 4390
// titov_side := 0 ;
4382: LD_ADDR_VAR 0 19
4386: PUSH
4387: LD_INT 0
4389: ST_TO_ADDR
// if Kovalyuk in scientists then
4390: LD_EXP 9
4394: PUSH
4395: LD_EXP 40
4399: IN
4400: IFFALSE 4412
// kovalyuk_side := 2 else
4402: LD_ADDR_VAR 0 11
4406: PUSH
4407: LD_INT 2
4409: ST_TO_ADDR
4410: GO 4442
// if Kovalyuk in player_units then
4412: LD_EXP 9
4416: PUSH
4417: LD_EXP 41
4421: IN
4422: IFFALSE 4434
// kovalyuk_side := 1 else
4424: LD_ADDR_VAR 0 11
4428: PUSH
4429: LD_INT 1
4431: ST_TO_ADDR
4432: GO 4442
// kovalyuk_side := 0 ;
4434: LD_ADDR_VAR 0 11
4438: PUSH
4439: LD_INT 0
4441: ST_TO_ADDR
// if Scholtze in scientists then
4442: LD_EXP 10
4446: PUSH
4447: LD_EXP 40
4451: IN
4452: IFFALSE 4464
// scholtze_side := 2 else
4454: LD_ADDR_VAR 0 12
4458: PUSH
4459: LD_INT 2
4461: ST_TO_ADDR
4462: GO 4494
// if Scholtze in player_units then
4464: LD_EXP 10
4468: PUSH
4469: LD_EXP 41
4473: IN
4474: IFFALSE 4486
// scholtze_side := 1 else
4476: LD_ADDR_VAR 0 12
4480: PUSH
4481: LD_INT 1
4483: ST_TO_ADDR
4484: GO 4494
// scholtze_side := 0 ;
4486: LD_ADDR_VAR 0 12
4490: PUSH
4491: LD_INT 0
4493: ST_TO_ADDR
// if Kuzmov in scientists then
4494: LD_EXP 11
4498: PUSH
4499: LD_EXP 40
4503: IN
4504: IFFALSE 4516
// kuzmov_side := 2 else
4506: LD_ADDR_VAR 0 13
4510: PUSH
4511: LD_INT 2
4513: ST_TO_ADDR
4514: GO 4546
// if Kuzmov in player_units then
4516: LD_EXP 11
4520: PUSH
4521: LD_EXP 41
4525: IN
4526: IFFALSE 4538
// kuzmov_side := 1 else
4528: LD_ADDR_VAR 0 13
4532: PUSH
4533: LD_INT 1
4535: ST_TO_ADDR
4536: GO 4546
// kuzmov_side := 0 ;
4538: LD_ADDR_VAR 0 13
4542: PUSH
4543: LD_INT 0
4545: ST_TO_ADDR
// if Karamazov in scientists then
4546: LD_EXP 12
4550: PUSH
4551: LD_EXP 40
4555: IN
4556: IFFALSE 4568
// karam_side := 2 else
4558: LD_ADDR_VAR 0 14
4562: PUSH
4563: LD_INT 2
4565: ST_TO_ADDR
4566: GO 4598
// if Karamazov in player_units then
4568: LD_EXP 12
4572: PUSH
4573: LD_EXP 41
4577: IN
4578: IFFALSE 4590
// karam_side := 1 else
4580: LD_ADDR_VAR 0 14
4584: PUSH
4585: LD_INT 1
4587: ST_TO_ADDR
4588: GO 4598
// karam_side := 0 ;
4590: LD_ADDR_VAR 0 14
4594: PUSH
4595: LD_INT 0
4597: ST_TO_ADDR
// if Petrovova in scientists then
4598: LD_EXP 13
4602: PUSH
4603: LD_EXP 40
4607: IN
4608: IFFALSE 4620
// petrov_side := 2 else
4610: LD_ADDR_VAR 0 17
4614: PUSH
4615: LD_INT 2
4617: ST_TO_ADDR
4618: GO 4650
// if Petrovova in player_units then
4620: LD_EXP 13
4624: PUSH
4625: LD_EXP 41
4629: IN
4630: IFFALSE 4642
// petrov_side := 1 else
4632: LD_ADDR_VAR 0 17
4636: PUSH
4637: LD_INT 1
4639: ST_TO_ADDR
4640: GO 4650
// petrov_side := 0 ;
4642: LD_ADDR_VAR 0 17
4646: PUSH
4647: LD_INT 0
4649: ST_TO_ADDR
// if Lipshchin in scientists then
4650: LD_EXP 14
4654: PUSH
4655: LD_EXP 40
4659: IN
4660: IFFALSE 4672
// lipshchin_side := 2 else
4662: LD_ADDR_VAR 0 18
4666: PUSH
4667: LD_INT 2
4669: ST_TO_ADDR
4670: GO 4702
// if Lipshchin in player_units then
4672: LD_EXP 14
4676: PUSH
4677: LD_EXP 41
4681: IN
4682: IFFALSE 4694
// lipshchin_side := 1 else
4684: LD_ADDR_VAR 0 18
4688: PUSH
4689: LD_INT 1
4691: ST_TO_ADDR
4692: GO 4702
// lipshchin_side := 0 ;
4694: LD_ADDR_VAR 0 18
4698: PUSH
4699: LD_INT 0
4701: ST_TO_ADDR
// if Dolgov in scientists then
4702: LD_EXP 15
4706: PUSH
4707: LD_EXP 40
4711: IN
4712: IFFALSE 4724
// dolgov_side := 2 else
4714: LD_ADDR_VAR 0 20
4718: PUSH
4719: LD_INT 2
4721: ST_TO_ADDR
4722: GO 4754
// if Dolgov in player_units then
4724: LD_EXP 15
4728: PUSH
4729: LD_EXP 41
4733: IN
4734: IFFALSE 4746
// dolgov_side := 1 else
4736: LD_ADDR_VAR 0 20
4740: PUSH
4741: LD_INT 1
4743: ST_TO_ADDR
4744: GO 4754
// dolgov_side := 0 ;
4746: LD_ADDR_VAR 0 20
4750: PUSH
4751: LD_INT 0
4753: ST_TO_ADDR
// if Xavier in scientists then
4754: LD_EXP 16
4758: PUSH
4759: LD_EXP 40
4763: IN
4764: IFFALSE 4776
// xavier_side := 2 else
4766: LD_ADDR_VAR 0 21
4770: PUSH
4771: LD_INT 2
4773: ST_TO_ADDR
4774: GO 4806
// if Xavier in player_units then
4776: LD_EXP 16
4780: PUSH
4781: LD_EXP 41
4785: IN
4786: IFFALSE 4798
// xavier_side := 1 else
4788: LD_ADDR_VAR 0 21
4792: PUSH
4793: LD_INT 1
4795: ST_TO_ADDR
4796: GO 4806
// xavier_side := 0 ;
4798: LD_ADDR_VAR 0 21
4802: PUSH
4803: LD_INT 0
4805: ST_TO_ADDR
// if Oblukov in scientists then
4806: LD_EXP 17
4810: PUSH
4811: LD_EXP 40
4815: IN
4816: IFFALSE 4828
// oblukov_side := 2 else
4818: LD_ADDR_VAR 0 22
4822: PUSH
4823: LD_INT 2
4825: ST_TO_ADDR
4826: GO 4858
// if Oblukov in player_units then
4828: LD_EXP 17
4832: PUSH
4833: LD_EXP 41
4837: IN
4838: IFFALSE 4850
// oblukov_side := 1 else
4840: LD_ADDR_VAR 0 22
4844: PUSH
4845: LD_INT 1
4847: ST_TO_ADDR
4848: GO 4858
// oblukov_side := 0 ;
4850: LD_ADDR_VAR 0 22
4854: PUSH
4855: LD_INT 0
4857: ST_TO_ADDR
// if Kozlov in scientists then
4858: LD_EXP 18
4862: PUSH
4863: LD_EXP 40
4867: IN
4868: IFFALSE 4880
// kozlov_side := 2 else
4870: LD_ADDR_VAR 0 23
4874: PUSH
4875: LD_INT 2
4877: ST_TO_ADDR
4878: GO 4910
// if Kozlov in player_units then
4880: LD_EXP 18
4884: PUSH
4885: LD_EXP 41
4889: IN
4890: IFFALSE 4902
// kozlov_side := 1 else
4892: LD_ADDR_VAR 0 23
4896: PUSH
4897: LD_INT 1
4899: ST_TO_ADDR
4900: GO 4910
// kozlov_side := 0 ;
4902: LD_ADDR_VAR 0 23
4906: PUSH
4907: LD_INT 0
4909: ST_TO_ADDR
// if Kapitsova in scientists then
4910: LD_EXP 19
4914: PUSH
4915: LD_EXP 40
4919: IN
4920: IFFALSE 4932
// kapitsova_side := 2 else
4922: LD_ADDR_VAR 0 24
4926: PUSH
4927: LD_INT 2
4929: ST_TO_ADDR
4930: GO 4962
// if Kapitsova in player_units then
4932: LD_EXP 19
4936: PUSH
4937: LD_EXP 41
4941: IN
4942: IFFALSE 4954
// kapitsova_side := 1 else
4944: LD_ADDR_VAR 0 24
4948: PUSH
4949: LD_INT 1
4951: ST_TO_ADDR
4952: GO 4962
// kapitsova_side := 0 ;
4954: LD_ADDR_VAR 0 24
4958: PUSH
4959: LD_INT 0
4961: ST_TO_ADDR
// SaveVariable ( belkov_side , belkov_side ) ;
4962: LD_VAR 0 8
4966: PPUSH
4967: LD_STRING belkov_side
4969: PPUSH
4970: CALL_OW 39
// SaveVariable ( gnyevko_side , gnyevko_side ) ;
4974: LD_VAR 0 9
4978: PPUSH
4979: LD_STRING gnyevko_side
4981: PPUSH
4982: CALL_OW 39
// SaveVariable ( kiril_side , kiril_side ) ;
4986: LD_VAR 0 10
4990: PPUSH
4991: LD_STRING kiril_side
4993: PPUSH
4994: CALL_OW 39
// SaveVariable ( gleb_side , gleb_side ) ;
4998: LD_VAR 0 16
5002: PPUSH
5003: LD_STRING gleb_side
5005: PPUSH
5006: CALL_OW 39
// SaveVariable ( petros_side , petros_side ) ;
5010: LD_VAR 0 15
5014: PPUSH
5015: LD_STRING petros_side
5017: PPUSH
5018: CALL_OW 39
// SaveVariable ( titov_side , titov_side ) ;
5022: LD_VAR 0 19
5026: PPUSH
5027: LD_STRING titov_side
5029: PPUSH
5030: CALL_OW 39
// SaveVariable ( kovalyuk_side , kovalyuk_side ) ;
5034: LD_VAR 0 11
5038: PPUSH
5039: LD_STRING kovalyuk_side
5041: PPUSH
5042: CALL_OW 39
// SaveVariable ( scholtze_side , scholtze_side ) ;
5046: LD_VAR 0 12
5050: PPUSH
5051: LD_STRING scholtze_side
5053: PPUSH
5054: CALL_OW 39
// SaveVariable ( kuzmov_side , kuzmov_side ) ;
5058: LD_VAR 0 13
5062: PPUSH
5063: LD_STRING kuzmov_side
5065: PPUSH
5066: CALL_OW 39
// SaveVariable ( karam_side , karam_side ) ;
5070: LD_VAR 0 14
5074: PPUSH
5075: LD_STRING karam_side
5077: PPUSH
5078: CALL_OW 39
// SaveVariable ( petrov_side , petrov_side ) ;
5082: LD_VAR 0 17
5086: PPUSH
5087: LD_STRING petrov_side
5089: PPUSH
5090: CALL_OW 39
// SaveVariable ( lipshchin_side , lipshchin_side ) ;
5094: LD_VAR 0 18
5098: PPUSH
5099: LD_STRING lipshchin_side
5101: PPUSH
5102: CALL_OW 39
// SaveVariable ( dolgov_side , dolgov_side ) ;
5106: LD_VAR 0 20
5110: PPUSH
5111: LD_STRING dolgov_side
5113: PPUSH
5114: CALL_OW 39
// SaveVariable ( xavier_side , xavier_side ) ;
5118: LD_VAR 0 21
5122: PPUSH
5123: LD_STRING xavier_side
5125: PPUSH
5126: CALL_OW 39
// SaveVariable ( oblukov_side , oblukov_side ) ;
5130: LD_VAR 0 22
5134: PPUSH
5135: LD_STRING oblukov_side
5137: PPUSH
5138: CALL_OW 39
// SaveVariable ( kozlov_side , kozlov_side ) ;
5142: LD_VAR 0 23
5146: PPUSH
5147: LD_STRING kozlov_side
5149: PPUSH
5150: CALL_OW 39
// SaveVariable ( kapitsova_side , kapitsova_side ) ;
5154: LD_VAR 0 24
5158: PPUSH
5159: LD_STRING kapitsova_side
5161: PPUSH
5162: CALL_OW 39
// YouWin ;
5166: CALL_OW 103
// exit ;
5170: GO 5172
// end ; end_of_file
5172: LD_VAR 0 1
5176: RET
// export function D_Start ; begin
5177: LD_INT 0
5179: PPUSH
// DisableExclamations ;
5180: CALL_OW 474
// Say ( Gossudarov , DStart-Gos-1 ) ;
5184: LD_EXP 8
5188: PPUSH
5189: LD_STRING DStart-Gos-1
5191: PPUSH
5192: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
5196: LD_EXP 1
5200: PPUSH
5201: LD_STRING DStart-Bur-1
5203: PPUSH
5204: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-2 ) ;
5208: LD_EXP 8
5212: PPUSH
5213: LD_STRING DStart-Gos-2
5215: PPUSH
5216: CALL_OW 88
// Say ( Burlak , DStart-Bur-2 ) ;
5220: LD_EXP 1
5224: PPUSH
5225: LD_STRING DStart-Bur-2
5227: PPUSH
5228: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-3 ) ;
5232: LD_EXP 8
5236: PPUSH
5237: LD_STRING DStart-Gos-3
5239: PPUSH
5240: CALL_OW 88
// Say ( Burlak , DStart-Bur-3 ) ;
5244: LD_EXP 1
5248: PPUSH
5249: LD_STRING DStart-Bur-3
5251: PPUSH
5252: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-4 ) ;
5256: LD_EXP 8
5260: PPUSH
5261: LD_STRING DStart-Gos-4
5263: PPUSH
5264: CALL_OW 88
// Say ( Burlak , DStart-Bur-4 ) ;
5268: LD_EXP 1
5272: PPUSH
5273: LD_STRING DStart-Bur-4
5275: PPUSH
5276: CALL_OW 88
// Say ( Gossudarov , DStart-Gos-5 ) ;
5280: LD_EXP 8
5284: PPUSH
5285: LD_STRING DStart-Gos-5
5287: PPUSH
5288: CALL_OW 88
// EnableExclamations ;
5292: CALL_OW 473
// end ;
5296: LD_VAR 0 1
5300: RET
// export function D_Platonov ; begin
5301: LD_INT 0
5303: PPUSH
// DisableExclamations ;
5304: CALL_OW 474
// Say ( RSoldier , DPlatonov-Rsol1-1 ) ;
5308: LD_EXP 21
5312: PPUSH
5313: LD_STRING DPlatonov-Rsol1-1
5315: PPUSH
5316: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-1 ) ;
5320: LD_EXP 1
5324: PPUSH
5325: LD_STRING DPlatonov-Bur-1
5327: PPUSH
5328: CALL_OW 88
// Say ( RSoldier , DPlatonov-Rsol1-2 ) ;
5332: LD_EXP 21
5336: PPUSH
5337: LD_STRING DPlatonov-Rsol1-2
5339: PPUSH
5340: CALL_OW 88
// Say ( Burlak , DPlatonov-Bur-2 ) ;
5344: LD_EXP 1
5348: PPUSH
5349: LD_STRING DPlatonov-Bur-2
5351: PPUSH
5352: CALL_OW 88
// ComEnterUnit ( Burlak , Masha ) ;
5356: LD_EXP 1
5360: PPUSH
5361: LD_EXP 43
5365: PPUSH
5366: CALL_OW 120
// Say ( RSoldier , DPlatonov-Rsol1-3 ) ;
5370: LD_EXP 21
5374: PPUSH
5375: LD_STRING DPlatonov-Rsol1-3
5377: PPUSH
5378: CALL_OW 88
// repeat Wait ( 0 0$0.2 ) ;
5382: LD_INT 7
5384: PPUSH
5385: CALL_OW 67
// until IsDrivenBy ( Masha ) = Burlak ;
5389: LD_EXP 43
5393: PPUSH
5394: CALL_OW 311
5398: PUSH
5399: LD_EXP 1
5403: EQUAL
5404: IFFALSE 5382
// Say ( Burlak , DPlatonov-Bur-3 ) ;
5406: LD_EXP 1
5410: PPUSH
5411: LD_STRING DPlatonov-Bur-3
5413: PPUSH
5414: CALL_OW 88
// AddComAttackUnit ( Burlak , RSoldier ) ;
5418: LD_EXP 1
5422: PPUSH
5423: LD_EXP 21
5427: PPUSH
5428: CALL_OW 175
// repeat Wait ( 0 0$0.2 ) ;
5432: LD_INT 7
5434: PPUSH
5435: CALL_OW 67
// until Attacks ( Masha ) = RSoldier ;
5439: LD_EXP 43
5443: PPUSH
5444: CALL_OW 320
5448: PUSH
5449: LD_EXP 21
5453: EQUAL
5454: IFFALSE 5432
// Wait ( 0 0$0.5 ) ;
5456: LD_INT 18
5458: PPUSH
5459: CALL_OW 67
// Say ( RSoldier , DPlatonov-Rsol1-4 ) ;
5463: LD_EXP 21
5467: PPUSH
5468: LD_STRING DPlatonov-Rsol1-4
5470: PPUSH
5471: CALL_OW 88
// ComAttackUnit ( RSoldier , Masha ) ;
5475: LD_EXP 21
5479: PPUSH
5480: LD_EXP 43
5484: PPUSH
5485: CALL_OW 115
// AddComAttackUnit ( Burlak , RSoldier ) ;
5489: LD_EXP 1
5493: PPUSH
5494: LD_EXP 21
5498: PPUSH
5499: CALL_OW 175
// Say ( Platonov , DPlatonov-Pla-4 ) ;
5503: LD_EXP 20
5507: PPUSH
5508: LD_STRING DPlatonov-Pla-4
5510: PPUSH
5511: CALL_OW 88
// Say ( Platonov , DPlatonov-Pla-4a ) ;
5515: LD_EXP 20
5519: PPUSH
5520: LD_STRING DPlatonov-Pla-4a
5522: PPUSH
5523: CALL_OW 88
// EnableExclamations ;
5527: CALL_OW 473
// end ;
5531: LD_VAR 0 1
5535: RET
// export function D_GosStart ; var un , filter , filter_all ; begin
5536: LD_INT 0
5538: PPUSH
5539: PPUSH
5540: PPUSH
5541: PPUSH
// DisableExclamations ;
5542: CALL_OW 474
// if IsOK ( Belkov ) and GetSide ( Belkov ) = you then
5546: LD_EXP 2
5550: PPUSH
5551: CALL_OW 302
5555: PUSH
5556: LD_EXP 2
5560: PPUSH
5561: CALL_OW 255
5565: PUSH
5566: LD_EXP 23
5570: EQUAL
5571: AND
5572: IFFALSE 5586
// Say ( Belkov , DGosStart-Bel-1 ) ;
5574: LD_EXP 2
5578: PPUSH
5579: LD_STRING DGosStart-Bel-1
5581: PPUSH
5582: CALL_OW 88
// if IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you then
5586: LD_EXP 3
5590: PPUSH
5591: CALL_OW 302
5595: PUSH
5596: LD_EXP 3
5600: PPUSH
5601: CALL_OW 255
5605: PUSH
5606: LD_EXP 23
5610: EQUAL
5611: AND
5612: IFFALSE 5626
// Say ( Gnyevko , DGosStart-Gny-1 ) ;
5614: LD_EXP 3
5618: PPUSH
5619: LD_STRING DGosStart-Gny-1
5621: PPUSH
5622: CALL_OW 88
// if IsOK ( Gleb ) and GetSide ( Gleb ) = you then
5626: LD_EXP 5
5630: PPUSH
5631: CALL_OW 302
5635: PUSH
5636: LD_EXP 5
5640: PPUSH
5641: CALL_OW 255
5645: PUSH
5646: LD_EXP 23
5650: EQUAL
5651: AND
5652: IFFALSE 5666
// Say ( Gleb , DGosStart-Glb-1 ) ;
5654: LD_EXP 5
5658: PPUSH
5659: LD_STRING DGosStart-Glb-1
5661: PPUSH
5662: CALL_OW 88
// if IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you then
5666: LD_EXP 6
5670: PPUSH
5671: CALL_OW 302
5675: PUSH
5676: LD_EXP 6
5680: PPUSH
5681: CALL_OW 255
5685: PUSH
5686: LD_EXP 23
5690: EQUAL
5691: AND
5692: IFFALSE 5706
// Say ( Petrosyan , DGosStart-Pty-1 ) ;
5694: LD_EXP 6
5698: PPUSH
5699: LD_STRING DGosStart-Pty-1
5701: PPUSH
5702: CALL_OW 88
// if IsOK ( Titov ) and GetSide ( Titov ) = you then
5706: LD_EXP 7
5710: PPUSH
5711: CALL_OW 302
5715: PUSH
5716: LD_EXP 7
5720: PPUSH
5721: CALL_OW 255
5725: PUSH
5726: LD_EXP 23
5730: EQUAL
5731: AND
5732: IFFALSE 5746
// Say ( Titov , DGosStart-Tit-1 ) ;
5734: LD_EXP 7
5738: PPUSH
5739: LD_STRING DGosStart-Tit-1
5741: PPUSH
5742: CALL_OW 88
// if IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you then
5746: LD_EXP 4
5750: PPUSH
5751: CALL_OW 302
5755: PUSH
5756: LD_EXP 4
5760: PPUSH
5761: CALL_OW 255
5765: PUSH
5766: LD_EXP 23
5770: EQUAL
5771: AND
5772: IFFALSE 5786
// Say ( Kirilenkova , DGosStart-Kir-1 ) ;
5774: LD_EXP 4
5778: PPUSH
5779: LD_STRING DGosStart-Kir-1
5781: PPUSH
5782: CALL_OW 88
// if not ( ( IsOK ( Belkov ) and GetSide ( Belkov ) = you ) or ( IsOK ( Gnyevko ) and GetSide ( Gnyevko ) = you ) or ( IsOK ( Gleb ) and GetSide ( Gleb ) = you ) or ( IsOK ( Petrosyan ) and GetSide ( Petrosyan ) = you ) or ( IsOK ( Titov ) and GetSide ( Titov ) = you ) or ( IsOK ( Kirilenkova ) and GetSide ( Kirilenkova ) = you ) ) then
5786: LD_EXP 2
5790: PPUSH
5791: CALL_OW 302
5795: PUSH
5796: LD_EXP 2
5800: PPUSH
5801: CALL_OW 255
5805: PUSH
5806: LD_EXP 23
5810: EQUAL
5811: AND
5812: PUSH
5813: LD_EXP 3
5817: PPUSH
5818: CALL_OW 302
5822: PUSH
5823: LD_EXP 3
5827: PPUSH
5828: CALL_OW 255
5832: PUSH
5833: LD_EXP 23
5837: EQUAL
5838: AND
5839: OR
5840: PUSH
5841: LD_EXP 5
5845: PPUSH
5846: CALL_OW 302
5850: PUSH
5851: LD_EXP 5
5855: PPUSH
5856: CALL_OW 255
5860: PUSH
5861: LD_EXP 23
5865: EQUAL
5866: AND
5867: OR
5868: PUSH
5869: LD_EXP 6
5873: PPUSH
5874: CALL_OW 302
5878: PUSH
5879: LD_EXP 6
5883: PPUSH
5884: CALL_OW 255
5888: PUSH
5889: LD_EXP 23
5893: EQUAL
5894: AND
5895: OR
5896: PUSH
5897: LD_EXP 7
5901: PPUSH
5902: CALL_OW 302
5906: PUSH
5907: LD_EXP 7
5911: PPUSH
5912: CALL_OW 255
5916: PUSH
5917: LD_EXP 23
5921: EQUAL
5922: AND
5923: OR
5924: PUSH
5925: LD_EXP 4
5929: PPUSH
5930: CALL_OW 302
5934: PUSH
5935: LD_EXP 4
5939: PPUSH
5940: CALL_OW 255
5944: PUSH
5945: LD_EXP 23
5949: EQUAL
5950: AND
5951: OR
5952: NOT
5953: IFFALSE 6317
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
5955: LD_ADDR_VAR 0 4
5959: PUSH
5960: LD_INT 22
5962: PUSH
5963: LD_EXP 23
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PUSH
5972: LD_INT 26
5974: PUSH
5975: LD_INT 1
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: PUSH
5982: LD_INT 50
5984: PUSH
5985: EMPTY
5986: LIST
5987: PUSH
5988: LD_INT 3
5990: PUSH
5991: LD_INT 23
5993: PUSH
5994: LD_INT 0
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: LIST
6010: PPUSH
6011: CALL_OW 69
6015: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6016: LD_ADDR_VAR 0 4
6020: PUSH
6021: LD_VAR 0 4
6025: PUSH
6026: LD_EXP 1
6030: DIFF
6031: ST_TO_ADDR
// if 0 + filter_all > 0 then
6032: LD_INT 0
6034: PUSH
6035: LD_VAR 0 4
6039: PLUS
6040: PUSH
6041: LD_INT 0
6043: GREATER
6044: IFFALSE 6145
// begin filter := [ ] ;
6046: LD_ADDR_VAR 0 3
6050: PUSH
6051: EMPTY
6052: ST_TO_ADDR
// for un in filter_all do
6053: LD_ADDR_VAR 0 2
6057: PUSH
6058: LD_VAR 0 4
6062: PUSH
6063: FOR_IN
6064: IFFALSE 6097
// if not ( un in all_possible ) then
6066: LD_VAR 0 2
6070: PUSH
6071: LD_EXP 39
6075: IN
6076: NOT
6077: IFFALSE 6095
// filter := filter union un ;
6079: LD_ADDR_VAR 0 3
6083: PUSH
6084: LD_VAR 0 3
6088: PUSH
6089: LD_VAR 0 2
6093: UNION
6094: ST_TO_ADDR
6095: GO 6063
6097: POP
6098: POP
// if filter > 0 then
6099: LD_VAR 0 3
6103: PUSH
6104: LD_INT 0
6106: GREATER
6107: IFFALSE 6127
// Say ( filter [ 1 ] , DGosStart-Sol1-1 ) else
6109: LD_VAR 0 3
6113: PUSH
6114: LD_INT 1
6116: ARRAY
6117: PPUSH
6118: LD_STRING DGosStart-Sol1-1
6120: PPUSH
6121: CALL_OW 88
6125: GO 6143
// Say ( filter_all [ 1 ] , DGosStart-Sol1-1 ) ;
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: ARRAY
6135: PPUSH
6136: LD_STRING DGosStart-Sol1-1
6138: PPUSH
6139: CALL_OW 88
// end else
6143: GO 6317
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6145: LD_ADDR_VAR 0 4
6149: PUSH
6150: LD_INT 22
6152: PUSH
6153: LD_EXP 23
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 26
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: LD_INT 50
6174: PUSH
6175: EMPTY
6176: LIST
6177: PUSH
6178: LD_INT 3
6180: PUSH
6181: LD_INT 23
6183: PUSH
6184: LD_INT 0
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 69
6205: ST_TO_ADDR
// if 0 + filter_all > 0 then
6206: LD_INT 0
6208: PUSH
6209: LD_VAR 0 4
6213: PLUS
6214: PUSH
6215: LD_INT 0
6217: GREATER
6218: IFFALSE 6317
// begin filter := [ ] ;
6220: LD_ADDR_VAR 0 3
6224: PUSH
6225: EMPTY
6226: ST_TO_ADDR
// for un in filter_all do
6227: LD_ADDR_VAR 0 2
6231: PUSH
6232: LD_VAR 0 4
6236: PUSH
6237: FOR_IN
6238: IFFALSE 6271
// if not ( un in all_possible ) then
6240: LD_VAR 0 2
6244: PUSH
6245: LD_EXP 39
6249: IN
6250: NOT
6251: IFFALSE 6269
// filter := filter union un ;
6253: LD_ADDR_VAR 0 3
6257: PUSH
6258: LD_VAR 0 3
6262: PUSH
6263: LD_VAR 0 2
6267: UNION
6268: ST_TO_ADDR
6269: GO 6237
6271: POP
6272: POP
// if filter > 0 then
6273: LD_VAR 0 3
6277: PUSH
6278: LD_INT 0
6280: GREATER
6281: IFFALSE 6301
// Say ( filter [ 1 ] , DGosStart-FSol1-1 ) else
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 1
6290: ARRAY
6291: PPUSH
6292: LD_STRING DGosStart-FSol1-1
6294: PPUSH
6295: CALL_OW 88
6299: GO 6317
// Say ( filter_all [ 1 ] , DGosStart-FSol1-1 ) ;
6301: LD_VAR 0 4
6305: PUSH
6306: LD_INT 1
6308: ARRAY
6309: PPUSH
6310: LD_STRING DGosStart-FSol1-1
6312: PPUSH
6313: CALL_OW 88
// end ; end ; end ; Say ( Burlak , DGosStart-Bur-1 ) ;
6317: LD_EXP 1
6321: PPUSH
6322: LD_STRING DGosStart-Bur-1
6324: PPUSH
6325: CALL_OW 88
// Wait ( 0 0$20 ) ;
6329: LD_INT 700
6331: PPUSH
6332: CALL_OW 67
// Say ( Burlak , DGosStart-Bur-1a ) ;
6336: LD_EXP 1
6340: PPUSH
6341: LD_STRING DGosStart-Bur-1a
6343: PPUSH
6344: CALL_OW 88
// SayRadio ( Gossudarov , DGosStart-Gos-1 ) ;
6348: LD_EXP 8
6352: PPUSH
6353: LD_STRING DGosStart-Gos-1
6355: PPUSH
6356: CALL_OW 94
// Say ( Burlak , DGosStart-Bur-2 ) ;
6360: LD_EXP 1
6364: PPUSH
6365: LD_STRING DGosStart-Bur-2
6367: PPUSH
6368: CALL_OW 88
// Hint ( Signal ) ;
6372: LD_STRING Signal
6374: PPUSH
6375: CALL_OW 339
// attackAvalaible = 1 ;
6379: LD_ADDR_EXP 61
6383: PUSH
6384: LD_INT 1
6386: ST_TO_ADDR
// enable ( 6 ) ;
6387: LD_INT 6
6389: ENABLE_MARKED
// EnableExclamations ;
6390: CALL_OW 473
// end ;
6394: LD_VAR 0 1
6398: RET
// export function D_Situation ; var un , filter , filter_all ; begin
6399: LD_INT 0
6401: PPUSH
6402: PPUSH
6403: PPUSH
6404: PPUSH
// DisableExclamations ;
6405: CALL_OW 474
// Say ( Burlak , DSituation-Bur-1 ) ;
6409: LD_EXP 1
6413: PPUSH
6414: LD_STRING DSituation-Bur-1
6416: PPUSH
6417: CALL_OW 88
// filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_female ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6421: LD_ADDR_VAR 0 4
6425: PUSH
6426: LD_INT 22
6428: PUSH
6429: LD_EXP 23
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: PUSH
6438: LD_INT 26
6440: PUSH
6441: LD_INT 2
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 50
6450: PUSH
6451: EMPTY
6452: LIST
6453: PUSH
6454: LD_INT 3
6456: PUSH
6457: LD_INT 23
6459: PUSH
6460: LD_INT 0
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: PPUSH
6477: CALL_OW 69
6481: ST_TO_ADDR
// if 0 + filter_all > 0 then
6482: LD_INT 0
6484: PUSH
6485: LD_VAR 0 4
6489: PLUS
6490: PUSH
6491: LD_INT 0
6493: GREATER
6494: IFFALSE 6595
// begin filter := [ ] ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: EMPTY
6502: ST_TO_ADDR
// for un in filter_all do
6503: LD_ADDR_VAR 0 2
6507: PUSH
6508: LD_VAR 0 4
6512: PUSH
6513: FOR_IN
6514: IFFALSE 6547
// if not ( un in all_possible ) then
6516: LD_VAR 0 2
6520: PUSH
6521: LD_EXP 39
6525: IN
6526: NOT
6527: IFFALSE 6545
// filter := filter union un ;
6529: LD_ADDR_VAR 0 3
6533: PUSH
6534: LD_VAR 0 3
6538: PUSH
6539: LD_VAR 0 2
6543: UNION
6544: ST_TO_ADDR
6545: GO 6513
6547: POP
6548: POP
// if filter > 0 then
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 0
6556: GREATER
6557: IFFALSE 6577
// Say ( filter [ 1 ] , DSituation-RFSol1-1 ) else
6559: LD_VAR 0 3
6563: PUSH
6564: LD_INT 1
6566: ARRAY
6567: PPUSH
6568: LD_STRING DSituation-RFSol1-1
6570: PPUSH
6571: CALL_OW 88
6575: GO 6593
// Say ( filter_all [ 1 ] , DSituation-RFSol1-1 ) ;
6577: LD_VAR 0 4
6581: PUSH
6582: LD_INT 1
6584: ARRAY
6585: PPUSH
6586: LD_STRING DSituation-RFSol1-1
6588: PPUSH
6589: CALL_OW 88
// end else
6593: GO 6783
// begin filter_all := FilterAllUnits ( [ [ f_side , you ] , [ f_sex , sex_male ] , [ f_ok ] , [ f_not , [ f_nation , nation_nature ] ] ] ) ;
6595: LD_ADDR_VAR 0 4
6599: PUSH
6600: LD_INT 22
6602: PUSH
6603: LD_EXP 23
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 26
6614: PUSH
6615: LD_INT 1
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PUSH
6622: LD_INT 50
6624: PUSH
6625: EMPTY
6626: LIST
6627: PUSH
6628: LD_INT 3
6630: PUSH
6631: LD_INT 23
6633: PUSH
6634: LD_INT 0
6636: PUSH
6637: EMPTY
6638: LIST
6639: LIST
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PPUSH
6651: CALL_OW 69
6655: ST_TO_ADDR
// filter_all := filter_all diff Burlak ;
6656: LD_ADDR_VAR 0 4
6660: PUSH
6661: LD_VAR 0 4
6665: PUSH
6666: LD_EXP 1
6670: DIFF
6671: ST_TO_ADDR
// if 0 + filter_all > 0 then
6672: LD_INT 0
6674: PUSH
6675: LD_VAR 0 4
6679: PLUS
6680: PUSH
6681: LD_INT 0
6683: GREATER
6684: IFFALSE 6783
// begin filter := [ ] ;
6686: LD_ADDR_VAR 0 3
6690: PUSH
6691: EMPTY
6692: ST_TO_ADDR
// for un in filter_all do
6693: LD_ADDR_VAR 0 2
6697: PUSH
6698: LD_VAR 0 4
6702: PUSH
6703: FOR_IN
6704: IFFALSE 6737
// if not ( un in all_possible ) then
6706: LD_VAR 0 2
6710: PUSH
6711: LD_EXP 39
6715: IN
6716: NOT
6717: IFFALSE 6735
// filter := filter union un ;
6719: LD_ADDR_VAR 0 3
6723: PUSH
6724: LD_VAR 0 3
6728: PUSH
6729: LD_VAR 0 2
6733: UNION
6734: ST_TO_ADDR
6735: GO 6703
6737: POP
6738: POP
// if filter > 0 then
6739: LD_VAR 0 3
6743: PUSH
6744: LD_INT 0
6746: GREATER
6747: IFFALSE 6767
// Say ( filter [ 1 ] , DSituation-RSol1-1 ) else
6749: LD_VAR 0 3
6753: PUSH
6754: LD_INT 1
6756: ARRAY
6757: PPUSH
6758: LD_STRING DSituation-RSol1-1
6760: PPUSH
6761: CALL_OW 88
6765: GO 6783
// Say ( filter_all [ 1 ] , DSituation-RSol1-1 ) ;
6767: LD_VAR 0 4
6771: PUSH
6772: LD_INT 1
6774: ARRAY
6775: PPUSH
6776: LD_STRING DSituation-RSol1-1
6778: PPUSH
6779: CALL_OW 88
// end ; end ; EnableExclamations ;
6783: CALL_OW 473
// end ;
6787: LD_VAR 0 1
6791: RET
// export function D_GO1 ; begin
6792: LD_INT 0
6794: PPUSH
// DisableExclamations ;
6795: CALL_OW 474
// Say ( Burlak , DGO#1-Bur-1 ) ;
6799: LD_EXP 1
6803: PPUSH
6804: LD_STRING DGO#1-Bur-1
6806: PPUSH
6807: CALL_OW 88
// EnableExclamations ;
6811: CALL_OW 473
// SetAreaMapShow ( ExitArea , 1 ) ;
6815: LD_INT 11
6817: PPUSH
6818: LD_INT 1
6820: PPUSH
6821: CALL_OW 424
// end ;
6825: LD_VAR 0 1
6829: RET
// export function D_SeeYou ; begin
6830: LD_INT 0
6832: PPUSH
// DisableExclamations ;
6833: CALL_OW 474
// DialogueOn ;
6837: CALL_OW 6
// Say ( Gossudarov , DSeeYou-Gos-1 ) ;
6841: LD_EXP 8
6845: PPUSH
6846: LD_STRING DSeeYou-Gos-1
6848: PPUSH
6849: CALL_OW 88
// Say ( Burlak , DSeeYou-Bur-1 ) ;
6853: LD_EXP 1
6857: PPUSH
6858: LD_STRING DSeeYou-Bur-1
6860: PPUSH
6861: CALL_OW 88
// DialogueOff ;
6865: CALL_OW 7
// EnableExclamations ;
6869: CALL_OW 473
// end ; end_of_file
6873: LD_VAR 0 1
6877: RET
// every 0 0$1 + 0 0$0.1 do var filter , un ;
6878: GO 6880
6880: DISABLE
6881: LD_INT 0
6883: PPUSH
6884: PPUSH
// begin if IsInArea ( Burlak , SeeBaseArea ) then
6885: LD_EXP 1
6889: PPUSH
6890: LD_INT 1
6892: PPUSH
6893: CALL_OW 308
6897: IFFALSE 6963
// begin filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_INT 22
6906: PUSH
6907: LD_EXP 27
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for un in filter do
6921: LD_ADDR_VAR 0 2
6925: PUSH
6926: LD_VAR 0 1
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6950
// setside ( un , you ) ;
6934: LD_VAR 0 2
6938: PPUSH
6939: LD_EXP 23
6943: PPUSH
6944: CALL_OW 235
6948: GO 6931
6950: POP
6951: POP
// BurlakReachedBase := true ;
6952: LD_ADDR_EXP 28
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// disable ;
6960: DISABLE
// end else
6961: GO 6964
// enable ;
6963: ENABLE
// end ;
6964: PPOPN 2
6966: END
// every 0 0$1 + 0 0$0.2 do var filter , un , skill , inzenyr ;
6967: GO 6969
6969: DISABLE
6970: LD_INT 0
6972: PPUSH
6973: PPUSH
6974: PPUSH
6975: PPUSH
// begin if IsInArea ( Burlak , StartBuildArea ) then
6976: LD_EXP 1
6980: PPUSH
6981: LD_INT 10
6983: PPUSH
6984: CALL_OW 308
6988: IFFALSE 7219
// begin DisableExclamations ;
6990: CALL_OW 474
// filter := FilterAllUnits ( [ f_side , neutral ] ) ;
6994: LD_ADDR_VAR 0 1
6998: PUSH
6999: LD_INT 22
7001: PUSH
7002: LD_EXP 27
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PPUSH
7011: CALL_OW 69
7015: ST_TO_ADDR
// skill := 0 ;
7016: LD_ADDR_VAR 0 3
7020: PUSH
7021: LD_INT 0
7023: ST_TO_ADDR
// for un in filter do
7024: LD_ADDR_VAR 0 2
7028: PUSH
7029: LD_VAR 0 1
7033: PUSH
7034: FOR_IN
7035: IFFALSE 7069
// if GetSkill ( un , skill_engineering ) >= skill then
7037: LD_VAR 0 2
7041: PPUSH
7042: LD_INT 2
7044: PPUSH
7045: CALL_OW 259
7049: PUSH
7050: LD_VAR 0 3
7054: GREATEREQUAL
7055: IFFALSE 7067
// inzenyr := un ;
7057: LD_ADDR_VAR 0 4
7061: PUSH
7062: LD_VAR 0 2
7066: ST_TO_ADDR
7067: GO 7034
7069: POP
7070: POP
// ComStop ( inzenyr ) ;
7071: LD_VAR 0 4
7075: PPUSH
7076: CALL_OW 141
// if GetClass ( inzenyr ) <> classtype_engineer then
7080: LD_VAR 0 4
7084: PPUSH
7085: CALL_OW 257
7089: PUSH
7090: LD_INT 2
7092: NONEQUAL
7093: IFFALSE 7184
// begin filter := FilterAllUnits ( [ [ f_btype , b_warehouse ] , [ f_side , neutral ] ] ) ;
7095: LD_ADDR_VAR 0 1
7099: PUSH
7100: LD_INT 30
7102: PUSH
7103: LD_INT 1
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: PUSH
7110: LD_INT 22
7112: PUSH
7113: LD_EXP 27
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: PPUSH
7126: CALL_OW 69
7130: ST_TO_ADDR
// ComEnterUnit ( inzenyr , filter [ 1 ] ) ;
7131: LD_VAR 0 4
7135: PPUSH
7136: LD_VAR 0 1
7140: PUSH
7141: LD_INT 1
7143: ARRAY
7144: PPUSH
7145: CALL_OW 120
// Wait ( 10 ) ;
7149: LD_INT 10
7151: PPUSH
7152: CALL_OW 67
// AddComChangeProfession ( inzenyr , classtype_engineer ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 183
// Wait ( 10 ) ;
7168: LD_INT 10
7170: PPUSH
7171: CALL_OW 67
// AddComExitBuilding ( inzenyr ) ;
7175: LD_VAR 0 4
7179: PPUSH
7180: CALL_OW 182
// end ; Wait ( 10 ) ;
7184: LD_INT 10
7186: PPUSH
7187: CALL_OW 67
// AddComBuild ( inzenyr , b_oil_power , 126 , 17 , 5 ) ;
7191: LD_VAR 0 4
7195: PPUSH
7196: LD_INT 26
7198: PPUSH
7199: LD_INT 126
7201: PPUSH
7202: LD_INT 17
7204: PPUSH
7205: LD_INT 5
7207: PPUSH
7208: CALL_OW 205
// EnableExclamations ;
7212: CALL_OW 473
// disable ;
7216: DISABLE
// end else
7217: GO 7220
// enable ;
7219: ENABLE
// end ;
7220: PPOPN 4
7222: END
// every 0 0$10 + 0 0$0.3 marked 1 do var i , bazukr ;
7223: GO 7225
7225: DISABLE
7226: LD_INT 0
7228: PPUSH
7229: PPUSH
// begin if straz < bazooker then
7230: LD_EXP 45
7234: PUSH
7235: LD_EXP 51
7239: LESS
7240: IFFALSE 7388
// begin bazooker := bazooker + 1 ;
7242: LD_ADDR_EXP 51
7246: PUSH
7247: LD_EXP 51
7251: PUSH
7252: LD_INT 1
7254: PLUS
7255: ST_TO_ADDR
// while straz < bazooker do
7256: LD_EXP 45
7260: PUSH
7261: LD_EXP 51
7265: LESS
7266: IFFALSE 7388
// begin uc_side := rus ;
7268: LD_ADDR_OWVAR 20
7272: PUSH
7273: LD_EXP 24
7277: ST_TO_ADDR
// uc_nation := nation_russian ;
7278: LD_ADDR_OWVAR 21
7282: PUSH
7283: LD_INT 3
7285: ST_TO_ADDR
// PrepareHuman ( sex_male , class_bazooker , 4 + difficulty ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_INT 9
7291: PPUSH
7292: LD_INT 4
7294: PUSH
7295: LD_OWVAR 67
7299: PLUS
7300: PPUSH
7301: CALL_OW 380
// hc_name :=  ;
7305: LD_ADDR_OWVAR 26
7309: PUSH
7310: LD_STRING 
7312: ST_TO_ADDR
// bazukr := CreateHuman ;
7313: LD_ADDR_VAR 0 2
7317: PUSH
7318: CALL_OW 44
7322: ST_TO_ADDR
// AddMcUnitsSpec ( rus_mcrep_id , bazukr , 1 ) ;
7323: LD_EXP 62
7327: PPUSH
7328: LD_VAR 0 2
7332: PPUSH
7333: LD_INT 1
7335: PPUSH
7336: CALL_OW 394
// straz := straz ^ bazukr ;
7340: LD_ADDR_EXP 45
7344: PUSH
7345: LD_EXP 45
7349: PUSH
7350: LD_VAR 0 2
7354: ADD
7355: ST_TO_ADDR
// PlaceUnitArea ( bazukr , EnterArea , false ) ;
7356: LD_VAR 0 2
7360: PPUSH
7361: LD_INT 9
7363: PPUSH
7364: LD_INT 0
7366: PPUSH
7367: CALL_OW 49
// ComAgressiveMove ( bazukr , 66 , 48 ) ;
7371: LD_VAR 0 2
7375: PPUSH
7376: LD_INT 66
7378: PPUSH
7379: LD_INT 48
7381: PPUSH
7382: CALL_OW 114
// end ;
7386: GO 7256
// end ; end ;
7388: PPOPN 2
7390: END
// every 0 0$5 + 0 0$0.4 marked 2 do var un ;
7391: GO 7393
7393: DISABLE
7394: LD_INT 0
7396: PPUSH
// begin if ( 0 + straz ) <> 0 then
7397: LD_INT 0
7399: PUSH
7400: LD_EXP 45
7404: PLUS
7405: PUSH
7406: LD_INT 0
7408: NONEQUAL
7409: IFFALSE 7652
// begin for un in straz do
7411: LD_ADDR_VAR 0 1
7415: PUSH
7416: LD_EXP 45
7420: PUSH
7421: FOR_IN
7422: IFFALSE 7650
// begin if not HasTask ( un ) and GetLives ( un ) > 601 then
7424: LD_VAR 0 1
7428: PPUSH
7429: CALL_OW 314
7433: NOT
7434: PUSH
7435: LD_VAR 0 1
7439: PPUSH
7440: CALL_OW 256
7444: PUSH
7445: LD_INT 601
7447: GREATER
7448: AND
7449: IFFALSE 7648
// begin if GetY ( un ) > 60 then
7451: LD_VAR 0 1
7455: PPUSH
7456: CALL_OW 251
7460: PUSH
7461: LD_INT 60
7463: GREATER
7464: IFFALSE 7558
// begin ComAgressiveMove ( un , 66 , 48 ) ;
7466: LD_VAR 0 1
7470: PPUSH
7471: LD_INT 66
7473: PPUSH
7474: LD_INT 48
7476: PPUSH
7477: CALL_OW 114
// AddComAgressiveMove ( un , 63 , 74 ) ;
7481: LD_VAR 0 1
7485: PPUSH
7486: LD_INT 63
7488: PPUSH
7489: LD_INT 74
7491: PPUSH
7492: CALL_OW 174
// AddComAgressiveMove ( un , 73 , 90 ) ;
7496: LD_VAR 0 1
7500: PPUSH
7501: LD_INT 73
7503: PPUSH
7504: LD_INT 90
7506: PPUSH
7507: CALL_OW 174
// AddComAgressiveMove ( un , 76 , 95 ) ;
7511: LD_VAR 0 1
7515: PPUSH
7516: LD_INT 76
7518: PPUSH
7519: LD_INT 95
7521: PPUSH
7522: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7526: LD_VAR 0 1
7530: PPUSH
7531: LD_INT 72
7533: PPUSH
7534: LD_INT 95
7536: PPUSH
7537: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7541: LD_VAR 0 1
7545: PPUSH
7546: LD_INT 50
7548: PPUSH
7549: LD_INT 73
7551: PPUSH
7552: CALL_OW 174
// end else
7556: GO 7648
// begin ComAgressiveMove ( un , 73 , 90 ) ;
7558: LD_VAR 0 1
7562: PPUSH
7563: LD_INT 73
7565: PPUSH
7566: LD_INT 90
7568: PPUSH
7569: CALL_OW 114
// AddComAgressiveMove ( un , 76 , 95 ) ;
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 76
7580: PPUSH
7581: LD_INT 95
7583: PPUSH
7584: CALL_OW 174
// AddComAgressiveMove ( un , 72 , 95 ) ;
7588: LD_VAR 0 1
7592: PPUSH
7593: LD_INT 72
7595: PPUSH
7596: LD_INT 95
7598: PPUSH
7599: CALL_OW 174
// AddComAgressiveMove ( un , 50 , 73 ) ;
7603: LD_VAR 0 1
7607: PPUSH
7608: LD_INT 50
7610: PPUSH
7611: LD_INT 73
7613: PPUSH
7614: CALL_OW 174
// AddComAgressiveMove ( un , 63 , 74 ) ;
7618: LD_VAR 0 1
7622: PPUSH
7623: LD_INT 63
7625: PPUSH
7626: LD_INT 74
7628: PPUSH
7629: CALL_OW 174
// AddComAgressiveMove ( un , 66 , 48 ) ;
7633: LD_VAR 0 1
7637: PPUSH
7638: LD_INT 66
7640: PPUSH
7641: LD_INT 48
7643: PPUSH
7644: CALL_OW 174
// end ; end ; end ;
7648: GO 7421
7650: POP
7651: POP
// end ; enable ;
7652: ENABLE
// end ;
7653: PPOPN 1
7655: END
// every 0 0$1 + 0 0$0.5 do var filter , un ;
7656: GO 7658
7658: DISABLE
7659: LD_INT 0
7661: PPUSH
7662: PPUSH
// begin if IsInArea ( Burlak , BaseArea ) then
7663: LD_EXP 1
7667: PPUSH
7668: LD_INT 2
7670: PPUSH
7671: CALL_OW 308
7675: IFFALSE 7719
// begin disabled5 := true ;
7677: LD_ADDR_LOC 4
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// D_GosStart ;
7685: CALL 5536 0 0
// Wait ( 0 0$5 ) ;
7689: LD_INT 175
7691: PPUSH
7692: CALL_OW 67
// D_Situation ;
7696: CALL 6399 0 0
// ChangeMissionObjectives ( MHold ) ;
7700: LD_STRING MHold
7702: PPUSH
7703: CALL_OW 337
// disable ;
7707: DISABLE
// enable ( 333 ) ;
7708: LD_INT 333
7710: ENABLE_MARKED
// enable ( 334 ) ;
7711: LD_INT 334
7713: ENABLE_MARKED
// enable ( 337 ) ;
7714: LD_INT 337
7716: ENABLE_MARKED
// end else
7717: GO 7720
// enable ;
7719: ENABLE
// end ;
7720: PPOPN 2
7722: END
// var disabled3 , disabled5 ; every 0 0$0.5 marked 3 do
7723: GO 7725
7725: DISABLE
// begin if IsSelected ( Gossudarov ) = true then
7726: LD_EXP 8
7730: PPUSH
7731: CALL_OW 306
7735: PUSH
7736: LD_INT 1
7738: EQUAL
7739: IFFALSE 7765
// begin if WasSelected = false then
7741: LD_EXP 46
7745: PUSH
7746: LD_INT 0
7748: EQUAL
7749: IFFALSE 7763
// begin QueryQGO ;
7751: CALL 7782 0 0
// WasSelected := true ;
7755: LD_ADDR_EXP 46
7759: PUSH
7760: LD_INT 1
7762: ST_TO_ADDR
// end ; end else
7763: GO 7773
// WasSelected := false ;
7765: LD_ADDR_EXP 46
7769: PUSH
7770: LD_INT 0
7772: ST_TO_ADDR
// if not disabled3 then
7773: LD_LOC 3
7777: NOT
7778: IFFALSE 7781
// enable ;
7780: ENABLE
// end ;
7781: END
// export function QueryQGO ; var res , filter , Goss_cargo , pocet , un , t ; begin
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
7787: PPUSH
7788: PPUSH
7789: PPUSH
7790: PPUSH
// res := Query ( QGO ) ;
7791: LD_ADDR_VAR 0 2
7795: PUSH
7796: LD_STRING QGO
7798: PPUSH
7799: CALL_OW 97
7803: ST_TO_ADDR
// if res = 1 then
7804: LD_VAR 0 2
7808: PUSH
7809: LD_INT 1
7811: EQUAL
7812: IFFALSE 8271
// begin disabled3 := true ;
7814: LD_ADDR_LOC 3
7818: PUSH
7819: LD_INT 1
7821: ST_TO_ADDR
// D_GO1 ;
7822: CALL 6792 0 0
// ChangeMissionObjectives ( MGuide ) ;
7826: LD_STRING MGuide
7828: PPUSH
7829: CALL_OW 337
// filter := FilterUnitsInArea ( BluekherCenterArea , [ [ f_type , unit_vehicle ] , [ f_weapon , ru_cargo_bay ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 3
7840: PPUSH
7841: LD_INT 21
7843: PUSH
7844: LD_INT 2
7846: PUSH
7847: EMPTY
7848: LIST
7849: LIST
7850: PUSH
7851: LD_INT 34
7853: PUSH
7854: LD_INT 51
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PUSH
7861: EMPTY
7862: LIST
7863: LIST
7864: PPUSH
7865: CALL_OW 70
7869: ST_TO_ADDR
// if filter = 0 then
7870: LD_VAR 0 3
7874: PUSH
7875: LD_INT 0
7877: EQUAL
7878: IFFALSE 8029
// begin ComMoveXY ( Gossudarov , 57 , 98 ) ;
7880: LD_EXP 8
7884: PPUSH
7885: LD_INT 57
7887: PPUSH
7888: LD_INT 98
7890: PPUSH
7891: CALL_OW 111
// repeat Wait ( 0 0$1 ) ;
7895: LD_INT 35
7897: PPUSH
7898: CALL_OW 67
// until not HasTask ( Gossudarov ) ;
7902: LD_EXP 8
7906: PPUSH
7907: CALL_OW 314
7911: NOT
7912: IFFALSE 7895
// RemoveUnit ( Gossudarov ) ;
7914: LD_EXP 8
7918: PPUSH
7919: CALL_OW 64
// uc_side := ally ;
7923: LD_ADDR_OWVAR 20
7927: PUSH
7928: LD_EXP 25
7932: ST_TO_ADDR
// uc_nation := nation_russian ;
7933: LD_ADDR_OWVAR 21
7937: PUSH
7938: LD_INT 3
7940: ST_TO_ADDR
// uc_direction := 5 ;
7941: LD_ADDR_OWVAR 24
7945: PUSH
7946: LD_INT 5
7948: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
7949: LD_ADDR_OWVAR 37
7953: PUSH
7954: LD_INT 21
7956: ST_TO_ADDR
// vc_engine := engine_combustion ;
7957: LD_ADDR_OWVAR 39
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// vc_control := control_manual ;
7965: LD_ADDR_OWVAR 38
7969: PUSH
7970: LD_INT 1
7972: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
7973: LD_ADDR_OWVAR 40
7977: PUSH
7978: LD_INT 51
7980: ST_TO_ADDR
// Goss_cargo := CreateVehicle ;
7981: LD_ADDR_VAR 0 4
7985: PUSH
7986: CALL_OW 45
7990: ST_TO_ADDR
// PlaceHumanInUnit ( Gossudarov , Goss_cargo ) ;
7991: LD_EXP 8
7995: PPUSH
7996: LD_VAR 0 4
8000: PPUSH
8001: CALL_OW 52
// Wait ( 0 0$5 ) ;
8005: LD_INT 175
8007: PPUSH
8008: CALL_OW 67
// PlaceUnitArea ( Goss_cargo , EnterArea , false ) ;
8012: LD_VAR 0 4
8016: PPUSH
8017: LD_INT 9
8019: PPUSH
8020: LD_INT 0
8022: PPUSH
8023: CALL_OW 49
// end else
8027: GO 8047
// ComEnterUnit ( Gossudarov , filter [ 1 ] ) ;
8029: LD_EXP 8
8033: PPUSH
8034: LD_VAR 0 3
8038: PUSH
8039: LD_INT 1
8041: ARRAY
8042: PPUSH
8043: CALL_OW 120
// AddComGet ( Gossudarov , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8047: LD_EXP 8
8051: PPUSH
8052: LD_INT 4
8054: PPUSH
8055: CALL_OW 469
8059: PUSH
8060: LD_INT 1
8062: ARRAY
8063: PPUSH
8064: LD_INT 4
8066: PPUSH
8067: CALL_OW 469
8071: PUSH
8072: LD_INT 2
8074: ARRAY
8075: PPUSH
8076: CALL_OW 220
// Wait ( 0 0$5 ) ;
8080: LD_INT 175
8082: PPUSH
8083: CALL_OW 67
// t := 0 0$50 ;
8087: LD_ADDR_VAR 0 7
8091: PUSH
8092: LD_INT 1750
8094: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8095: LD_INT 35
8097: PPUSH
8098: CALL_OW 67
// t := t - 0 0$1 ;
8102: LD_ADDR_VAR 0 7
8106: PUSH
8107: LD_VAR 0 7
8111: PUSH
8112: LD_INT 35
8114: MINUS
8115: ST_TO_ADDR
// if not HasTask ( Gossudarov ) then
8116: LD_EXP 8
8120: PPUSH
8121: CALL_OW 314
8125: NOT
8126: IFFALSE 8143
// ComMoveXY ( Gossudarov , 50 , 58 ) ;
8128: LD_EXP 8
8132: PPUSH
8133: LD_INT 50
8135: PPUSH
8136: LD_INT 58
8138: PPUSH
8139: CALL_OW 111
// until not FilterUnitsInArea ( BluekherArea , [ f_weapon , ru_cargo_bay ] ) or not t ;
8143: LD_INT 22
8145: PPUSH
8146: LD_INT 34
8148: PUSH
8149: LD_INT 51
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: PPUSH
8156: CALL_OW 70
8160: NOT
8161: PUSH
8162: LD_VAR 0 7
8166: NOT
8167: OR
8168: IFFALSE 8095
// ComExitBuilding ( scientists ) ;
8170: LD_EXP 40
8174: PPUSH
8175: CALL_OW 122
// AddComMoveXY ( scientists ^ Gossudarov , 50 , 58 ) ;
8179: LD_EXP 40
8183: PUSH
8184: LD_EXP 8
8188: ADD
8189: PPUSH
8190: LD_INT 50
8192: PPUSH
8193: LD_INT 58
8195: PPUSH
8196: CALL_OW 171
// for un in scientists ^ Gossudarov do
8200: LD_ADDR_VAR 0 6
8204: PUSH
8205: LD_EXP 40
8209: PUSH
8210: LD_EXP 8
8214: ADD
8215: PUSH
8216: FOR_IN
8217: IFFALSE 8235
// AddComSailEvent ( un , un ) ;
8219: LD_VAR 0 6
8223: PPUSH
8224: LD_VAR 0 6
8228: PPUSH
8229: CALL_OW 224
8233: GO 8216
8235: POP
8236: POP
// player_units := player_units union scientists union Gossudarov ;
8237: LD_ADDR_EXP 41
8241: PUSH
8242: LD_EXP 41
8246: PUSH
8247: LD_EXP 40
8251: UNION
8252: PUSH
8253: LD_EXP 8
8257: UNION
8258: ST_TO_ADDR
// enable ( 4 ) ;
8259: LD_INT 4
8261: ENABLE_MARKED
// enable ( 7 ) ;
8262: LD_INT 7
8264: ENABLE_MARKED
// enable ( 8 ) ;
8265: LD_INT 8
8267: ENABLE_MARKED
// enable ( 9 ) ;
8268: LD_INT 9
8270: ENABLE_MARKED
// end ; end ;
8271: LD_VAR 0 1
8275: RET
// every 0 0$1 + 0 0$0.6 marked 4 do var un ;
8276: GO 8278
8278: DISABLE
8279: LD_INT 0
8281: PPUSH
// begin for un in scientists do
8282: LD_ADDR_VAR 0 1
8286: PUSH
8287: LD_EXP 40
8291: PUSH
8292: FOR_IN
8293: IFFALSE 8363
// begin if IsInArea ( un , ExitArea ) then
8295: LD_VAR 0 1
8299: PPUSH
8300: LD_INT 11
8302: PPUSH
8303: CALL_OW 308
8307: IFFALSE 8334
// begin scientists_saved := scientists_saved union un ;
8309: LD_ADDR_EXP 48
8313: PUSH
8314: LD_EXP 48
8318: PUSH
8319: LD_VAR 0 1
8323: UNION
8324: ST_TO_ADDR
// RemoveUnit ( un ) ;
8325: LD_VAR 0 1
8329: PPUSH
8330: CALL_OW 64
// end ; if IsDead ( un ) then
8334: LD_VAR 0 1
8338: PPUSH
8339: CALL_OW 301
8343: IFFALSE 8361
// scientists_dead := scientists_dead union un ;
8345: LD_ADDR_EXP 49
8349: PUSH
8350: LD_EXP 49
8354: PUSH
8355: LD_VAR 0 1
8359: UNION
8360: ST_TO_ADDR
// end ;
8361: GO 8292
8363: POP
8364: POP
// if ( IsInArea ( Gossudarov , ExitArea ) or IsInArea ( IsInUnit ( Gossudarov ) , ExitArea ) ) and scientists_saved + scientists_dead = scientists and GetSide ( Artifact_cargo ) = you and IsInArea ( Artifact_cargo , ExitArea ) and GetCargo ( Artifact_cargo , mat_artifact ) = 40 then
8365: LD_EXP 8
8369: PPUSH
8370: LD_INT 11
8372: PPUSH
8373: CALL_OW 308
8377: PUSH
8378: LD_EXP 8
8382: PPUSH
8383: CALL_OW 310
8387: PPUSH
8388: LD_INT 11
8390: PPUSH
8391: CALL_OW 308
8395: OR
8396: PUSH
8397: LD_EXP 48
8401: PUSH
8402: LD_EXP 49
8406: PLUS
8407: PUSH
8408: LD_EXP 40
8412: EQUAL
8413: AND
8414: PUSH
8415: LD_EXP 50
8419: PPUSH
8420: CALL_OW 255
8424: PUSH
8425: LD_EXP 23
8429: EQUAL
8430: AND
8431: PUSH
8432: LD_EXP 50
8436: PPUSH
8437: LD_INT 11
8439: PPUSH
8440: CALL_OW 308
8444: AND
8445: PUSH
8446: LD_EXP 50
8450: PPUSH
8451: LD_INT 4
8453: PPUSH
8454: CALL_OW 289
8458: PUSH
8459: LD_INT 40
8461: EQUAL
8462: AND
8463: IFFALSE 8475
// begin D_SeeYou ;
8465: CALL 6830 0 0
// TheEnd ;
8469: CALL 3316 0 0
// end else
8473: GO 8476
// enable ;
8475: ENABLE
// end ;
8476: PPOPN 1
8478: END
// var Attack1 , Attack2 , Attack3 ; every 0 0$1 + 0 0$0.8 marked 5 do var i ;
8479: GO 8481
8481: DISABLE
8482: LD_INT 0
8484: PPUSH
// begin if IsInArea ( Burlak , Attack1Area ) or IsInArea ( Masha , Attack1Area ) then
8485: LD_EXP 1
8489: PPUSH
8490: LD_INT 18
8492: PPUSH
8493: CALL_OW 308
8497: PUSH
8498: LD_EXP 43
8502: PPUSH
8503: LD_INT 18
8505: PPUSH
8506: CALL_OW 308
8510: OR
8511: IFFALSE 8528
// begin Wait ( 0 0$3 ) ;
8513: LD_INT 105
8515: PPUSH
8516: CALL_OW 67
// Attack1 := true ;
8520: LD_ADDR_LOC 5
8524: PUSH
8525: LD_INT 1
8527: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack2Area ) or IsInArea ( Masha , Attack2Area ) then
8528: LD_EXP 1
8532: PPUSH
8533: LD_INT 19
8535: PPUSH
8536: CALL_OW 308
8540: PUSH
8541: LD_EXP 43
8545: PPUSH
8546: LD_INT 19
8548: PPUSH
8549: CALL_OW 308
8553: OR
8554: IFFALSE 8571
// begin Wait ( 0 0$3 ) ;
8556: LD_INT 105
8558: PPUSH
8559: CALL_OW 67
// Attack2 := true ;
8563: LD_ADDR_LOC 6
8567: PUSH
8568: LD_INT 1
8570: ST_TO_ADDR
// end ; if IsInArea ( Burlak , Attack3Area ) or IsInArea ( Masha , Attack3Area ) then
8571: LD_EXP 1
8575: PPUSH
8576: LD_INT 20
8578: PPUSH
8579: CALL_OW 308
8583: PUSH
8584: LD_EXP 43
8588: PPUSH
8589: LD_INT 20
8591: PPUSH
8592: CALL_OW 308
8596: OR
8597: IFFALSE 8614
// begin Wait ( 0 0$3 ) ;
8599: LD_INT 105
8601: PPUSH
8602: CALL_OW 67
// Attack3 := true ;
8606: LD_ADDR_LOC 7
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// end ; if Attack1 and not Attack2 and not Attack3 then
8614: LD_LOC 5
8618: PUSH
8619: LD_LOC 6
8623: NOT
8624: AND
8625: PUSH
8626: LD_LOC 7
8630: NOT
8631: AND
8632: IFFALSE 8695
// for i := pursuers_base + 1 to pursuers_base + pursuers do
8634: LD_ADDR_VAR 0 1
8638: PUSH
8639: DOUBLE
8640: LD_EXP 31
8644: PUSH
8645: LD_INT 1
8647: PLUS
8648: DEC
8649: ST_TO_ADDR
8650: LD_EXP 31
8654: PUSH
8655: LD_EXP 30
8659: PLUS
8660: PUSH
8661: FOR_TO
8662: IFFALSE 8693
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8664: LD_EXP 29
8668: PUSH
8669: LD_VAR 0 1
8673: ARRAY
8674: PPUSH
8675: LD_EXP 1
8679: PPUSH
8680: CALL_OW 115
// Wait ( 2 ) ;
8684: LD_INT 2
8686: PPUSH
8687: CALL_OW 67
// end ;
8691: GO 8661
8693: POP
8694: POP
// if Attack1 and Attack2 and not Attack3 then
8695: LD_LOC 5
8699: PUSH
8700: LD_LOC 6
8704: AND
8705: PUSH
8706: LD_LOC 7
8710: NOT
8711: AND
8712: IFFALSE 8779
// for i := pursuers_base + 1 to pursuers_base + 2 * pursuers do
8714: LD_ADDR_VAR 0 1
8718: PUSH
8719: DOUBLE
8720: LD_EXP 31
8724: PUSH
8725: LD_INT 1
8727: PLUS
8728: DEC
8729: ST_TO_ADDR
8730: LD_EXP 31
8734: PUSH
8735: LD_INT 2
8737: PUSH
8738: LD_EXP 30
8742: MUL
8743: PLUS
8744: PUSH
8745: FOR_TO
8746: IFFALSE 8777
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8748: LD_EXP 29
8752: PUSH
8753: LD_VAR 0 1
8757: ARRAY
8758: PPUSH
8759: LD_EXP 1
8763: PPUSH
8764: CALL_OW 115
// Wait ( 2 ) ;
8768: LD_INT 2
8770: PPUSH
8771: CALL_OW 67
// end ;
8775: GO 8745
8777: POP
8778: POP
// if Attack1 and Attack2 and Attack3 then
8779: LD_LOC 5
8783: PUSH
8784: LD_LOC 6
8788: AND
8789: PUSH
8790: LD_LOC 7
8794: AND
8795: IFFALSE 8862
// for i := pursuers_base + 1 to pursuers_base + 3 * pursuers do
8797: LD_ADDR_VAR 0 1
8801: PUSH
8802: DOUBLE
8803: LD_EXP 31
8807: PUSH
8808: LD_INT 1
8810: PLUS
8811: DEC
8812: ST_TO_ADDR
8813: LD_EXP 31
8817: PUSH
8818: LD_INT 3
8820: PUSH
8821: LD_EXP 30
8825: MUL
8826: PLUS
8827: PUSH
8828: FOR_TO
8829: IFFALSE 8860
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8831: LD_EXP 29
8835: PUSH
8836: LD_VAR 0 1
8840: ARRAY
8841: PPUSH
8842: LD_EXP 1
8846: PPUSH
8847: CALL_OW 115
// Wait ( 2 ) ;
8851: LD_INT 2
8853: PPUSH
8854: CALL_OW 67
// end ;
8858: GO 8828
8860: POP
8861: POP
// for i := 1 to pursuers_base do
8862: LD_ADDR_VAR 0 1
8866: PUSH
8867: DOUBLE
8868: LD_INT 1
8870: DEC
8871: ST_TO_ADDR
8872: LD_EXP 31
8876: PUSH
8877: FOR_TO
8878: IFFALSE 8909
// begin ComAttackUnit ( pursuer [ i ] , Burlak ) ;
8880: LD_EXP 29
8884: PUSH
8885: LD_VAR 0 1
8889: ARRAY
8890: PPUSH
8891: LD_EXP 1
8895: PPUSH
8896: CALL_OW 115
// Wait ( 2 ) ;
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 67
// end ;
8907: GO 8877
8909: POP
8910: POP
// if not disabled5 then
8911: LD_LOC 4
8915: NOT
8916: IFFALSE 8919
// enable ;
8918: ENABLE
// end ;
8919: PPOPN 1
8921: END
// every 0 0$1 marked 6 do
8922: GO 8924
8924: DISABLE
// begin if Goss_time > 0 then
8925: LD_EXP 47
8929: PUSH
8930: LD_INT 0
8932: GREATER
8933: IFFALSE 8969
// begin display_strings := [ #Ru12a-1 , Goss_time ] ;
8935: LD_ADDR_OWVAR 47
8939: PUSH
8940: LD_STRING #Ru12a-1
8942: PUSH
8943: LD_EXP 47
8947: PUSH
8948: EMPTY
8949: LIST
8950: LIST
8951: ST_TO_ADDR
// Goss_time := Goss_time - 0 0$1 ;
8952: LD_ADDR_EXP 47
8956: PUSH
8957: LD_EXP 47
8961: PUSH
8962: LD_INT 35
8964: MINUS
8965: ST_TO_ADDR
// enable ;
8966: ENABLE
// end else
8967: GO 8980
// begin display_strings :=  ;
8969: LD_ADDR_OWVAR 47
8973: PUSH
8974: LD_STRING 
8976: ST_TO_ADDR
// enable ( 3 ) ;
8977: LD_INT 3
8979: ENABLE_MARKED
// end ; end ;
8980: END
// every 0 0$1 marked 7 do
8981: GO 8983
8983: DISABLE
// begin if FindArtifact ( 4 ) then
8984: LD_INT 4
8986: PPUSH
8987: CALL_OW 469
8991: IFFALSE 9045
// begin ComGet ( Rus_Cargo , FindArtifact ( 4 ) [ 1 ] , FindArtifact ( 4 ) [ 2 ] ) ;
8993: LD_LOC 8
8997: PPUSH
8998: LD_INT 4
9000: PPUSH
9001: CALL_OW 469
9005: PUSH
9006: LD_INT 1
9008: ARRAY
9009: PPUSH
9010: LD_INT 4
9012: PPUSH
9013: CALL_OW 469
9017: PUSH
9018: LD_INT 2
9020: ARRAY
9021: PPUSH
9022: CALL_OW 160
// Wait ( 3 ) ;
9026: LD_INT 3
9028: PPUSH
9029: CALL_OW 67
// AddComMoveToArea ( Rus_Cargo , EnterArea ) ;
9033: LD_LOC 8
9037: PPUSH
9038: LD_INT 9
9040: PPUSH
9041: CALL_OW 173
// end ; enable ;
9045: ENABLE
// end ;
9046: END
// var Rus_Cargo ; every 0 0$1 marked 8 do var i , clovek , sc_utok , un ;
9047: GO 9049
9049: DISABLE
9050: LD_INT 0
9052: PPUSH
9053: PPUSH
9054: PPUSH
9055: PPUSH
// begin Wait ( pausa ) ;
9056: LD_EXP 37
9060: PPUSH
9061: CALL_OW 67
// sc_utok := [ ] ;
9065: LD_ADDR_VAR 0 3
9069: PUSH
9070: EMPTY
9071: ST_TO_ADDR
// for i := 1 to 2 + difficulty do
9072: LD_ADDR_VAR 0 1
9076: PUSH
9077: DOUBLE
9078: LD_INT 1
9080: DEC
9081: ST_TO_ADDR
9082: LD_INT 2
9084: PUSH
9085: LD_OWVAR 67
9089: PLUS
9090: PUSH
9091: FOR_TO
9092: IFFALSE 9296
// begin uc_side := rus ;
9094: LD_ADDR_OWVAR 20
9098: PUSH
9099: LD_EXP 24
9103: ST_TO_ADDR
// uc_nation := nation_russian ;
9104: LD_ADDR_OWVAR 21
9108: PUSH
9109: LD_INT 3
9111: ST_TO_ADDR
// uc_direction := 5 ;
9112: LD_ADDR_OWVAR 24
9116: PUSH
9117: LD_INT 5
9119: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
9120: LD_INT 1
9122: PPUSH
9123: LD_INT 3
9125: PPUSH
9126: CALL_OW 12
9130: PUSH
9131: LD_INT 1
9133: DOUBLE
9134: EQUAL
9135: IFTRUE 9139
9137: GO 9163
9139: POP
// PrepareHuman ( sex_male , class_soldier , Rand ( 4 , 8 ) ) ; 2 .. 3 :
9140: LD_INT 1
9142: PPUSH
9143: LD_INT 1
9145: PPUSH
9146: LD_INT 4
9148: PPUSH
9149: LD_INT 8
9151: PPUSH
9152: CALL_OW 12
9156: PPUSH
9157: CALL_OW 380
9161: GO 9202
9163: LD_INT 2
9165: DOUBLE
9166: GREATEREQUAL
9167: IFFALSE 9175
9169: LD_INT 3
9171: DOUBLE
9172: LESSEQUAL
9173: IFTRUE 9177
9175: GO 9201
9177: POP
// PrepareHuman ( sex_male , class_bazooker , Rand ( 3 , 7 ) ) ; end ;
9178: LD_INT 1
9180: PPUSH
9181: LD_INT 9
9183: PPUSH
9184: LD_INT 3
9186: PPUSH
9187: LD_INT 7
9189: PPUSH
9190: CALL_OW 12
9194: PPUSH
9195: CALL_OW 380
9199: GO 9202
9201: POP
// hc_name :=  ;
9202: LD_ADDR_OWVAR 26
9206: PUSH
9207: LD_STRING 
9209: ST_TO_ADDR
// clovek := CreateHuman ;
9210: LD_ADDR_VAR 0 2
9214: PUSH
9215: CALL_OW 44
9219: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
9220: LD_VAR 0 2
9224: PPUSH
9225: LD_INT 9
9227: PPUSH
9228: LD_INT 0
9230: PPUSH
9231: CALL_OW 49
// Wait ( 0 0$2 ) ;
9235: LD_INT 70
9237: PPUSH
9238: CALL_OW 67
// ComMoveXY ( clovek , 50 , 84 ) ;
9242: LD_VAR 0 2
9246: PPUSH
9247: LD_INT 50
9249: PPUSH
9250: LD_INT 84
9252: PPUSH
9253: CALL_OW 111
// Wait ( 2 ) ;
9257: LD_INT 2
9259: PPUSH
9260: CALL_OW 67
// AddComAttackUnit ( clovek , Artifact_cargo ) ;
9264: LD_VAR 0 2
9268: PPUSH
9269: LD_EXP 50
9273: PPUSH
9274: CALL_OW 175
// sc_utok := sc_utok ^ clovek ;
9278: LD_ADDR_VAR 0 3
9282: PUSH
9283: LD_VAR 0 3
9287: PUSH
9288: LD_VAR 0 2
9292: ADD
9293: ST_TO_ADDR
// end ;
9294: GO 9091
9296: POP
9297: POP
// Wait ( 0 0$10 ) ;
9298: LD_INT 350
9300: PPUSH
9301: CALL_OW 67
// if not IsOK ( Rus_Cargo ) then
9305: LD_LOC 8
9309: PPUSH
9310: CALL_OW 302
9314: NOT
9315: IFFALSE 9422
// begin uc_side := rus ;
9317: LD_ADDR_OWVAR 20
9321: PUSH
9322: LD_EXP 24
9326: ST_TO_ADDR
// uc_nation := nation_russian ;
9327: LD_ADDR_OWVAR 21
9331: PUSH
9332: LD_INT 3
9334: ST_TO_ADDR
// uc_direction := 5 ;
9335: LD_ADDR_OWVAR 24
9339: PUSH
9340: LD_INT 5
9342: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
9343: LD_ADDR_OWVAR 37
9347: PUSH
9348: LD_INT 22
9350: ST_TO_ADDR
// vc_control := control_computer ;
9351: LD_ADDR_OWVAR 38
9355: PUSH
9356: LD_INT 3
9358: ST_TO_ADDR
// vc_engine := engine_siberite ;
9359: LD_ADDR_OWVAR 39
9363: PUSH
9364: LD_INT 3
9366: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
9367: LD_ADDR_OWVAR 40
9371: PUSH
9372: LD_INT 51
9374: ST_TO_ADDR
// Rus_Cargo := CreateVehicle ;
9375: LD_ADDR_LOC 8
9379: PUSH
9380: CALL_OW 45
9384: ST_TO_ADDR
// PlaceUnitArea ( Rus_Cargo , EnterArea , false ) ;
9385: LD_LOC 8
9389: PPUSH
9390: LD_INT 9
9392: PPUSH
9393: LD_INT 0
9395: PPUSH
9396: CALL_OW 49
// Wait ( 0 0$0.5 ) ;
9400: LD_INT 18
9402: PPUSH
9403: CALL_OW 67
// ComMoveXY ( Rus_Cargo , 55 , 84 ) ;
9407: LD_LOC 8
9411: PPUSH
9412: LD_INT 55
9414: PPUSH
9415: LD_INT 84
9417: PPUSH
9418: CALL_OW 111
// end ; while sc_utok and IsOK ( Rus_Cargo ) do
9422: LD_VAR 0 3
9426: PUSH
9427: LD_LOC 8
9431: PPUSH
9432: CALL_OW 302
9436: AND
9437: IFFALSE 9507
// begin ComAttackUnit ( sc_utok , Artifact_cargo ) ;
9439: LD_VAR 0 3
9443: PPUSH
9444: LD_EXP 50
9448: PPUSH
9449: CALL_OW 115
// Wait ( 0 0$2 ) ;
9453: LD_INT 70
9455: PPUSH
9456: CALL_OW 67
// for un in sc_utok do
9460: LD_ADDR_VAR 0 4
9464: PUSH
9465: LD_VAR 0 3
9469: PUSH
9470: FOR_IN
9471: IFFALSE 9503
// if not IsOK ( un ) then
9473: LD_VAR 0 4
9477: PPUSH
9478: CALL_OW 302
9482: NOT
9483: IFFALSE 9501
// sc_utok := sc_utok diff un ;
9485: LD_ADDR_VAR 0 3
9489: PUSH
9490: LD_VAR 0 3
9494: PUSH
9495: LD_VAR 0 4
9499: DIFF
9500: ST_TO_ADDR
9501: GO 9470
9503: POP
9504: POP
// end ;
9505: GO 9422
// Wait ( 0 0$5 ) ;
9507: LD_INT 175
9509: PPUSH
9510: CALL_OW 67
// enable ;
9514: ENABLE
// end ;
9515: PPOPN 4
9517: END
// every 0 0$3 marked 9 do
9518: GO 9520
9520: DISABLE
// begin if IsInArea ( Rus_Cargo , BluekherCenterArea ) and ( GetCargo ( Rus_Cargo , mat_artifact ) = 40 ) then
9521: LD_LOC 8
9525: PPUSH
9526: LD_INT 3
9528: PPUSH
9529: CALL_OW 308
9533: PUSH
9534: LD_LOC 8
9538: PPUSH
9539: LD_INT 4
9541: PPUSH
9542: CALL_OW 289
9546: PUSH
9547: LD_INT 40
9549: EQUAL
9550: AND
9551: IFFALSE 9560
// YouLost ( Artefact ) ;
9553: LD_STRING Artefact
9555: PPUSH
9556: CALL_OW 104
// enable ;
9560: ENABLE
// end ;
9561: END
// on UnitDestroyed ( human ) do var i , un ;
9562: LD_INT 0
9564: PPUSH
9565: PPUSH
// begin if human = Burlak then
9566: LD_VAR 0 1
9570: PUSH
9571: LD_EXP 1
9575: EQUAL
9576: IFFALSE 9585
// YouLost ( Burlak ) ;
9578: LD_STRING Burlak
9580: PPUSH
9581: CALL_OW 104
// if human = Gossudarov then
9585: LD_VAR 0 1
9589: PUSH
9590: LD_EXP 8
9594: EQUAL
9595: IFFALSE 9604
// YouLost ( Gossudarov ) ;
9597: LD_STRING Gossudarov
9599: PPUSH
9600: CALL_OW 104
// if human = Masha then
9604: LD_VAR 0 1
9608: PUSH
9609: LD_EXP 43
9613: EQUAL
9614: IFFALSE 9624
// lost_masha := true ;
9616: LD_ADDR_EXP 52
9620: PUSH
9621: LD_INT 1
9623: ST_TO_ADDR
// if human in straz then
9624: LD_VAR 0 1
9628: PUSH
9629: LD_EXP 45
9633: IN
9634: IFFALSE 9683
// begin straz := straz diff human ;
9636: LD_ADDR_EXP 45
9640: PUSH
9641: LD_EXP 45
9645: PUSH
9646: LD_VAR 0 1
9650: DIFF
9651: ST_TO_ADDR
// RemoveMcUnitsSpec ( rus_mcrep_id , human , 1 ) ;
9652: LD_EXP 62
9656: PPUSH
9657: LD_VAR 0 1
9661: PPUSH
9662: LD_INT 1
9664: PPUSH
9665: CALL_OW 395
// killed_russians := killed_russians + 1 ;
9669: LD_ADDR_EXP 53
9673: PUSH
9674: LD_EXP 53
9678: PUSH
9679: LD_INT 1
9681: PLUS
9682: ST_TO_ADDR
// end ; if GetSide ( human ) = 3 and human in attackGroup then
9683: LD_VAR 0 1
9687: PPUSH
9688: CALL_OW 255
9692: PUSH
9693: LD_INT 3
9695: EQUAL
9696: PUSH
9697: LD_VAR 0 1
9701: PUSH
9702: LD_EXP 60
9706: IN
9707: AND
9708: IFFALSE 9755
// begin for i in attackGroup do
9710: LD_ADDR_VAR 0 2
9714: PUSH
9715: LD_EXP 60
9719: PUSH
9720: FOR_IN
9721: IFFALSE 9753
// if i = human then
9723: LD_VAR 0 2
9727: PUSH
9728: LD_VAR 0 1
9732: EQUAL
9733: IFFALSE 9751
// attackGroup = attackGroup diff i ;
9735: LD_ADDR_EXP 60
9739: PUSH
9740: LD_EXP 60
9744: PUSH
9745: LD_VAR 0 2
9749: DIFF
9750: ST_TO_ADDR
9751: GO 9720
9753: POP
9754: POP
// end ; end ;
9755: PPOPN 3
9757: END
// on SailEvent ( num ) do begin if num = Gossudarov then
9758: LD_VAR 0 1
9762: PUSH
9763: LD_EXP 8
9767: EQUAL
9768: IFFALSE 9789
// SetSide ( IsInUnit ( Gossudarov ) , you ) ;
9770: LD_EXP 8
9774: PPUSH
9775: CALL_OW 310
9779: PPUSH
9780: LD_EXP 23
9784: PPUSH
9785: CALL_OW 235
// SetSide ( num , you ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: LD_EXP 23
9798: PPUSH
9799: CALL_OW 235
// end ;
9803: PPOPN 1
9805: END
// on ArtifactLoaded ( un , size ) do begin if GetSide ( un ) <> rus then
9806: LD_VAR 0 1
9810: PPUSH
9811: CALL_OW 255
9815: PUSH
9816: LD_EXP 24
9820: NONEQUAL
9821: IFFALSE 9833
// Artifact_cargo := un ;
9823: LD_ADDR_EXP 50
9827: PUSH
9828: LD_VAR 0 1
9832: ST_TO_ADDR
// end ; end_of_file
9833: PPOPN 2
9835: END
// var vehicles , attack ; every 0 0$1 + 0 0$0.1 marked 333 do var filter , i , rnd , typ , auto , clovek , un ;
9836: GO 9838
9838: DISABLE
9839: LD_INT 0
9841: PPUSH
9842: PPUSH
9843: PPUSH
9844: PPUSH
9845: PPUSH
9846: PPUSH
9847: PPUSH
// begin case tick of 0 .. 30000 :
9848: LD_OWVAR 1
9852: PUSH
9853: LD_INT 0
9855: DOUBLE
9856: GREATEREQUAL
9857: IFFALSE 9865
9859: LD_INT 30000
9861: DOUBLE
9862: LESSEQUAL
9863: IFTRUE 9867
9865: GO 9877
9867: POP
// Wait ( 0 0$30 ) ; 30001 .. 50000 :
9868: LD_INT 1050
9870: PPUSH
9871: CALL_OW 67
9875: GO 10053
9877: LD_INT 30001
9879: DOUBLE
9880: GREATEREQUAL
9881: IFFALSE 9889
9883: LD_INT 50000
9885: DOUBLE
9886: LESSEQUAL
9887: IFTRUE 9891
9889: GO 9901
9891: POP
// Wait ( 0 0$45 ) ; 50001 .. 70000 :
9892: LD_INT 1575
9894: PPUSH
9895: CALL_OW 67
9899: GO 10053
9901: LD_INT 50001
9903: DOUBLE
9904: GREATEREQUAL
9905: IFFALSE 9913
9907: LD_INT 70000
9909: DOUBLE
9910: LESSEQUAL
9911: IFTRUE 9915
9913: GO 9925
9915: POP
// Wait ( 1 1$0 ) ; 70001 .. 90000 :
9916: LD_INT 2100
9918: PPUSH
9919: CALL_OW 67
9923: GO 10053
9925: LD_INT 70001
9927: DOUBLE
9928: GREATEREQUAL
9929: IFFALSE 9937
9931: LD_INT 90000
9933: DOUBLE
9934: LESSEQUAL
9935: IFTRUE 9939
9937: GO 9949
9939: POP
// Wait ( 1 1$15 ) ; 70001 .. 90000 :
9940: LD_INT 2625
9942: PPUSH
9943: CALL_OW 67
9947: GO 10053
9949: LD_INT 70001
9951: DOUBLE
9952: GREATEREQUAL
9953: IFFALSE 9961
9955: LD_INT 90000
9957: DOUBLE
9958: LESSEQUAL
9959: IFTRUE 9963
9961: GO 9973
9963: POP
// Wait ( 1 1$30 ) ; 90001 .. 110000 :
9964: LD_INT 3150
9966: PPUSH
9967: CALL_OW 67
9971: GO 10053
9973: LD_INT 90001
9975: DOUBLE
9976: GREATEREQUAL
9977: IFFALSE 9985
9979: LD_INT 110000
9981: DOUBLE
9982: LESSEQUAL
9983: IFTRUE 9987
9985: GO 9997
9987: POP
// Wait ( 1 1$45 ) ; 110001 .. 130000 :
9988: LD_INT 3675
9990: PPUSH
9991: CALL_OW 67
9995: GO 10053
9997: LD_INT 110001
9999: DOUBLE
10000: GREATEREQUAL
10001: IFFALSE 10009
10003: LD_INT 130000
10005: DOUBLE
10006: LESSEQUAL
10007: IFTRUE 10011
10009: GO 10021
10011: POP
// Wait ( 2 2$0 ) ; 130001 .. 150000 :
10012: LD_INT 4200
10014: PPUSH
10015: CALL_OW 67
10019: GO 10053
10021: LD_INT 130001
10023: DOUBLE
10024: GREATEREQUAL
10025: IFFALSE 10033
10027: LD_INT 150000
10029: DOUBLE
10030: LESSEQUAL
10031: IFTRUE 10035
10033: GO 10045
10035: POP
// Wait ( 2 2$15 ) ; else
10036: LD_INT 4725
10038: PPUSH
10039: CALL_OW 67
10043: GO 10053
10045: POP
// Wait ( 2 2$30 ) ; end ;
10046: LD_INT 5250
10048: PPUSH
10049: CALL_OW 67
// vehicles := [ [ ru_medium_tracked , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_gatling_gun ] , [ ru_heavy_tracked , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_wheeled , control_computer , engine_combustion , ru_rocket_launcher ] , [ ru_medium_tracked , control_computer , engine_combustion , ru_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_heavy_gun ] , [ ru_heavy_wheeled , control_computer , engine_siberite , ru_rocket ] , [ ru_heavy_tracked , control_computer , engine_siberite , ru_time_lapser ] , [ ru_heavy_wheeled , control_computer , engine_combustion , ru_time_lapser ] ] ;
10053: LD_ADDR_LOC 9
10057: PUSH
10058: LD_INT 22
10060: PUSH
10061: LD_INT 3
10063: PUSH
10064: LD_INT 1
10066: PUSH
10067: LD_INT 43
10069: PUSH
10070: EMPTY
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: PUSH
10076: LD_INT 23
10078: PUSH
10079: LD_INT 3
10081: PUSH
10082: LD_INT 1
10084: PUSH
10085: LD_INT 45
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 21
10096: PUSH
10097: LD_INT 3
10099: PUSH
10100: LD_INT 1
10102: PUSH
10103: LD_INT 43
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: PUSH
10112: LD_INT 24
10114: PUSH
10115: LD_INT 3
10117: PUSH
10118: LD_INT 1
10120: PUSH
10121: LD_INT 45
10123: PUSH
10124: EMPTY
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: PUSH
10130: LD_INT 21
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: LD_INT 1
10138: PUSH
10139: LD_INT 45
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: LD_INT 1
10156: PUSH
10157: LD_INT 44
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: PUSH
10166: LD_INT 24
10168: PUSH
10169: LD_INT 3
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 46
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: PUSH
10184: LD_INT 23
10186: PUSH
10187: LD_INT 3
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: LD_INT 46
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 24
10204: PUSH
10205: LD_INT 3
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: LD_INT 46
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 23
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: LD_INT 3
10228: PUSH
10229: LD_INT 47
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 24
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: LD_INT 49
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: PUSH
10256: LD_INT 23
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: LD_INT 1
10264: PUSH
10265: LD_INT 49
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: LIST
10272: LIST
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
10288: LD_ADDR_VAR 0 1
10292: PUSH
10293: LD_INT 22
10295: PUSH
10296: LD_EXP 23
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: PUSH
10305: LD_INT 21
10307: PUSH
10308: LD_INT 2
10310: PUSH
10311: EMPTY
10312: LIST
10313: LIST
10314: PUSH
10315: EMPTY
10316: LIST
10317: LIST
10318: PPUSH
10319: CALL_OW 69
10323: ST_TO_ADDR
// if filter < 3 then
10324: LD_VAR 0 1
10328: PUSH
10329: LD_INT 3
10331: LESS
10332: IFFALSE 10342
// filter := 3 ;
10334: LD_ADDR_VAR 0 1
10338: PUSH
10339: LD_INT 3
10341: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_ok ] , [ f_or , [ f_weapon , 43 ] , [ f_weapon , 45 ] , [ f_weapon , 44 ] , [ f_weapon , 46 ] , [ f_weapon , 47 ] , [ f_weapon , 49 ] ] ] ) <= 6 then
10342: LD_INT 22
10344: PUSH
10345: LD_INT 3
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: PUSH
10352: LD_INT 21
10354: PUSH
10355: LD_INT 2
10357: PUSH
10358: EMPTY
10359: LIST
10360: LIST
10361: PUSH
10362: LD_INT 50
10364: PUSH
10365: EMPTY
10366: LIST
10367: PUSH
10368: LD_INT 2
10370: PUSH
10371: LD_INT 34
10373: PUSH
10374: LD_INT 43
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: PUSH
10381: LD_INT 34
10383: PUSH
10384: LD_INT 45
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: LD_INT 34
10393: PUSH
10394: LD_INT 44
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 34
10403: PUSH
10404: LD_INT 46
10406: PUSH
10407: EMPTY
10408: LIST
10409: LIST
10410: PUSH
10411: LD_INT 34
10413: PUSH
10414: LD_INT 47
10416: PUSH
10417: EMPTY
10418: LIST
10419: LIST
10420: PUSH
10421: LD_INT 34
10423: PUSH
10424: LD_INT 49
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: LIST
10444: LIST
10445: PPUSH
10446: CALL_OW 69
10450: PUSH
10451: LD_INT 6
10453: LESSEQUAL
10454: IFFALSE 10985
// for i := 1 to ( filter div 3 ) do
10456: LD_ADDR_VAR 0 2
10460: PUSH
10461: DOUBLE
10462: LD_INT 1
10464: DEC
10465: ST_TO_ADDR
10466: LD_VAR 0 1
10470: PUSH
10471: LD_INT 3
10473: DIV
10474: PUSH
10475: FOR_TO
10476: IFFALSE 10983
// begin uc_side := rus ;
10478: LD_ADDR_OWVAR 20
10482: PUSH
10483: LD_EXP 24
10487: ST_TO_ADDR
// uc_nation := nation_russian ;
10488: LD_ADDR_OWVAR 21
10492: PUSH
10493: LD_INT 3
10495: ST_TO_ADDR
// uc_direction := 5 ;
10496: LD_ADDR_OWVAR 24
10500: PUSH
10501: LD_INT 5
10503: ST_TO_ADDR
// if tick < 60000 or GetTech ( tech_TauRad , you ) = state_researched then
10504: LD_OWVAR 1
10508: PUSH
10509: LD_INT 60000
10511: LESS
10512: PUSH
10513: LD_INT 28
10515: PPUSH
10516: LD_EXP 23
10520: PPUSH
10521: CALL_OW 321
10525: PUSH
10526: LD_INT 2
10528: EQUAL
10529: OR
10530: IFFALSE 10556
// typ := rand ( 1 , vehicles - 2 ) else
10532: LD_ADDR_VAR 0 4
10536: PUSH
10537: LD_INT 1
10539: PPUSH
10540: LD_LOC 9
10544: PUSH
10545: LD_INT 2
10547: MINUS
10548: PPUSH
10549: CALL_OW 12
10553: ST_TO_ADDR
10554: GO 10574
// typ := rand ( 1 , vehicles ) ;
10556: LD_ADDR_VAR 0 4
10560: PUSH
10561: LD_INT 1
10563: PPUSH
10564: LD_LOC 9
10568: PPUSH
10569: CALL_OW 12
10573: ST_TO_ADDR
// vc_chassis := vehicles [ typ ] [ 1 ] ;
10574: LD_ADDR_OWVAR 37
10578: PUSH
10579: LD_LOC 9
10583: PUSH
10584: LD_VAR 0 4
10588: ARRAY
10589: PUSH
10590: LD_INT 1
10592: ARRAY
10593: ST_TO_ADDR
// vc_control := vehicles [ typ ] [ 2 ] ;
10594: LD_ADDR_OWVAR 38
10598: PUSH
10599: LD_LOC 9
10603: PUSH
10604: LD_VAR 0 4
10608: ARRAY
10609: PUSH
10610: LD_INT 2
10612: ARRAY
10613: ST_TO_ADDR
// vc_engine := vehicles [ typ ] [ 3 ] ;
10614: LD_ADDR_OWVAR 39
10618: PUSH
10619: LD_LOC 9
10623: PUSH
10624: LD_VAR 0 4
10628: ARRAY
10629: PUSH
10630: LD_INT 3
10632: ARRAY
10633: ST_TO_ADDR
// vc_weapon := vehicles [ typ ] [ 4 ] ;
10634: LD_ADDR_OWVAR 40
10638: PUSH
10639: LD_LOC 9
10643: PUSH
10644: LD_VAR 0 4
10648: ARRAY
10649: PUSH
10650: LD_INT 4
10652: ARRAY
10653: ST_TO_ADDR
// auto := CreateVehicle ;
10654: LD_ADDR_VAR 0 5
10658: PUSH
10659: CALL_OW 45
10663: ST_TO_ADDR
// PlaceUnitArea ( auto , EnterArea , false ) ;
10664: LD_VAR 0 5
10668: PPUSH
10669: LD_INT 9
10671: PPUSH
10672: LD_INT 0
10674: PPUSH
10675: CALL_OW 49
// attack := attack ^ auto ;
10679: LD_ADDR_LOC 10
10683: PUSH
10684: LD_LOC 10
10688: PUSH
10689: LD_VAR 0 5
10693: ADD
10694: ST_TO_ADDR
// ComAgressiveMove ( auto , 52 , 61 ) ;
10695: LD_VAR 0 5
10699: PPUSH
10700: LD_INT 52
10702: PPUSH
10703: LD_INT 61
10705: PPUSH
10706: CALL_OW 114
// AddComAgressiveMove ( auto , 52 , 61 ) ;
10710: LD_VAR 0 5
10714: PPUSH
10715: LD_INT 52
10717: PPUSH
10718: LD_INT 61
10720: PPUSH
10721: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10725: LD_INT 1
10727: PPUSH
10728: LD_INT 2
10730: PPUSH
10731: CALL_OW 12
10735: PUSH
10736: LD_INT 1
10738: DOUBLE
10739: EQUAL
10740: IFTRUE 10744
10742: GO 10762
10744: POP
// AddComAgressiveMove ( auto , 35 , 30 ) ; 2 :
10745: LD_VAR 0 5
10749: PPUSH
10750: LD_INT 35
10752: PPUSH
10753: LD_INT 30
10755: PPUSH
10756: CALL_OW 174
10760: GO 10789
10762: LD_INT 2
10764: DOUBLE
10765: EQUAL
10766: IFTRUE 10770
10768: GO 10788
10770: POP
// AddComAgressiveMove ( auto , 17 , 29 ) ; end ;
10771: LD_VAR 0 5
10775: PPUSH
10776: LD_INT 17
10778: PPUSH
10779: LD_INT 29
10781: PPUSH
10782: CALL_OW 174
10786: GO 10789
10788: POP
// AddComAgressiveMove ( auto , 29 , 5 ) ;
10789: LD_VAR 0 5
10793: PPUSH
10794: LD_INT 29
10796: PPUSH
10797: LD_INT 5
10799: PPUSH
10800: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
10804: LD_INT 1
10806: PPUSH
10807: LD_INT 2
10809: PPUSH
10810: CALL_OW 12
10814: PUSH
10815: LD_INT 1
10817: DOUBLE
10818: EQUAL
10819: IFTRUE 10823
10821: GO 10841
10823: POP
// AddComAgressiveMove ( auto , 60 , 30 ) ; 2 :
10824: LD_VAR 0 5
10828: PPUSH
10829: LD_INT 60
10831: PPUSH
10832: LD_INT 30
10834: PPUSH
10835: CALL_OW 174
10839: GO 10868
10841: LD_INT 2
10843: DOUBLE
10844: EQUAL
10845: IFTRUE 10849
10847: GO 10867
10849: POP
// AddComAgressiveMove ( auto , 84 , 30 ) ; end ;
10850: LD_VAR 0 5
10854: PPUSH
10855: LD_INT 84
10857: PPUSH
10858: LD_INT 30
10860: PPUSH
10861: CALL_OW 174
10865: GO 10868
10867: POP
// case Rand ( 1 , 2 ) of 1 :
10868: LD_INT 1
10870: PPUSH
10871: LD_INT 2
10873: PPUSH
10874: CALL_OW 12
10878: PUSH
10879: LD_INT 1
10881: DOUBLE
10882: EQUAL
10883: IFTRUE 10887
10885: GO 10905
10887: POP
// AddComAgressiveMove ( auto , 71 , 59 ) ; 2 :
10888: LD_VAR 0 5
10892: PPUSH
10893: LD_INT 71
10895: PPUSH
10896: LD_INT 59
10898: PPUSH
10899: CALL_OW 174
10903: GO 10932
10905: LD_INT 2
10907: DOUBLE
10908: EQUAL
10909: IFTRUE 10913
10911: GO 10931
10913: POP
// AddComAgressiveMove ( auto , 92 , 66 ) ; end ;
10914: LD_VAR 0 5
10918: PPUSH
10919: LD_INT 92
10921: PPUSH
10922: LD_INT 66
10924: PPUSH
10925: CALL_OW 174
10929: GO 10932
10931: POP
// AddComAgressiveMove ( auto , 78 , 88 ) ;
10932: LD_VAR 0 5
10936: PPUSH
10937: LD_INT 78
10939: PPUSH
10940: LD_INT 88
10942: PPUSH
10943: CALL_OW 174
// AddComAgressiveMove ( auto , 117 , 90 ) ;
10947: LD_VAR 0 5
10951: PPUSH
10952: LD_INT 117
10954: PPUSH
10955: LD_INT 90
10957: PPUSH
10958: CALL_OW 174
// AddComMoveToArea ( auto , BeforeWaterArea ) ;
10962: LD_VAR 0 5
10966: PPUSH
10967: LD_INT 15
10969: PPUSH
10970: CALL_OW 173
// Wait ( 0 0$4 ) ;
10974: LD_INT 140
10976: PPUSH
10977: CALL_OW 67
// end ;
10981: GO 10475
10983: POP
10984: POP
// enable ;
10985: ENABLE
// end ;
10986: PPOPN 7
10988: END
// export function PrepareInfantry ; var i , clovek ; begin
10989: LD_INT 0
10991: PPUSH
10992: PPUSH
10993: PPUSH
// for i = 1 to 6 do
10994: LD_ADDR_VAR 0 2
10998: PUSH
10999: DOUBLE
11000: LD_INT 1
11002: DEC
11003: ST_TO_ADDR
11004: LD_INT 6
11006: PUSH
11007: FOR_TO
11008: IFFALSE 11185
// begin uc_side = 3 ;
11010: LD_ADDR_OWVAR 20
11014: PUSH
11015: LD_INT 3
11017: ST_TO_ADDR
// uc_nation = 3 ;
11018: LD_ADDR_OWVAR 21
11022: PUSH
11023: LD_INT 3
11025: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
11026: LD_INT 1
11028: PPUSH
11029: LD_INT 3
11031: PPUSH
11032: CALL_OW 12
11036: PUSH
11037: LD_INT 1
11039: DOUBLE
11040: EQUAL
11041: IFTRUE 11045
11043: GO 11075
11045: POP
// PrepareHuman ( sex_male , class_soldier , rand ( 3 , 5 + Difficulty ) ) ; 2 .. 3 :
11046: LD_INT 1
11048: PPUSH
11049: LD_INT 1
11051: PPUSH
11052: LD_INT 3
11054: PPUSH
11055: LD_INT 5
11057: PUSH
11058: LD_OWVAR 67
11062: PLUS
11063: PPUSH
11064: CALL_OW 12
11068: PPUSH
11069: CALL_OW 380
11073: GO 11120
11075: LD_INT 2
11077: DOUBLE
11078: GREATEREQUAL
11079: IFFALSE 11087
11081: LD_INT 3
11083: DOUBLE
11084: LESSEQUAL
11085: IFTRUE 11089
11087: GO 11119
11089: POP
// PrepareHuman ( sex_male , class_bazooker , rand ( 3 , 4 + Difficulty ) ) ; end ;
11090: LD_INT 1
11092: PPUSH
11093: LD_INT 9
11095: PPUSH
11096: LD_INT 3
11098: PPUSH
11099: LD_INT 4
11101: PUSH
11102: LD_OWVAR 67
11106: PLUS
11107: PPUSH
11108: CALL_OW 12
11112: PPUSH
11113: CALL_OW 380
11117: GO 11120
11119: POP
// hc_name :=  ;
11120: LD_ADDR_OWVAR 26
11124: PUSH
11125: LD_STRING 
11127: ST_TO_ADDR
// clovek := CreateHuman ;
11128: LD_ADDR_VAR 0 3
11132: PUSH
11133: CALL_OW 44
11137: ST_TO_ADDR
// PlaceUnitArea ( clovek , EnterArea , false ) ;
11138: LD_VAR 0 3
11142: PPUSH
11143: LD_INT 9
11145: PPUSH
11146: LD_INT 0
11148: PPUSH
11149: CALL_OW 49
// infantryCounter = infantryCounter - 1 ;
11153: LD_ADDR_EXP 59
11157: PUSH
11158: LD_EXP 59
11162: PUSH
11163: LD_INT 1
11165: MINUS
11166: ST_TO_ADDR
// attackGroup = attackGroup ^ clovek ;
11167: LD_ADDR_EXP 60
11171: PUSH
11172: LD_EXP 60
11176: PUSH
11177: LD_VAR 0 3
11181: ADD
11182: ST_TO_ADDR
// end ;
11183: GO 11007
11185: POP
11186: POP
// ComAgressiveMove ( attackGroup , 52 , 61 ) ;
11187: LD_EXP 60
11191: PPUSH
11192: LD_INT 52
11194: PPUSH
11195: LD_INT 61
11197: PPUSH
11198: CALL_OW 114
// case Rand ( 1 , 2 ) of 1 :
11202: LD_INT 1
11204: PPUSH
11205: LD_INT 2
11207: PPUSH
11208: CALL_OW 12
11212: PUSH
11213: LD_INT 1
11215: DOUBLE
11216: EQUAL
11217: IFTRUE 11221
11219: GO 11239
11221: POP
// AddComAgressiveMove ( attackGroup , 35 , 30 ) ; 2 :
11222: LD_EXP 60
11226: PPUSH
11227: LD_INT 35
11229: PPUSH
11230: LD_INT 30
11232: PPUSH
11233: CALL_OW 174
11237: GO 11266
11239: LD_INT 2
11241: DOUBLE
11242: EQUAL
11243: IFTRUE 11247
11245: GO 11265
11247: POP
// AddComAgressiveMove ( attackGroup , 17 , 29 ) ; end ;
11248: LD_EXP 60
11252: PPUSH
11253: LD_INT 17
11255: PPUSH
11256: LD_INT 29
11258: PPUSH
11259: CALL_OW 174
11263: GO 11266
11265: POP
// AddComAgressiveMove ( attackGroup , 29 , 5 ) ;
11266: LD_EXP 60
11270: PPUSH
11271: LD_INT 29
11273: PPUSH
11274: LD_INT 5
11276: PPUSH
11277: CALL_OW 174
// case Rand ( 1 , 2 ) of 1 :
11281: LD_INT 1
11283: PPUSH
11284: LD_INT 2
11286: PPUSH
11287: CALL_OW 12
11291: PUSH
11292: LD_INT 1
11294: DOUBLE
11295: EQUAL
11296: IFTRUE 11300
11298: GO 11318
11300: POP
// AddComAgressiveMove ( attackGroup , 60 , 30 ) ; 2 :
11301: LD_EXP 60
11305: PPUSH
11306: LD_INT 60
11308: PPUSH
11309: LD_INT 30
11311: PPUSH
11312: CALL_OW 174
11316: GO 11345
11318: LD_INT 2
11320: DOUBLE
11321: EQUAL
11322: IFTRUE 11326
11324: GO 11344
11326: POP
// AddComAgressiveMove ( attackGroup , 84 , 30 ) ; end ;
11327: LD_EXP 60
11331: PPUSH
11332: LD_INT 84
11334: PPUSH
11335: LD_INT 30
11337: PPUSH
11338: CALL_OW 174
11342: GO 11345
11344: POP
// case Rand ( 1 , 2 ) of 1 :
11345: LD_INT 1
11347: PPUSH
11348: LD_INT 2
11350: PPUSH
11351: CALL_OW 12
11355: PUSH
11356: LD_INT 1
11358: DOUBLE
11359: EQUAL
11360: IFTRUE 11364
11362: GO 11382
11364: POP
// AddComAgressiveMove ( attackGroup , 71 , 59 ) ; 2 :
11365: LD_EXP 60
11369: PPUSH
11370: LD_INT 71
11372: PPUSH
11373: LD_INT 59
11375: PPUSH
11376: CALL_OW 174
11380: GO 11409
11382: LD_INT 2
11384: DOUBLE
11385: EQUAL
11386: IFTRUE 11390
11388: GO 11408
11390: POP
// AddComAgressiveMove ( attackGroup , 92 , 66 ) ; end ;
11391: LD_EXP 60
11395: PPUSH
11396: LD_INT 92
11398: PPUSH
11399: LD_INT 66
11401: PPUSH
11402: CALL_OW 174
11406: GO 11409
11408: POP
// AddComAgressiveMove ( attackGroup , 78 , 88 ) ;
11409: LD_EXP 60
11413: PPUSH
11414: LD_INT 78
11416: PPUSH
11417: LD_INT 88
11419: PPUSH
11420: CALL_OW 174
// AddComAgressiveMove ( attackGroup , 117 , 90 ) ;
11424: LD_EXP 60
11428: PPUSH
11429: LD_INT 117
11431: PPUSH
11432: LD_INT 90
11434: PPUSH
11435: CALL_OW 174
// AddComMoveToArea ( attackGroup , BeforeWaterArea ) ;
11439: LD_EXP 60
11443: PPUSH
11444: LD_INT 15
11446: PPUSH
11447: CALL_OW 173
// end ;
11451: LD_VAR 0 1
11455: RET
// every 0 0$3 trigger attackGroup = [ ] and attackAvalaible = 1 do
11456: LD_EXP 60
11460: PUSH
11461: EMPTY
11462: EQUAL
11463: PUSH
11464: LD_EXP 61
11468: PUSH
11469: LD_INT 1
11471: EQUAL
11472: AND
11473: IFFALSE 11483
11475: GO 11477
11477: DISABLE
// begin enable ;
11478: ENABLE
// PrepareInfantry ;
11479: CALL 10989 0 0
// end ;
11483: END
// every 0 0$1 + 0 0$0.3 marked 334 do var filter , mnozstvi ;
11484: GO 11486
11486: DISABLE
11487: LD_INT 0
11489: PPUSH
11490: PPUSH
// begin filter := FilterUnitsInArea ( BeforeWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11491: LD_ADDR_VAR 0 1
11495: PUSH
11496: LD_INT 15
11498: PPUSH
11499: LD_INT 22
11501: PUSH
11502: LD_EXP 24
11506: PUSH
11507: EMPTY
11508: LIST
11509: LIST
11510: PUSH
11511: LD_INT 50
11513: PUSH
11514: EMPTY
11515: LIST
11516: PUSH
11517: LD_INT 2
11519: PUSH
11520: LD_INT 21
11522: PUSH
11523: LD_INT 2
11525: PUSH
11526: EMPTY
11527: LIST
11528: LIST
11529: PUSH
11530: LD_INT 21
11532: PUSH
11533: LD_INT 1
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: LIST
11544: PUSH
11545: EMPTY
11546: LIST
11547: LIST
11548: LIST
11549: PPUSH
11550: CALL_OW 70
11554: ST_TO_ADDR
// case tick of 0 .. 30000 :
11555: LD_OWVAR 1
11559: PUSH
11560: LD_INT 0
11562: DOUBLE
11563: GREATEREQUAL
11564: IFFALSE 11572
11566: LD_INT 30000
11568: DOUBLE
11569: LESSEQUAL
11570: IFTRUE 11574
11572: GO 11591
11574: POP
// mnozstvi := maxaut - 4 ; 30001 .. 50000 :
11575: LD_ADDR_VAR 0 2
11579: PUSH
11580: LD_EXP 34
11584: PUSH
11585: LD_INT 4
11587: MINUS
11588: ST_TO_ADDR
11589: GO 11695
11591: LD_INT 30001
11593: DOUBLE
11594: GREATEREQUAL
11595: IFFALSE 11603
11597: LD_INT 50000
11599: DOUBLE
11600: LESSEQUAL
11601: IFTRUE 11605
11603: GO 11622
11605: POP
// mnozstvi := maxaut - 3 ; 50001 .. 70000 :
11606: LD_ADDR_VAR 0 2
11610: PUSH
11611: LD_EXP 34
11615: PUSH
11616: LD_INT 3
11618: MINUS
11619: ST_TO_ADDR
11620: GO 11695
11622: LD_INT 50001
11624: DOUBLE
11625: GREATEREQUAL
11626: IFFALSE 11634
11628: LD_INT 70000
11630: DOUBLE
11631: LESSEQUAL
11632: IFTRUE 11636
11634: GO 11653
11636: POP
// mnozstvi := maxaut - 2 ; 70001 .. 90000 :
11637: LD_ADDR_VAR 0 2
11641: PUSH
11642: LD_EXP 34
11646: PUSH
11647: LD_INT 2
11649: MINUS
11650: ST_TO_ADDR
11651: GO 11695
11653: LD_INT 70001
11655: DOUBLE
11656: GREATEREQUAL
11657: IFFALSE 11665
11659: LD_INT 90000
11661: DOUBLE
11662: LESSEQUAL
11663: IFTRUE 11667
11665: GO 11684
11667: POP
// mnozstvi := maxaut - 1 ; else
11668: LD_ADDR_VAR 0 2
11672: PUSH
11673: LD_EXP 34
11677: PUSH
11678: LD_INT 1
11680: MINUS
11681: ST_TO_ADDR
11682: GO 11695
11684: POP
// mnozstvi := maxaut ; end ;
11685: LD_ADDR_VAR 0 2
11689: PUSH
11690: LD_EXP 34
11694: ST_TO_ADDR
// if filter >= mnozstvi then
11695: LD_VAR 0 1
11699: PUSH
11700: LD_VAR 0 2
11704: GREATEREQUAL
11705: IFFALSE 11722
// ComMoveXY ( filter , 138 , 69 ) ;
11707: LD_VAR 0 1
11711: PPUSH
11712: LD_INT 138
11714: PPUSH
11715: LD_INT 69
11717: PPUSH
11718: CALL_OW 111
// enable ;
11722: ENABLE
// end ;
11723: PPOPN 2
11725: END
// every 0 0$1 + 0 0$0.5 marked 335 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
11726: GO 11728
11728: DISABLE
11729: LD_INT 0
11731: PPUSH
11732: PPUSH
11733: PPUSH
11734: PPUSH
11735: PPUSH
11736: PPUSH
// begin enable ;
11737: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_not , [ f_weapon , ru_time_lapser ] ] ] ) ;
11738: LD_ADDR_VAR 0 1
11742: PUSH
11743: LD_INT 12
11745: PPUSH
11746: LD_INT 22
11748: PUSH
11749: LD_EXP 24
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: LD_INT 50
11760: PUSH
11761: EMPTY
11762: LIST
11763: PUSH
11764: LD_INT 3
11766: PUSH
11767: LD_INT 34
11769: PUSH
11770: LD_INT 49
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: LIST
11785: PPUSH
11786: CALL_OW 70
11790: ST_TO_ADDR
// if GetTech ( tech_Virus , you ) = state_researched then
11791: LD_INT 33
11793: PPUSH
11794: LD_EXP 23
11798: PPUSH
11799: CALL_OW 321
11803: PUSH
11804: LD_INT 2
11806: EQUAL
11807: IFFALSE 11861
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , you ] , [ f_class , class_scientistic ] , [ f_see , rus ] ] ) ;
11809: LD_ADDR_VAR 0 2
11813: PUSH
11814: LD_INT 12
11816: PPUSH
11817: LD_INT 22
11819: PUSH
11820: LD_EXP 23
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 4
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 101
11841: PUSH
11842: LD_EXP 24
11846: PUSH
11847: EMPTY
11848: LIST
11849: LIST
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: LIST
11855: PPUSH
11856: CALL_OW 70
11860: ST_TO_ADDR
// if filter_you = 0 then
11861: LD_VAR 0 2
11865: PUSH
11866: LD_INT 0
11868: EQUAL
11869: IFFALSE 11978
// begin filter_you := FilterAllUnits ( [ [ f_side , you ] , [ f_ok ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , ] ] ) ;
11871: LD_ADDR_VAR 0 2
11875: PUSH
11876: LD_INT 22
11878: PUSH
11879: LD_EXP 23
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: PUSH
11888: LD_INT 50
11890: PUSH
11891: EMPTY
11892: LIST
11893: PUSH
11894: LD_INT 2
11896: PUSH
11897: LD_INT 21
11899: PUSH
11900: LD_INT 1
11902: PUSH
11903: EMPTY
11904: LIST
11905: LIST
11906: PUSH
11907: LD_INT 21
11909: PUSH
11910: LD_INT 2
11912: PUSH
11913: EMPTY
11914: LIST
11915: LIST
11916: PUSH
11917: LD_INT 21
11919: PUSH
11920: LD_INT 3
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: LIST
11937: PPUSH
11938: CALL_OW 69
11942: ST_TO_ADDR
// if filter_you = 0 then
11943: LD_VAR 0 2
11947: PUSH
11948: LD_INT 0
11950: EQUAL
11951: IFFALSE 11978
// filter_you := FilterUnitsInArea ( BehindWaterArea , [ f_side , you ] ) ;
11953: LD_ADDR_VAR 0 2
11957: PUSH
11958: LD_INT 12
11960: PPUSH
11961: LD_INT 22
11963: PUSH
11964: LD_EXP 23
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: PPUSH
11973: CALL_OW 70
11977: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
11978: LD_VAR 0 1
11982: PUSH
11983: LD_INT 0
11985: GREATER
11986: PUSH
11987: LD_VAR 0 2
11991: PUSH
11992: LD_INT 0
11994: GREATER
11995: AND
11996: IFFALSE 12387
// begin for un_rus in filter_rus do
11998: LD_ADDR_VAR 0 3
12002: PUSH
12003: LD_VAR 0 1
12007: PUSH
12008: FOR_IN
12009: IFFALSE 12385
// begin Wait ( 5 ) ;
12011: LD_INT 5
12013: PPUSH
12014: CALL_OW 67
// min := 99999 ;
12018: LD_ADDR_VAR 0 5
12022: PUSH
12023: LD_INT 99999
12025: ST_TO_ADDR
// cil := 0 ;
12026: LD_ADDR_VAR 0 6
12030: PUSH
12031: LD_INT 0
12033: ST_TO_ADDR
// for un_you in filter_you do
12034: LD_ADDR_VAR 0 4
12038: PUSH
12039: LD_VAR 0 2
12043: PUSH
12044: FOR_IN
12045: IFFALSE 12241
// begin if Attacks ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12047: LD_VAR 0 4
12051: PPUSH
12052: CALL_OW 320
12056: PUSH
12057: LD_VAR 0 4
12061: PPUSH
12062: CALL_OW 256
12066: PUSH
12067: LD_VAR 0 5
12071: LESS
12072: AND
12073: PUSH
12074: LD_VAR 0 3
12078: PPUSH
12079: LD_VAR 0 4
12083: PPUSH
12084: CALL_OW 296
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: LD_INT 2
12094: PUSH
12095: LD_INT 4
12097: PUSH
12098: LD_INT 6
12100: PUSH
12101: LD_INT 5
12103: PUSH
12104: LD_INT 9
12106: PUSH
12107: LD_INT 0
12109: PUSH
12110: LD_INT 2
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: LIST
12122: PUSH
12123: LD_VAR 0 3
12127: PPUSH
12128: CALL_OW 264
12132: PUSH
12133: LD_INT 41
12135: MINUS
12136: ARRAY
12137: GREATEREQUAL
12138: AND
12139: PUSH
12140: LD_VAR 0 3
12144: PPUSH
12145: LD_VAR 0 4
12149: PPUSH
12150: CALL_OW 296
12154: PUSH
12155: LD_INT 15
12157: PUSH
12158: LD_INT 16
12160: PUSH
12161: LD_INT 17
12163: PUSH
12164: LD_INT 22
12166: PUSH
12167: LD_INT 20
12169: PUSH
12170: LD_INT 28
12172: PUSH
12173: LD_INT 0
12175: PUSH
12176: LD_INT 51
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: LIST
12186: LIST
12187: LIST
12188: PUSH
12189: LD_VAR 0 3
12193: PPUSH
12194: CALL_OW 264
12198: PUSH
12199: LD_INT 41
12201: MINUS
12202: ARRAY
12203: LESSEQUAL
12204: AND
12205: IFFALSE 12232
// begin min := GetLives ( un_you ) ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_VAR 0 4
12216: PPUSH
12217: CALL_OW 256
12221: ST_TO_ADDR
// cil := un_you ;
12222: LD_ADDR_VAR 0 6
12226: PUSH
12227: LD_VAR 0 4
12231: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12232: LD_INT 5
12234: PPUSH
12235: CALL_OW 67
// end ;
12239: GO 12044
12241: POP
12242: POP
// if cil <> 0 then
12243: LD_VAR 0 6
12247: PUSH
12248: LD_INT 0
12250: NONEQUAL
12251: IFFALSE 12269
// ComAttackUnit ( un_rus , cil ) else
12253: LD_VAR 0 3
12257: PPUSH
12258: LD_VAR 0 6
12262: PPUSH
12263: CALL_OW 115
12267: GO 12383
// begin for un_you in filter_you do
12269: LD_ADDR_VAR 0 4
12273: PUSH
12274: LD_VAR 0 2
12278: PUSH
12279: FOR_IN
12280: IFFALSE 12367
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12282: LD_VAR 0 4
12286: PPUSH
12287: CALL_OW 266
12291: PUSH
12292: LD_INT 0
12294: PUSH
12295: LD_INT 1
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: IN
12302: IFFALSE 12316
// cil := un_you else
12304: LD_ADDR_VAR 0 6
12308: PUSH
12309: LD_VAR 0 4
12313: ST_TO_ADDR
12314: GO 12358
// if GetLives ( un_you ) < min then
12316: LD_VAR 0 4
12320: PPUSH
12321: CALL_OW 256
12325: PUSH
12326: LD_VAR 0 5
12330: LESS
12331: IFFALSE 12358
// begin min := GetLives ( un_you ) ;
12333: LD_ADDR_VAR 0 5
12337: PUSH
12338: LD_VAR 0 4
12342: PPUSH
12343: CALL_OW 256
12347: ST_TO_ADDR
// cil := un_you ;
12348: LD_ADDR_VAR 0 6
12352: PUSH
12353: LD_VAR 0 4
12357: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12358: LD_INT 5
12360: PPUSH
12361: CALL_OW 67
// end ;
12365: GO 12279
12367: POP
12368: POP
// ComAttackUnit ( un_rus , cil ) end ;
12369: LD_VAR 0 3
12373: PPUSH
12374: LD_VAR 0 6
12378: PPUSH
12379: CALL_OW 115
// end ;
12383: GO 12008
12385: POP
12386: POP
// end ; end ;
12387: PPOPN 6
12389: END
// every 0 0$1 + 0 0$0.7 marked 337 do var filter_rus , filter_you , un_rus , un_you , min , cil ;
12390: GO 12392
12392: DISABLE
12393: LD_INT 0
12395: PPUSH
12396: PPUSH
12397: PPUSH
12398: PPUSH
12399: PPUSH
12400: PPUSH
// begin enable ;
12401: ENABLE
// filter_rus := FilterUnitsInArea ( ScientistsArea , [ [ f_side , rus ] , f_not , [ f_or , [ f_type , unit_building ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , ru_cargo_bay ] , [ f_class , class_scientistic ] , [ f_class , class_engineer ] , [ f_inside ] ] ] ) ;
12402: LD_ADDR_VAR 0 1
12406: PUSH
12407: LD_INT 21
12409: PPUSH
12410: LD_INT 22
12412: PUSH
12413: LD_EXP 24
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: LD_INT 3
12424: PUSH
12425: LD_INT 2
12427: PUSH
12428: LD_INT 21
12430: PUSH
12431: LD_INT 3
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 34
12440: PUSH
12441: LD_INT 49
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 34
12450: PUSH
12451: LD_INT 51
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: LD_INT 25
12460: PUSH
12461: LD_INT 4
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PUSH
12468: LD_INT 25
12470: PUSH
12471: LD_INT 2
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 54
12480: PUSH
12481: EMPTY
12482: LIST
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: PUSH
12493: EMPTY
12494: LIST
12495: LIST
12496: LIST
12497: PPUSH
12498: CALL_OW 70
12502: ST_TO_ADDR
// filter_rus := filter_rus diff straz ;
12503: LD_ADDR_VAR 0 1
12507: PUSH
12508: LD_VAR 0 1
12512: PUSH
12513: LD_EXP 45
12517: DIFF
12518: ST_TO_ADDR
// filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ;
12519: LD_ADDR_VAR 0 2
12523: PUSH
12524: LD_INT 21
12526: PPUSH
12527: LD_INT 22
12529: PUSH
12530: LD_EXP 23
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 21
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PPUSH
12553: CALL_OW 70
12557: ST_TO_ADDR
// if not filter_you then
12558: LD_VAR 0 2
12562: NOT
12563: IFFALSE 12636
// begin filter_you := FilterUnitsInArea ( ScientistsArea , [ [ f_side , you ] , [ f_class , class_scientistic ] ] ) ;
12565: LD_ADDR_VAR 0 2
12569: PUSH
12570: LD_INT 21
12572: PPUSH
12573: LD_INT 22
12575: PUSH
12576: LD_EXP 23
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 25
12587: PUSH
12588: LD_INT 4
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PPUSH
12599: CALL_OW 70
12603: ST_TO_ADDR
// if not filter_you then
12604: LD_VAR 0 2
12608: NOT
12609: IFFALSE 12636
// filter_you := FilterUnitsInArea ( ScientistsArea , [ f_side , you ] ) ;
12611: LD_ADDR_VAR 0 2
12615: PUSH
12616: LD_INT 21
12618: PPUSH
12619: LD_INT 22
12621: PUSH
12622: LD_EXP 23
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PPUSH
12631: CALL_OW 70
12635: ST_TO_ADDR
// end ; if filter_rus > 0 and filter_you > 0 then
12636: LD_VAR 0 1
12640: PUSH
12641: LD_INT 0
12643: GREATER
12644: PUSH
12645: LD_VAR 0 2
12649: PUSH
12650: LD_INT 0
12652: GREATER
12653: AND
12654: IFFALSE 13045
// begin for un_rus in filter_rus do
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: LD_VAR 0 1
12665: PUSH
12666: FOR_IN
12667: IFFALSE 13043
// begin Wait ( 5 ) ;
12669: LD_INT 5
12671: PPUSH
12672: CALL_OW 67
// min := 99999 ;
12676: LD_ADDR_VAR 0 5
12680: PUSH
12681: LD_INT 99999
12683: ST_TO_ADDR
// cil := 0 ;
12684: LD_ADDR_VAR 0 6
12688: PUSH
12689: LD_INT 0
12691: ST_TO_ADDR
// for un_you in filter_you do
12692: LD_ADDR_VAR 0 4
12696: PUSH
12697: LD_VAR 0 2
12701: PUSH
12702: FOR_IN
12703: IFFALSE 12899
// begin if IsOK ( un_you ) and GetLives ( un_you ) < min and GetDistUnits ( un_rus , un_you ) >= ( [ 2 , 2 , 4 , 6 , 5 , 9 , 0 , 2 ] [ GetWeapon ( un_rus ) - 41 ] ) and GetDistUnits ( un_rus , un_you ) <= ( [ 15 , 16 , 17 , 22 , 20 , 28 , 0 , 51 ] [ GetWeapon ( un_rus ) - 41 ] ) then
12705: LD_VAR 0 4
12709: PPUSH
12710: CALL_OW 302
12714: PUSH
12715: LD_VAR 0 4
12719: PPUSH
12720: CALL_OW 256
12724: PUSH
12725: LD_VAR 0 5
12729: LESS
12730: AND
12731: PUSH
12732: LD_VAR 0 3
12736: PPUSH
12737: LD_VAR 0 4
12741: PPUSH
12742: CALL_OW 296
12746: PUSH
12747: LD_INT 2
12749: PUSH
12750: LD_INT 2
12752: PUSH
12753: LD_INT 4
12755: PUSH
12756: LD_INT 6
12758: PUSH
12759: LD_INT 5
12761: PUSH
12762: LD_INT 9
12764: PUSH
12765: LD_INT 0
12767: PUSH
12768: LD_INT 2
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PUSH
12781: LD_VAR 0 3
12785: PPUSH
12786: CALL_OW 264
12790: PUSH
12791: LD_INT 41
12793: MINUS
12794: ARRAY
12795: GREATEREQUAL
12796: AND
12797: PUSH
12798: LD_VAR 0 3
12802: PPUSH
12803: LD_VAR 0 4
12807: PPUSH
12808: CALL_OW 296
12812: PUSH
12813: LD_INT 15
12815: PUSH
12816: LD_INT 16
12818: PUSH
12819: LD_INT 17
12821: PUSH
12822: LD_INT 22
12824: PUSH
12825: LD_INT 20
12827: PUSH
12828: LD_INT 28
12830: PUSH
12831: LD_INT 0
12833: PUSH
12834: LD_INT 51
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: PUSH
12847: LD_VAR 0 3
12851: PPUSH
12852: CALL_OW 264
12856: PUSH
12857: LD_INT 41
12859: MINUS
12860: ARRAY
12861: LESSEQUAL
12862: AND
12863: IFFALSE 12890
// begin min := GetLives ( un_you ) ;
12865: LD_ADDR_VAR 0 5
12869: PUSH
12870: LD_VAR 0 4
12874: PPUSH
12875: CALL_OW 256
12879: ST_TO_ADDR
// cil := un_you ;
12880: LD_ADDR_VAR 0 6
12884: PUSH
12885: LD_VAR 0 4
12889: ST_TO_ADDR
// end ; Wait ( 5 ) ;
12890: LD_INT 5
12892: PPUSH
12893: CALL_OW 67
// end ;
12897: GO 12702
12899: POP
12900: POP
// if cil <> 0 then
12901: LD_VAR 0 6
12905: PUSH
12906: LD_INT 0
12908: NONEQUAL
12909: IFFALSE 12927
// ComAttackUnit ( un_rus , cil ) else
12911: LD_VAR 0 3
12915: PPUSH
12916: LD_VAR 0 6
12920: PPUSH
12921: CALL_OW 115
12925: GO 13041
// begin for un_you in filter_you do
12927: LD_ADDR_VAR 0 4
12931: PUSH
12932: LD_VAR 0 2
12936: PUSH
12937: FOR_IN
12938: IFFALSE 13025
// begin if GetBType ( un_you ) in [ b_depot , b_warehouse ] then
12940: LD_VAR 0 4
12944: PPUSH
12945: CALL_OW 266
12949: PUSH
12950: LD_INT 0
12952: PUSH
12953: LD_INT 1
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: IN
12960: IFFALSE 12974
// cil := un_you else
12962: LD_ADDR_VAR 0 6
12966: PUSH
12967: LD_VAR 0 4
12971: ST_TO_ADDR
12972: GO 13016
// if GetLives ( un_you ) < min then
12974: LD_VAR 0 4
12978: PPUSH
12979: CALL_OW 256
12983: PUSH
12984: LD_VAR 0 5
12988: LESS
12989: IFFALSE 13016
// begin min := GetLives ( un_you ) ;
12991: LD_ADDR_VAR 0 5
12995: PUSH
12996: LD_VAR 0 4
13000: PPUSH
13001: CALL_OW 256
13005: ST_TO_ADDR
// cil := un_you ;
13006: LD_ADDR_VAR 0 6
13010: PUSH
13011: LD_VAR 0 4
13015: ST_TO_ADDR
// end ; Wait ( 5 ) ;
13016: LD_INT 5
13018: PPUSH
13019: CALL_OW 67
// end ;
13023: GO 12937
13025: POP
13026: POP
// ComAttackUnit ( un_rus , cil ) end ;
13027: LD_VAR 0 3
13031: PPUSH
13032: LD_VAR 0 6
13036: PPUSH
13037: CALL_OW 115
// end ;
13041: GO 12666
13043: POP
13044: POP
// end ; end ;
13045: PPOPN 6
13047: END
// every 0 0$3 + 0 0$0.9 marked 338 do var filter_rus , filter_you , un_rus , un_you ;
13048: GO 13050
13050: DISABLE
13051: LD_INT 0
13053: PPUSH
13054: PPUSH
13055: PPUSH
13056: PPUSH
// begin if not GetTech ( tech_TauRad , you ) = state_researched then
13057: LD_INT 28
13059: PPUSH
13060: LD_EXP 23
13064: PPUSH
13065: CALL_OW 321
13069: PUSH
13070: LD_INT 2
13072: EQUAL
13073: NOT
13074: IFFALSE 13077
// enable ;
13076: ENABLE
// filter_rus := FilterUnitsInArea ( BehindWaterArea , [ [ f_side , rus ] , [ f_ok ] , [ f_weapon , ru_time_lapser ] ] ) ;
13077: LD_ADDR_VAR 0 1
13081: PUSH
13082: LD_INT 12
13084: PPUSH
13085: LD_INT 22
13087: PUSH
13088: LD_EXP 24
13092: PUSH
13093: EMPTY
13094: LIST
13095: LIST
13096: PUSH
13097: LD_INT 50
13099: PUSH
13100: EMPTY
13101: LIST
13102: PUSH
13103: LD_INT 34
13105: PUSH
13106: LD_INT 49
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL_OW 70
13122: ST_TO_ADDR
// if filter_rus > 0 then
13123: LD_VAR 0 1
13127: PUSH
13128: LD_INT 0
13130: GREATER
13131: IFFALSE 13172
// for un_rus in filter_rus do
13133: LD_ADDR_VAR 0 3
13137: PUSH
13138: LD_VAR 0 1
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13170
// begin ComMoveXY ( un_rus , 122 , 27 ) ;
13146: LD_VAR 0 3
13150: PPUSH
13151: LD_INT 122
13153: PPUSH
13154: LD_INT 27
13156: PPUSH
13157: CALL_OW 111
// Wait ( 5 ) ;
13161: LD_INT 5
13163: PPUSH
13164: CALL_OW 67
// end ;
13168: GO 13143
13170: POP
13171: POP
// end ;
13172: PPOPN 4
13174: END
// every 1 1$0 + 0 0$5.5 do
13175: GO 13177
13177: DISABLE
// begin if ( not GetTech ( tech_Comp3 , rus ) = state_researched ) and tick >= tick_tech_comp3 then
13178: LD_INT 59
13180: PPUSH
13181: LD_EXP 24
13185: PPUSH
13186: CALL_OW 321
13190: PUSH
13191: LD_INT 2
13193: EQUAL
13194: NOT
13195: PUSH
13196: LD_OWVAR 1
13200: PUSH
13201: LD_EXP 54
13205: GREATEREQUAL
13206: AND
13207: IFFALSE 13224
// SetTech ( tech_Comp3 , rus , state_researched ) ;
13209: LD_INT 59
13211: PPUSH
13212: LD_EXP 24
13216: PPUSH
13217: LD_INT 2
13219: PPUSH
13220: CALL_OW 322
// if ( not GetTech ( tech_Tech3 , rus ) = state_researched ) and tick >= tick_tech_tech3 then
13224: LD_INT 50
13226: PPUSH
13227: LD_EXP 24
13231: PPUSH
13232: CALL_OW 321
13236: PUSH
13237: LD_INT 2
13239: EQUAL
13240: NOT
13241: PUSH
13242: LD_OWVAR 1
13246: PUSH
13247: LD_EXP 55
13251: GREATEREQUAL
13252: AND
13253: IFFALSE 13270
// SetTech ( tech_Tech3 , rus , state_researched ) ;
13255: LD_INT 50
13257: PPUSH
13258: LD_EXP 24
13262: PPUSH
13263: LD_INT 2
13265: PPUSH
13266: CALL_OW 322
// if ( not GetTech ( tech_Weap3 , rus ) = state_researched ) and tick >= tick_tech_weap3 then
13270: LD_INT 53
13272: PPUSH
13273: LD_EXP 24
13277: PPUSH
13278: CALL_OW 321
13282: PUSH
13283: LD_INT 2
13285: EQUAL
13286: NOT
13287: PUSH
13288: LD_OWVAR 1
13292: PUSH
13293: LD_EXP 56
13297: GREATEREQUAL
13298: AND
13299: IFFALSE 13316
// SetTech ( tech_Weap3 , rus , state_researched ) ;
13301: LD_INT 53
13303: PPUSH
13304: LD_EXP 24
13308: PPUSH
13309: LD_INT 2
13311: PPUSH
13312: CALL_OW 322
// if ( not GetTech ( tech_Sib3 , rus ) = state_researched ) and tick >= tick_tech_sib3 then
13316: LD_INT 56
13318: PPUSH
13319: LD_EXP 24
13323: PPUSH
13324: CALL_OW 321
13328: PUSH
13329: LD_INT 2
13331: EQUAL
13332: NOT
13333: PUSH
13334: LD_OWVAR 1
13338: PUSH
13339: LD_EXP 57
13343: GREATEREQUAL
13344: AND
13345: IFFALSE 13362
// SetTech ( tech_Sib3 , rus , state_researched ) ;
13347: LD_INT 56
13349: PPUSH
13350: LD_EXP 24
13354: PPUSH
13355: LD_INT 2
13357: PPUSH
13358: CALL_OW 322
// if ( not GetTech ( tech_ST3 , rus ) = state_researched ) and tick >= tick_tech_st3 then
13362: LD_INT 65
13364: PPUSH
13365: LD_EXP 24
13369: PPUSH
13370: CALL_OW 321
13374: PUSH
13375: LD_INT 2
13377: EQUAL
13378: NOT
13379: PUSH
13380: LD_OWVAR 1
13384: PUSH
13385: LD_EXP 58
13389: GREATEREQUAL
13390: AND
13391: IFFALSE 13408
// SetTech ( tech_ST3 , rus , state_researched ) ;
13393: LD_INT 65
13395: PPUSH
13396: LD_EXP 24
13400: PPUSH
13401: LD_INT 2
13403: PPUSH
13404: CALL_OW 322
// if not ( GetTech ( tech_Comp3 , rus ) = state_researched and GetTech ( tech_Tech3 , rus ) = state_researched and GetTech ( tech_Weap3 , rus ) = state_researched and GetTech ( tech_Sib3 , rus ) = state_researched and GetTech ( tech_ST3 , rus ) = state_researched ) then
13408: LD_INT 59
13410: PPUSH
13411: LD_EXP 24
13415: PPUSH
13416: CALL_OW 321
13420: PUSH
13421: LD_INT 2
13423: EQUAL
13424: PUSH
13425: LD_INT 50
13427: PPUSH
13428: LD_EXP 24
13432: PPUSH
13433: CALL_OW 321
13437: PUSH
13438: LD_INT 2
13440: EQUAL
13441: AND
13442: PUSH
13443: LD_INT 53
13445: PPUSH
13446: LD_EXP 24
13450: PPUSH
13451: CALL_OW 321
13455: PUSH
13456: LD_INT 2
13458: EQUAL
13459: AND
13460: PUSH
13461: LD_INT 56
13463: PPUSH
13464: LD_EXP 24
13468: PPUSH
13469: CALL_OW 321
13473: PUSH
13474: LD_INT 2
13476: EQUAL
13477: AND
13478: PUSH
13479: LD_INT 65
13481: PPUSH
13482: LD_EXP 24
13486: PPUSH
13487: CALL_OW 321
13491: PUSH
13492: LD_INT 2
13494: EQUAL
13495: AND
13496: NOT
13497: IFFALSE 13500
// enable ;
13499: ENABLE
// end ; end_of_file
13500: END
// export rus_mcrep_id , rus_mcrep_units , rus_mcrep_bui , rus_depot , rus_lab , rus_breastwork ; every 0 0$0.1 do
13501: GO 13503
13503: DISABLE
// begin rus_mcrep_units := [ 14 , 18 , 19 , 20 , 21 , 22 , 23 , ] ;
13504: LD_ADDR_EXP 63
13508: PUSH
13509: LD_INT 14
13511: PUSH
13512: LD_INT 18
13514: PUSH
13515: LD_INT 19
13517: PUSH
13518: LD_INT 20
13520: PUSH
13521: LD_INT 21
13523: PUSH
13524: LD_INT 22
13526: PUSH
13527: LD_INT 23
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: LIST
13534: LIST
13535: LIST
13536: LIST
13537: LIST
13538: ST_TO_ADDR
// rus_mcrep_bui := FilterAllUnits ( [ [ f_side , rus ] , [ f_type , unit_building ] ] ) ^ [ 14 , 15 ] ;
13539: LD_ADDR_EXP 64
13543: PUSH
13544: LD_INT 22
13546: PUSH
13547: LD_EXP 24
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 21
13558: PUSH
13559: LD_INT 3
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: EMPTY
13567: LIST
13568: LIST
13569: PPUSH
13570: CALL_OW 69
13574: PUSH
13575: LD_INT 14
13577: PUSH
13578: LD_INT 15
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: ADD
13585: ST_TO_ADDR
// rus_depot := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
13586: LD_ADDR_EXP 65
13590: PUSH
13591: LD_INT 22
13593: PUSH
13594: LD_EXP 24
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: PUSH
13603: LD_INT 30
13605: PUSH
13606: LD_INT 1
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PPUSH
13617: CALL_OW 69
13621: PUSH
13622: LD_INT 1
13624: ARRAY
13625: ST_TO_ADDR
// rus_lab := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
13626: LD_ADDR_EXP 66
13630: PUSH
13631: LD_INT 22
13633: PUSH
13634: LD_EXP 24
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: PUSH
13643: LD_INT 30
13645: PUSH
13646: LD_INT 8
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: PPUSH
13657: CALL_OW 69
13661: PUSH
13662: LD_INT 1
13664: ARRAY
13665: ST_TO_ADDR
// rus_breastwork := FilterAllUnits ( [ [ f_side , rus ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ;
13666: LD_ADDR_EXP 67
13670: PUSH
13671: LD_INT 22
13673: PUSH
13674: LD_EXP 24
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: PUSH
13683: LD_INT 30
13685: PUSH
13686: LD_INT 31
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PPUSH
13697: CALL_OW 69
13701: PUSH
13702: LD_INT 1
13704: ARRAY
13705: ST_TO_ADDR
// enable ( 401 ) ;
13706: LD_INT 401
13708: ENABLE_MARKED
// end ;
13709: END
// every 0 0$10 + 0 0$0.5 marked 401 do var un , CanReturnToDepot , filter ;
13710: GO 13712
13712: DISABLE
13713: LD_INT 0
13715: PPUSH
13716: PPUSH
13717: PPUSH
// begin if not ExistMc ( rus_mcrep_id ) then
13718: LD_EXP 62
13722: PPUSH
13723: CALL_OW 386
13727: NOT
13728: IFFALSE 13783
// rus_mcrep_id := McRepair ( 100 , rus_mcrep_units , rus_mcrep_bui ^ rus_mcrep_units , [ [ mcr_hum_area , BluekherRepairArea ] , [ mcr_repb_area , BluekherArea ] ] ) ;
13730: LD_ADDR_EXP 62
13734: PUSH
13735: LD_INT 100
13737: PPUSH
13738: LD_EXP 63
13742: PPUSH
13743: LD_EXP 64
13747: PUSH
13748: LD_EXP 63
13752: ADD
13753: PPUSH
13754: LD_INT 1
13756: PUSH
13757: LD_INT 23
13759: PUSH
13760: EMPTY
13761: LIST
13762: LIST
13763: PUSH
13764: LD_INT 10
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: EMPTY
13771: LIST
13772: LIST
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PPUSH
13778: CALL_OW 414
13782: ST_TO_ADDR
// if IsLive ( rus_depot ) or IsLive ( rus_lab ) or IsLive ( rus_breastwork ) then
13783: LD_EXP 65
13787: PPUSH
13788: CALL_OW 300
13792: PUSH
13793: LD_EXP 66
13797: PPUSH
13798: CALL_OW 300
13802: OR
13803: PUSH
13804: LD_EXP 67
13808: PPUSH
13809: CALL_OW 300
13813: OR
13814: IFFALSE 14040
// begin for un in rus_mcrep_units do
13816: LD_ADDR_VAR 0 1
13820: PUSH
13821: LD_EXP 63
13825: PUSH
13826: FOR_IN
13827: IFFALSE 14038
// if GetUnitMc ( un ) = 0 and GetLives ( un ) = 1000 then
13829: LD_VAR 0 1
13833: PPUSH
13834: CALL_OW 388
13838: PUSH
13839: LD_INT 0
13841: EQUAL
13842: PUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 256
13852: PUSH
13853: LD_INT 1000
13855: EQUAL
13856: AND
13857: IFFALSE 14024
// case GetClass ( un ) of class_engineer :
13859: LD_VAR 0 1
13863: PPUSH
13864: CALL_OW 257
13868: PUSH
13869: LD_INT 2
13871: DOUBLE
13872: EQUAL
13873: IFTRUE 13877
13875: GO 13921
13877: POP
// if IsLive ( rus_depot ) and not ( UnitsInside ( rus_depot ) = 6 ) then
13878: LD_EXP 65
13882: PPUSH
13883: CALL_OW 300
13887: PUSH
13888: LD_EXP 65
13892: PPUSH
13893: CALL_OW 313
13897: PUSH
13898: LD_INT 6
13900: EQUAL
13901: NOT
13902: AND
13903: IFFALSE 13919
// ComEnterUnit ( un , rus_depot ) ; class_scientistic :
13905: LD_VAR 0 1
13909: PPUSH
13910: LD_EXP 65
13914: PPUSH
13915: CALL_OW 120
13919: GO 14022
13921: LD_INT 4
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 13973
13929: POP
// if IsLive ( rus_lab ) and not ( UnitsInside ( rus_lab ) = 6 ) then
13930: LD_EXP 66
13934: PPUSH
13935: CALL_OW 300
13939: PUSH
13940: LD_EXP 66
13944: PPUSH
13945: CALL_OW 313
13949: PUSH
13950: LD_INT 6
13952: EQUAL
13953: NOT
13954: AND
13955: IFFALSE 13971
// ComEnterUnit ( un , rus_lab ) ; class_soldier :
13957: LD_VAR 0 1
13961: PPUSH
13962: LD_EXP 66
13966: PPUSH
13967: CALL_OW 120
13971: GO 14022
13973: LD_INT 1
13975: DOUBLE
13976: EQUAL
13977: IFTRUE 13981
13979: GO 14021
13981: POP
// if IsLive ( rus_breastwork ) and not UnitsInside ( rus_breastwork ) then
13982: LD_EXP 67
13986: PPUSH
13987: CALL_OW 300
13991: PUSH
13992: LD_EXP 67
13996: PPUSH
13997: CALL_OW 313
14001: NOT
14002: AND
14003: IFFALSE 14019
// ComEnterUnit ( un , rus_breastwork ) ; end else
14005: LD_VAR 0 1
14009: PPUSH
14010: LD_EXP 67
14014: PPUSH
14015: CALL_OW 120
14019: GO 14022
14021: POP
14022: GO 14036
// ComMoveToArea ( un , BluekherRepairArea ) ;
14024: LD_VAR 0 1
14028: PPUSH
14029: LD_INT 23
14031: PPUSH
14032: CALL_OW 113
14036: GO 13826
14038: POP
14039: POP
// end ; filter := FilterUnitsExceptArea ( BluekherArea , [ [ f_side , rus ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_scientistic ] ] ] ) ;
14040: LD_ADDR_VAR 0 3
14044: PUSH
14045: LD_INT 22
14047: PPUSH
14048: LD_INT 22
14050: PUSH
14051: LD_EXP 24
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: PUSH
14060: LD_INT 2
14062: PUSH
14063: LD_INT 25
14065: PUSH
14066: LD_INT 2
14068: PUSH
14069: EMPTY
14070: LIST
14071: LIST
14072: PUSH
14073: LD_INT 25
14075: PUSH
14076: LD_INT 4
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: PUSH
14083: EMPTY
14084: LIST
14085: LIST
14086: LIST
14087: PUSH
14088: EMPTY
14089: LIST
14090: LIST
14091: PPUSH
14092: CALL_OW 71
14096: ST_TO_ADDR
// if filter then
14097: LD_VAR 0 3
14101: IFFALSE 14118
// ComMoveXY ( filter , 48 , 88 ) ;
14103: LD_VAR 0 3
14107: PPUSH
14108: LD_INT 48
14110: PPUSH
14111: LD_INT 88
14113: PPUSH
14114: CALL_OW 111
// enable ;
14118: ENABLE
// end ; end_of_file
14119: PPOPN 3
14121: END
// every 0 0$2 + 0 0$0.1 do
14122: GO 14124
14124: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
14125: LD_INT 22
14127: PUSH
14128: LD_INT 7
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: PUSH
14135: LD_INT 2
14137: PUSH
14138: LD_INT 25
14140: PUSH
14141: LD_INT 12
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_INT 25
14150: PUSH
14151: LD_INT 16
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: PUSH
14158: LD_INT 25
14160: PUSH
14161: LD_INT 15
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: PUSH
14168: LD_INT 25
14170: PUSH
14171: LD_INT 17
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: PUSH
14185: EMPTY
14186: LIST
14187: LIST
14188: PPUSH
14189: CALL_OW 69
14193: PUSH
14194: LD_INT 22
14196: PUSH
14197: LD_INT 7
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: PUSH
14204: LD_INT 21
14206: PUSH
14207: LD_INT 1
14209: PUSH
14210: EMPTY
14211: LIST
14212: LIST
14213: PUSH
14214: LD_INT 3
14216: PUSH
14217: LD_INT 2
14219: PUSH
14220: LD_INT 25
14222: PUSH
14223: LD_INT 12
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: PUSH
14230: LD_INT 25
14232: PUSH
14233: LD_INT 16
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: PUSH
14240: LD_INT 25
14242: PUSH
14243: LD_INT 15
14245: PUSH
14246: EMPTY
14247: LIST
14248: LIST
14249: PUSH
14250: LD_INT 25
14252: PUSH
14253: LD_INT 17
14255: PUSH
14256: EMPTY
14257: LIST
14258: LIST
14259: PUSH
14260: EMPTY
14261: LIST
14262: LIST
14263: LIST
14264: LIST
14265: LIST
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: LIST
14275: PPUSH
14276: CALL_OW 69
14280: GREATER
14281: IFFALSE 14292
// begin SetAchievement ( ACH_POTA ) ;
14283: LD_STRING ACH_POTA
14285: PPUSH
14286: CALL_OW 543
// exit ;
14290: GO 14293
// end ; enable ;
14292: ENABLE
// end ; end_of_file
14293: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
14294: LD_INT 0
14296: PPUSH
14297: PPUSH
// if not missionNumber then
14298: LD_VAR 0 2
14302: NOT
14303: IFFALSE 14307
// exit ;
14305: GO 14437
// achiv := false ;
14307: LD_ADDR_VAR 0 7
14311: PUSH
14312: LD_INT 0
14314: ST_TO_ADDR
// case campaignNumber of 1 :
14315: LD_VAR 0 1
14319: PUSH
14320: LD_INT 1
14322: DOUBLE
14323: EQUAL
14324: IFTRUE 14328
14326: GO 14339
14328: POP
// achiv := ACH_GOTA ; 2 :
14329: LD_ADDR_VAR 0 7
14333: PUSH
14334: LD_STRING ACH_GOTA
14336: ST_TO_ADDR
14337: GO 14389
14339: LD_INT 2
14341: DOUBLE
14342: EQUAL
14343: IFTRUE 14347
14345: GO 14350
14347: POP
// ; 3 :
14348: GO 14389
14350: LD_INT 3
14352: DOUBLE
14353: EQUAL
14354: IFTRUE 14358
14356: GO 14369
14358: POP
// achiv := ACH_MOTSU ; 4 :
14359: LD_ADDR_VAR 0 7
14363: PUSH
14364: LD_STRING ACH_MOTSU
14366: ST_TO_ADDR
14367: GO 14389
14369: LD_INT 4
14371: DOUBLE
14372: EQUAL
14373: IFTRUE 14377
14375: GO 14388
14377: POP
// achiv := ACH_LOP ; end ;
14378: LD_ADDR_VAR 0 7
14382: PUSH
14383: LD_STRING ACH_LOP
14385: ST_TO_ADDR
14386: GO 14389
14388: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
14389: LD_OWVAR 67
14393: PUSH
14394: LD_INT 3
14396: EQUAL
14397: PUSH
14398: LD_VAR 0 7
14402: AND
14403: PUSH
14404: LD_VAR 0 3
14408: AND
14409: PUSH
14410: LD_VAR 0 4
14414: AND
14415: PUSH
14416: LD_VAR 0 5
14420: AND
14421: IFFALSE 14437
// SetAchievementEX ( achiv , missionNumber ) ;
14423: LD_VAR 0 7
14427: PPUSH
14428: LD_VAR 0 2
14432: PPUSH
14433: CALL_OW 564
// end ;
14437: LD_VAR 0 6
14441: RET
// export function SA_BehemothConstructed ; begin
14442: LD_INT 0
14444: PPUSH
// SetAchievement ( ACH_SMC ) ;
14445: LD_STRING ACH_SMC
14447: PPUSH
14448: CALL_OW 543
// end ;
14452: LD_VAR 0 1
14456: RET
