// export you , russians , arabians , you2 ; export apemans ; export prilet_tvoji ; export prilet_rusaci ; export prilet_arabi ; export all , other ; export not_char , used , opicaci ; export zgamy2 ; export JMM ; export Har ; export RadioSci ; export Sol1 , Eng1 ; export Frank , Lisa ; export Cyrus , Bobby , Donaldson , Brown , Denis , Gladstone ; export MSol1 , MSol2 , MSol3 , MEng1 , MMec1 , Joan ; export Op1 , Op2 , Op3 , Op4 , Op5 ; export RMSo1 , RMSo2 , RMEn1 , RMMe1 ; export Kurt ; export Car1 , Car2 ; export Denis_P , Kurt_P , Joan_P , Lisa_P , Frank_P ; export MaterialNavic ; export DialogInProgress ; export map_size_x , map_size_y ; export start_game ; export test_JMM_Joan ; export before_d6 ; export act_Lisa_JMM ; export hledani ; export attacky ; export more_scouting ; export go_up ; export attacking ; export under_attack ; export odplata_1 ; export odplata_2 ; export attack_to_scouting ; export start_scouting ; export WasD11aa , WasD11ab , WasD11b , WasD11c , WasD11d , WasD11e , WasD11f ; export crates ; export list_of_R1_query ; export Gamma3_lab_upgraded_to_opto ; export Gamma3_lab_upgraded_to_weapon ; export radar_invented ; export vzit_opicaku ; export remote_tried ; export Gamma2Commander ; export NavicLidi ; export KurtTryToEscape ; export noBodyLeft ; starting begin disable ( 33 ) ;
   0: LD_INT 33
   2: DISABLE_MARKED
// disable_prediction := true ;
   3: LD_ADDR_OWVAR 50
   7: PUSH
   8: LD_INT 1
  10: ST_TO_ADDR
// map_size_x := 100 ;
  11: LD_ADDR_EXP 53
  15: PUSH
  16: LD_INT 100
  18: ST_TO_ADDR
// map_size_y := 100 ;
  19: LD_ADDR_EXP 54
  23: PUSH
  24: LD_INT 100
  26: ST_TO_ADDR
// noBodyLeft := true ;
  27: LD_ADDR_EXP 86
  31: PUSH
  32: LD_INT 1
  34: ST_TO_ADDR
// prepare_sides ;
  35: CALL 2069 0 0
// load_characters ;
  39: CALL 276 0 0
// prepare_russian_units ;
  43: CALL 1698 0 0
// prepare_arabian_units ;
  47: CALL 2024 0 0
// if radar_invented then
  51: LD_EXP 80
  55: IFFALSE 72
// SetTech ( tech_Radar , you , state_researched ) ;
  57: LD_INT 6
  59: PPUSH
  60: LD_EXP 1
  64: PPUSH
  65: LD_INT 2
  67: PPUSH
  68: CALL_OW 322
// Gamma3_lab_upgraded_to_opto := false ;
  72: LD_ADDR_EXP 78
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// Gamma3_lab_upgraded_to_weapon := false ;
  80: LD_ADDR_EXP 79
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// SetDifficulty ;
  88: CALL 2169 0 0
// apemans := FilterAllUnits ( [ f_nation , nation_nature ] ) ;
  92: LD_ADDR_EXP 5
  96: PUSH
  97: LD_INT 23
  99: PUSH
 100: LD_INT 0
 102: PUSH
 103: EMPTY
 104: LIST
 105: LIST
 106: PPUSH
 107: CALL_OW 69
 111: ST_TO_ADDR
// Kurt_P := false ;
 112: LD_ADDR_EXP 47
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// Joan_P := false ;
 120: LD_ADDR_EXP 48
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// start_game := false ;
 128: LD_ADDR_EXP 55
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// test_JMM_Joan := false ;
 136: LD_ADDR_EXP 56
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// before_d6 := false ;
 144: LD_ADDR_EXP 57
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// act_Lisa_JMM := false ;
 152: LD_ADDR_EXP 58
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// hledani := false ;
 160: LD_ADDR_EXP 59
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// more_scouting := false ;
 168: LD_ADDR_EXP 61
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// go_up := false ;
 176: LD_ADDR_EXP 62
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// WasD11aa := false ;
 184: LD_ADDR_EXP 69
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// WasD11ab := false ;
 192: LD_ADDR_EXP 70
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// WasD11b := false ;
 200: LD_ADDR_EXP 71
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// WasD11c := false ;
 208: LD_ADDR_EXP 72
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// WasD11d := false ;
 216: LD_ADDR_EXP 73
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// WasD11e := false ;
 224: LD_ADDR_EXP 74
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// WasD11f := false ;
 232: LD_ADDR_EXP 75
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// crates := [ ] ;
 240: LD_ADDR_EXP 76
 244: PUSH
 245: EMPTY
 246: ST_TO_ADDR
// attacky := 0 ;
 247: LD_ADDR_EXP 60
 251: PUSH
 252: LD_INT 0
 254: ST_TO_ADDR
// attacking := false ;
 255: LD_ADDR_EXP 63
 259: PUSH
 260: LD_INT 0
 262: ST_TO_ADDR
// under_attack := false ;
 263: LD_ADDR_EXP 64
 267: PUSH
 268: LD_INT 0
 270: ST_TO_ADDR
// Dialog1 ;
 271: CALL 4408 0 0
// end ;
 275: END
// function load_characters ; begin
 276: LD_INT 0
 278: PPUSH
// InitUc ;
 279: CALL_OW 18
// InitHc ;
 283: CALL_OW 19
// InitVc ;
 287: CALL_OW 20
// uc_side := arabians ;
 291: LD_ADDR_OWVAR 20
 295: PUSH
 296: LD_EXP 3
 300: ST_TO_ADDR
// uc_nation := nation_arabian ;
 301: LD_ADDR_OWVAR 21
 305: PUSH
 306: LD_INT 2
 308: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
 309: LD_ADDR_EXP 43
 313: PUSH
 314: LD_STRING Kurt
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// uc_side := you ;
 322: LD_ADDR_OWVAR 20
 326: PUSH
 327: LD_EXP 1
 331: ST_TO_ADDR
// uc_nation := nation_american ;
 332: LD_ADDR_OWVAR 21
 336: PUSH
 337: LD_INT 1
 339: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 340: LD_ADDR_EXP 15
 344: PUSH
 345: LD_STRING JMM
 347: PPUSH
 348: CALL_OW 34
 352: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 353: LD_ADDR_EXP 16
 357: PUSH
 358: LD_STRING Harisson
 360: PPUSH
 361: CALL_OW 25
 365: ST_TO_ADDR
// if TestCharacters ( other_from5to6 ) then
 366: LD_STRING other_from5to6
 368: PPUSH
 369: CALL_OW 28
 373: IFFALSE 390
// all := CreateCharacterSet ( other_from5to6 ) else
 375: LD_ADDR_EXP 9
 379: PUSH
 380: LD_STRING other_from5to6
 382: PPUSH
 383: CALL_OW 31
 387: ST_TO_ADDR
 388: GO 397
// all := [ ] ;
 390: LD_ADDR_EXP 9
 394: PUSH
 395: EMPTY
 396: ST_TO_ADDR
// if CheckCharacterSet ( radiosci_from5to6 ) then
 397: LD_STRING radiosci_from5to6
 399: PPUSH
 400: CALL_OW 29
 404: IFFALSE 421
// RadioSci := CreateCharacter ( radiosci_from5to6 ) else
 406: LD_ADDR_EXP 17
 410: PUSH
 411: LD_STRING radiosci_from5to6
 413: PPUSH
 414: CALL_OW 34
 418: ST_TO_ADDR
 419: GO 441
// begin PrepareScientist ( sex_male , 10 ) ;
 421: LD_INT 1
 423: PPUSH
 424: LD_INT 10
 426: PPUSH
 427: CALL_OW 384
// RadioSci := CreateHuman ;
 431: LD_ADDR_EXP 17
 435: PUSH
 436: CALL_OW 44
 440: ST_TO_ADDR
// end ; DeleteCharacters ( radiosci_from5to6 ) ;
 441: LD_STRING radiosci_from5to6
 443: PPUSH
 444: CALL_OW 40
// other := all ;
 448: LD_ADDR_EXP 10
 452: PUSH
 453: LD_EXP 9
 457: ST_TO_ADDR
// radar_invented := LoadVariable ( RadarDeveloped , false ) ;
 458: LD_ADDR_EXP 80
 462: PUSH
 463: LD_STRING RadarDeveloped
 465: PPUSH
 466: LD_INT 0
 468: PPUSH
 469: CALL_OW 30
 473: ST_TO_ADDR
// Gamma2Commander := LoadVariable ( Gamma2Commander , 3 ) ;
 474: LD_ADDR_EXP 83
 478: PUSH
 479: LD_STRING Gamma2Commander
 481: PPUSH
 482: LD_INT 3
 484: PPUSH
 485: CALL_OW 30
 489: ST_TO_ADDR
// opicaci := [ ] ;
 490: LD_ADDR_EXP 13
 494: PUSH
 495: EMPTY
 496: ST_TO_ADDR
// if CheckCharacterSet ( opicaci ) then
 497: LD_STRING opicaci
 499: PPUSH
 500: CALL_OW 29
 504: IFFALSE 519
// opicaci := CreateCharacterSet ( opicaci ) ;
 506: LD_ADDR_EXP 13
 510: PUSH
 511: LD_STRING opicaci
 513: PPUSH
 514: CALL_OW 31
 518: ST_TO_ADDR
// Lisa := 0 ;
 519: LD_ADDR_EXP 21
 523: PUSH
 524: LD_INT 0
 526: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 527: LD_STRING Lisa
 529: PPUSH
 530: CALL_OW 29
 534: IFFALSE 592
// if LoadVariable ( LisaLoc , 0 ) = 8 then
 536: LD_STRING LisaLoc
 538: PPUSH
 539: LD_INT 0
 541: PPUSH
 542: CALL_OW 30
 546: PUSH
 547: LD_INT 8
 549: EQUAL
 550: IFFALSE 592
// begin Lisa := CreateCharacter ( Lisa ) ;
 552: LD_ADDR_EXP 21
 556: PUSH
 557: LD_STRING Lisa
 559: PPUSH
 560: CALL_OW 34
 564: ST_TO_ADDR
// Lisa_P := true ;
 565: LD_ADDR_EXP 49
 569: PUSH
 570: LD_INT 1
 572: ST_TO_ADDR
// all := all ^ [ Lisa ] ;
 573: LD_ADDR_EXP 9
 577: PUSH
 578: LD_EXP 9
 582: PUSH
 583: LD_EXP 21
 587: PUSH
 588: EMPTY
 589: LIST
 590: ADD
 591: ST_TO_ADDR
// end ; Cyrus := 0 ;
 592: LD_ADDR_EXP 22
 596: PUSH
 597: LD_INT 0
 599: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 600: LD_STRING Cyrus
 602: PPUSH
 603: CALL_OW 29
 607: IFFALSE 657
// if LoadVariable ( CyrusLoc , 0 ) = 8 then
 609: LD_STRING CyrusLoc
 611: PPUSH
 612: LD_INT 0
 614: PPUSH
 615: CALL_OW 30
 619: PUSH
 620: LD_INT 8
 622: EQUAL
 623: IFFALSE 657
// begin Cyrus := CreateCharacter ( Cyrus ) ;
 625: LD_ADDR_EXP 22
 629: PUSH
 630: LD_STRING Cyrus
 632: PPUSH
 633: CALL_OW 34
 637: ST_TO_ADDR
// all := all ^ [ Cyrus ] ;
 638: LD_ADDR_EXP 9
 642: PUSH
 643: LD_EXP 9
 647: PUSH
 648: LD_EXP 22
 652: PUSH
 653: EMPTY
 654: LIST
 655: ADD
 656: ST_TO_ADDR
// end ; Bobby := 0 ;
 657: LD_ADDR_EXP 23
 661: PUSH
 662: LD_INT 0
 664: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 665: LD_STRING Bobby
 667: PPUSH
 668: CALL_OW 29
 672: IFFALSE 722
// if LoadVariable ( BobbyLoc , 0 ) = 8 then
 674: LD_STRING BobbyLoc
 676: PPUSH
 677: LD_INT 0
 679: PPUSH
 680: CALL_OW 30
 684: PUSH
 685: LD_INT 8
 687: EQUAL
 688: IFFALSE 722
// begin Bobby := CreateCharacter ( Bobby ) ;
 690: LD_ADDR_EXP 23
 694: PUSH
 695: LD_STRING Bobby
 697: PPUSH
 698: CALL_OW 34
 702: ST_TO_ADDR
// all := all ^ [ Bobby ] ;
 703: LD_ADDR_EXP 9
 707: PUSH
 708: LD_EXP 9
 712: PUSH
 713: LD_EXP 23
 717: PUSH
 718: EMPTY
 719: LIST
 720: ADD
 721: ST_TO_ADDR
// end ; Frank := 0 ;
 722: LD_ADDR_EXP 20
 726: PUSH
 727: LD_INT 0
 729: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 730: LD_STRING Frank
 732: PPUSH
 733: CALL_OW 29
 737: IFFALSE 795
// if LoadVariable ( FrankLoc , 0 ) = 8 then
 739: LD_STRING FrankLoc
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: CALL_OW 30
 749: PUSH
 750: LD_INT 8
 752: EQUAL
 753: IFFALSE 795
// begin Frank := CreateCharacter ( Frank ) ;
 755: LD_ADDR_EXP 20
 759: PUSH
 760: LD_STRING Frank
 762: PPUSH
 763: CALL_OW 34
 767: ST_TO_ADDR
// Frank_P := true ;
 768: LD_ADDR_EXP 50
 772: PUSH
 773: LD_INT 1
 775: ST_TO_ADDR
// all := all ^ [ Frank ] ;
 776: LD_ADDR_EXP 9
 780: PUSH
 781: LD_EXP 9
 785: PUSH
 786: LD_EXP 20
 790: PUSH
 791: EMPTY
 792: LIST
 793: ADD
 794: ST_TO_ADDR
// end ; Donaldson := 0 ;
 795: LD_ADDR_EXP 24
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 803: LD_STRING Donaldson
 805: PPUSH
 806: CALL_OW 29
 810: IFFALSE 860
// if LoadVariable ( DonaldsonLoc , 0 ) = 8 then
 812: LD_STRING DonaldsonLoc
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL_OW 30
 822: PUSH
 823: LD_INT 8
 825: EQUAL
 826: IFFALSE 860
// begin Donaldson := CreateCharacter ( Donaldson ) ;
 828: LD_ADDR_EXP 24
 832: PUSH
 833: LD_STRING Donaldson
 835: PPUSH
 836: CALL_OW 34
 840: ST_TO_ADDR
// all := all ^ [ Donaldson ] ;
 841: LD_ADDR_EXP 9
 845: PUSH
 846: LD_EXP 9
 850: PUSH
 851: LD_EXP 24
 855: PUSH
 856: EMPTY
 857: LIST
 858: ADD
 859: ST_TO_ADDR
// end ; Brown := 0 ;
 860: LD_ADDR_EXP 25
 864: PUSH
 865: LD_INT 0
 867: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 868: LD_STRING Brown
 870: PPUSH
 871: CALL_OW 29
 875: IFFALSE 925
// if LoadVariable ( BrownLoc , 0 ) = 8 then
 877: LD_STRING BrownLoc
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL_OW 30
 887: PUSH
 888: LD_INT 8
 890: EQUAL
 891: IFFALSE 925
// begin Brown := CreateCharacter ( Brown ) ;
 893: LD_ADDR_EXP 25
 897: PUSH
 898: LD_STRING Brown
 900: PPUSH
 901: CALL_OW 34
 905: ST_TO_ADDR
// all := all ^ [ Brown ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_EXP 9
 915: PUSH
 916: LD_EXP 25
 920: PUSH
 921: EMPTY
 922: LIST
 923: ADD
 924: ST_TO_ADDR
// end ; Denis := 0 ;
 925: LD_ADDR_EXP 26
 929: PUSH
 930: LD_INT 0
 932: ST_TO_ADDR
// if CheckCharacterSet ( Denis ) then
 933: LD_STRING Denis
 935: PPUSH
 936: CALL_OW 29
 940: IFFALSE 979
// if LoadVariable ( DenisLoc , 0 ) = 8 then
 942: LD_STRING DenisLoc
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 30
 952: PUSH
 953: LD_INT 8
 955: EQUAL
 956: IFFALSE 979
// begin Denis := CreateCharacter ( Denis ) ;
 958: LD_ADDR_EXP 26
 962: PUSH
 963: LD_STRING Denis
 965: PPUSH
 966: CALL_OW 34
 970: ST_TO_ADDR
// Denis_P := true ;
 971: LD_ADDR_EXP 46
 975: PUSH
 976: LD_INT 1
 978: ST_TO_ADDR
// end ; Gladstone := 0 ;
 979: LD_ADDR_EXP 27
 983: PUSH
 984: LD_INT 0
 986: ST_TO_ADDR
// if CheckCharacterSet ( Gladstone ) then
 987: LD_STRING Gladstone
 989: PPUSH
 990: CALL_OW 29
 994: IFFALSE 1044
// if LoadVariable ( GladstoneLoc , 0 ) = 8 then
 996: LD_STRING GladstoneLoc
 998: PPUSH
 999: LD_INT 0
1001: PPUSH
1002: CALL_OW 30
1006: PUSH
1007: LD_INT 8
1009: EQUAL
1010: IFFALSE 1044
// begin Gladstone := CreateCharacter ( Gladstone ) ;
1012: LD_ADDR_EXP 27
1016: PUSH
1017: LD_STRING Gladstone
1019: PPUSH
1020: CALL_OW 34
1024: ST_TO_ADDR
// all := all ^ [ Gladstone ] ;
1025: LD_ADDR_EXP 9
1029: PUSH
1030: LD_EXP 9
1034: PUSH
1035: LD_EXP 27
1039: PUSH
1040: EMPTY
1041: LIST
1042: ADD
1043: ST_TO_ADDR
// end ; uc_side := you2 ;
1044: LD_ADDR_OWVAR 20
1048: PUSH
1049: LD_EXP 4
1053: ST_TO_ADDR
// Joan := NewCharacter ( Joan ) ;
1054: LD_ADDR_EXP 33
1058: PUSH
1059: LD_STRING Joan
1061: PPUSH
1062: CALL_OW 25
1066: ST_TO_ADDR
// SetLives ( Joan , hranice_umirani - 1 ) ;
1067: LD_EXP 33
1071: PPUSH
1072: LD_INT 250
1074: PUSH
1075: LD_INT 1
1077: MINUS
1078: PPUSH
1079: CALL_OW 234
// uc_side := you ;
1083: LD_ADDR_OWVAR 20
1087: PUSH
1088: LD_EXP 1
1092: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1093: LD_ADDR_OWVAR 37
1097: PUSH
1098: LD_INT 1
1100: ST_TO_ADDR
// vc_control := control_manual ;
1101: LD_ADDR_OWVAR 38
1105: PUSH
1106: LD_INT 1
1108: ST_TO_ADDR
// vc_engine := engine_solar ;
1109: LD_ADDR_OWVAR 39
1113: PUSH
1114: LD_INT 2
1116: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1117: LD_ADDR_OWVAR 40
1121: PUSH
1122: LD_INT 2
1124: ST_TO_ADDR
// Car1 := CreateVehicle ;
1125: LD_ADDR_EXP 44
1129: PUSH
1130: CALL_OW 45
1134: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
1135: LD_ADDR_OWVAR 37
1139: PUSH
1140: LD_INT 1
1142: ST_TO_ADDR
// vc_control := control_manual ;
1143: LD_ADDR_OWVAR 38
1147: PUSH
1148: LD_INT 1
1150: ST_TO_ADDR
// vc_engine := engine_solar ;
1151: LD_ADDR_OWVAR 39
1155: PUSH
1156: LD_INT 2
1158: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
1159: LD_ADDR_OWVAR 40
1163: PUSH
1164: LD_INT 2
1166: ST_TO_ADDR
// Car2 := CreateVehicle ;
1167: LD_ADDR_EXP 45
1171: PUSH
1172: CALL_OW 45
1176: ST_TO_ADDR
// uc_nation := nation_american ;
1177: LD_ADDR_OWVAR 21
1181: PUSH
1182: LD_INT 1
1184: ST_TO_ADDR
// hc_sex := sex_female ;
1185: LD_ADDR_OWVAR 27
1189: PUSH
1190: LD_INT 2
1192: ST_TO_ADDR
// hc_class := class_soldier ;
1193: LD_ADDR_OWVAR 28
1197: PUSH
1198: LD_INT 1
1200: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1201: LD_ADDR_OWVAR 29
1205: PUSH
1206: LD_INT 10
1208: PUSH
1209: LD_INT 10
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: ST_TO_ADDR
// hc_skills := [ 4 , 2 , 1 , 0 ] ;
1216: LD_ADDR_OWVAR 31
1220: PUSH
1221: LD_INT 4
1223: PUSH
1224: LD_INT 2
1226: PUSH
1227: LD_INT 1
1229: PUSH
1230: LD_INT 0
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: ST_TO_ADDR
// Sol1 := CreateHuman ;
1239: LD_ADDR_EXP 18
1243: PUSH
1244: CALL_OW 44
1248: ST_TO_ADDR
// hc_sex := sex_male ;
1249: LD_ADDR_OWVAR 27
1253: PUSH
1254: LD_INT 1
1256: ST_TO_ADDR
// hc_class := class_engineer ;
1257: LD_ADDR_OWVAR 28
1261: PUSH
1262: LD_INT 2
1264: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1265: LD_ADDR_OWVAR 29
1269: PUSH
1270: LD_INT 10
1272: PUSH
1273: LD_INT 10
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: ST_TO_ADDR
// hc_skills := [ 3 , 4 , 0 , 0 ] ;
1280: LD_ADDR_OWVAR 31
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 0
1293: PUSH
1294: LD_INT 0
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: ST_TO_ADDR
// Eng1 := CreateHuman ;
1303: LD_ADDR_EXP 19
1307: PUSH
1308: CALL_OW 44
1312: ST_TO_ADDR
// zgamy2 := [ Sol1 , Eng1 ] ;
1313: LD_ADDR_EXP 14
1317: PUSH
1318: LD_EXP 18
1322: PUSH
1323: LD_EXP 19
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: ST_TO_ADDR
// hc_sex := sex_female ;
1332: LD_ADDR_OWVAR 27
1336: PUSH
1337: LD_INT 2
1339: ST_TO_ADDR
// hc_class := class_soldier ;
1340: LD_ADDR_OWVAR 28
1344: PUSH
1345: LD_INT 1
1347: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1348: LD_ADDR_OWVAR 29
1352: PUSH
1353: LD_INT 10
1355: PUSH
1356: LD_INT 10
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1363: LD_ADDR_OWVAR 31
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: LD_INT 1
1373: PUSH
1374: LD_INT 0
1376: PUSH
1377: LD_INT 0
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: ST_TO_ADDR
// MSol1 := CreateHuman ;
1386: LD_ADDR_EXP 28
1390: PUSH
1391: CALL_OW 44
1395: ST_TO_ADDR
// hc_sex := sex_male ;
1396: LD_ADDR_OWVAR 27
1400: PUSH
1401: LD_INT 1
1403: ST_TO_ADDR
// hc_class := class_soldier ;
1404: LD_ADDR_OWVAR 28
1408: PUSH
1409: LD_INT 1
1411: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1412: LD_ADDR_OWVAR 29
1416: PUSH
1417: LD_INT 10
1419: PUSH
1420: LD_INT 10
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1427: LD_ADDR_OWVAR 31
1431: PUSH
1432: LD_INT 2
1434: PUSH
1435: LD_INT 0
1437: PUSH
1438: LD_INT 1
1440: PUSH
1441: LD_INT 0
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: ST_TO_ADDR
// MSol2 := CreateHuman ;
1450: LD_ADDR_EXP 29
1454: PUSH
1455: CALL_OW 44
1459: ST_TO_ADDR
// hc_sex := sex_male ;
1460: LD_ADDR_OWVAR 27
1464: PUSH
1465: LD_INT 1
1467: ST_TO_ADDR
// hc_class := class_soldier ;
1468: LD_ADDR_OWVAR 28
1472: PUSH
1473: LD_INT 1
1475: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1476: LD_ADDR_OWVAR 29
1480: PUSH
1481: LD_INT 10
1483: PUSH
1484: LD_INT 10
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1491: LD_ADDR_OWVAR 31
1495: PUSH
1496: LD_INT 2
1498: PUSH
1499: LD_INT 0
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 0
1507: PUSH
1508: EMPTY
1509: LIST
1510: LIST
1511: LIST
1512: LIST
1513: ST_TO_ADDR
// MSol3 := CreateHuman ;
1514: LD_ADDR_EXP 30
1518: PUSH
1519: CALL_OW 44
1523: ST_TO_ADDR
// hc_sex := sex_female ;
1524: LD_ADDR_OWVAR 27
1528: PUSH
1529: LD_INT 2
1531: ST_TO_ADDR
// hc_class := class_engineer ;
1532: LD_ADDR_OWVAR 28
1536: PUSH
1537: LD_INT 2
1539: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1540: LD_ADDR_OWVAR 29
1544: PUSH
1545: LD_INT 9
1547: PUSH
1548: LD_INT 10
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1555: LD_ADDR_OWVAR 31
1559: PUSH
1560: LD_INT 0
1562: PUSH
1563: LD_INT 2
1565: PUSH
1566: LD_INT 0
1568: PUSH
1569: LD_INT 0
1571: PUSH
1572: EMPTY
1573: LIST
1574: LIST
1575: LIST
1576: LIST
1577: ST_TO_ADDR
// MEng1 := CreateHuman ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: CALL_OW 44
1587: ST_TO_ADDR
// hc_sex := sex_male ;
1588: LD_ADDR_OWVAR 27
1592: PUSH
1593: LD_INT 1
1595: ST_TO_ADDR
// hc_class := class_mechanic ;
1596: LD_ADDR_OWVAR 28
1600: PUSH
1601: LD_INT 3
1603: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1604: LD_ADDR_OWVAR 29
1608: PUSH
1609: LD_INT 10
1611: PUSH
1612: LD_INT 9
1614: PUSH
1615: EMPTY
1616: LIST
1617: LIST
1618: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1619: LD_ADDR_OWVAR 31
1623: PUSH
1624: LD_INT 0
1626: PUSH
1627: LD_INT 0
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 0
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: ST_TO_ADDR
// MMec1 := CreateHuman ;
1642: LD_ADDR_EXP 32
1646: PUSH
1647: CALL_OW 44
1651: ST_TO_ADDR
// prilet_tvoji := [ MSol1 , MSol2 , MEng1 , MMec1 ] ;
1652: LD_ADDR_EXP 6
1656: PUSH
1657: LD_EXP 28
1661: PUSH
1662: LD_EXP 29
1666: PUSH
1667: LD_EXP 31
1671: PUSH
1672: LD_EXP 32
1676: PUSH
1677: EMPTY
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: ST_TO_ADDR
// NavicLidi := prilet_tvoji ;
1683: LD_ADDR_EXP 84
1687: PUSH
1688: LD_EXP 6
1692: ST_TO_ADDR
// end ;
1693: LD_VAR 0 1
1697: RET
// function prepare_russian_units ; begin
1698: LD_INT 0
1700: PPUSH
// InitUc ;
1701: CALL_OW 18
// InitHc ;
1705: CALL_OW 19
// InitVc ;
1709: CALL_OW 20
// uc_nation := nation_russian ;
1713: LD_ADDR_OWVAR 21
1717: PUSH
1718: LD_INT 3
1720: ST_TO_ADDR
// uc_side := russians ;
1721: LD_ADDR_OWVAR 20
1725: PUSH
1726: LD_EXP 2
1730: ST_TO_ADDR
// hc_sex := sex_female ;
1731: LD_ADDR_OWVAR 27
1735: PUSH
1736: LD_INT 2
1738: ST_TO_ADDR
// hc_class := class_soldier ;
1739: LD_ADDR_OWVAR 28
1743: PUSH
1744: LD_INT 1
1746: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1747: LD_ADDR_OWVAR 29
1751: PUSH
1752: LD_INT 10
1754: PUSH
1755: LD_INT 10
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: ST_TO_ADDR
// hc_skills := [ 1 , 1 , 0 , 0 ] ;
1762: LD_ADDR_OWVAR 31
1766: PUSH
1767: LD_INT 1
1769: PUSH
1770: LD_INT 1
1772: PUSH
1773: LD_INT 0
1775: PUSH
1776: LD_INT 0
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: ST_TO_ADDR
// RMSo1 := CreateHuman ;
1785: LD_ADDR_EXP 39
1789: PUSH
1790: CALL_OW 44
1794: ST_TO_ADDR
// hc_sex := sex_male ;
1795: LD_ADDR_OWVAR 27
1799: PUSH
1800: LD_INT 1
1802: ST_TO_ADDR
// hc_class := class_soldier ;
1803: LD_ADDR_OWVAR 28
1807: PUSH
1808: LD_INT 1
1810: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
1811: LD_ADDR_OWVAR 29
1815: PUSH
1816: LD_INT 10
1818: PUSH
1819: LD_INT 10
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: ST_TO_ADDR
// hc_skills := [ 2 , 0 , 1 , 0 ] ;
1826: LD_ADDR_OWVAR 31
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: LD_INT 0
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 0
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: ST_TO_ADDR
// RMSo2 := CreateHuman ;
1849: LD_ADDR_EXP 40
1853: PUSH
1854: CALL_OW 44
1858: ST_TO_ADDR
// hc_sex := sex_female ;
1859: LD_ADDR_OWVAR 27
1863: PUSH
1864: LD_INT 2
1866: ST_TO_ADDR
// hc_class := class_engineer ;
1867: LD_ADDR_OWVAR 28
1871: PUSH
1872: LD_INT 2
1874: ST_TO_ADDR
// hc_attr := [ 9 , 10 ] ;
1875: LD_ADDR_OWVAR 29
1879: PUSH
1880: LD_INT 9
1882: PUSH
1883: LD_INT 10
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: ST_TO_ADDR
// hc_skills := [ 0 , 2 , 0 , 0 ] ;
1890: LD_ADDR_OWVAR 31
1894: PUSH
1895: LD_INT 0
1897: PUSH
1898: LD_INT 2
1900: PUSH
1901: LD_INT 0
1903: PUSH
1904: LD_INT 0
1906: PUSH
1907: EMPTY
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: ST_TO_ADDR
// RMEn1 := CreateHuman ;
1913: LD_ADDR_EXP 41
1917: PUSH
1918: CALL_OW 44
1922: ST_TO_ADDR
// hc_sex := sex_male ;
1923: LD_ADDR_OWVAR 27
1927: PUSH
1928: LD_INT 1
1930: ST_TO_ADDR
// hc_class := class_mechanic ;
1931: LD_ADDR_OWVAR 28
1935: PUSH
1936: LD_INT 3
1938: ST_TO_ADDR
// hc_attr := [ 10 , 9 ] ;
1939: LD_ADDR_OWVAR 29
1943: PUSH
1944: LD_INT 10
1946: PUSH
1947: LD_INT 9
1949: PUSH
1950: EMPTY
1951: LIST
1952: LIST
1953: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 3 , 0 ] ;
1954: LD_ADDR_OWVAR 31
1958: PUSH
1959: LD_INT 0
1961: PUSH
1962: LD_INT 0
1964: PUSH
1965: LD_INT 3
1967: PUSH
1968: LD_INT 0
1970: PUSH
1971: EMPTY
1972: LIST
1973: LIST
1974: LIST
1975: LIST
1976: ST_TO_ADDR
// RMMe1 := CreateHuman ;
1977: LD_ADDR_EXP 42
1981: PUSH
1982: CALL_OW 44
1986: ST_TO_ADDR
// prilet_rusaci := [ RMSo1 , RMSo2 , RMMe1 ] ;
1987: LD_ADDR_EXP 7
1991: PUSH
1992: LD_EXP 39
1996: PUSH
1997: LD_EXP 40
2001: PUSH
2002: LD_EXP 42
2006: PUSH
2007: EMPTY
2008: LIST
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// prilet_arabi := [ ] ;
2012: LD_ADDR_EXP 8
2016: PUSH
2017: EMPTY
2018: ST_TO_ADDR
// end ;
2019: LD_VAR 0 1
2023: RET
// function prepare_arabian_units ; begin
2024: LD_INT 0
2026: PPUSH
// InitUc ;
2027: CALL_OW 18
// InitHc ;
2031: CALL_OW 19
// InitVc ;
2035: CALL_OW 20
// uc_nation := nation_arabian ;
2039: LD_ADDR_OWVAR 21
2043: PUSH
2044: LD_INT 2
2046: ST_TO_ADDR
// uc_side := arabians ;
2047: LD_ADDR_OWVAR 20
2051: PUSH
2052: LD_EXP 3
2056: ST_TO_ADDR
// prilet_arabi := [ ] ;
2057: LD_ADDR_EXP 8
2061: PUSH
2062: EMPTY
2063: ST_TO_ADDR
// end ;
2064: LD_VAR 0 1
2068: RET
// function prepare_sides ; begin
2069: LD_INT 0
2071: PPUSH
// you := 1 ;
2072: LD_ADDR_EXP 1
2076: PUSH
2077: LD_INT 1
2079: ST_TO_ADDR
// you2 := 4 ;
2080: LD_ADDR_EXP 4
2084: PUSH
2085: LD_INT 4
2087: ST_TO_ADDR
// arabians := 2 ;
2088: LD_ADDR_EXP 3
2092: PUSH
2093: LD_INT 2
2095: ST_TO_ADDR
// russians := 3 ;
2096: LD_ADDR_EXP 2
2100: PUSH
2101: LD_INT 3
2103: ST_TO_ADDR
// SetAttitude ( russians , you , att_enemy , true ) ;
2104: LD_EXP 2
2108: PPUSH
2109: LD_EXP 1
2113: PPUSH
2114: LD_INT 2
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: CALL_OW 80
// SetAttitude ( arabians , you , att_neutral , true ) ;
2124: LD_EXP 3
2128: PPUSH
2129: LD_EXP 1
2133: PPUSH
2134: LD_INT 0
2136: PPUSH
2137: LD_INT 1
2139: PPUSH
2140: CALL_OW 80
// SetAttitude ( arabians , russians , att_enemy , true ) ;
2144: LD_EXP 3
2148: PPUSH
2149: LD_EXP 2
2153: PPUSH
2154: LD_INT 2
2156: PPUSH
2157: LD_INT 1
2159: PPUSH
2160: CALL_OW 80
// end ;
2164: LD_VAR 0 1
2168: RET
// function SetDifficulty ; var t1 ; begin
2169: LD_INT 0
2171: PPUSH
2172: PPUSH
// MaterialNavic := [ 350 , 500 , 700 ] [ difficulty ] ;
2173: LD_ADDR_EXP 51
2177: PUSH
2178: LD_INT 350
2180: PUSH
2181: LD_INT 500
2183: PUSH
2184: LD_INT 700
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: LIST
2191: PUSH
2192: LD_OWVAR 67
2196: ARRAY
2197: ST_TO_ADDR
// odplata_1 := [ 130 , 90 , 75 ] [ difficulty ] ;
2198: LD_ADDR_EXP 65
2202: PUSH
2203: LD_INT 130
2205: PUSH
2206: LD_INT 90
2208: PUSH
2209: LD_INT 75
2211: PUSH
2212: EMPTY
2213: LIST
2214: LIST
2215: LIST
2216: PUSH
2217: LD_OWVAR 67
2221: ARRAY
2222: ST_TO_ADDR
// odplata_2 := [ 350 , 250 , 150 ] [ difficulty ] ;
2223: LD_ADDR_EXP 66
2227: PUSH
2228: LD_INT 350
2230: PUSH
2231: LD_INT 250
2233: PUSH
2234: LD_INT 150
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: LD_OWVAR 67
2246: ARRAY
2247: ST_TO_ADDR
// attack_to_scouting := [ 15 , 10 , 5 ] [ difficulty ] ;
2248: LD_ADDR_EXP 67
2252: PUSH
2253: LD_INT 15
2255: PUSH
2256: LD_INT 10
2258: PUSH
2259: LD_INT 5
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: LIST
2266: PUSH
2267: LD_OWVAR 67
2271: ARRAY
2272: ST_TO_ADDR
// start_scouting := [ 5 5$0 , 2 2$0 , 0 0$0 ] [ difficulty ] ;
2273: LD_ADDR_EXP 68
2277: PUSH
2278: LD_INT 10500
2280: PUSH
2281: LD_INT 4200
2283: PUSH
2284: LD_INT 0
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: LIST
2291: PUSH
2292: LD_OWVAR 67
2296: ARRAY
2297: ST_TO_ADDR
// case difficulty of 1 :
2298: LD_OWVAR 67
2302: PUSH
2303: LD_INT 1
2305: DOUBLE
2306: EQUAL
2307: IFTRUE 2311
2309: GO 2703
2311: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2312: LD_ADDR_VAR 0 2
2316: PUSH
2317: LD_INT 22
2319: PUSH
2320: LD_EXP 2
2324: PUSH
2325: EMPTY
2326: LIST
2327: LIST
2328: PUSH
2329: LD_INT 21
2331: PUSH
2332: LD_INT 1
2334: PUSH
2335: EMPTY
2336: LIST
2337: LIST
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: PPUSH
2343: CALL_OW 69
2347: PUSH
2348: FOR_IN
2349: IFFALSE 2411
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 3 ) ;
2351: LD_VAR 0 2
2355: PPUSH
2356: LD_INT 1
2358: PPUSH
2359: LD_VAR 0 2
2363: PPUSH
2364: LD_INT 1
2366: PPUSH
2367: CALL_OW 260
2371: PUSH
2372: LD_INT 3
2374: MINUS
2375: PPUSH
2376: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 2 ) ;
2380: LD_VAR 0 2
2384: PPUSH
2385: LD_INT 2
2387: PPUSH
2388: LD_VAR 0 2
2392: PPUSH
2393: LD_INT 2
2395: PPUSH
2396: CALL_OW 260
2400: PUSH
2401: LD_INT 2
2403: MINUS
2404: PPUSH
2405: CALL_OW 239
// end ;
2409: GO 2348
2411: POP
2412: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_INT 22
2420: PUSH
2421: LD_EXP 2
2425: PUSH
2426: EMPTY
2427: LIST
2428: LIST
2429: PUSH
2430: LD_INT 25
2432: PUSH
2433: LD_INT 1
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: PPUSH
2444: CALL_OW 69
2448: PUSH
2449: FOR_IN
2450: IFFALSE 2483
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) - 1 ) ;
2452: LD_VAR 0 2
2456: PPUSH
2457: LD_INT 1
2459: PPUSH
2460: LD_VAR 0 2
2464: PPUSH
2465: LD_INT 1
2467: PPUSH
2468: CALL_OW 259
2472: PUSH
2473: LD_INT 1
2475: MINUS
2476: PPUSH
2477: CALL_OW 237
// end ;
2481: GO 2449
2483: POP
2484: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_INT 22
2492: PUSH
2493: LD_EXP 2
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PUSH
2502: LD_INT 25
2504: PUSH
2505: LD_INT 2
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PPUSH
2516: CALL_OW 69
2520: PUSH
2521: FOR_IN
2522: IFFALSE 2555
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2524: LD_VAR 0 2
2528: PPUSH
2529: LD_INT 2
2531: PPUSH
2532: LD_VAR 0 2
2536: PPUSH
2537: LD_INT 2
2539: PPUSH
2540: CALL_OW 259
2544: PUSH
2545: LD_INT 2
2547: PLUS
2548: PPUSH
2549: CALL_OW 237
// end ;
2553: GO 2521
2555: POP
2556: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2557: LD_ADDR_VAR 0 2
2561: PUSH
2562: LD_INT 22
2564: PUSH
2565: LD_EXP 2
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PUSH
2574: LD_INT 25
2576: PUSH
2577: LD_INT 3
2579: PUSH
2580: EMPTY
2581: LIST
2582: LIST
2583: PUSH
2584: EMPTY
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 69
2592: PUSH
2593: FOR_IN
2594: IFFALSE 2627
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) - 1 ) ;
2596: LD_VAR 0 2
2600: PPUSH
2601: LD_INT 3
2603: PPUSH
2604: LD_VAR 0 2
2608: PPUSH
2609: LD_INT 3
2611: PPUSH
2612: CALL_OW 259
2616: PUSH
2617: LD_INT 1
2619: MINUS
2620: PPUSH
2621: CALL_OW 237
// end ;
2625: GO 2593
2627: POP
2628: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
2629: LD_ADDR_VAR 0 2
2633: PUSH
2634: LD_INT 22
2636: PUSH
2637: LD_EXP 2
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: PUSH
2646: LD_INT 25
2648: PUSH
2649: LD_INT 4
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: PPUSH
2660: CALL_OW 69
2664: PUSH
2665: FOR_IN
2666: IFFALSE 2699
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) - 1 ) ;
2668: LD_VAR 0 2
2672: PPUSH
2673: LD_INT 4
2675: PPUSH
2676: LD_VAR 0 2
2680: PPUSH
2681: LD_INT 4
2683: PPUSH
2684: CALL_OW 259
2688: PUSH
2689: LD_INT 1
2691: MINUS
2692: PPUSH
2693: CALL_OW 237
// end ;
2697: GO 2665
2699: POP
2700: POP
// end ; 2 :
2701: GO 3554
2703: LD_INT 2
2705: DOUBLE
2706: EQUAL
2707: IFTRUE 2711
2709: GO 3124
2711: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
2712: LD_ADDR_VAR 0 2
2716: PUSH
2717: LD_INT 22
2719: PUSH
2720: LD_EXP 2
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: PUSH
2729: LD_INT 21
2731: PUSH
2732: LD_INT 1
2734: PUSH
2735: EMPTY
2736: LIST
2737: LIST
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 69
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2836
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) - 1 ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: LD_VAR 0 2
2763: PPUSH
2764: LD_INT 1
2766: PPUSH
2767: CALL_OW 260
2771: PUSH
2772: LD_INT 1
2774: MINUS
2775: PPUSH
2776: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) - 1 ) ;
2780: LD_VAR 0 2
2784: PPUSH
2785: LD_INT 2
2787: PPUSH
2788: LD_VAR 0 2
2792: PPUSH
2793: LD_INT 2
2795: PPUSH
2796: CALL_OW 260
2800: PUSH
2801: LD_INT 1
2803: MINUS
2804: PPUSH
2805: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) ) ;
2809: LD_VAR 0 2
2813: PPUSH
2814: LD_INT 1
2816: PPUSH
2817: LD_VAR 0 2
2821: PPUSH
2822: LD_INT 1
2824: PPUSH
2825: CALL_OW 259
2829: PPUSH
2830: CALL_OW 237
// end ;
2834: GO 2748
2836: POP
2837: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
2838: LD_ADDR_VAR 0 2
2842: PUSH
2843: LD_INT 22
2845: PUSH
2846: LD_EXP 2
2850: PUSH
2851: EMPTY
2852: LIST
2853: LIST
2854: PUSH
2855: LD_INT 25
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PPUSH
2869: CALL_OW 69
2873: PUSH
2874: FOR_IN
2875: IFFALSE 2908
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
2877: LD_VAR 0 2
2881: PPUSH
2882: LD_INT 1
2884: PPUSH
2885: LD_VAR 0 2
2889: PPUSH
2890: LD_INT 1
2892: PPUSH
2893: CALL_OW 259
2897: PUSH
2898: LD_INT 1
2900: PLUS
2901: PPUSH
2902: CALL_OW 237
// end ;
2906: GO 2874
2908: POP
2909: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
2910: LD_ADDR_VAR 0 2
2914: PUSH
2915: LD_INT 22
2917: PUSH
2918: LD_EXP 2
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 25
2929: PUSH
2930: LD_INT 2
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 69
2945: PUSH
2946: FOR_IN
2947: IFFALSE 2980
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
2949: LD_VAR 0 2
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_VAR 0 2
2961: PPUSH
2962: LD_INT 2
2964: PPUSH
2965: CALL_OW 259
2969: PUSH
2970: LD_INT 2
2972: PLUS
2973: PPUSH
2974: CALL_OW 237
// end ;
2978: GO 2946
2980: POP
2981: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
2982: LD_ADDR_VAR 0 2
2986: PUSH
2987: LD_INT 22
2989: PUSH
2990: LD_EXP 2
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: LD_INT 25
3001: PUSH
3002: LD_INT 3
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: PPUSH
3013: CALL_OW 69
3017: PUSH
3018: FOR_IN
3019: IFFALSE 3048
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) ) ;
3021: LD_VAR 0 2
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: LD_VAR 0 2
3033: PPUSH
3034: LD_INT 3
3036: PPUSH
3037: CALL_OW 259
3041: PPUSH
3042: CALL_OW 237
// end ;
3046: GO 3018
3048: POP
3049: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3050: LD_ADDR_VAR 0 2
3054: PUSH
3055: LD_INT 22
3057: PUSH
3058: LD_EXP 2
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 25
3069: PUSH
3070: LD_INT 4
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PPUSH
3081: CALL_OW 69
3085: PUSH
3086: FOR_IN
3087: IFFALSE 3120
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 1 ) ;
3089: LD_VAR 0 2
3093: PPUSH
3094: LD_INT 4
3096: PPUSH
3097: LD_VAR 0 2
3101: PPUSH
3102: LD_INT 4
3104: PPUSH
3105: CALL_OW 259
3109: PUSH
3110: LD_INT 1
3112: PLUS
3113: PPUSH
3114: CALL_OW 237
// end ;
3118: GO 3086
3120: POP
3121: POP
// end ; 3 :
3122: GO 3554
3124: LD_INT 3
3126: DOUBLE
3127: EQUAL
3128: IFTRUE 3132
3130: GO 3553
3132: POP
// begin for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] ] ) do
3133: LD_ADDR_VAR 0 2
3137: PUSH
3138: LD_INT 22
3140: PUSH
3141: LD_EXP 2
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 21
3152: PUSH
3153: LD_INT 1
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 69
3168: PUSH
3169: FOR_IN
3170: IFFALSE 3261
// begin SetAttr ( t1 , attr_stamina , GetAttr ( t1 , attr_stamina ) + 1 ) ;
3172: LD_VAR 0 2
3176: PPUSH
3177: LD_INT 1
3179: PPUSH
3180: LD_VAR 0 2
3184: PPUSH
3185: LD_INT 1
3187: PPUSH
3188: CALL_OW 260
3192: PUSH
3193: LD_INT 1
3195: PLUS
3196: PPUSH
3197: CALL_OW 239
// SetAttr ( t1 , attr_speed , GetAttr ( t1 , attr_speed ) + 1 ) ;
3201: LD_VAR 0 2
3205: PPUSH
3206: LD_INT 2
3208: PPUSH
3209: LD_VAR 0 2
3213: PPUSH
3214: LD_INT 2
3216: PPUSH
3217: CALL_OW 260
3221: PUSH
3222: LD_INT 1
3224: PLUS
3225: PPUSH
3226: CALL_OW 239
// SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 1 ) ;
3230: LD_VAR 0 2
3234: PPUSH
3235: LD_INT 1
3237: PPUSH
3238: LD_VAR 0 2
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: CALL_OW 259
3250: PUSH
3251: LD_INT 1
3253: PLUS
3254: PPUSH
3255: CALL_OW 237
// end ;
3259: GO 3169
3261: POP
3262: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_soldier ] ] ) do
3263: LD_ADDR_VAR 0 2
3267: PUSH
3268: LD_INT 22
3270: PUSH
3271: LD_EXP 2
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PUSH
3280: LD_INT 25
3282: PUSH
3283: LD_INT 1
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PPUSH
3294: CALL_OW 69
3298: PUSH
3299: FOR_IN
3300: IFFALSE 3333
// begin SetSkill ( t1 , skill_combat , GetSkill ( t1 , skill_combat ) + 2 ) ;
3302: LD_VAR 0 2
3306: PPUSH
3307: LD_INT 1
3309: PPUSH
3310: LD_VAR 0 2
3314: PPUSH
3315: LD_INT 1
3317: PPUSH
3318: CALL_OW 259
3322: PUSH
3323: LD_INT 2
3325: PLUS
3326: PPUSH
3327: CALL_OW 237
// end ;
3331: GO 3299
3333: POP
3334: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_engineer ] ] ) do
3335: LD_ADDR_VAR 0 2
3339: PUSH
3340: LD_INT 22
3342: PUSH
3343: LD_EXP 2
3347: PUSH
3348: EMPTY
3349: LIST
3350: LIST
3351: PUSH
3352: LD_INT 25
3354: PUSH
3355: LD_INT 2
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: PPUSH
3366: CALL_OW 69
3370: PUSH
3371: FOR_IN
3372: IFFALSE 3405
// begin SetSkill ( t1 , skill_engineering , GetSkill ( t1 , skill_engineering ) + 2 ) ;
3374: LD_VAR 0 2
3378: PPUSH
3379: LD_INT 2
3381: PPUSH
3382: LD_VAR 0 2
3386: PPUSH
3387: LD_INT 2
3389: PPUSH
3390: CALL_OW 259
3394: PUSH
3395: LD_INT 2
3397: PLUS
3398: PPUSH
3399: CALL_OW 237
// end ;
3403: GO 3371
3405: POP
3406: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_mechanic ] ] ) do
3407: LD_ADDR_VAR 0 2
3411: PUSH
3412: LD_INT 22
3414: PUSH
3415: LD_EXP 2
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: PUSH
3424: LD_INT 25
3426: PUSH
3427: LD_INT 3
3429: PUSH
3430: EMPTY
3431: LIST
3432: LIST
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: PPUSH
3438: CALL_OW 69
3442: PUSH
3443: FOR_IN
3444: IFFALSE 3477
// begin SetSkill ( t1 , skill_mechanical , GetSkill ( t1 , skill_mechanical ) + 2 ) ;
3446: LD_VAR 0 2
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_VAR 0 2
3458: PPUSH
3459: LD_INT 3
3461: PPUSH
3462: CALL_OW 259
3466: PUSH
3467: LD_INT 2
3469: PLUS
3470: PPUSH
3471: CALL_OW 237
// end ;
3475: GO 3443
3477: POP
3478: POP
// for t1 in FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) do
3479: LD_ADDR_VAR 0 2
3483: PUSH
3484: LD_INT 22
3486: PUSH
3487: LD_EXP 2
3491: PUSH
3492: EMPTY
3493: LIST
3494: LIST
3495: PUSH
3496: LD_INT 25
3498: PUSH
3499: LD_INT 4
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: PUSH
3506: EMPTY
3507: LIST
3508: LIST
3509: PPUSH
3510: CALL_OW 69
3514: PUSH
3515: FOR_IN
3516: IFFALSE 3549
// begin SetSkill ( t1 , skill_scientistic , GetSkill ( t1 , skill_scientistic ) + 2 ) ;
3518: LD_VAR 0 2
3522: PPUSH
3523: LD_INT 4
3525: PPUSH
3526: LD_VAR 0 2
3530: PPUSH
3531: LD_INT 4
3533: PPUSH
3534: CALL_OW 259
3538: PUSH
3539: LD_INT 2
3541: PLUS
3542: PPUSH
3543: CALL_OW 237
// end ;
3547: GO 3515
3549: POP
3550: POP
// end ; end ;
3551: GO 3554
3553: POP
// end ;
3554: LD_VAR 0 1
3558: RET
// every 50 50$0 do var bases , i , mat ;
3559: GO 3561
3561: DISABLE
3562: LD_INT 0
3564: PPUSH
3565: PPUSH
3566: PPUSH
// begin if count_crates < MaterialNavic then
3567: CALL 26178 0 0
3571: PUSH
3572: LD_EXP 51
3576: LESS
3577: IFFALSE 3591
// begin disable ( 0 ) ;
3579: LD_INT 0
3581: DISABLE_MARKED
// YouLost ( matmin ) ;
3582: LD_STRING matmin
3584: PPUSH
3585: CALL_OW 104
// end else
3589: GO 3666
// begin disable ( 0 ) ;
3591: LD_INT 0
3593: DISABLE_MARKED
// SetMedals ;
3594: CALL 4153 0 0
// GiveMedals ( Main ) ;
3598: LD_STRING Main
3600: PPUSH
3601: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_ok ] , [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3605: LD_INT 50
3607: PUSH
3608: EMPTY
3609: LIST
3610: PUSH
3611: LD_INT 22
3613: PUSH
3614: LD_EXP 1
3618: PUSH
3619: EMPTY
3620: LIST
3621: LIST
3622: PUSH
3623: LD_INT 21
3625: PUSH
3626: LD_INT 1
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: PUSH
3633: LD_INT 23
3635: PUSH
3636: LD_INT 1
3638: PUSH
3639: EMPTY
3640: LIST
3641: LIST
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: PPUSH
3649: CALL_OW 69
3653: PPUSH
3654: CALL_OW 43
// Save ;
3658: CALL 3669 0 0
// YouWin ;
3662: CALL_OW 103
// end ; end ;
3666: PPOPN 3
3668: END
// export function Save ; begin
3669: LD_INT 0
3671: PPUSH
// SaveCharacters ( JMM , JMM ) ;
3672: LD_EXP 15
3676: PPUSH
3677: LD_STRING JMM
3679: PPUSH
3680: CALL_OW 38
// SaveCharacters ( Kurt , Kurt ) ;
3684: LD_EXP 43
3688: PPUSH
3689: LD_STRING Kurt
3691: PPUSH
3692: CALL_OW 38
// SaveVariable ( not IsDead ( Kurt ) , KurtLeaves ) ;
3696: LD_EXP 43
3700: PPUSH
3701: CALL_OW 301
3705: NOT
3706: PPUSH
3707: LD_STRING KurtLeaves
3709: PPUSH
3710: CALL_OW 39
// SaveVariable ( KurtTryToEscape and not IsDead ( Kurt ) , KurtEscapes ) ;
3714: LD_EXP 85
3718: IFFALSE 3732
3720: PUSH
3721: LD_EXP 43
3725: PPUSH
3726: CALL_OW 301
3730: NOT
3731: AND
3732: PPUSH
3733: LD_STRING KurtEscapes
3735: PPUSH
3736: CALL_OW 39
// SaveVariable ( remote_tried , RemoteUsed ) ;
3740: LD_EXP 82
3744: PPUSH
3745: LD_STRING RemoteUsed
3747: PPUSH
3748: CALL_OW 39
// SaveVariable ( Researched ( you , tech_RemCont ) , RemoteDeveloped ) ;
3752: LD_EXP 1
3756: PPUSH
3757: LD_INT 15
3759: PPUSH
3760: CALL_OW 325
3764: PPUSH
3765: LD_STRING RemoteDeveloped
3767: PPUSH
3768: CALL_OW 39
// if Lisa then
3772: LD_EXP 21
3776: IFFALSE 3800
// begin SaveCharacters ( Lisa , Lisa ) ;
3778: LD_EXP 21
3782: PPUSH
3783: LD_STRING Lisa
3785: PPUSH
3786: CALL_OW 38
// SaveVariable ( 9 , LisaLoc ) ;
3790: LD_INT 9
3792: PPUSH
3793: LD_STRING LisaLoc
3795: PPUSH
3796: CALL_OW 39
// end ; if Frank then
3800: LD_EXP 20
3804: IFFALSE 3828
// begin SaveCharacters ( Frank , Frank ) ;
3806: LD_EXP 20
3810: PPUSH
3811: LD_STRING Frank
3813: PPUSH
3814: CALL_OW 38
// SaveVariable ( 9 , FrankLoc ) ;
3818: LD_INT 9
3820: PPUSH
3821: LD_STRING FrankLoc
3823: PPUSH
3824: CALL_OW 39
// end ; if Donaldson then
3828: LD_EXP 24
3832: IFFALSE 3856
// begin SaveCharacters ( Donaldson , Donaldson ) ;
3834: LD_EXP 24
3838: PPUSH
3839: LD_STRING Donaldson
3841: PPUSH
3842: CALL_OW 38
// SaveVariable ( 9 , DonaldsonLoc ) ;
3846: LD_INT 9
3848: PPUSH
3849: LD_STRING DonaldsonLoc
3851: PPUSH
3852: CALL_OW 39
// end ; if Brown then
3856: LD_EXP 25
3860: IFFALSE 3884
// begin SaveCharacters ( Brown , Brown ) ;
3862: LD_EXP 25
3866: PPUSH
3867: LD_STRING Brown
3869: PPUSH
3870: CALL_OW 38
// SaveVariable ( 9 , BrownLoc ) ;
3874: LD_INT 9
3876: PPUSH
3877: LD_STRING BrownLoc
3879: PPUSH
3880: CALL_OW 39
// end ; if Gladstone then
3884: LD_EXP 27
3888: IFFALSE 3912
// begin SaveCharacters ( Gladstone , Gladstone ) ;
3890: LD_EXP 27
3894: PPUSH
3895: LD_STRING Gladstone
3897: PPUSH
3898: CALL_OW 38
// SaveVariable ( 9 , GladstoneLoc ) ;
3902: LD_INT 9
3904: PPUSH
3905: LD_STRING GladstoneLoc
3907: PPUSH
3908: CALL_OW 39
// end ; SaveCharacters ( Joan , Joan ) ;
3912: LD_EXP 33
3916: PPUSH
3917: LD_STRING Joan
3919: PPUSH
3920: CALL_OW 38
// SaveVariable ( 9 , JoanLoc ) ;
3924: LD_INT 9
3926: PPUSH
3927: LD_STRING JoanLoc
3929: PPUSH
3930: CALL_OW 39
// if Denis then
3934: LD_EXP 26
3938: IFFALSE 3962
// begin SaveCharacters ( Denis , Denis ) ;
3940: LD_EXP 26
3944: PPUSH
3945: LD_STRING Denis
3947: PPUSH
3948: CALL_OW 38
// SaveVariable ( 9 , DenisLoc ) ;
3952: LD_INT 9
3954: PPUSH
3955: LD_STRING DenisLoc
3957: PPUSH
3958: CALL_OW 39
// end ; if Bobby then
3962: LD_EXP 23
3966: IFFALSE 3990
// begin SaveCharacters ( Bobby , Bobby ) ;
3968: LD_EXP 23
3972: PPUSH
3973: LD_STRING Bobby
3975: PPUSH
3976: CALL_OW 38
// SaveVariable ( 9 , BobbyLoc ) ;
3980: LD_INT 9
3982: PPUSH
3983: LD_STRING BobbyLoc
3985: PPUSH
3986: CALL_OW 39
// end ; if Cyrus then
3990: LD_EXP 22
3994: IFFALSE 4018
// begin SaveCharacters ( Cyrus , Cyrus ) ;
3996: LD_EXP 22
4000: PPUSH
4001: LD_STRING Cyrus
4003: PPUSH
4004: CALL_OW 38
// SaveVariable ( 9 , CyrusLoc ) ;
4008: LD_INT 9
4010: PPUSH
4011: LD_STRING CyrusLoc
4013: PPUSH
4014: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Donaldson , Brown , Gladstone , Joan , Denis , Bobby , Cyrus , 0 ] , OtherUnplaced ) ;
4018: LD_INT 22
4020: PUSH
4021: LD_EXP 1
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: PUSH
4030: LD_INT 21
4032: PUSH
4033: LD_INT 1
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 23
4042: PUSH
4043: LD_INT 1
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PPUSH
4055: CALL_OW 69
4059: PUSH
4060: LD_EXP 15
4064: PUSH
4065: LD_EXP 21
4069: PUSH
4070: LD_EXP 20
4074: PUSH
4075: LD_EXP 24
4079: PUSH
4080: LD_EXP 25
4084: PUSH
4085: LD_EXP 27
4089: PUSH
4090: LD_EXP 33
4094: PUSH
4095: LD_EXP 26
4099: PUSH
4100: LD_EXP 23
4104: PUSH
4105: LD_EXP 22
4109: PUSH
4110: LD_INT 0
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: LIST
4120: LIST
4121: LIST
4122: LIST
4123: LIST
4124: LIST
4125: DIFF
4126: PPUSH
4127: LD_STRING OtherUnplaced
4129: PPUSH
4130: CALL_OW 38
// DeleteCharacters ( opicaci ) ;
4134: LD_STRING opicaci
4136: PPUSH
4137: CALL_OW 40
// DeleteCharacters ( other_from5to6 ) ;
4141: LD_STRING other_from5to6
4143: PPUSH
4144: CALL_OW 40
// end ;
4148: LD_VAR 0 1
4152: RET
// export function SetMedals ; var medal1 , medal2 , medal3 ; begin
4153: LD_INT 0
4155: PPUSH
4156: PPUSH
4157: PPUSH
4158: PPUSH
// medal1 := false ;
4159: LD_ADDR_VAR 0 2
4163: PUSH
4164: LD_INT 0
4166: ST_TO_ADDR
// medal2 := false ;
4167: LD_ADDR_VAR 0 3
4171: PUSH
4172: LD_INT 0
4174: ST_TO_ADDR
// medal3 := false ;
4175: LD_ADDR_VAR 0 4
4179: PUSH
4180: LD_INT 0
4182: ST_TO_ADDR
// AddMedal ( cans , count_crates >= ( MaterialNavic + 100 ) ) ;
4183: LD_STRING cans
4185: PPUSH
4186: CALL 26178 0 0
4190: PUSH
4191: LD_EXP 51
4195: PUSH
4196: LD_INT 100
4198: PLUS
4199: GREATEREQUAL
4200: PPUSH
4201: CALL_OW 101
// medal1 := count_crates >= ( MaterialNavic + 100 ) ;
4205: LD_ADDR_VAR 0 2
4209: PUSH
4210: CALL 26178 0 0
4214: PUSH
4215: LD_EXP 51
4219: PUSH
4220: LD_INT 100
4222: PLUS
4223: GREATEREQUAL
4224: ST_TO_ADDR
// SA_CratesGathered ( count_crates ) ;
4225: CALL 26178 0 0
4229: PPUSH
4230: CALL 27276 0 1
// if count_crates >= 1000 then
4234: CALL 26178 0 0
4238: PUSH
4239: LD_INT 1000
4241: GREATEREQUAL
4242: IFFALSE 4248
// SA_On1000CratesGathered ;
4244: CALL 27261 0 0
// NavicLidi := UnitFilter ( NavicLidi , [ f_ok ] ) ;
4248: LD_ADDR_EXP 84
4252: PUSH
4253: LD_EXP 84
4257: PPUSH
4258: LD_INT 50
4260: PUSH
4261: EMPTY
4262: LIST
4263: PPUSH
4264: CALL_OW 72
4268: ST_TO_ADDR
// AddMedal ( people , NavicLidi >= 3 ) ;
4269: LD_STRING people
4271: PPUSH
4272: LD_EXP 84
4276: PUSH
4277: LD_INT 3
4279: GREATEREQUAL
4280: PPUSH
4281: CALL_OW 101
// medal2 := NavicLidi >= 3 ;
4285: LD_ADDR_VAR 0 3
4289: PUSH
4290: LD_EXP 84
4294: PUSH
4295: LD_INT 3
4297: GREATEREQUAL
4298: ST_TO_ADDR
// if noBodyLeft then
4299: LD_EXP 86
4303: IFFALSE 4309
// SA_NoBodyLeft ;
4305: CALL 27296 0 0
// if remote_tried then
4309: LD_EXP 82
4313: IFFALSE 4335
// begin AddMedal ( remote , 1 ) ;
4315: LD_STRING remote
4317: PPUSH
4318: LD_INT 1
4320: PPUSH
4321: CALL_OW 101
// medal3 := true ;
4325: LD_ADDR_VAR 0 4
4329: PUSH
4330: LD_INT 1
4332: ST_TO_ADDR
// end else
4333: GO 4377
// begin if GetTech ( tech_RemCont , you ) = state_researched then
4335: LD_INT 15
4337: PPUSH
4338: LD_EXP 1
4342: PPUSH
4343: CALL_OW 321
4347: PUSH
4348: LD_INT 2
4350: EQUAL
4351: IFFALSE 4366
// AddMedal ( remote , - 2 ) else
4353: LD_STRING remote
4355: PPUSH
4356: LD_INT 2
4358: NEG
4359: PPUSH
4360: CALL_OW 101
4364: GO 4377
// AddMedal ( remote , - 1 ) ;
4366: LD_STRING remote
4368: PPUSH
4369: LD_INT 1
4371: NEG
4372: PPUSH
4373: CALL_OW 101
// end ; SA_EndMission ( 1 , 6 , medal1 , medal2 , medal3 ) ;
4377: LD_INT 1
4379: PPUSH
4380: LD_INT 6
4382: PPUSH
4383: LD_VAR 0 2
4387: PPUSH
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_VAR 0 4
4397: PPUSH
4398: CALL 27326 0 5
// end ;
4402: LD_VAR 0 1
4406: RET
// final begin end ; end_of_file
4407: END
// export mytick ; export function Dialog1 ; var Sci , i ; begin
4408: LD_INT 0
4410: PPUSH
4411: PPUSH
4412: PPUSH
// used := all ^ [ JMM ] ;
4413: LD_ADDR_EXP 12
4417: PUSH
4418: LD_EXP 9
4422: PUSH
4423: LD_EXP 15
4427: PUSH
4428: EMPTY
4429: LIST
4430: ADD
4431: ST_TO_ADDR
// if Lisa in used then
4432: LD_EXP 21
4436: PUSH
4437: LD_EXP 12
4441: IN
4442: IFFALSE 4452
// Lisa_P := true ;
4444: LD_ADDR_EXP 49
4448: PUSH
4449: LD_INT 1
4451: ST_TO_ADDR
// if Frank in used then
4452: LD_EXP 20
4456: PUSH
4457: LD_EXP 12
4461: IN
4462: IFFALSE 4472
// Frank_P := true ;
4464: LD_ADDR_EXP 50
4468: PUSH
4469: LD_INT 1
4471: ST_TO_ADDR
// opicaci := Delete ( opicaci , 3 ) ;
4472: LD_ADDR_EXP 13
4476: PUSH
4477: LD_EXP 13
4481: PPUSH
4482: LD_INT 3
4484: PPUSH
4485: CALL_OW 3
4489: ST_TO_ADDR
// used := used ^ opicaci ;
4490: LD_ADDR_EXP 12
4494: PUSH
4495: LD_EXP 12
4499: PUSH
4500: LD_EXP 13
4504: ADD
4505: ST_TO_ADDR
// used := used union zgamy2 ;
4506: LD_ADDR_EXP 12
4510: PUSH
4511: LD_EXP 12
4515: PUSH
4516: LD_EXP 14
4520: UNION
4521: ST_TO_ADDR
// not_char := used diff [ JMM , Lisa , Frank ] ;
4522: LD_ADDR_EXP 11
4526: PUSH
4527: LD_EXP 12
4531: PUSH
4532: LD_EXP 15
4536: PUSH
4537: LD_EXP 21
4541: PUSH
4542: LD_EXP 20
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: LIST
4551: DIFF
4552: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Gladstone , Denis , Brown , Donaldson ] ;
4553: LD_ADDR_EXP 11
4557: PUSH
4558: LD_EXP 11
4562: PUSH
4563: LD_EXP 22
4567: PUSH
4568: LD_EXP 23
4572: PUSH
4573: LD_EXP 27
4577: PUSH
4578: LD_EXP 26
4582: PUSH
4583: LD_EXP 25
4587: PUSH
4588: LD_EXP 24
4592: PUSH
4593: EMPTY
4594: LIST
4595: LIST
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: DIFF
4601: ST_TO_ADDR
// if Brown in used then
4602: LD_EXP 25
4606: PUSH
4607: LD_EXP 12
4611: IN
4612: IFFALSE 4633
// not_char := not_char ^ [ Brown ] ;
4614: LD_ADDR_EXP 11
4618: PUSH
4619: LD_EXP 11
4623: PUSH
4624: LD_EXP 25
4628: PUSH
4629: EMPTY
4630: LIST
4631: ADD
4632: ST_TO_ADDR
// if Donaldson in used then
4633: LD_EXP 24
4637: PUSH
4638: LD_EXP 12
4642: IN
4643: IFFALSE 4664
// not_char := not_char ^ [ Donaldson ] ;
4645: LD_ADDR_EXP 11
4649: PUSH
4650: LD_EXP 11
4654: PUSH
4655: LD_EXP 24
4659: PUSH
4660: EMPTY
4661: LIST
4662: ADD
4663: ST_TO_ADDR
// if Cyrus in used then
4664: LD_EXP 22
4668: PUSH
4669: LD_EXP 12
4673: IN
4674: IFFALSE 4695
// not_char := not_char ^ [ Cyrus ] ;
4676: LD_ADDR_EXP 11
4680: PUSH
4681: LD_EXP 11
4685: PUSH
4686: LD_EXP 22
4690: PUSH
4691: EMPTY
4692: LIST
4693: ADD
4694: ST_TO_ADDR
// if Bobby in used then
4695: LD_EXP 23
4699: PUSH
4700: LD_EXP 12
4704: IN
4705: IFFALSE 4726
// not_char := not_char ^ [ Bobby ] ;
4707: LD_ADDR_EXP 11
4711: PUSH
4712: LD_EXP 11
4716: PUSH
4717: LD_EXP 23
4721: PUSH
4722: EMPTY
4723: LIST
4724: ADD
4725: ST_TO_ADDR
// if Gladstone in used then
4726: LD_EXP 27
4730: PUSH
4731: LD_EXP 12
4735: IN
4736: IFFALSE 4757
// not_char := not_char ^ [ Gladstone ] ;
4738: LD_ADDR_EXP 11
4742: PUSH
4743: LD_EXP 11
4747: PUSH
4748: LD_EXP 27
4752: PUSH
4753: EMPTY
4754: LIST
4755: ADD
4756: ST_TO_ADDR
// if Denis in used then
4757: LD_EXP 26
4761: PUSH
4762: LD_EXP 12
4766: IN
4767: IFFALSE 4788
// not_char := not_char ^ [ Denis ] ;
4769: LD_ADDR_EXP 11
4773: PUSH
4774: LD_EXP 11
4778: PUSH
4779: LD_EXP 26
4783: PUSH
4784: EMPTY
4785: LIST
4786: ADD
4787: ST_TO_ADDR
// SaveForQuickRestart ;
4788: CALL_OW 22
// Wait ( 0 0$1.0 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
4799: LD_STRING M1
4801: PPUSH
4802: CALL_OW 337
// case difficulty of 1 :
4806: LD_OWVAR 67
4810: PUSH
4811: LD_INT 1
4813: DOUBLE
4814: EQUAL
4815: IFTRUE 4819
4817: GO 4829
4819: POP
// ChangeMissionObjectives ( M1-1 ) ; 2 :
4820: LD_STRING M1-1
4822: PPUSH
4823: CALL_OW 337
4827: GO 4866
4829: LD_INT 2
4831: DOUBLE
4832: EQUAL
4833: IFTRUE 4837
4835: GO 4847
4837: POP
// ChangeMissionObjectives ( M1-2 ) ; 3 :
4838: LD_STRING M1-2
4840: PPUSH
4841: CALL_OW 337
4845: GO 4866
4847: LD_INT 3
4849: DOUBLE
4850: EQUAL
4851: IFTRUE 4855
4853: GO 4865
4855: POP
// ChangeMissionObjectives ( M1-3 ) ; end ;
4856: LD_STRING M1-3
4858: PPUSH
4859: CALL_OW 337
4863: GO 4866
4865: POP
// ChangeMissionObjectives ( M1cont ) ;
4866: LD_STRING M1cont
4868: PPUSH
4869: CALL_OW 337
// PlaceHumanInUnit ( zgamy2 [ 1 ] , Car1 ) ;
4873: LD_EXP 14
4877: PUSH
4878: LD_INT 1
4880: ARRAY
4881: PPUSH
4882: LD_EXP 44
4886: PPUSH
4887: CALL_OW 52
// PlaceHumanInUnit ( zgamy2 [ 2 ] , Car2 ) ;
4891: LD_EXP 14
4895: PUSH
4896: LD_INT 2
4898: ARRAY
4899: PPUSH
4900: LD_EXP 45
4904: PPUSH
4905: CALL_OW 52
// PlaceUnitXYR ( Car1 , 13 , 3 , 8 , false ) ;
4909: LD_EXP 44
4913: PPUSH
4914: LD_INT 13
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 8
4922: PPUSH
4923: LD_INT 0
4925: PPUSH
4926: CALL_OW 50
// PlaceUnitXYR ( Car2 , 13 , 3 , 8 , false ) ;
4930: LD_EXP 45
4934: PPUSH
4935: LD_INT 13
4937: PPUSH
4938: LD_INT 3
4940: PPUSH
4941: LD_INT 8
4943: PPUSH
4944: LD_INT 0
4946: PPUSH
4947: CALL_OW 50
// for i := 1 to used diff ( zgamy2 ^ [ Car1 , Car2 ] ) do
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: DOUBLE
4957: LD_INT 1
4959: DEC
4960: ST_TO_ADDR
4961: LD_EXP 12
4965: PUSH
4966: LD_EXP 14
4970: PUSH
4971: LD_EXP 44
4975: PUSH
4976: LD_EXP 45
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: ADD
4985: DIFF
4986: PUSH
4987: FOR_TO
4988: IFFALSE 5019
// PlaceUnitXYR ( used [ i ] , 70 , 3 , 8 , false ) ;
4990: LD_EXP 12
4994: PUSH
4995: LD_VAR 0 3
4999: ARRAY
5000: PPUSH
5001: LD_INT 70
5003: PPUSH
5004: LD_INT 3
5006: PPUSH
5007: LD_INT 8
5009: PPUSH
5010: LD_INT 0
5012: PPUSH
5013: CALL_OW 50
5017: GO 4987
5019: POP
5020: POP
// mytick := tick ;
5021: LD_ADDR_EXP 87
5025: PUSH
5026: LD_OWVAR 1
5030: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
5031: LD_EXP 15
5035: PPUSH
5036: CALL_OW 87
// Wait ( 0 0$3 ) ;
5040: LD_INT 105
5042: PPUSH
5043: CALL_OW 67
// talkOn ;
5047: CALL 17268 0 0
// Say ( zgamy2 [ 2 ] , DEng-Eng1-1 ) ;
5051: LD_EXP 14
5055: PUSH
5056: LD_INT 2
5058: ARRAY
5059: PPUSH
5060: LD_STRING DEng-Eng1-1
5062: PPUSH
5063: CALL_OW 88
// talkOff ;
5067: CALL 17284 0 0
// CenterOnUnits ( Car1 ) ;
5071: LD_EXP 44
5075: PPUSH
5076: CALL_OW 85
// InGameOff ;
5080: CALL_OW 9
// start_game := true ;
5084: LD_ADDR_EXP 55
5088: PUSH
5089: LD_INT 1
5091: ST_TO_ADDR
// end ;
5092: LD_VAR 0 1
5096: RET
// every 1 1$20 do
5097: GO 5099
5099: DISABLE
// begin DialogueOn ;
5100: CALL_OW 6
// SayRadio ( Har , DRem-Har-1 ) ;
5104: LD_EXP 16
5108: PPUSH
5109: LD_STRING DRem-Har-1
5111: PPUSH
5112: CALL_OW 94
// if attacky then
5116: LD_EXP 60
5120: IFFALSE 5136
// Say ( JMM , DRem-JMM-1 ) else
5122: LD_EXP 15
5126: PPUSH
5127: LD_STRING DRem-JMM-1
5129: PPUSH
5130: CALL_OW 88
5134: GO 5148
// Say ( JMM , DRem-JMM-1a ) ;
5136: LD_EXP 15
5140: PPUSH
5141: LD_STRING DRem-JMM-1a
5143: PPUSH
5144: CALL_OW 88
// SayRadio ( Har , DRem-Har-2 ) ;
5148: LD_EXP 16
5152: PPUSH
5153: LD_STRING DRem-Har-2
5155: PPUSH
5156: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5160: LD_STRING Denis
5162: PPUSH
5163: CALL_OW 29
5167: IFFALSE 5183
// Say ( JMM , DRem-JMM-2 ) else
5169: LD_EXP 15
5173: PPUSH
5174: LD_STRING DRem-JMM-2
5176: PPUSH
5177: CALL_OW 88
5181: GO 5195
// Say ( JMM , DRem-JMM-2a ) ;
5183: LD_EXP 15
5187: PPUSH
5188: LD_STRING DRem-JMM-2a
5190: PPUSH
5191: CALL_OW 88
// SayRadio ( Har , DRem-Har-3 ) ;
5195: LD_EXP 16
5199: PPUSH
5200: LD_STRING DRem-Har-3
5202: PPUSH
5203: CALL_OW 94
// Say ( JMM , DRem-JMM-3 ) ;
5207: LD_EXP 15
5211: PPUSH
5212: LD_STRING DRem-JMM-3
5214: PPUSH
5215: CALL_OW 88
// SayRadio ( Har , DRem-Har-4 ) ;
5219: LD_EXP 16
5223: PPUSH
5224: LD_STRING DRem-Har-4
5226: PPUSH
5227: CALL_OW 94
// if CheckCharacterSet ( Denis ) then
5231: LD_STRING Denis
5233: PPUSH
5234: CALL_OW 29
5238: IFFALSE 5264
// begin Say ( JMM , DRem-JMM-4 ) ;
5240: LD_EXP 15
5244: PPUSH
5245: LD_STRING DRem-JMM-4
5247: PPUSH
5248: CALL_OW 88
// SayRadio ( Har , DRem-Har-5 ) ;
5252: LD_EXP 16
5256: PPUSH
5257: LD_STRING DRem-Har-5
5259: PPUSH
5260: CALL_OW 94
// end ; DialogueOff ;
5264: CALL_OW 7
// ChangeMissionObjectives ( MR ) ;
5268: LD_STRING MR
5270: PPUSH
5271: CALL_OW 337
// if CheckCharacterSet ( Denis ) then
5275: LD_STRING Denis
5277: PPUSH
5278: CALL_OW 29
5282: IFFALSE 5330
// begin InitUc ;
5284: CALL_OW 18
// InitHc ;
5288: CALL_OW 19
// uc_side := you2 ;
5292: LD_ADDR_OWVAR 20
5296: PUSH
5297: LD_EXP 4
5301: ST_TO_ADDR
// uc_nation := nation_american ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 1
5309: ST_TO_ADDR
// Denis := CreateCharacterWithClass ( Denis , class_scientistic ) ;
5310: LD_ADDR_EXP 26
5314: PUSH
5315: LD_STRING Denis
5317: PPUSH
5318: LD_INT 4
5320: PPUSH
5321: CALL_OW 35
5325: ST_TO_ADDR
// DialogDenis ;
5326: CALL 5331 0 0
// end ; end ;
5330: END
// function DialogDenis ; var depot , nekdo , mytick ; begin
5331: LD_INT 0
5333: PPUSH
5334: PPUSH
5335: PPUSH
5336: PPUSH
// wait ( 9 9$0 ) ;
5337: LD_INT 18900
5339: PPUSH
5340: CALL_OW 67
// depot := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5344: LD_ADDR_VAR 0 2
5348: PUSH
5349: LD_INT 22
5351: PUSH
5352: LD_EXP 1
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: PUSH
5361: LD_INT 2
5363: PUSH
5364: LD_INT 30
5366: PUSH
5367: LD_INT 0
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: PUSH
5374: LD_INT 30
5376: PUSH
5377: LD_INT 1
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: PPUSH
5393: CALL_OW 69
5397: ST_TO_ADDR
// if depot then
5398: LD_VAR 0 2
5402: IFFALSE 5418
// depot := depot [ 1 ] ;
5404: LD_ADDR_VAR 0 2
5408: PUSH
5409: LD_VAR 0 2
5413: PUSH
5414: LD_INT 1
5416: ARRAY
5417: ST_TO_ADDR
// mytick := tick + 0 0$15 ;
5418: LD_ADDR_VAR 0 4
5422: PUSH
5423: LD_OWVAR 1
5427: PUSH
5428: LD_INT 525
5430: PLUS
5431: ST_TO_ADDR
// PlaceUnitArea ( Denis , denis_come , false ) ;
5432: LD_EXP 26
5436: PPUSH
5437: LD_INT 9
5439: PPUSH
5440: LD_INT 0
5442: PPUSH
5443: CALL_OW 49
// case true of GetDistUnits ( Denis , JMM ) < 20 :
5447: LD_INT 1
5449: PUSH
5450: LD_EXP 26
5454: PPUSH
5455: LD_EXP 15
5459: PPUSH
5460: CALL_OW 296
5464: PUSH
5465: LD_INT 20
5467: LESS
5468: DOUBLE
5469: EQUAL
5470: IFTRUE 5474
5472: GO 5547
5474: POP
// begin ComMoveUnit ( Denis , JMM ) ;
5475: LD_EXP 26
5479: PPUSH
5480: LD_EXP 15
5484: PPUSH
5485: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and tick < mytick do
5489: LD_EXP 26
5493: PPUSH
5494: LD_VAR 0 2
5498: PPUSH
5499: CALL_OW 296
5503: PUSH
5504: LD_INT 5
5506: GREATER
5507: IFFALSE 5520
5509: PUSH
5510: LD_EXP 26
5514: PPUSH
5515: CALL_OW 302
5519: AND
5520: IFFALSE 5534
5522: PUSH
5523: LD_OWVAR 1
5527: PUSH
5528: LD_VAR 0 4
5532: LESS
5533: AND
5534: IFFALSE 5545
// begin wait ( 0 0$1 ) ;
5536: LD_INT 35
5538: PPUSH
5539: CALL_OW 67
// end ;
5543: GO 5489
// end ; GetDistUnits ( Denis , depot ) < 20 :
5545: GO 5774
5547: LD_EXP 26
5551: PPUSH
5552: LD_VAR 0 2
5556: PPUSH
5557: CALL_OW 296
5561: PUSH
5562: LD_INT 20
5564: LESS
5565: DOUBLE
5566: EQUAL
5567: IFTRUE 5571
5569: GO 5657
5571: POP
// begin ComMoveUnit ( Denis , depot ) ;
5572: LD_EXP 26
5576: PPUSH
5577: LD_VAR 0 2
5581: PPUSH
5582: CALL_OW 112
// while GetDistUnits ( Denis , depot ) > 5 and IsOk ( denis ) and IsOk ( depot ) and tick < mytick do
5586: LD_EXP 26
5590: PPUSH
5591: LD_VAR 0 2
5595: PPUSH
5596: CALL_OW 296
5600: PUSH
5601: LD_INT 5
5603: GREATER
5604: IFFALSE 5617
5606: PUSH
5607: LD_EXP 26
5611: PPUSH
5612: CALL_OW 302
5616: AND
5617: IFFALSE 5630
5619: PUSH
5620: LD_VAR 0 2
5624: PPUSH
5625: CALL_OW 302
5629: AND
5630: IFFALSE 5644
5632: PUSH
5633: LD_OWVAR 1
5637: PUSH
5638: LD_VAR 0 4
5642: LESS
5643: AND
5644: IFFALSE 5655
// begin wait ( 0 0$1 ) ;
5646: LD_INT 35
5648: PPUSH
5649: CALL_OW 67
// end ;
5653: GO 5586
// end ; else
5655: GO 5774
5657: POP
// begin nekdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) , denis ) ;
5658: LD_ADDR_VAR 0 3
5662: PUSH
5663: LD_INT 22
5665: PUSH
5666: LD_EXP 1
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 21
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: CALL_OW 69
5693: PPUSH
5694: LD_EXP 26
5698: PPUSH
5699: CALL_OW 74
5703: ST_TO_ADDR
// ComMoveUnit ( Denis , nekdo ) ;
5704: LD_EXP 26
5708: PPUSH
5709: LD_VAR 0 3
5713: PPUSH
5714: CALL_OW 112
// while GetDistUnits ( Denis , nekdo ) > 5 and IsOK ( nekdo ) and tick < mytick do
5718: LD_EXP 26
5722: PPUSH
5723: LD_VAR 0 3
5727: PPUSH
5728: CALL_OW 296
5732: PUSH
5733: LD_INT 5
5735: GREATER
5736: IFFALSE 5749
5738: PUSH
5739: LD_VAR 0 3
5743: PPUSH
5744: CALL_OW 302
5748: AND
5749: IFFALSE 5763
5751: PUSH
5752: LD_OWVAR 1
5756: PUSH
5757: LD_VAR 0 4
5761: LESS
5762: AND
5763: IFFALSE 5774
// begin wait ( 0 0$1 ) ;
5765: LD_INT 35
5767: PPUSH
5768: CALL_OW 67
// end ;
5772: GO 5718
// end ; end ; ComStop ( Denis ) ;
5774: LD_EXP 26
5778: PPUSH
5779: CALL_OW 141
// SetSide ( Denis , you ) ;
5783: LD_EXP 26
5787: PPUSH
5788: LD_EXP 1
5792: PPUSH
5793: CALL_OW 235
// if IsLive ( Denis ) then
5797: LD_EXP 26
5801: PPUSH
5802: CALL_OW 300
5806: IFFALSE 5900
// begin enable ( 33 ) ;
5808: LD_INT 33
5810: ENABLE_MARKED
// DialogueOn ;
5811: CALL_OW 6
// CenterOnUnits ( Denis ) ;
5815: LD_EXP 26
5819: PPUSH
5820: CALL_OW 85
// Say ( Denis , DDen-Den-1 ) ;
5824: LD_EXP 26
5828: PPUSH
5829: LD_STRING DDen-Den-1
5831: PPUSH
5832: CALL_OW 88
// Say ( JMM , DDen-JMM-1 ) ;
5836: LD_EXP 15
5840: PPUSH
5841: LD_STRING DDen-JMM-1
5843: PPUSH
5844: CALL_OW 88
// Say ( Denis , DDen-Den-2 ) ;
5848: LD_EXP 26
5852: PPUSH
5853: LD_STRING DDen-Den-2
5855: PPUSH
5856: CALL_OW 88
// Say ( JMM , DDen-JMM-2 ) ;
5860: LD_EXP 15
5864: PPUSH
5865: LD_STRING DDen-JMM-2
5867: PPUSH
5868: CALL_OW 88
// Say ( Denis , DDen-Den-3 ) ;
5872: LD_EXP 26
5876: PPUSH
5877: LD_STRING DDen-Den-3
5879: PPUSH
5880: CALL_OW 88
// Say ( JMM , DDen-JMM-3 ) ;
5884: LD_EXP 15
5888: PPUSH
5889: LD_STRING DDen-JMM-3
5891: PPUSH
5892: CALL_OW 88
// DialogueOff ;
5896: CALL_OW 7
// end ; end ;
5900: LD_VAR 0 1
5904: RET
// export was_dialogR0 ; export function DialogR0 ; var kdo1 , kdo2 , r ; begin
5905: LD_INT 0
5907: PPUSH
5908: PPUSH
5909: PPUSH
5910: PPUSH
// if not was_dialogR0 then
5911: LD_EXP 88
5915: NOT
5916: IFFALSE 6228
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
5918: LD_ADDR_VAR 0 2
5922: PUSH
5923: LD_EXP 11
5927: PPUSH
5928: LD_EXP 1
5932: PPUSH
5933: LD_INT 1
5935: PPUSH
5936: LD_INT 0
5938: PPUSH
5939: LD_INT 1
5941: PPUSH
5942: CALL 17380 0 5
5946: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
5947: LD_ADDR_VAR 0 3
5951: PUSH
5952: LD_EXP 11
5956: PPUSH
5957: LD_EXP 1
5961: PPUSH
5962: LD_INT 1
5964: PPUSH
5965: LD_INT 0
5967: PPUSH
5968: LD_INT 2
5970: PPUSH
5971: CALL 17380 0 5
5975: ST_TO_ADDR
// if not kdo1 then
5976: LD_VAR 0 2
5980: NOT
5981: IFFALSE 6033
// kdo1 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 1 ) ;
5983: LD_ADDR_VAR 0 2
5987: PUSH
5988: CALL 13620 0 0
5992: PUSH
5993: LD_EXP 15
5997: PUSH
5998: LD_EXP 22
6002: PUSH
6003: LD_EXP 26
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: LIST
6012: DIFF
6013: PPUSH
6014: LD_EXP 1
6018: PPUSH
6019: LD_INT 1
6021: PPUSH
6022: LD_INT 0
6024: PPUSH
6025: LD_INT 1
6027: PPUSH
6028: CALL 17380 0 5
6032: ST_TO_ADDR
// if not kdo2 then
6033: LD_VAR 0 3
6037: NOT
6038: IFFALSE 6090
// kdo2 := WhoSayAny ( TvojiLidi diff [ JMM , Cyrus , Denis ] , you , sex_male , 0 , 2 ) ;
6040: LD_ADDR_VAR 0 3
6044: PUSH
6045: CALL 13620 0 0
6049: PUSH
6050: LD_EXP 15
6054: PUSH
6055: LD_EXP 22
6059: PUSH
6060: LD_EXP 26
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: LIST
6069: DIFF
6070: PPUSH
6071: LD_EXP 1
6075: PPUSH
6076: LD_INT 1
6078: PPUSH
6079: LD_INT 0
6081: PPUSH
6082: LD_INT 2
6084: PPUSH
6085: CALL 17380 0 5
6089: ST_TO_ADDR
// TalkOn ;
6090: CALL 17268 0 0
// if IsOK ( Lisa ) then
6094: LD_EXP 21
6098: PPUSH
6099: CALL_OW 302
6103: IFFALSE 6125
// r := Say ( Lisa , DR0-Lisa-1 ) else
6105: LD_ADDR_VAR 0 4
6109: PUSH
6110: LD_EXP 21
6114: PPUSH
6115: LD_STRING DR0-Lisa-1
6117: PPUSH
6118: CALL_OW 88
6122: ST_TO_ADDR
6123: GO 6143
// r := Say ( kdo1 , DR0-Sol1-1 ) ;
6125: LD_ADDR_VAR 0 4
6129: PUSH
6130: LD_VAR 0 2
6134: PPUSH
6135: LD_STRING DR0-Sol1-1
6137: PPUSH
6138: CALL_OW 88
6142: ST_TO_ADDR
// if r then
6143: LD_VAR 0 4
6147: IFFALSE 6198
// if IsOK ( Cyrus ) then
6149: LD_EXP 22
6153: PPUSH
6154: CALL_OW 302
6158: IFFALSE 6180
// r := Say ( Cyrus , DR0-Cyrus-1 ) else
6160: LD_ADDR_VAR 0 4
6164: PUSH
6165: LD_EXP 22
6169: PPUSH
6170: LD_STRING DR0-Cyrus-1
6172: PPUSH
6173: CALL_OW 88
6177: ST_TO_ADDR
6178: GO 6198
// r := Say ( kdo2 , DR0-Sol2-1 ) ;
6180: LD_ADDR_VAR 0 4
6184: PUSH
6185: LD_VAR 0 3
6189: PPUSH
6190: LD_STRING DR0-Sol2-1
6192: PPUSH
6193: CALL_OW 88
6197: ST_TO_ADDR
// if r then
6198: LD_VAR 0 4
6202: IFFALSE 6216
// Say ( JMM , DR0-JMM-1 ) ;
6204: LD_EXP 15
6208: PPUSH
6209: LD_STRING DR0-JMM-1
6211: PPUSH
6212: CALL_OW 88
// TalkOff ;
6216: CALL 17284 0 0
// was_dialogR0 := true ;
6220: LD_ADDR_EXP 88
6224: PUSH
6225: LD_INT 1
6227: ST_TO_ADDR
// end ; end ;
6228: LD_VAR 0 1
6232: RET
// function MajiOpto ; var i ; begin
6233: LD_INT 0
6235: PPUSH
6236: PPUSH
// result := false ;
6237: LD_ADDR_VAR 0 1
6241: PUSH
6242: LD_INT 0
6244: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) do
6245: LD_ADDR_VAR 0 2
6249: PUSH
6250: LD_INT 22
6252: PUSH
6253: LD_EXP 1
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 2
6264: PUSH
6265: LD_INT 30
6267: PUSH
6268: LD_INT 7
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: LD_INT 30
6277: PUSH
6278: LD_INT 8
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: EMPTY
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PPUSH
6294: CALL_OW 69
6298: PUSH
6299: FOR_IN
6300: IFFALSE 6352
// if ( GetLabKind ( i , 1 ) = b_lab_opto ) or ( GetLabKind ( i , 2 ) = b_lab_opto ) then
6302: LD_VAR 0 2
6306: PPUSH
6307: LD_INT 1
6309: PPUSH
6310: CALL_OW 268
6314: PUSH
6315: LD_INT 15
6317: EQUAL
6318: IFTRUE 6338
6320: PUSH
6321: LD_VAR 0 2
6325: PPUSH
6326: LD_INT 2
6328: PPUSH
6329: CALL_OW 268
6333: PUSH
6334: LD_INT 15
6336: EQUAL
6337: OR
6338: IFFALSE 6350
// begin result := true ;
6340: LD_ADDR_VAR 0 1
6344: PUSH
6345: LD_INT 1
6347: ST_TO_ADDR
// break ;
6348: GO 6352
// end ;
6350: GO 6299
6352: POP
6353: POP
// end ;
6354: LD_VAR 0 1
6358: RET
// every 0 0$7 trigger MajiOpto and FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_oil_power ] , [ f_btype , b_solar_power ] ] ] ) marked 33 do
6359: CALL 6233 0 0
6363: IFFALSE 6415
6365: PUSH
6366: LD_INT 22
6368: PUSH
6369: LD_EXP 1
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 2
6380: PUSH
6381: LD_INT 30
6383: PUSH
6384: LD_INT 26
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 30
6393: PUSH
6394: LD_INT 27
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: PPUSH
6410: CALL_OW 69
6414: AND
6415: IFFALSE 6465
6417: GO 6419
6419: DISABLE
// begin if IsOK ( Denis ) then
6420: LD_EXP 26
6424: PPUSH
6425: CALL_OW 302
6429: IFFALSE 6465
// begin DialogueOn ;
6431: CALL_OW 6
// if Say ( Denis , DR1-Den-1 ) then
6435: LD_EXP 26
6439: PPUSH
6440: LD_STRING DR1-Den-1
6442: PPUSH
6443: CALL_OW 88
6447: IFFALSE 6461
// Say ( JMM , DR1-JMM-1 ) ;
6449: LD_EXP 15
6453: PPUSH
6454: LD_STRING DR1-JMM-1
6456: PPUSH
6457: CALL_OW 88
// DialogueOff ;
6461: CALL_OW 7
// end ; end ;
6465: END
// function ScisInLabs ; var labs , i , inlabs ; begin
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
6471: PPUSH
// inlabs := [ ] ;
6472: LD_ADDR_VAR 0 4
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// labs := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
6479: LD_ADDR_VAR 0 2
6483: PUSH
6484: LD_INT 22
6486: PUSH
6487: LD_EXP 1
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: PUSH
6496: LD_INT 2
6498: PUSH
6499: LD_INT 30
6501: PUSH
6502: LD_INT 6
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: PUSH
6509: LD_INT 30
6511: PUSH
6512: LD_INT 7
6514: PUSH
6515: EMPTY
6516: LIST
6517: LIST
6518: PUSH
6519: LD_INT 30
6521: PUSH
6522: LD_INT 8
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PPUSH
6539: CALL_OW 69
6543: ST_TO_ADDR
// for i in labs do
6544: LD_ADDR_VAR 0 3
6548: PUSH
6549: LD_VAR 0 2
6553: PUSH
6554: FOR_IN
6555: IFFALSE 6580
// inlabs := inlabs ^ UnitsInside ( i ) ;
6557: LD_ADDR_VAR 0 4
6561: PUSH
6562: LD_VAR 0 4
6566: PUSH
6567: LD_VAR 0 3
6571: PPUSH
6572: CALL_OW 313
6576: ADD
6577: ST_TO_ADDR
6578: GO 6554
6580: POP
6581: POP
// result := UnitFilter ( inlabs , [ f_class , class_scientistic ] ) ;
6582: LD_ADDR_VAR 0 1
6586: PUSH
6587: LD_VAR 0 4
6591: PPUSH
6592: LD_INT 25
6594: PUSH
6595: LD_INT 4
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: PPUSH
6602: CALL_OW 72
6606: ST_TO_ADDR
// end ;
6607: LD_VAR 0 1
6611: RET
// export function DialogR2 ; var scis , r ; begin
6612: LD_INT 0
6614: PPUSH
6615: PPUSH
6616: PPUSH
// scis := ScisInLabs ;
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: CALL 6466 0 0
6626: ST_TO_ADDR
// if scis isect ( not_char union Denis ) then
6627: LD_VAR 0 2
6631: PUSH
6632: LD_EXP 11
6636: PUSH
6637: LD_EXP 26
6641: UNION
6642: ISECT
6643: IFFALSE 6667
// scis := scis isect ( not_char union Denis ) ;
6645: LD_ADDR_VAR 0 2
6649: PUSH
6650: LD_VAR 0 2
6654: PUSH
6655: LD_EXP 11
6659: PUSH
6660: LD_EXP 26
6664: UNION
6665: ISECT
6666: ST_TO_ADDR
// if scis then
6667: LD_VAR 0 2
6671: IFFALSE 6856
// begin DialogueOn ;
6673: CALL_OW 6
// if not IsDead ( Denis ) and ( Denis in scis ) then
6677: LD_EXP 26
6681: PPUSH
6682: CALL_OW 301
6686: NOT
6687: IFFALSE 6701
6689: PUSH
6690: LD_EXP 26
6694: PUSH
6695: LD_VAR 0 2
6699: IN
6700: AND
6701: IFFALSE 6723
// r := Say ( Denis , DR2-Den-1 ) else
6703: LD_ADDR_VAR 0 3
6707: PUSH
6708: LD_EXP 26
6712: PPUSH
6713: LD_STRING DR2-Den-1
6715: PPUSH
6716: CALL_OW 88
6720: ST_TO_ADDR
6721: GO 6788
// if GetSex ( scis [ 1 ] ) = sex_male then
6723: LD_VAR 0 2
6727: PUSH
6728: LD_INT 1
6730: ARRAY
6731: PPUSH
6732: CALL_OW 258
6736: PUSH
6737: LD_INT 1
6739: EQUAL
6740: IFFALSE 6766
// r := Say ( scis [ 1 ] , DR2-Sci1-1 ) else
6742: LD_ADDR_VAR 0 3
6746: PUSH
6747: LD_VAR 0 2
6751: PUSH
6752: LD_INT 1
6754: ARRAY
6755: PPUSH
6756: LD_STRING DR2-Sci1-1
6758: PPUSH
6759: CALL_OW 88
6763: ST_TO_ADDR
6764: GO 6788
// r := Say ( scis [ 1 ] , DR2-FSci1-1 ) ;
6766: LD_ADDR_VAR 0 3
6770: PUSH
6771: LD_VAR 0 2
6775: PUSH
6776: LD_INT 1
6778: ARRAY
6779: PPUSH
6780: LD_STRING DR2-FSci1-1
6782: PPUSH
6783: CALL_OW 88
6787: ST_TO_ADDR
// if r then
6788: LD_VAR 0 3
6792: IFFALSE 6806
// Say ( JMM , DR2-JMM-1 ) ;
6794: LD_EXP 15
6798: PPUSH
6799: LD_STRING DR2-JMM-1
6801: PPUSH
6802: CALL_OW 88
// if r then
6806: LD_VAR 0 3
6810: IFFALSE 6852
// if SayAny ( not_char , DR2-Sol1-1 , you , sex_male , 0 , 0 ) then
6812: LD_EXP 11
6816: PPUSH
6817: LD_STRING DR2-Sol1-1
6819: PPUSH
6820: LD_EXP 1
6824: PPUSH
6825: LD_INT 1
6827: PPUSH
6828: LD_INT 0
6830: PPUSH
6831: LD_INT 0
6833: PPUSH
6834: CALL 17300 0 6
6838: IFFALSE 6852
// Say ( JMM , DR2-JMM-2 ) ;
6840: LD_EXP 15
6844: PPUSH
6845: LD_STRING DR2-JMM-2
6847: PPUSH
6848: CALL_OW 88
// DialogueOff ;
6852: CALL_OW 7
// end ; end ;
6856: LD_VAR 0 1
6860: RET
// export function DialogKurt ( kdo ) ; var qr , mytick ; var JeMM , JeF ; begin
6861: LD_INT 0
6863: PPUSH
6864: PPUSH
6865: PPUSH
6866: PPUSH
6867: PPUSH
// DialogInProgress := true ;
6868: LD_ADDR_EXP 52
6872: PUSH
6873: LD_INT 1
6875: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_outside ] , [ f_nation , nation_american ] , [ f_alive ] ] ) , Kurt ) ;
6876: LD_ADDR_VAR 0 1
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_EXP 1
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: LD_INT 21
6895: PUSH
6896: LD_INT 1
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: PUSH
6903: LD_INT 56
6905: PUSH
6906: EMPTY
6907: LIST
6908: PUSH
6909: LD_INT 23
6911: PUSH
6912: LD_INT 1
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 51
6921: PUSH
6922: EMPTY
6923: LIST
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: LIST
6929: LIST
6930: LIST
6931: PPUSH
6932: CALL_OW 69
6936: PPUSH
6937: LD_EXP 43
6941: PPUSH
6942: CALL_OW 74
6946: ST_TO_ADDR
// JeF := ( GetSex ( kdo ) = sex_female ) ;
6947: LD_ADDR_VAR 0 6
6951: PUSH
6952: LD_VAR 0 1
6956: PPUSH
6957: CALL_OW 258
6961: PUSH
6962: LD_INT 2
6964: EQUAL
6965: ST_TO_ADDR
// JeMM := ( kdo = JMM ) ;
6966: LD_ADDR_VAR 0 5
6970: PUSH
6971: LD_VAR 0 1
6975: PUSH
6976: LD_EXP 15
6980: EQUAL
6981: ST_TO_ADDR
// InGameOn ;
6982: CALL_OW 8
// CenterOnUnits ( Kurt ) ;
6986: LD_EXP 43
6990: PPUSH
6991: CALL_OW 85
// Wait ( 0 0$4 ) ;
6995: LD_INT 140
6997: PPUSH
6998: CALL_OW 67
// ComMoveUnit ( kdo , Kurt ) ;
7002: LD_VAR 0 1
7006: PPUSH
7007: LD_EXP 43
7011: PPUSH
7012: CALL_OW 112
// AddComTurnUnit ( kdo , Kurt ) ;
7016: LD_VAR 0 1
7020: PPUSH
7021: LD_EXP 43
7025: PPUSH
7026: CALL_OW 179
// AddComHold ( kdo ) ;
7030: LD_VAR 0 1
7034: PPUSH
7035: CALL_OW 200
// ComMoveUnit ( Kurt , kdo ) ;
7039: LD_EXP 43
7043: PPUSH
7044: LD_VAR 0 1
7048: PPUSH
7049: CALL_OW 112
// AddComTurnUnit ( Kurt , kdo ) ;
7053: LD_EXP 43
7057: PPUSH
7058: LD_VAR 0 1
7062: PPUSH
7063: CALL_OW 179
// AddComHold ( Kurt ) ;
7067: LD_EXP 43
7071: PPUSH
7072: CALL_OW 200
// mytick := tick + 0 0$15 ;
7076: LD_ADDR_VAR 0 4
7080: PUSH
7081: LD_OWVAR 1
7085: PUSH
7086: LD_INT 525
7088: PLUS
7089: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Kurt , kdo ) > 4 do
7090: LD_VAR 0 4
7094: PUSH
7095: LD_OWVAR 1
7099: GREATER
7100: IFFALSE 7122
7102: PUSH
7103: LD_EXP 43
7107: PPUSH
7108: LD_VAR 0 1
7112: PPUSH
7113: CALL_OW 296
7117: PUSH
7118: LD_INT 4
7120: GREATER
7121: AND
7122: IFFALSE 7133
// Wait ( 0 0$1 ) ;
7124: LD_INT 35
7126: PPUSH
7127: CALL_OW 67
7131: GO 7090
// InGameOff ;
7133: CALL_OW 9
// if IsLive ( Kurt ) and IsLive ( kdo ) then
7137: LD_EXP 43
7141: PPUSH
7142: CALL_OW 300
7146: IFFALSE 7159
7148: PUSH
7149: LD_VAR 0 1
7153: PPUSH
7154: CALL_OW 300
7158: AND
7159: IFFALSE 8437
// begin DialogueOn ;
7161: CALL_OW 6
// if JeMM then
7165: LD_VAR 0 5
7169: IFFALSE 7499
// begin Say ( Kurt , D2-Kurt-1 ) ;
7171: LD_EXP 43
7175: PPUSH
7176: LD_STRING D2-Kurt-1
7178: PPUSH
7179: CALL_OW 88
// Say ( kdo , D2-JMM-1 ) ;
7183: LD_VAR 0 1
7187: PPUSH
7188: LD_STRING D2-JMM-1
7190: PPUSH
7191: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7195: LD_EXP 43
7199: PPUSH
7200: LD_STRING D2-Kurt-2
7202: PPUSH
7203: CALL_OW 88
// Say ( kdo , D2-JMM-2 ) ;
7207: LD_VAR 0 1
7211: PPUSH
7212: LD_STRING D2-JMM-2
7214: PPUSH
7215: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7219: LD_EXP 43
7223: PPUSH
7224: LD_STRING D2-Kurt-3
7226: PPUSH
7227: CALL_OW 88
// Say ( kdo , D2-JMM-3 ) ;
7231: LD_VAR 0 1
7235: PPUSH
7236: LD_STRING D2-JMM-3
7238: PPUSH
7239: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7243: LD_EXP 43
7247: PPUSH
7248: LD_STRING D2-Kurt-4
7250: PPUSH
7251: CALL_OW 88
// Say ( kdo , D2-JMM-4 ) ;
7255: LD_VAR 0 1
7259: PPUSH
7260: LD_STRING D2-JMM-4
7262: PPUSH
7263: CALL_OW 88
// qr := Query ( QKill ) ;
7267: LD_ADDR_VAR 0 3
7271: PUSH
7272: LD_STRING QKill
7274: PPUSH
7275: CALL_OW 97
7279: ST_TO_ADDR
// case qr of 1 :
7280: LD_VAR 0 3
7284: PUSH
7285: LD_INT 1
7287: DOUBLE
7288: EQUAL
7289: IFTRUE 7293
7291: GO 7308
7293: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7294: LD_EXP 43
7298: PPUSH
7299: LD_STRING D2a-Kurt-1
7301: PPUSH
7302: CALL_OW 88
// end ; 2 :
7306: GO 7410
7308: LD_INT 2
7310: DOUBLE
7311: EQUAL
7312: IFTRUE 7316
7314: GO 7374
7316: POP
// begin Say ( kdo , D2b-JMM-1 ) ;
7317: LD_VAR 0 1
7321: PPUSH
7322: LD_STRING D2b-JMM-1
7324: PPUSH
7325: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7329: LD_EXP 43
7333: PPUSH
7334: LD_STRING D2b-Kurt-1
7336: PPUSH
7337: CALL_OW 88
// Say ( kdo , D2b-JMM-2 ) ;
7341: LD_VAR 0 1
7345: PPUSH
7346: LD_STRING D2b-JMM-2
7348: PPUSH
7349: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7353: LD_EXP 43
7357: PPUSH
7358: LD_STRING D2b-Kurt-2
7360: PPUSH
7361: CALL_OW 88
// SayEffect ( Kurtfire.wav ) ;
7365: LD_STRING Kurtfire.wav
7367: PPUSH
7368: CALL_OW 96
// end ; 3 :
7372: GO 7410
7374: LD_INT 3
7376: DOUBLE
7377: EQUAL
7378: IFTRUE 7382
7380: GO 7409
7382: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7383: LD_VAR 0 1
7387: PPUSH
7388: LD_STRING D2c-JMM-1
7390: PPUSH
7391: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7395: LD_EXP 43
7399: PPUSH
7400: LD_STRING D2c-Kurt-1
7402: PPUSH
7403: CALL_OW 88
// end ; end ;
7407: GO 7410
7409: POP
// if qr = 2 then
7410: LD_VAR 0 3
7414: PUSH
7415: LD_INT 2
7417: EQUAL
7418: IFFALSE 7497
// begin qr := Query ( QKill2 ) ;
7420: LD_ADDR_VAR 0 3
7424: PUSH
7425: LD_STRING QKill2
7427: PPUSH
7428: CALL_OW 97
7432: ST_TO_ADDR
// case qr of 1 :
7433: LD_VAR 0 3
7437: PUSH
7438: LD_INT 1
7440: DOUBLE
7441: EQUAL
7442: IFTRUE 7446
7444: GO 7461
7446: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7447: LD_EXP 43
7451: PPUSH
7452: LD_STRING D2a-Kurt-1
7454: PPUSH
7455: CALL_OW 88
// end ; 2 :
7459: GO 7497
7461: LD_INT 2
7463: DOUBLE
7464: EQUAL
7465: IFTRUE 7469
7467: GO 7496
7469: POP
// begin Say ( kdo , D2c-JMM-1 ) ;
7470: LD_VAR 0 1
7474: PPUSH
7475: LD_STRING D2c-JMM-1
7477: PPUSH
7478: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7482: LD_EXP 43
7486: PPUSH
7487: LD_STRING D2c-Kurt-1
7489: PPUSH
7490: CALL_OW 88
// end ; end ;
7494: GO 7497
7496: POP
// end ; end else
7497: GO 8193
// if JeF then
7499: LD_VAR 0 6
7503: IFFALSE 7850
// begin Say ( Kurt , D2-Kurt-1 ) ;
7505: LD_EXP 43
7509: PPUSH
7510: LD_STRING D2-Kurt-1
7512: PPUSH
7513: CALL_OW 88
// Say ( kdo , D2-FSol1-1 ) ;
7517: LD_VAR 0 1
7521: PPUSH
7522: LD_STRING D2-FSol1-1
7524: PPUSH
7525: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7529: LD_EXP 43
7533: PPUSH
7534: LD_STRING D2-Kurt-2
7536: PPUSH
7537: CALL_OW 88
// Say ( kdo , D2-FSol1-2 ) ;
7541: LD_VAR 0 1
7545: PPUSH
7546: LD_STRING D2-FSol1-2
7548: PPUSH
7549: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7553: LD_EXP 43
7557: PPUSH
7558: LD_STRING D2-Kurt-3
7560: PPUSH
7561: CALL_OW 88
// Say ( kdo , D2-FSol1-3 ) ;
7565: LD_VAR 0 1
7569: PPUSH
7570: LD_STRING D2-FSol1-3
7572: PPUSH
7573: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7577: LD_EXP 43
7581: PPUSH
7582: LD_STRING D2-Kurt-4
7584: PPUSH
7585: CALL_OW 88
// Say ( kdo , D2-FSol1-4 ) ;
7589: LD_VAR 0 1
7593: PPUSH
7594: LD_STRING D2-FSol1-4
7596: PPUSH
7597: CALL_OW 88
// Say ( kdo , D2-FSol1-5 ) ;
7601: LD_VAR 0 1
7605: PPUSH
7606: LD_STRING D2-FSol1-5
7608: PPUSH
7609: CALL_OW 88
// qr := Query ( QKill ) ;
7613: LD_ADDR_VAR 0 3
7617: PUSH
7618: LD_STRING QKill
7620: PPUSH
7621: CALL_OW 97
7625: ST_TO_ADDR
// case qr of 1 :
7626: LD_VAR 0 3
7630: PUSH
7631: LD_INT 1
7633: DOUBLE
7634: EQUAL
7635: IFTRUE 7639
7637: GO 7654
7639: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7640: LD_EXP 43
7644: PPUSH
7645: LD_STRING D2a-Kurt-1
7647: PPUSH
7648: CALL_OW 88
// end ; 2 :
7652: GO 7761
7654: LD_INT 2
7656: DOUBLE
7657: EQUAL
7658: IFTRUE 7662
7660: GO 7725
7662: POP
// begin Say ( kdo , D2b-FSol1-1 ) ;
7663: LD_VAR 0 1
7667: PPUSH
7668: LD_STRING D2b-FSol1-1
7670: PPUSH
7671: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
7675: LD_EXP 43
7679: PPUSH
7680: LD_STRING D2b-Kurt-1
7682: PPUSH
7683: CALL_OW 88
// Say ( kdo , D2b-FSol1-2 ) ;
7687: LD_VAR 0 1
7691: PPUSH
7692: LD_STRING D2b-FSol1-2
7694: PPUSH
7695: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
7699: LD_EXP 43
7703: PPUSH
7704: LD_STRING D2b-Kurt-2
7706: PPUSH
7707: CALL_OW 88
// Say ( kdo , D2b-FSol1-3 ) ;
7711: LD_VAR 0 1
7715: PPUSH
7716: LD_STRING D2b-FSol1-3
7718: PPUSH
7719: CALL_OW 88
// end ; 3 :
7723: GO 7761
7725: LD_INT 3
7727: DOUBLE
7728: EQUAL
7729: IFTRUE 7733
7731: GO 7760
7733: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7734: LD_VAR 0 1
7738: PPUSH
7739: LD_STRING D2c-FSol1-1
7741: PPUSH
7742: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7746: LD_EXP 43
7750: PPUSH
7751: LD_STRING D2c-Kurt-1
7753: PPUSH
7754: CALL_OW 88
// end ; end ;
7758: GO 7761
7760: POP
// if qr = 2 then
7761: LD_VAR 0 3
7765: PUSH
7766: LD_INT 2
7768: EQUAL
7769: IFFALSE 7848
// begin qr := Query ( QKill2 ) ;
7771: LD_ADDR_VAR 0 3
7775: PUSH
7776: LD_STRING QKill2
7778: PPUSH
7779: CALL_OW 97
7783: ST_TO_ADDR
// case qr of 1 :
7784: LD_VAR 0 3
7788: PUSH
7789: LD_INT 1
7791: DOUBLE
7792: EQUAL
7793: IFTRUE 7797
7795: GO 7812
7797: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7798: LD_EXP 43
7802: PPUSH
7803: LD_STRING D2a-Kurt-1
7805: PPUSH
7806: CALL_OW 88
// end ; 2 :
7810: GO 7848
7812: LD_INT 2
7814: DOUBLE
7815: EQUAL
7816: IFTRUE 7820
7818: GO 7847
7820: POP
// begin Say ( kdo , D2c-FSol1-1 ) ;
7821: LD_VAR 0 1
7825: PPUSH
7826: LD_STRING D2c-FSol1-1
7828: PPUSH
7829: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
7833: LD_EXP 43
7837: PPUSH
7838: LD_STRING D2c-Kurt-1
7840: PPUSH
7841: CALL_OW 88
// end ; end ;
7845: GO 7848
7847: POP
// end ; end else
7848: GO 8193
// begin Say ( Kurt , D2-Kurt-1 ) ;
7850: LD_EXP 43
7854: PPUSH
7855: LD_STRING D2-Kurt-1
7857: PPUSH
7858: CALL_OW 88
// Say ( kdo , D2-Sol1-1 ) ;
7862: LD_VAR 0 1
7866: PPUSH
7867: LD_STRING D2-Sol1-1
7869: PPUSH
7870: CALL_OW 88
// Say ( Kurt , D2-Kurt-2 ) ;
7874: LD_EXP 43
7878: PPUSH
7879: LD_STRING D2-Kurt-2
7881: PPUSH
7882: CALL_OW 88
// Say ( kdo , D2-Sol1-2 ) ;
7886: LD_VAR 0 1
7890: PPUSH
7891: LD_STRING D2-Sol1-2
7893: PPUSH
7894: CALL_OW 88
// Say ( Kurt , D2-Kurt-3 ) ;
7898: LD_EXP 43
7902: PPUSH
7903: LD_STRING D2-Kurt-3
7905: PPUSH
7906: CALL_OW 88
// Say ( kdo , D2-Sol1-3 ) ;
7910: LD_VAR 0 1
7914: PPUSH
7915: LD_STRING D2-Sol1-3
7917: PPUSH
7918: CALL_OW 88
// Say ( Kurt , D2-Kurt-4 ) ;
7922: LD_EXP 43
7926: PPUSH
7927: LD_STRING D2-Kurt-4
7929: PPUSH
7930: CALL_OW 88
// Say ( kdo , D2-Sol1-4 ) ;
7934: LD_VAR 0 1
7938: PPUSH
7939: LD_STRING D2-Sol1-4
7941: PPUSH
7942: CALL_OW 88
// Say ( kdo , D2-Sol1-5 ) ;
7946: LD_VAR 0 1
7950: PPUSH
7951: LD_STRING D2-Sol1-5
7953: PPUSH
7954: CALL_OW 88
// qr := Query ( QKill ) ;
7958: LD_ADDR_VAR 0 3
7962: PUSH
7963: LD_STRING QKill
7965: PPUSH
7966: CALL_OW 97
7970: ST_TO_ADDR
// case qr of 1 :
7971: LD_VAR 0 3
7975: PUSH
7976: LD_INT 1
7978: DOUBLE
7979: EQUAL
7980: IFTRUE 7984
7982: GO 7999
7984: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
7985: LD_EXP 43
7989: PPUSH
7990: LD_STRING D2a-Kurt-1
7992: PPUSH
7993: CALL_OW 88
// end ; 2 :
7997: GO 8106
7999: LD_INT 2
8001: DOUBLE
8002: EQUAL
8003: IFTRUE 8007
8005: GO 8070
8007: POP
// begin Say ( kdo , D2b-Sol1-1 ) ;
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_STRING D2b-Sol1-1
8015: PPUSH
8016: CALL_OW 88
// Say ( Kurt , D2b-Kurt-1 ) ;
8020: LD_EXP 43
8024: PPUSH
8025: LD_STRING D2b-Kurt-1
8027: PPUSH
8028: CALL_OW 88
// Say ( kdo , D2b-Sol1-2 ) ;
8032: LD_VAR 0 1
8036: PPUSH
8037: LD_STRING D2b-Sol1-2
8039: PPUSH
8040: CALL_OW 88
// Say ( Kurt , D2b-Kurt-2 ) ;
8044: LD_EXP 43
8048: PPUSH
8049: LD_STRING D2b-Kurt-2
8051: PPUSH
8052: CALL_OW 88
// Say ( kdo , D2b-Sol1-3 ) ;
8056: LD_VAR 0 1
8060: PPUSH
8061: LD_STRING D2b-Sol1-3
8063: PPUSH
8064: CALL_OW 88
// end ; 3 :
8068: GO 8106
8070: LD_INT 3
8072: DOUBLE
8073: EQUAL
8074: IFTRUE 8078
8076: GO 8105
8078: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8079: LD_VAR 0 1
8083: PPUSH
8084: LD_STRING D2c-Sol1-1
8086: PPUSH
8087: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8091: LD_EXP 43
8095: PPUSH
8096: LD_STRING D2c-Kurt-1
8098: PPUSH
8099: CALL_OW 88
// end ; end ;
8103: GO 8106
8105: POP
// if qr = 2 then
8106: LD_VAR 0 3
8110: PUSH
8111: LD_INT 2
8113: EQUAL
8114: IFFALSE 8193
// begin qr := Query ( QKill2 ) ;
8116: LD_ADDR_VAR 0 3
8120: PUSH
8121: LD_STRING QKill2
8123: PPUSH
8124: CALL_OW 97
8128: ST_TO_ADDR
// case qr of 1 :
8129: LD_VAR 0 3
8133: PUSH
8134: LD_INT 1
8136: DOUBLE
8137: EQUAL
8138: IFTRUE 8142
8140: GO 8157
8142: POP
// begin Say ( Kurt , D2a-Kurt-1 ) ;
8143: LD_EXP 43
8147: PPUSH
8148: LD_STRING D2a-Kurt-1
8150: PPUSH
8151: CALL_OW 88
// end ; 2 :
8155: GO 8193
8157: LD_INT 2
8159: DOUBLE
8160: EQUAL
8161: IFTRUE 8165
8163: GO 8192
8165: POP
// begin Say ( kdo , D2c-Sol1-1 ) ;
8166: LD_VAR 0 1
8170: PPUSH
8171: LD_STRING D2c-Sol1-1
8173: PPUSH
8174: CALL_OW 88
// Say ( Kurt , D2c-Kurt-1 ) ;
8178: LD_EXP 43
8182: PPUSH
8183: LD_STRING D2c-Kurt-1
8185: PPUSH
8186: CALL_OW 88
// end ; end ;
8190: GO 8193
8192: POP
// end ; end ; DialogueOff ;
8193: CALL_OW 7
// if qr = 1 then
8197: LD_VAR 0 3
8201: PUSH
8202: LD_INT 1
8204: EQUAL
8205: IFFALSE 8323
// begin KurtTryToEscape := true ;
8207: LD_ADDR_EXP 85
8211: PUSH
8212: LD_INT 1
8214: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
8215: LD_EXP 3
8219: PPUSH
8220: LD_EXP 1
8224: PPUSH
8225: LD_INT 2
8227: PPUSH
8228: LD_INT 1
8230: PPUSH
8231: CALL_OW 80
// ComAttackUnit ( kdo , Kurt ) ;
8235: LD_VAR 0 1
8239: PPUSH
8240: LD_EXP 43
8244: PPUSH
8245: CALL_OW 115
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) do
8249: LD_EXP 43
8253: PPUSH
8254: LD_INT 10
8256: PPUSH
8257: CALL_OW 308
8261: NOT
8262: IFFALSE 8275
8264: PUSH
8265: LD_EXP 43
8269: PPUSH
8270: CALL_OW 300
8274: AND
8275: IFFALSE 8298
// begin ComMoveToArea ( Kurt , border ) ;
8277: LD_EXP 43
8281: PPUSH
8282: LD_INT 10
8284: PPUSH
8285: CALL_OW 113
// wait ( 0 0$1 ) ;
8289: LD_INT 35
8291: PPUSH
8292: CALL_OW 67
// end ;
8296: GO 8249
// if IsInArea ( Kurt , border ) then
8298: LD_EXP 43
8302: PPUSH
8303: LD_INT 10
8305: PPUSH
8306: CALL_OW 308
8310: IFFALSE 8321
// RemoveUnit ( Kurt ) ;
8312: LD_EXP 43
8316: PPUSH
8317: CALL_OW 64
// end else
8321: GO 8437
// begin SA_OnKurtSpared ;
8323: CALL 27231 0 0
// mytick := tick + 0 0$20 ;
8327: LD_ADDR_VAR 0 4
8331: PUSH
8332: LD_OWVAR 1
8336: PUSH
8337: LD_INT 700
8339: PLUS
8340: ST_TO_ADDR
// while not IsInArea ( Kurt , border ) and IsLive ( Kurt ) and mytick > tick do
8341: LD_EXP 43
8345: PPUSH
8346: LD_INT 10
8348: PPUSH
8349: CALL_OW 308
8353: NOT
8354: IFFALSE 8367
8356: PUSH
8357: LD_EXP 43
8361: PPUSH
8362: CALL_OW 300
8366: AND
8367: IFFALSE 8381
8369: PUSH
8370: LD_VAR 0 4
8374: PUSH
8375: LD_OWVAR 1
8379: GREATER
8380: AND
8381: IFFALSE 8404
// begin ComMoveToArea ( Kurt , border ) ;
8383: LD_EXP 43
8387: PPUSH
8388: LD_INT 10
8390: PPUSH
8391: CALL_OW 113
// wait ( 0 0$1 ) ;
8395: LD_INT 35
8397: PPUSH
8398: CALL_OW 67
// end ;
8402: GO 8341
// if IsPlaced ( Kurt ) and IsLive ( kurt ) then
8404: LD_EXP 43
8408: PPUSH
8409: CALL_OW 305
8413: IFFALSE 8426
8415: PUSH
8416: LD_EXP 43
8420: PPUSH
8421: CALL_OW 300
8425: AND
8426: IFFALSE 8437
// RemoveUnit ( Kurt ) ;
8428: LD_EXP 43
8432: PPUSH
8433: CALL_OW 64
// end ; end ; DialogInProgress := false ;
8437: LD_ADDR_EXP 52
8441: PUSH
8442: LD_INT 0
8444: ST_TO_ADDR
// end ;
8445: LD_VAR 0 2
8449: RET
// every 0 0$10 trigger GetAttitude ( arabians , you ) = att_enemy do
8450: LD_EXP 3
8454: PPUSH
8455: LD_EXP 1
8459: PPUSH
8460: CALL_OW 81
8464: PUSH
8465: LD_INT 2
8467: EQUAL
8468: IFFALSE 8481
8470: GO 8472
8472: DISABLE
// begin KurtTryToEscape := true ;
8473: LD_ADDR_EXP 85
8477: PUSH
8478: LD_INT 1
8480: ST_TO_ADDR
// end ;
8481: END
// export function DialogJoan ( kdo ) ; var mytick ; begin
8482: LD_INT 0
8484: PPUSH
8485: PPUSH
// DialogInProgress := true ;
8486: LD_ADDR_EXP 52
8490: PUSH
8491: LD_INT 1
8493: ST_TO_ADDR
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8494: LD_ADDR_VAR 0 1
8498: PUSH
8499: LD_INT 26
8501: PUSH
8502: LD_INT 1
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PUSH
8509: LD_INT 22
8511: PUSH
8512: LD_EXP 1
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PUSH
8521: LD_INT 21
8523: PUSH
8524: LD_INT 1
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PUSH
8531: LD_INT 3
8533: PUSH
8534: LD_INT 54
8536: PUSH
8537: EMPTY
8538: LIST
8539: PUSH
8540: LD_INT 3
8542: PUSH
8543: LD_INT 55
8545: PUSH
8546: EMPTY
8547: LIST
8548: PUSH
8549: LD_INT 3
8551: PUSH
8552: LD_INT 23
8554: PUSH
8555: LD_INT 0
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PUSH
8562: LD_INT 51
8564: PUSH
8565: EMPTY
8566: LIST
8567: PUSH
8568: EMPTY
8569: LIST
8570: LIST
8571: LIST
8572: LIST
8573: LIST
8574: LIST
8575: LIST
8576: LIST
8577: LIST
8578: LIST
8579: PPUSH
8580: CALL_OW 69
8584: PUSH
8585: LD_EXP 33
8589: DIFF
8590: PPUSH
8591: LD_EXP 33
8595: PPUSH
8596: CALL_OW 74
8600: ST_TO_ADDR
// InGameOn ;
8601: CALL_OW 8
// CenterOnUnits ( Joan ) ;
8605: LD_EXP 33
8609: PPUSH
8610: CALL_OW 85
// DoNotAttack ( russians , Joan ) ;
8614: LD_EXP 2
8618: PPUSH
8619: LD_EXP 33
8623: PPUSH
8624: CALL_OW 471
// Wait ( 0 0$5 ) ;
8628: LD_INT 175
8630: PPUSH
8631: CALL_OW 67
// SetLives ( Joan , hranice_umirani + 50 ) ;
8635: LD_EXP 33
8639: PPUSH
8640: LD_INT 250
8642: PUSH
8643: LD_INT 50
8645: PLUS
8646: PPUSH
8647: CALL_OW 234
// AddComMoveUnit ( Joan , kdo ) ;
8651: LD_EXP 33
8655: PPUSH
8656: LD_VAR 0 1
8660: PPUSH
8661: CALL_OW 172
// AddComTurnUnit ( Joan , kdo ) ;
8665: LD_EXP 33
8669: PPUSH
8670: LD_VAR 0 1
8674: PPUSH
8675: CALL_OW 179
// AddComHold ( Joan ) ;
8679: LD_EXP 33
8683: PPUSH
8684: CALL_OW 200
// ComMoveUnit ( kdo , Joan ) ;
8688: LD_VAR 0 1
8692: PPUSH
8693: LD_EXP 33
8697: PPUSH
8698: CALL_OW 112
// AddComTurnUnit ( kdo , Joan ) ;
8702: LD_VAR 0 1
8706: PPUSH
8707: LD_EXP 33
8711: PPUSH
8712: CALL_OW 179
// AddComHold ( kdo ) ;
8716: LD_VAR 0 1
8720: PPUSH
8721: CALL_OW 200
// mytick := tick + 0 0$15 ;
8725: LD_ADDR_VAR 0 3
8729: PUSH
8730: LD_OWVAR 1
8734: PUSH
8735: LD_INT 525
8737: PLUS
8738: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , kdo ) > 4 and IsOK ( kdo ) do
8739: LD_VAR 0 3
8743: PUSH
8744: LD_OWVAR 1
8748: GREATER
8749: IFFALSE 8771
8751: PUSH
8752: LD_EXP 33
8756: PPUSH
8757: LD_VAR 0 1
8761: PPUSH
8762: CALL_OW 296
8766: PUSH
8767: LD_INT 4
8769: GREATER
8770: AND
8771: IFFALSE 8784
8773: PUSH
8774: LD_VAR 0 1
8778: PPUSH
8779: CALL_OW 302
8783: AND
8784: IFFALSE 8795
// Wait ( 0 0$1 ) ;
8786: LD_INT 35
8788: PPUSH
8789: CALL_OW 67
8793: GO 8739
// if not IsOK ( kdo ) then
8795: LD_VAR 0 1
8799: PPUSH
8800: CALL_OW 302
8804: NOT
8805: IFFALSE 8914
// kdo := NearestUnitToUnit ( FilterAllUnits ( [ [ f_sex , sex_male ] , [ f_side , you ] , [ f_type , unit_human ] , f_not , [ f_inside ] , f_not , [ f_driving ] , f_not , [ f_nation , nation_nature ] , [ f_alive ] ] ) diff Joan , Joan ) ;
8807: LD_ADDR_VAR 0 1
8811: PUSH
8812: LD_INT 26
8814: PUSH
8815: LD_INT 1
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: PUSH
8822: LD_INT 22
8824: PUSH
8825: LD_EXP 1
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PUSH
8834: LD_INT 21
8836: PUSH
8837: LD_INT 1
8839: PUSH
8840: EMPTY
8841: LIST
8842: LIST
8843: PUSH
8844: LD_INT 3
8846: PUSH
8847: LD_INT 54
8849: PUSH
8850: EMPTY
8851: LIST
8852: PUSH
8853: LD_INT 3
8855: PUSH
8856: LD_INT 55
8858: PUSH
8859: EMPTY
8860: LIST
8861: PUSH
8862: LD_INT 3
8864: PUSH
8865: LD_INT 23
8867: PUSH
8868: LD_INT 0
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: LD_INT 51
8877: PUSH
8878: EMPTY
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: LIST
8887: LIST
8888: LIST
8889: LIST
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: LD_EXP 33
8902: DIFF
8903: PPUSH
8904: LD_EXP 33
8908: PPUSH
8909: CALL_OW 74
8913: ST_TO_ADDR
// InGameOff ;
8914: CALL_OW 9
// if IsLive ( Joan ) and IsLive ( kdo ) then
8918: LD_EXP 33
8922: PPUSH
8923: CALL_OW 300
8927: IFFALSE 8940
8929: PUSH
8930: LD_VAR 0 1
8934: PPUSH
8935: CALL_OW 300
8939: AND
8940: IFFALSE 9306
// begin DialogueOn ;
8942: CALL_OW 6
// if kdo = JMM then
8946: LD_VAR 0 1
8950: PUSH
8951: LD_EXP 15
8955: EQUAL
8956: IFFALSE 9032
// begin Say ( kdo , D5b-JMM-1 ) ;
8958: LD_VAR 0 1
8962: PPUSH
8963: LD_STRING D5b-JMM-1
8965: PPUSH
8966: CALL_OW 88
// Say ( Joan , D5b-Joan-1 ) ;
8970: LD_EXP 33
8974: PPUSH
8975: LD_STRING D5b-Joan-1
8977: PPUSH
8978: CALL_OW 88
// Say ( kdo , D5b-JMM-2 ) ;
8982: LD_VAR 0 1
8986: PPUSH
8987: LD_STRING D5b-JMM-2
8989: PPUSH
8990: CALL_OW 88
// Say ( Joan , D5b-Joan-2 ) ;
8994: LD_EXP 33
8998: PPUSH
8999: LD_STRING D5b-Joan-2
9001: PPUSH
9002: CALL_OW 88
// Say ( kdo , D5b-JMM-3 ) ;
9006: LD_VAR 0 1
9010: PPUSH
9011: LD_STRING D5b-JMM-3
9013: PPUSH
9014: CALL_OW 88
// Say ( Joan , D5b-Joan-3 ) ;
9018: LD_EXP 33
9022: PPUSH
9023: LD_STRING D5b-Joan-3
9025: PPUSH
9026: CALL_OW 88
// end else
9030: GO 9306
// begin Say ( kdo , D5a-Sol1-1 ) ;
9032: LD_VAR 0 1
9036: PPUSH
9037: LD_STRING D5a-Sol1-1
9039: PPUSH
9040: CALL_OW 88
// Say ( Joan , D5a-Joan-1 ) ;
9044: LD_EXP 33
9048: PPUSH
9049: LD_STRING D5a-Joan-1
9051: PPUSH
9052: CALL_OW 88
// Say ( kdo , D5a-Sol1-2 ) ;
9056: LD_VAR 0 1
9060: PPUSH
9061: LD_STRING D5a-Sol1-2
9063: PPUSH
9064: CALL_OW 88
// Say ( Joan , D5a-Joan-2 ) ;
9068: LD_EXP 33
9072: PPUSH
9073: LD_STRING D5a-Joan-2
9075: PPUSH
9076: CALL_OW 88
// Say ( kdo , D5a-Sol1-3 ) ;
9080: LD_VAR 0 1
9084: PPUSH
9085: LD_STRING D5a-Sol1-3
9087: PPUSH
9088: CALL_OW 88
// Say ( Joan , D5a-Joan-3 ) ;
9092: LD_EXP 33
9096: PPUSH
9097: LD_STRING D5a-Joan-3
9099: PPUSH
9100: CALL_OW 88
// Say ( kdo , D5a-Sol1-4 ) ;
9104: LD_VAR 0 1
9108: PPUSH
9109: LD_STRING D5a-Sol1-4
9111: PPUSH
9112: CALL_OW 88
// ComMoveUnit ( [ kdo , Joan ] , JMM ) ;
9116: LD_VAR 0 1
9120: PUSH
9121: LD_EXP 33
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PPUSH
9130: LD_EXP 15
9134: PPUSH
9135: CALL_OW 112
// AddComHold ( [ kdo , Joan ] ) ;
9139: LD_VAR 0 1
9143: PUSH
9144: LD_EXP 33
9148: PUSH
9149: EMPTY
9150: LIST
9151: LIST
9152: PPUSH
9153: CALL_OW 200
// DialogueOff ;
9157: CALL_OW 7
// mytick := tick + 0 0$15 ;
9161: LD_ADDR_VAR 0 3
9165: PUSH
9166: LD_OWVAR 1
9170: PUSH
9171: LD_INT 525
9173: PLUS
9174: ST_TO_ADDR
// while mytick > tick and GetDistUnits ( Joan , JMM ) > 5 do
9175: LD_VAR 0 3
9179: PUSH
9180: LD_OWVAR 1
9184: GREATER
9185: IFFALSE 9207
9187: PUSH
9188: LD_EXP 33
9192: PPUSH
9193: LD_EXP 15
9197: PPUSH
9198: CALL_OW 296
9202: PUSH
9203: LD_INT 5
9205: GREATER
9206: AND
9207: IFFALSE 9218
// Wait ( 0 0$1 ) ;
9209: LD_INT 35
9211: PPUSH
9212: CALL_OW 67
9216: GO 9175
// DialogueOn ;
9218: CALL_OW 6
// if IsLive ( Joan ) and IsLive ( JMM ) then
9222: LD_EXP 33
9226: PPUSH
9227: CALL_OW 300
9231: IFFALSE 9244
9233: PUSH
9234: LD_EXP 15
9238: PPUSH
9239: CALL_OW 300
9243: AND
9244: IFFALSE 9306
// begin Say ( Joan , D5a-Joan-4 ) ;
9246: LD_EXP 33
9250: PPUSH
9251: LD_STRING D5a-Joan-4
9253: PPUSH
9254: CALL_OW 88
// Say ( JMM , D5a-JMM-4 ) ;
9258: LD_EXP 15
9262: PPUSH
9263: LD_STRING D5a-JMM-4
9265: PPUSH
9266: CALL_OW 88
// Say ( Joan , D5a-Joan-5 ) ;
9270: LD_EXP 33
9274: PPUSH
9275: LD_STRING D5a-Joan-5
9277: PPUSH
9278: CALL_OW 88
// Say ( JMM , D5a-JMM-5 ) ;
9282: LD_EXP 15
9286: PPUSH
9287: LD_STRING D5a-JMM-5
9289: PPUSH
9290: CALL_OW 88
// Say ( Joan , D5a-Joan-6 ) ;
9294: LD_EXP 33
9298: PPUSH
9299: LD_STRING D5a-Joan-6
9301: PPUSH
9302: CALL_OW 88
// end ; end ; end ; Dialog6 ;
9306: CALL 9315 0 0
// end ;
9310: LD_VAR 0 2
9314: RET
// function Dialog6 ; begin
9315: LD_INT 0
9317: PPUSH
// if IsLive ( Joan ) then
9318: LD_EXP 33
9322: PPUSH
9323: CALL_OW 300
9327: IFFALSE 9477
// begin ComStop ( [ Joan , JMM ] ) ;
9329: LD_EXP 33
9333: PUSH
9334: LD_EXP 15
9338: PUSH
9339: EMPTY
9340: LIST
9341: LIST
9342: PPUSH
9343: CALL_OW 141
// ComTurnUnit ( JMM , Joan ) ;
9347: LD_EXP 15
9351: PPUSH
9352: LD_EXP 33
9356: PPUSH
9357: CALL_OW 119
// ComTurnUnit ( Joan , JMM ) ;
9361: LD_EXP 33
9365: PPUSH
9366: LD_EXP 15
9370: PPUSH
9371: CALL_OW 119
// AddComHold ( [ JMM , Joan ] ) ;
9375: LD_EXP 15
9379: PUSH
9380: LD_EXP 33
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PPUSH
9389: CALL_OW 200
// Say ( JMM , D6-JMM-1 ) ;
9393: LD_EXP 15
9397: PPUSH
9398: LD_STRING D6-JMM-1
9400: PPUSH
9401: CALL_OW 88
// Say ( Joan , D6-Joan-1 ) ;
9405: LD_EXP 33
9409: PPUSH
9410: LD_STRING D6-Joan-1
9412: PPUSH
9413: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9417: LD_EXP 15
9421: PPUSH
9422: LD_STRING D6-JMM-2
9424: PPUSH
9425: CALL_OW 88
// Say ( Joan , D6-Joan-2 ) ;
9429: LD_EXP 33
9433: PPUSH
9434: LD_STRING D6-Joan-2
9436: PPUSH
9437: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9441: LD_EXP 15
9445: PPUSH
9446: LD_STRING D6-JMM-3
9448: PPUSH
9449: CALL_OW 88
// Say ( Joan , D6-Joan-3 ) ;
9453: LD_EXP 33
9457: PPUSH
9458: LD_STRING D6-Joan-3
9460: PPUSH
9461: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9465: LD_EXP 15
9469: PPUSH
9470: LD_STRING D6-JMM-4
9472: PPUSH
9473: CALL_OW 88
// end ; DialogueOff ;
9477: CALL_OW 7
// ChangeMissionObjectives ( MJ ) ;
9481: LD_STRING MJ
9483: PPUSH
9484: CALL_OW 337
// SetSide ( Joan , you ) ;
9488: LD_EXP 33
9492: PPUSH
9493: LD_EXP 1
9497: PPUSH
9498: CALL_OW 235
// NormalAttack ( russians , Joan ) ;
9502: LD_EXP 2
9506: PPUSH
9507: LD_EXP 33
9511: PPUSH
9512: CALL_OW 472
// if IsLive ( Lisa ) then
9516: LD_EXP 21
9520: PPUSH
9521: CALL_OW 300
9525: IFFALSE 9535
// act_Lisa_JMM := true ;
9527: LD_ADDR_EXP 58
9531: PUSH
9532: LD_INT 1
9534: ST_TO_ADDR
// DialogInProgress := false ;
9535: LD_ADDR_EXP 52
9539: PUSH
9540: LD_INT 0
9542: ST_TO_ADDR
// end ;
9543: LD_VAR 0 1
9547: RET
// every 1 1$0 trigger act_Lisa_JMM do
9548: LD_EXP 58
9552: IFFALSE 9716
9554: GO 9556
9556: DISABLE
// begin Wait ( 3 3$0 ) ;
9557: LD_INT 6300
9559: PPUSH
9560: CALL_OW 67
// if IsLive ( Joan ) and IsLive ( Lisa ) then
9564: LD_EXP 33
9568: PPUSH
9569: CALL_OW 300
9573: IFFALSE 9586
9575: PUSH
9576: LD_EXP 21
9580: PPUSH
9581: CALL_OW 300
9585: AND
9586: IFFALSE 9716
// begin DialogueOn ;
9588: CALL_OW 6
// Say ( Lisa , D7-Lisa-1 ) ;
9592: LD_EXP 21
9596: PPUSH
9597: LD_STRING D7-Lisa-1
9599: PPUSH
9600: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
9604: LD_EXP 15
9608: PPUSH
9609: LD_STRING D7-JMM-1
9611: PPUSH
9612: CALL_OW 88
// Say ( Lisa , D7-Lisa-2 ) ;
9616: LD_EXP 21
9620: PPUSH
9621: LD_STRING D7-Lisa-2
9623: PPUSH
9624: CALL_OW 88
// Say ( JMM , D7-JMM-2 ) ;
9628: LD_EXP 15
9632: PPUSH
9633: LD_STRING D7-JMM-2
9635: PPUSH
9636: CALL_OW 88
// Say ( Lisa , D7-Lisa-3 ) ;
9640: LD_EXP 21
9644: PPUSH
9645: LD_STRING D7-Lisa-3
9647: PPUSH
9648: CALL_OW 88
// Say ( JMM , D7-JMM-3 ) ;
9652: LD_EXP 15
9656: PPUSH
9657: LD_STRING D7-JMM-3
9659: PPUSH
9660: CALL_OW 88
// Say ( Lisa , D7-Lisa-4 ) ;
9664: LD_EXP 21
9668: PPUSH
9669: LD_STRING D7-Lisa-4
9671: PPUSH
9672: CALL_OW 88
// Say ( JMM , D7-JMM-4 ) ;
9676: LD_EXP 15
9680: PPUSH
9681: LD_STRING D7-JMM-4
9683: PPUSH
9684: CALL_OW 88
// Say ( JMM , D7-JMM-4a ) ;
9688: LD_EXP 15
9692: PPUSH
9693: LD_STRING D7-JMM-4a
9695: PPUSH
9696: CALL_OW 88
// Say ( Lisa , D7-Lisa-5 ) ;
9700: LD_EXP 21
9704: PPUSH
9705: LD_STRING D7-Lisa-5
9707: PPUSH
9708: CALL_OW 88
// DialogueOff ;
9712: CALL_OW 7
// end ; end ;
9716: END
// every 0 0$1.0 trigger Joan_P and not IsLive ( Joan ) do
9717: LD_EXP 48
9721: IFFALSE 9735
9723: PUSH
9724: LD_EXP 33
9728: PPUSH
9729: CALL_OW 300
9733: NOT
9734: AND
9735: IFFALSE 9747
9737: GO 9739
9739: DISABLE
// begin ChangeMissionObjectives ( MJa ) ;
9740: LD_STRING MJa
9742: PPUSH
9743: CALL_OW 337
// end ;
9747: END
// every 0 0$10.0 trigger not bojujese and IsOk ( Frank ) and UnitFilter ( apemans , [ f_side , you ] ) do var kdo , kdo2 ;
9748: CALL 13563 0 0
9752: NOT
9753: IFFALSE 9766
9755: PUSH
9756: LD_EXP 20
9760: PPUSH
9761: CALL_OW 302
9765: AND
9766: IFFALSE 9791
9768: PUSH
9769: LD_EXP 5
9773: PPUSH
9774: LD_INT 22
9776: PUSH
9777: LD_EXP 1
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 72
9790: AND
9791: IFFALSE 10095
9793: GO 9795
9795: DISABLE
9796: LD_INT 0
9798: PPUSH
9799: PPUSH
// begin while DialogInProgress do
9800: LD_EXP 52
9804: IFFALSE 9815
// Wait ( 0 0$5 ) ;
9806: LD_INT 175
9808: PPUSH
9809: CALL_OW 67
9813: GO 9800
// kdo := WhoSayAny ( not_char , you , 0 , 0 , 1 ) ;
9815: LD_ADDR_VAR 0 1
9819: PUSH
9820: LD_EXP 11
9824: PPUSH
9825: LD_EXP 1
9829: PPUSH
9830: LD_INT 0
9832: PPUSH
9833: LD_INT 0
9835: PPUSH
9836: LD_INT 1
9838: PPUSH
9839: CALL 17380 0 5
9843: ST_TO_ADDR
// if not kdo then
9844: LD_VAR 0 1
9848: NOT
9849: IFFALSE 9880
// kdo := WhoSayAny ( TvojiLidi , you , 0 , 0 , 1 ) ;
9851: LD_ADDR_VAR 0 1
9855: PUSH
9856: CALL 13620 0 0
9860: PPUSH
9861: LD_EXP 1
9865: PPUSH
9866: LD_INT 0
9868: PPUSH
9869: LD_INT 0
9871: PPUSH
9872: LD_INT 1
9874: PPUSH
9875: CALL 17380 0 5
9879: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , 0 , 0 , 2 ) ;
9880: LD_ADDR_VAR 0 2
9884: PUSH
9885: LD_EXP 11
9889: PPUSH
9890: LD_EXP 1
9894: PPUSH
9895: LD_INT 0
9897: PPUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 2
9903: PPUSH
9904: CALL 17380 0 5
9908: ST_TO_ADDR
// if not kdo then
9909: LD_VAR 0 1
9913: NOT
9914: IFFALSE 9945
// kdo2 := WhoSayAny ( TvojiLidi , you , 0 , 0 , 2 ) ;
9916: LD_ADDR_VAR 0 2
9920: PUSH
9921: CALL 13620 0 0
9925: PPUSH
9926: LD_EXP 1
9930: PPUSH
9931: LD_INT 0
9933: PPUSH
9934: LD_INT 0
9936: PPUSH
9937: LD_INT 2
9939: PPUSH
9940: CALL 17380 0 5
9944: ST_TO_ADDR
// if IsOk ( Frank ) then
9945: LD_EXP 20
9949: PPUSH
9950: CALL_OW 302
9954: IFFALSE 10095
// begin TalkOn ;
9956: CALL 17268 0 0
// Say ( Frank , D10-Frank-1 ) ;
9960: LD_EXP 20
9964: PPUSH
9965: LD_STRING D10-Frank-1
9967: PPUSH
9968: CALL_OW 88
// if GetSex ( kdo ) = sex_male then
9972: LD_VAR 0 1
9976: PPUSH
9977: CALL_OW 258
9981: PUSH
9982: LD_INT 1
9984: EQUAL
9985: IFFALSE 10001
// Say ( kdo , D10-Sol1-1 ) else
9987: LD_VAR 0 1
9991: PPUSH
9992: LD_STRING D10-Sol1-1
9994: PPUSH
9995: CALL_OW 88
9999: GO 10013
// Say ( kdo , D10-FSol1-1 ) ;
10001: LD_VAR 0 1
10005: PPUSH
10006: LD_STRING D10-FSol1-1
10008: PPUSH
10009: CALL_OW 88
// Say ( Frank , D10-Frank-2 ) ;
10013: LD_EXP 20
10017: PPUSH
10018: LD_STRING D10-Frank-2
10020: PPUSH
10021: CALL_OW 88
// if IsOk ( Lisa ) then
10025: LD_EXP 21
10029: PPUSH
10030: CALL_OW 302
10034: IFFALSE 10050
// Say ( Lisa , D10-Lisa-2 ) else
10036: LD_EXP 21
10040: PPUSH
10041: LD_STRING D10-Lisa-2
10043: PPUSH
10044: CALL_OW 88
10048: GO 10091
// if GetSex ( kdo2 ) = sex_male then
10050: LD_VAR 0 2
10054: PPUSH
10055: CALL_OW 258
10059: PUSH
10060: LD_INT 1
10062: EQUAL
10063: IFFALSE 10079
// Say ( kdo2 , D10-Sol1-2 ) else
10065: LD_VAR 0 2
10069: PPUSH
10070: LD_STRING D10-Sol1-2
10072: PPUSH
10073: CALL_OW 88
10077: GO 10091
// Say ( kdo2 , D10-FSol1-2 ) ;
10079: LD_VAR 0 2
10083: PPUSH
10084: LD_STRING D10-FSol1-2
10086: PPUSH
10087: CALL_OW 88
// TalkOff ;
10091: CALL 17284 0 0
// end ; end ;
10095: PPOPN 2
10097: END
// export function Dialog11aa ( kdo ) ; begin
10098: LD_INT 0
10100: PPUSH
// DialogueOn ;
10101: CALL_OW 6
// Say ( kdo , D11a-Sol2-1 ) ;
10105: LD_VAR 0 1
10109: PPUSH
10110: LD_STRING D11a-Sol2-1
10112: PPUSH
10113: CALL_OW 88
// WasD11aa := true ;
10117: LD_ADDR_EXP 69
10121: PUSH
10122: LD_INT 1
10124: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10125: LD_INT 35
10127: PPUSH
10128: CALL_OW 67
// DialogueOff ;
10132: CALL_OW 7
// end ;
10136: LD_VAR 0 2
10140: RET
// export function Dialog11ab ( kdo ) ; begin
10141: LD_INT 0
10143: PPUSH
// DialogueOn ;
10144: CALL_OW 6
// Say ( kdo , D11a-FSol2-1 ) ;
10148: LD_VAR 0 1
10152: PPUSH
10153: LD_STRING D11a-FSol2-1
10155: PPUSH
10156: CALL_OW 88
// WasD11ab := true ;
10160: LD_ADDR_EXP 70
10164: PUSH
10165: LD_INT 1
10167: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10168: LD_INT 35
10170: PPUSH
10171: CALL_OW 67
// DialogueOff ;
10175: CALL_OW 7
// end ;
10179: LD_VAR 0 2
10183: RET
// export function Dialog11b ( kdo ) ; begin
10184: LD_INT 0
10186: PPUSH
// DialogueOn ;
10187: CALL_OW 6
// Say ( kdo , D11b-Sol3-1 ) ;
10191: LD_VAR 0 1
10195: PPUSH
10196: LD_STRING D11b-Sol3-1
10198: PPUSH
10199: CALL_OW 88
// Say ( JMM , D11b-JMM-1 ) ;
10203: LD_EXP 15
10207: PPUSH
10208: LD_STRING D11b-JMM-1
10210: PPUSH
10211: CALL_OW 88
// WasD11b := true ;
10215: LD_ADDR_EXP 71
10219: PUSH
10220: LD_INT 1
10222: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10223: LD_INT 35
10225: PPUSH
10226: CALL_OW 67
// DialogueOff ;
10230: CALL_OW 7
// end ;
10234: LD_VAR 0 2
10238: RET
// export function Dialog11c ( kdo ) ; var dep ; begin
10239: LD_INT 0
10241: PPUSH
10242: PPUSH
// DialogueOn ;
10243: CALL_OW 6
// Say ( kdo , D11c-FSol3-1 ) ;
10247: LD_VAR 0 1
10251: PPUSH
10252: LD_STRING D11c-FSol3-1
10254: PPUSH
10255: CALL_OW 88
// dep := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) ;
10259: LD_ADDR_VAR 0 3
10263: PUSH
10264: LD_INT 22
10266: PUSH
10267: LD_EXP 1
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 2
10278: PUSH
10279: LD_INT 30
10281: PUSH
10282: LD_INT 1
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PUSH
10289: LD_INT 30
10291: PUSH
10292: LD_INT 0
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PPUSH
10308: CALL_OW 69
10312: ST_TO_ADDR
// if dep then
10313: LD_VAR 0 3
10317: IFFALSE 10355
// if GetDistUnits ( kdo , dep [ 1 ] ) > 30 then
10319: LD_VAR 0 1
10323: PPUSH
10324: LD_VAR 0 3
10328: PUSH
10329: LD_INT 1
10331: ARRAY
10332: PPUSH
10333: CALL_OW 296
10337: PUSH
10338: LD_INT 30
10340: GREATER
10341: IFFALSE 10355
// Say ( JMM , D11c-JMM-1 ) ;
10343: LD_EXP 15
10347: PPUSH
10348: LD_STRING D11c-JMM-1
10350: PPUSH
10351: CALL_OW 88
// WasD11c := true ;
10355: LD_ADDR_EXP 72
10359: PUSH
10360: LD_INT 1
10362: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10363: LD_INT 35
10365: PPUSH
10366: CALL_OW 67
// DialogueOff ;
10370: CALL_OW 7
// end ;
10374: LD_VAR 0 2
10378: RET
// export function Dialog11d ( kdo ) ; begin
10379: LD_INT 0
10381: PPUSH
// DialogueOn ;
10382: CALL_OW 6
// Say ( kdo , D11d-Sol4-1 ) ;
10386: LD_VAR 0 1
10390: PPUSH
10391: LD_STRING D11d-Sol4-1
10393: PPUSH
10394: CALL_OW 88
// Say ( JMM , D11d-JMM-1 ) ;
10398: LD_EXP 15
10402: PPUSH
10403: LD_STRING D11d-JMM-1
10405: PPUSH
10406: CALL_OW 88
// WasD11d := true ;
10410: LD_ADDR_EXP 73
10414: PUSH
10415: LD_INT 1
10417: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10418: LD_INT 35
10420: PPUSH
10421: CALL_OW 67
// DialogueOff ;
10425: CALL_OW 7
// end ;
10429: LD_VAR 0 2
10433: RET
// export function Dialog11e ( kdo ) ; begin
10434: LD_INT 0
10436: PPUSH
// DialogueOn ;
10437: CALL_OW 6
// Say ( kdo , D11e-FSol4-1 ) ;
10441: LD_VAR 0 1
10445: PPUSH
10446: LD_STRING D11e-FSol4-1
10448: PPUSH
10449: CALL_OW 88
// WasD11e := true ;
10453: LD_ADDR_EXP 74
10457: PUSH
10458: LD_INT 1
10460: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10461: LD_INT 35
10463: PPUSH
10464: CALL_OW 67
// DialogueOff ;
10468: CALL_OW 7
// end ;
10472: LD_VAR 0 2
10476: RET
// export function Dialog11f ( kdo ) ; begin
10477: LD_INT 0
10479: PPUSH
// DialogueOn ;
10480: CALL_OW 6
// Say ( kdo , D11f-Sol5-1 ) ;
10484: LD_VAR 0 1
10488: PPUSH
10489: LD_STRING D11f-Sol5-1
10491: PPUSH
10492: CALL_OW 88
// WasD11f := true ;
10496: LD_ADDR_EXP 75
10500: PUSH
10501: LD_INT 1
10503: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10504: LD_INT 35
10506: PPUSH
10507: CALL_OW 67
// DialogueOff ;
10511: CALL_OW 7
// end ;
10515: LD_VAR 0 2
10519: RET
// every 0 0$3 trigger FilterAllUnits ( [ [ f_control , control_remote ] ] ) and not FilterAllUnits ( [ [ f_btype , b_control_tower ] ] ) do var a ;
10520: LD_INT 33
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: PPUSH
10533: CALL_OW 69
10537: IFFALSE 10559
10539: PUSH
10540: LD_INT 30
10542: PUSH
10543: LD_INT 36
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PUSH
10550: EMPTY
10551: LIST
10552: PPUSH
10553: CALL_OW 69
10557: NOT
10558: AND
10559: IFFALSE 10672
10561: GO 10563
10563: DISABLE
10564: LD_INT 0
10566: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10567: LD_ADDR_VAR 0 1
10571: PUSH
10572: LD_EXP 11
10576: PPUSH
10577: LD_EXP 1
10581: PPUSH
10582: LD_INT 0
10584: PPUSH
10585: LD_INT 3
10587: PPUSH
10588: LD_INT 0
10590: PPUSH
10591: CALL 17380 0 5
10595: ST_TO_ADDR
// TalkOn ;
10596: CALL 17268 0 0
// if a then
10600: LD_VAR 0 1
10604: IFFALSE 10661
// if not SayAny ( a , D3a-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10606: LD_VAR 0 1
10610: PPUSH
10611: LD_STRING D3a-Mech1-1
10613: PPUSH
10614: LD_EXP 1
10618: PPUSH
10619: LD_INT 1
10621: PPUSH
10622: LD_INT 3
10624: PPUSH
10625: LD_INT 0
10627: PPUSH
10628: CALL 17300 0 6
10632: NOT
10633: IFFALSE 10661
// SayAny ( a , D3a-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10635: LD_VAR 0 1
10639: PPUSH
10640: LD_STRING D3a-FMech1-1
10642: PPUSH
10643: LD_EXP 1
10647: PPUSH
10648: LD_INT 2
10650: PPUSH
10651: LD_INT 3
10653: PPUSH
10654: LD_INT 0
10656: PPUSH
10657: CALL 17300 0 6
// TalkOff ;
10661: CALL 17284 0 0
// MyHint ( Linking ) ;
10665: LD_STRING Linking
10667: PPUSH
10668: CALL 17743 0 1
// end ;
10672: PPOPN 1
10674: END
// every 0 0$3 trigger not FilterAllUnits ( [ f_control , control_remote ] ) and maj_ct do var a ;
10675: LD_INT 33
10677: PUSH
10678: LD_INT 2
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PPUSH
10685: CALL_OW 69
10689: NOT
10690: IFFALSE 10698
10692: PUSH
10693: LD_EXP 95
10697: AND
10698: IFFALSE 10811
10700: GO 10702
10702: DISABLE
10703: LD_INT 0
10705: PPUSH
// begin a := WhoSayAny ( not_char , you , 0 , class_mechanic , 0 ) ;
10706: LD_ADDR_VAR 0 1
10710: PUSH
10711: LD_EXP 11
10715: PPUSH
10716: LD_EXP 1
10720: PPUSH
10721: LD_INT 0
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_INT 0
10729: PPUSH
10730: CALL 17380 0 5
10734: ST_TO_ADDR
// TalkOn ;
10735: CALL 17268 0 0
// if a then
10739: LD_VAR 0 1
10743: IFFALSE 10800
// if not SayAny ( a , D3b-Mech1-1 , you , sex_male , class_mechanic , 0 ) then
10745: LD_VAR 0 1
10749: PPUSH
10750: LD_STRING D3b-Mech1-1
10752: PPUSH
10753: LD_EXP 1
10757: PPUSH
10758: LD_INT 1
10760: PPUSH
10761: LD_INT 3
10763: PPUSH
10764: LD_INT 0
10766: PPUSH
10767: CALL 17300 0 6
10771: NOT
10772: IFFALSE 10800
// SayAny ( a , D3b-FMech1-1 , you , sex_female , class_mechanic , 0 ) ;
10774: LD_VAR 0 1
10778: PPUSH
10779: LD_STRING D3b-FMech1-1
10781: PPUSH
10782: LD_EXP 1
10786: PPUSH
10787: LD_INT 2
10789: PPUSH
10790: LD_INT 3
10792: PPUSH
10793: LD_INT 0
10795: PPUSH
10796: CALL 17300 0 6
// TalkOff ;
10800: CALL 17284 0 0
// MyHint ( Linking ) ;
10804: LD_STRING Linking
10806: PPUSH
10807: CALL 17743 0 1
// end ;
10811: PPOPN 1
10813: END
// every 0 0$3 do var who , i ;
10814: GO 10816
10816: DISABLE
10817: LD_INT 0
10819: PPUSH
10820: PPUSH
// begin who := [ ] ;
10821: LD_ADDR_VAR 0 1
10825: PUSH
10826: EMPTY
10827: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_btype , b_control_tower ] ) do
10828: LD_ADDR_VAR 0 2
10832: PUSH
10833: LD_INT 30
10835: PUSH
10836: LD_INT 36
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PPUSH
10843: CALL_OW 69
10847: PUSH
10848: FOR_IN
10849: IFFALSE 10889
// who := who ^ UnitFilter ( UnitsInside ( i ) , [ f_class , class_mechanic ] ) ;
10851: LD_ADDR_VAR 0 1
10855: PUSH
10856: LD_VAR 0 1
10860: PUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL_OW 313
10870: PPUSH
10871: LD_INT 25
10873: PUSH
10874: LD_INT 3
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PPUSH
10881: CALL_OW 72
10885: ADD
10886: ST_TO_ADDR
10887: GO 10848
10889: POP
10890: POP
// if FilterAllUnits ( [ f_control , control_remote ] ) and who then
10891: LD_INT 33
10893: PUSH
10894: LD_INT 2
10896: PUSH
10897: EMPTY
10898: LIST
10899: LIST
10900: PPUSH
10901: CALL_OW 69
10905: IFFALSE 10913
10907: PUSH
10908: LD_VAR 0 1
10912: AND
10913: IFFALSE 11025
// begin TalkOn ;
10915: CALL 17268 0 0
// who := who [ 1 ] ;
10919: LD_ADDR_VAR 0 1
10923: PUSH
10924: LD_VAR 0 1
10928: PUSH
10929: LD_INT 1
10931: ARRAY
10932: ST_TO_ADDR
// if JMM in who then
10933: LD_EXP 15
10937: PUSH
10938: LD_VAR 0 1
10942: IN
10943: IFFALSE 10959
// Say ( JMM , D4a-JMM-1 ) else
10945: LD_EXP 15
10949: PPUSH
10950: LD_STRING D4a-JMM-1
10952: PPUSH
10953: CALL_OW 88
10957: GO 11004
// begin if GetSex ( who [ 1 ] ) = sex_male then
10959: LD_VAR 0 1
10963: PUSH
10964: LD_INT 1
10966: ARRAY
10967: PPUSH
10968: CALL_OW 258
10972: PUSH
10973: LD_INT 1
10975: EQUAL
10976: IFFALSE 10992
// Say ( who , D4a-Mech1-1 ) else
10978: LD_VAR 0 1
10982: PPUSH
10983: LD_STRING D4a-Mech1-1
10985: PPUSH
10986: CALL_OW 88
10990: GO 11004
// Say ( who , D4a-FMech1-1 ) ;
10992: LD_VAR 0 1
10996: PPUSH
10997: LD_STRING D4a-FMech1-1
10999: PPUSH
11000: CALL_OW 88
// end ; remote_tried := true ;
11004: LD_ADDR_EXP 82
11008: PUSH
11009: LD_INT 1
11011: ST_TO_ADDR
// TalkOff ;
11012: CALL 17284 0 0
// MyHint ( Linking ) ;
11016: LD_STRING Linking
11018: PPUSH
11019: CALL 17743 0 1
// end else
11023: GO 11026
// enable ;
11025: ENABLE
// end ;
11026: PPOPN 2
11028: END
// every 0 0$3 do var who , facts , rems , ok , i , j ;
11029: GO 11031
11031: DISABLE
11032: LD_INT 0
11034: PPUSH
11035: PPUSH
11036: PPUSH
11037: PPUSH
11038: PPUSH
11039: PPUSH
// begin who := [ ] ;
11040: LD_ADDR_VAR 0 1
11044: PUSH
11045: EMPTY
11046: ST_TO_ADDR
// facts := FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_factory ] ] ) ;
11047: LD_ADDR_VAR 0 2
11051: PUSH
11052: LD_INT 22
11054: PUSH
11055: LD_EXP 1
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 30
11066: PUSH
11067: LD_INT 3
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: PPUSH
11078: CALL_OW 69
11082: ST_TO_ADDR
// rems := FilterAllUnits ( [ f_control , control_remote ] ) ;
11083: LD_ADDR_VAR 0 3
11087: PUSH
11088: LD_INT 33
11090: PUSH
11091: LD_INT 2
11093: PUSH
11094: EMPTY
11095: LIST
11096: LIST
11097: PPUSH
11098: CALL_OW 69
11102: ST_TO_ADDR
// for i in facts do
11103: LD_ADDR_VAR 0 5
11107: PUSH
11108: LD_VAR 0 2
11112: PUSH
11113: FOR_IN
11114: IFFALSE 11165
// for j in rems do
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: LD_VAR 0 3
11125: PUSH
11126: FOR_IN
11127: IFFALSE 11161
// if GetDistUnits ( i , j ) > 9 then
11129: LD_VAR 0 5
11133: PPUSH
11134: LD_VAR 0 6
11138: PPUSH
11139: CALL_OW 296
11143: PUSH
11144: LD_INT 9
11146: GREATER
11147: IFFALSE 11159
// ok := j ;
11149: LD_ADDR_VAR 0 4
11153: PUSH
11154: LD_VAR 0 6
11158: ST_TO_ADDR
11159: GO 11126
11161: POP
11162: POP
11163: GO 11113
11165: POP
11166: POP
// if ok then
11167: LD_VAR 0 4
11171: IFFALSE 11276
// begin TalkOn ;
11173: CALL 17268 0 0
// who := IsControledBy ( ok ) ;
11177: LD_ADDR_VAR 0 1
11181: PUSH
11182: LD_VAR 0 4
11186: PPUSH
11187: CALL_OW 312
11191: ST_TO_ADDR
// if JMM in who then
11192: LD_EXP 15
11196: PUSH
11197: LD_VAR 0 1
11201: IN
11202: IFFALSE 11218
// Say ( JMM , D4b-JMM-1 ) else
11204: LD_EXP 15
11208: PPUSH
11209: LD_STRING D4b-JMM-1
11211: PPUSH
11212: CALL_OW 88
11216: GO 11263
// begin if GetSex ( who [ 1 ] ) = sex_male then
11218: LD_VAR 0 1
11222: PUSH
11223: LD_INT 1
11225: ARRAY
11226: PPUSH
11227: CALL_OW 258
11231: PUSH
11232: LD_INT 1
11234: EQUAL
11235: IFFALSE 11251
// Say ( who , D4b-Mech1-1 ) else
11237: LD_VAR 0 1
11241: PPUSH
11242: LD_STRING D4b-Mech1-1
11244: PPUSH
11245: CALL_OW 88
11249: GO 11263
// Say ( who , D4b-FMech1-1 ) ;
11251: LD_VAR 0 1
11255: PPUSH
11256: LD_STRING D4b-FMech1-1
11258: PPUSH
11259: CALL_OW 88
// end ; TalkOff ;
11263: CALL 17284 0 0
// MyHint ( RemoteControlling ) ;
11267: LD_STRING RemoteControlling
11269: PPUSH
11270: CALL 17743 0 1
// end else
11274: GO 11277
// enable ;
11276: ENABLE
// end ;
11277: PPOPN 6
11279: END
// every 4 4$30 do
11280: GO 11282
11282: DISABLE
// begin TalkOn ;
11283: CALL 17268 0 0
// SayRadio ( RadioSci , D12a-Sci-1 ) ;
11287: LD_EXP 17
11291: PPUSH
11292: LD_STRING D12a-Sci-1
11294: PPUSH
11295: CALL_OW 94
// Say ( JMM , D12a-JMM-1 ) ;
11299: LD_EXP 15
11303: PPUSH
11304: LD_STRING D12a-JMM-1
11306: PPUSH
11307: CALL_OW 88
// TalkOff ;
11311: CALL 17284 0 0
// end ;
11315: END
// every 14 14$0 do
11316: GO 11318
11318: DISABLE
// begin TalkOn ;
11319: CALL 17268 0 0
// SayRadio ( RadioSci , D12b-Sci-1 ) ;
11323: LD_EXP 17
11327: PPUSH
11328: LD_STRING D12b-Sci-1
11330: PPUSH
11331: CALL_OW 94
// TalkOff ;
11335: CALL 17284 0 0
// end ;
11339: END
// every 16 16$0 do
11340: GO 11342
11342: DISABLE
// begin TalkOn ;
11343: CALL 17268 0 0
// SayRadio ( RadioSci , D12c-Sci-1 ) ;
11347: LD_EXP 17
11351: PPUSH
11352: LD_STRING D12c-Sci-1
11354: PPUSH
11355: CALL_OW 94
// TalkOff ;
11359: CALL 17284 0 0
// end ;
11363: END
// every 34 34$0 do
11364: GO 11366
11366: DISABLE
// begin TalkOn ;
11367: CALL 17268 0 0
// SayRadio ( RadioSci , D12d-Sci-1 ) ;
11371: LD_EXP 17
11375: PPUSH
11376: LD_STRING D12d-Sci-1
11378: PPUSH
11379: CALL_OW 94
// TalkOff ;
11383: CALL 17284 0 0
// end ;
11387: END
// every 46 46$0 do
11388: GO 11390
11390: DISABLE
// begin TalkOn ;
11391: CALL 17268 0 0
// SayRadio ( RadioSci , D12e-Sci-1 ) ;
11395: LD_EXP 17
11399: PPUSH
11400: LD_STRING D12e-Sci-1
11402: PPUSH
11403: CALL_OW 94
// Say ( JMM , D12e-JMM-1 ) ;
11407: LD_EXP 15
11411: PPUSH
11412: LD_STRING D12e-JMM-1
11414: PPUSH
11415: CALL_OW 88
// TalkOff ;
11419: CALL 17284 0 0
// end ;
11423: END
// on DestinationUnreachable ( unit ) do begin if unit = Kurt then
11424: LD_VAR 0 1
11428: PUSH
11429: LD_EXP 43
11433: EQUAL
11434: IFFALSE 11448
// begin ComMoveToArea ( Kurt , border ) ;
11436: LD_EXP 43
11440: PPUSH
11441: LD_INT 10
11443: PPUSH
11444: CALL_OW 113
// end ; end ; end_of_file
11448: PPOPN 1
11450: END
// var objevovani_zasilek ; every 0 0$0.1 do
11451: GO 11453
11453: DISABLE
// begin objevovani_zasilek := [ [ 4 , 3 , 7 , 2 , 0 , 2 , 5 , 3 , 1 , 1 ] , [ 4 , 4 , 8 , 2 , 0 , 2 , 5 , 4 , 2 , 1 ] , [ 4 , 3 , 8 , 1 , 0 , 2 , 6 , 5 , 3 , 1 ] ] [ difficulty ] ;
11454: LD_ADDR_LOC 1
11458: PUSH
11459: LD_INT 4
11461: PUSH
11462: LD_INT 3
11464: PUSH
11465: LD_INT 7
11467: PUSH
11468: LD_INT 2
11470: PUSH
11471: LD_INT 0
11473: PUSH
11474: LD_INT 2
11476: PUSH
11477: LD_INT 5
11479: PUSH
11480: LD_INT 3
11482: PUSH
11483: LD_INT 1
11485: PUSH
11486: LD_INT 1
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: PUSH
11501: LD_INT 4
11503: PUSH
11504: LD_INT 4
11506: PUSH
11507: LD_INT 8
11509: PUSH
11510: LD_INT 2
11512: PUSH
11513: LD_INT 0
11515: PUSH
11516: LD_INT 2
11518: PUSH
11519: LD_INT 5
11521: PUSH
11522: LD_INT 4
11524: PUSH
11525: LD_INT 2
11527: PUSH
11528: LD_INT 1
11530: PUSH
11531: EMPTY
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: PUSH
11543: LD_INT 4
11545: PUSH
11546: LD_INT 3
11548: PUSH
11549: LD_INT 8
11551: PUSH
11552: LD_INT 1
11554: PUSH
11555: LD_INT 0
11557: PUSH
11558: LD_INT 2
11560: PUSH
11561: LD_INT 6
11563: PUSH
11564: LD_INT 5
11566: PUSH
11567: LD_INT 3
11569: PUSH
11570: LD_INT 1
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: LIST
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: LIST
11589: PUSH
11590: LD_OWVAR 67
11594: ARRAY
11595: ST_TO_ADDR
// Randomize ;
11596: CALL_OW 10
// end ;
11600: END
// every 0 0$10 do
11601: GO 11603
11603: DISABLE
// begin Randomize ;
11604: CALL_OW 10
// enable ;
11608: ENABLE
// end ;
11609: END
// every 0 0$1 trigger start_game do
11610: LD_EXP 55
11614: IFFALSE 11658
11616: GO 11618
11618: DISABLE
// begin Wait ( Rand ( 0 0$10 , 0 0$25 ) ) ;
11619: LD_INT 350
11621: PPUSH
11622: LD_INT 875
11624: PPUSH
11625: CALL_OW 12
11629: PPUSH
11630: CALL_OW 67
// CreateCratesArea ( 5 , first_crate , true ) ;
11634: LD_INT 5
11636: PPUSH
11637: LD_INT 3
11639: PPUSH
11640: LD_INT 1
11642: PPUSH
11643: CALL_OW 55
// wait ( 0 0$5 ) ;
11647: LD_INT 175
11649: PPUSH
11650: CALL_OW 67
// DialogR0 ;
11654: CALL 5905 0 0
// end ;
11658: END
// every 0 0$15 do
11659: GO 11661
11661: DISABLE
// begin bum_bedny ;
11662: CALL 11676 0 0
// end ;
11666: END
// every 5 5$0 + 0 0$20 marked 567 do
11667: GO 11669
11669: DISABLE
// begin enable ;
11670: ENABLE
// bum_bedny ;
11671: CALL 11676 0 0
// end ;
11675: END
// function bum_bedny ; var x , w , i , hex , cek , cek2 , last , min5 ; begin
11676: LD_INT 0
11678: PPUSH
11679: PPUSH
11680: PPUSH
11681: PPUSH
11682: PPUSH
11683: PPUSH
11684: PPUSH
11685: PPUSH
11686: PPUSH
// min5 := ( tick div 5 5$0 ) + 1 ;
11687: LD_ADDR_VAR 0 9
11691: PUSH
11692: LD_OWVAR 1
11696: PUSH
11697: LD_INT 10500
11699: DIV
11700: PUSH
11701: LD_INT 1
11703: PLUS
11704: ST_TO_ADDR
// cek := [ ] ;
11705: LD_ADDR_VAR 0 6
11709: PUSH
11710: EMPTY
11711: ST_TO_ADDR
// cek2 := [ ] ;
11712: LD_ADDR_VAR 0 7
11716: PUSH
11717: EMPTY
11718: ST_TO_ADDR
// last := 0 ;
11719: LD_ADDR_VAR 0 8
11723: PUSH
11724: LD_INT 0
11726: ST_TO_ADDR
// x := objevovani_zasilek [ min5 ] ;
11727: LD_ADDR_VAR 0 2
11731: PUSH
11732: LD_LOC 1
11736: PUSH
11737: LD_VAR 0 9
11741: ARRAY
11742: ST_TO_ADDR
// for i := 1 to x * 2 do
11743: LD_ADDR_VAR 0 4
11747: PUSH
11748: DOUBLE
11749: LD_INT 1
11751: DEC
11752: ST_TO_ADDR
11753: LD_VAR 0 2
11757: PUSH
11758: LD_INT 2
11760: MUL
11761: PUSH
11762: FOR_TO
11763: IFFALSE 11789
// cek := cek ^ Rand ( 0 0$15 , 5 5$0 ) ;
11765: LD_ADDR_VAR 0 6
11769: PUSH
11770: LD_VAR 0 6
11774: PUSH
11775: LD_INT 525
11777: PPUSH
11778: LD_INT 10500
11780: PPUSH
11781: CALL_OW 12
11785: ADD
11786: ST_TO_ADDR
11787: GO 11762
11789: POP
11790: POP
// cek := SortListByListAsc ( cek , cek ) ;
11791: LD_ADDR_VAR 0 6
11795: PUSH
11796: LD_VAR 0 6
11800: PPUSH
11801: LD_VAR 0 6
11805: PPUSH
11806: CALL_OW 76
11810: ST_TO_ADDR
// for i in cek do
11811: LD_ADDR_VAR 0 4
11815: PUSH
11816: LD_VAR 0 6
11820: PUSH
11821: FOR_IN
11822: IFFALSE 11858
// begin cek2 := cek2 ^ i - last ;
11824: LD_ADDR_VAR 0 7
11828: PUSH
11829: LD_VAR 0 7
11833: PUSH
11834: LD_VAR 0 4
11838: PUSH
11839: LD_VAR 0 8
11843: MINUS
11844: ADD
11845: ST_TO_ADDR
// last := i ;
11846: LD_ADDR_VAR 0 8
11850: PUSH
11851: LD_VAR 0 4
11855: ST_TO_ADDR
// end ;
11856: GO 11821
11858: POP
11859: POP
// for i := 1 to x do
11860: LD_ADDR_VAR 0 4
11864: PUSH
11865: DOUBLE
11866: LD_INT 1
11868: DEC
11869: ST_TO_ADDR
11870: LD_VAR 0 2
11874: PUSH
11875: FOR_TO
11876: IFFALSE 12107
// begin hex := RandHexArea ( bottom_bigger , false ) ;
11878: LD_ADDR_VAR 0 5
11882: PUSH
11883: LD_INT 8
11885: PPUSH
11886: LD_INT 0
11888: PPUSH
11889: CALL_OW 16
11893: ST_TO_ADDR
// crates := crates ^ [ hex ] ;
11894: LD_ADDR_EXP 76
11898: PUSH
11899: LD_EXP 76
11903: PUSH
11904: LD_VAR 0 5
11908: PUSH
11909: EMPTY
11910: LIST
11911: ADD
11912: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
11913: LD_INT 5
11915: PPUSH
11916: LD_VAR 0 5
11920: PUSH
11921: LD_INT 1
11923: ARRAY
11924: PPUSH
11925: LD_VAR 0 5
11929: PUSH
11930: LD_INT 2
11932: ARRAY
11933: PPUSH
11934: LD_INT 1
11936: PPUSH
11937: CALL_OW 54
// Wait ( cek2 [ i * 2 - 1 ] ) ;
11941: LD_VAR 0 7
11945: PUSH
11946: LD_VAR 0 4
11950: PUSH
11951: LD_INT 2
11953: MUL
11954: PUSH
11955: LD_INT 1
11957: MINUS
11958: ARRAY
11959: PPUSH
11960: CALL_OW 67
// hex := RandHexArea ( top_bigger , false ) ;
11964: LD_ADDR_VAR 0 5
11968: PUSH
11969: LD_INT 7
11971: PPUSH
11972: LD_INT 0
11974: PPUSH
11975: CALL_OW 16
11979: ST_TO_ADDR
// if more_scouting then
11980: LD_EXP 61
11984: IFFALSE 12005
// crates := crates ^ [ hex ] ;
11986: LD_ADDR_EXP 76
11990: PUSH
11991: LD_EXP 76
11995: PUSH
11996: LD_VAR 0 5
12000: PUSH
12001: EMPTY
12002: LIST
12003: ADD
12004: ST_TO_ADDR
// CreateCratesXY ( 5 , hex [ 1 ] , hex [ 2 ] , true ) ;
12005: LD_INT 5
12007: PPUSH
12008: LD_VAR 0 5
12012: PUSH
12013: LD_INT 1
12015: ARRAY
12016: PPUSH
12017: LD_VAR 0 5
12021: PUSH
12022: LD_INT 2
12024: ARRAY
12025: PPUSH
12026: LD_INT 1
12028: PPUSH
12029: CALL_OW 54
// if not was_dialogR0 and GetDistUnitXY ( JMM , hex [ 1 ] , hex [ 2 ] ) > 30 then
12033: LD_EXP 88
12037: NOT
12038: IFFALSE 12073
12040: PUSH
12041: LD_EXP 15
12045: PPUSH
12046: LD_VAR 0 5
12050: PUSH
12051: LD_INT 1
12053: ARRAY
12054: PPUSH
12055: LD_VAR 0 5
12059: PUSH
12060: LD_INT 2
12062: ARRAY
12063: PPUSH
12064: CALL_OW 297
12068: PUSH
12069: LD_INT 30
12071: GREATER
12072: AND
12073: IFFALSE 12086
// begin wait ( 0 0$6 ) ;
12075: LD_INT 210
12077: PPUSH
12078: CALL_OW 67
// DialogR0 ;
12082: CALL 5905 0 0
// end ; Wait ( cek2 [ i * 2 ] ) ;
12086: LD_VAR 0 7
12090: PUSH
12091: LD_VAR 0 4
12095: PUSH
12096: LD_INT 2
12098: MUL
12099: ARRAY
12100: PPUSH
12101: CALL_OW 67
// end ;
12105: GO 11875
12107: POP
12108: POP
// if min5 = ( objevovani_zasilek + 0 ) then
12109: LD_VAR 0 9
12113: PUSH
12114: LD_LOC 1
12118: PUSH
12119: LD_INT 0
12121: PLUS
12122: EQUAL
12123: IFFALSE 12128
// disable ( 567 ) ;
12125: LD_INT 567
12127: DISABLE_MARKED
// end ;
12128: LD_VAR 0 1
12132: RET
// every 5 5$0 + 5 5$20 trigger start_game do var a , un , counter , h ;
12133: LD_EXP 55
12137: IFFALSE 12962
12139: GO 12141
12141: DISABLE
12142: LD_INT 0
12144: PPUSH
12145: PPUSH
12146: PPUSH
12147: PPUSH
// begin a := prilet_rusaci union prilet_tvoji ;
12148: LD_ADDR_VAR 0 1
12152: PUSH
12153: LD_EXP 7
12157: PUSH
12158: LD_EXP 6
12162: UNION
12163: ST_TO_ADDR
// if a then
12164: LD_VAR 0 1
12168: IFFALSE 12962
// begin un := a [ Rand ( 1 , ( a + 0 ) ) ] ;
12170: LD_ADDR_VAR 0 2
12174: PUSH
12175: LD_VAR 0 1
12179: PUSH
12180: LD_INT 1
12182: PPUSH
12183: LD_VAR 0 1
12187: PUSH
12188: LD_INT 0
12190: PLUS
12191: PPUSH
12192: CALL_OW 12
12196: ARRAY
12197: ST_TO_ADDR
// if prilet_tvoji = 2 and Getside ( un ) = you then
12198: LD_EXP 6
12202: PUSH
12203: LD_INT 2
12205: EQUAL
12206: IFFALSE 12225
12208: PUSH
12209: LD_VAR 0 2
12213: PPUSH
12214: CALL_OW 255
12218: PUSH
12219: LD_EXP 1
12223: EQUAL
12224: AND
12225: IFFALSE 12244
// begin PlaceUnitArea ( un , lidi_base , true ) ;
12227: LD_VAR 0 2
12231: PPUSH
12232: LD_INT 15
12234: PPUSH
12235: LD_INT 1
12237: PPUSH
12238: CALL_OW 49
// end else
12242: GO 12584
// begin if Rand ( 1 , 2 ) = 1 then
12244: LD_INT 1
12246: PPUSH
12247: LD_INT 2
12249: PPUSH
12250: CALL_OW 12
12254: PUSH
12255: LD_INT 1
12257: EQUAL
12258: IFFALSE 12423
// begin counter := 0 ;
12260: LD_ADDR_VAR 0 3
12264: PUSH
12265: LD_INT 0
12267: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_bottom , false ) ;
12268: LD_ADDR_VAR 0 4
12272: PUSH
12273: LD_INT 14
12275: PPUSH
12276: LD_INT 0
12278: PPUSH
12279: CALL_OW 16
12283: ST_TO_ADDR
// counter := counter + 1 ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: LD_VAR 0 3
12293: PUSH
12294: LD_INT 1
12296: PLUS
12297: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12298: LD_VAR 0 2
12302: PPUSH
12303: CALL_OW 255
12307: PUSH
12308: LD_EXP 2
12312: EQUAL
12313: IFTRUE 12325
12315: PUSH
12316: LD_VAR 0 3
12320: PUSH
12321: LD_INT 200
12323: GREATER
12324: OR
12325: IFTRUE 12357
12327: PUSH
12328: LD_EXP 2
12332: PPUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_VAR 0 4
12346: PUSH
12347: LD_INT 2
12349: ARRAY
12350: PPUSH
12351: CALL_OW 293
12355: NOT
12356: OR
12357: IFFALSE 12268
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12359: LD_VAR 0 2
12363: PPUSH
12364: LD_VAR 0 4
12368: PUSH
12369: LD_INT 1
12371: ARRAY
12372: PPUSH
12373: LD_VAR 0 4
12377: PUSH
12378: LD_INT 2
12380: ARRAY
12381: PPUSH
12382: LD_INT 1
12384: PPUSH
12385: CALL_OW 48
12389: IFTRUE 12401
12391: PUSH
12392: LD_VAR 0 3
12396: PUSH
12397: LD_INT 200
12399: GREATER
12400: OR
12401: IFFALSE 12268
// if counter > 200 then
12403: LD_VAR 0 3
12407: PUSH
12408: LD_INT 200
12410: GREATER
12411: IFFALSE 12421
// un := 0 ;
12413: LD_ADDR_VAR 0 2
12417: PUSH
12418: LD_INT 0
12420: ST_TO_ADDR
// end else
12421: GO 12584
// begin counter := 0 ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 0
12430: ST_TO_ADDR
// repeat repeat h := RandHexArea ( lidi_top , false ) ;
12431: LD_ADDR_VAR 0 4
12435: PUSH
12436: LD_INT 17
12438: PPUSH
12439: LD_INT 0
12441: PPUSH
12442: CALL_OW 16
12446: ST_TO_ADDR
// counter := counter + 1 ;
12447: LD_ADDR_VAR 0 3
12451: PUSH
12452: LD_VAR 0 3
12456: PUSH
12457: LD_INT 1
12459: PLUS
12460: ST_TO_ADDR
// until Getside ( un ) = russians or counter > 200 or not SeeXY ( russians , h [ 1 ] , h [ 2 ] ) ;
12461: LD_VAR 0 2
12465: PPUSH
12466: CALL_OW 255
12470: PUSH
12471: LD_EXP 2
12475: EQUAL
12476: IFTRUE 12488
12478: PUSH
12479: LD_VAR 0 3
12483: PUSH
12484: LD_INT 200
12486: GREATER
12487: OR
12488: IFTRUE 12520
12490: PUSH
12491: LD_EXP 2
12495: PPUSH
12496: LD_VAR 0 4
12500: PUSH
12501: LD_INT 1
12503: ARRAY
12504: PPUSH
12505: LD_VAR 0 4
12509: PUSH
12510: LD_INT 2
12512: ARRAY
12513: PPUSH
12514: CALL_OW 293
12518: NOT
12519: OR
12520: IFFALSE 12431
// until PlaceUnitXY ( un , h [ 1 ] , h [ 2 ] , true ) or counter > 200 ;
12522: LD_VAR 0 2
12526: PPUSH
12527: LD_VAR 0 4
12531: PUSH
12532: LD_INT 1
12534: ARRAY
12535: PPUSH
12536: LD_VAR 0 4
12540: PUSH
12541: LD_INT 2
12543: ARRAY
12544: PPUSH
12545: LD_INT 1
12547: PPUSH
12548: CALL_OW 48
12552: IFTRUE 12564
12554: PUSH
12555: LD_VAR 0 3
12559: PUSH
12560: LD_INT 200
12562: GREATER
12563: OR
12564: IFFALSE 12431
// if counter > 200 then
12566: LD_VAR 0 3
12570: PUSH
12571: LD_INT 200
12573: GREATER
12574: IFFALSE 12584
// un := 0 ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_INT 0
12583: ST_TO_ADDR
// end ; end ; Wait ( 0 0$4 ) ;
12584: LD_INT 140
12586: PPUSH
12587: CALL_OW 67
// if un in prilet_rusaci then
12591: LD_VAR 0 2
12595: PUSH
12596: LD_EXP 7
12600: IN
12601: IFFALSE 12765
// begin prilet_rusaci := prilet_rusaci diff un ;
12603: LD_ADDR_EXP 7
12607: PUSH
12608: LD_EXP 7
12612: PUSH
12613: LD_VAR 0 2
12617: DIFF
12618: ST_TO_ADDR
// ComWait ( un , 0 0$3 ) ;
12619: LD_VAR 0 2
12623: PPUSH
12624: LD_INT 105
12626: PPUSH
12627: CALL_OW 142
// AddComMoveXY ( un , 122 , 84 ) ;
12631: LD_VAR 0 2
12635: PPUSH
12636: LD_INT 122
12638: PPUSH
12639: LD_INT 84
12641: PPUSH
12642: CALL_OW 171
// case GetClass ( un ) of class_soldier :
12646: LD_VAR 0 2
12650: PPUSH
12651: CALL_OW 257
12655: PUSH
12656: LD_INT 1
12658: DOUBLE
12659: EQUAL
12660: IFTRUE 12664
12662: GO 12683
12664: POP
// sol := sol ^ un ; class_engineer :
12665: LD_ADDR_EXP 91
12669: PUSH
12670: LD_EXP 91
12674: PUSH
12675: LD_VAR 0 2
12679: ADD
12680: ST_TO_ADDR
12681: GO 12765
12683: LD_INT 2
12685: DOUBLE
12686: EQUAL
12687: IFTRUE 12691
12689: GO 12710
12691: POP
// eng := eng ^ un ; class_scientistic :
12692: LD_ADDR_EXP 94
12696: PUSH
12697: LD_EXP 94
12701: PUSH
12702: LD_VAR 0 2
12706: ADD
12707: ST_TO_ADDR
12708: GO 12765
12710: LD_INT 4
12712: DOUBLE
12713: EQUAL
12714: IFTRUE 12718
12716: GO 12737
12718: POP
// sci := sci ^ un ; class_mechanic :
12719: LD_ADDR_EXP 92
12723: PUSH
12724: LD_EXP 92
12728: PUSH
12729: LD_VAR 0 2
12733: ADD
12734: ST_TO_ADDR
12735: GO 12765
12737: LD_INT 3
12739: DOUBLE
12740: EQUAL
12741: IFTRUE 12745
12743: GO 12764
12745: POP
// mec := mec ^ un ; end ;
12746: LD_ADDR_EXP 93
12750: PUSH
12751: LD_EXP 93
12755: PUSH
12756: LD_VAR 0 2
12760: ADD
12761: ST_TO_ADDR
12762: GO 12765
12764: POP
// end ; if un in prilet_tvoji then
12765: LD_VAR 0 2
12769: PUSH
12770: LD_EXP 6
12774: IN
12775: IFFALSE 12961
// begin prilet_tvoji := prilet_tvoji diff un ;
12777: LD_ADDR_EXP 6
12781: PUSH
12782: LD_EXP 6
12786: PUSH
12787: LD_VAR 0 2
12791: DIFF
12792: ST_TO_ADDR
// if IsInArea ( un , base ) then
12793: LD_VAR 0 2
12797: PPUSH
12798: LD_INT 5
12800: PPUSH
12801: CALL_OW 308
12805: IFFALSE 12858
// begin if GetSex ( un ) = sex_male then
12807: LD_VAR 0 2
12811: PPUSH
12812: CALL_OW 258
12816: PUSH
12817: LD_INT 1
12819: EQUAL
12820: IFFALSE 12856
// if not WasD11aa then
12822: LD_EXP 69
12826: NOT
12827: IFFALSE 12840
// Dialog11aa ( un ) else
12829: LD_VAR 0 2
12833: PPUSH
12834: CALL 10098 0 1
12838: GO 12856
// if not WasD11ab then
12840: LD_EXP 70
12844: NOT
12845: IFFALSE 12856
// Dialog11ab ( un ) ;
12847: LD_VAR 0 2
12851: PPUSH
12852: CALL 10141 0 1
// end else
12856: GO 12961
// begin if GetSex ( un ) = sex_female then
12858: LD_VAR 0 2
12862: PPUSH
12863: CALL_OW 258
12867: PUSH
12868: LD_INT 2
12870: EQUAL
12871: IFFALSE 12909
// begin if not WasD11c then
12873: LD_EXP 72
12877: NOT
12878: IFFALSE 12891
// Dialog11c ( un ) else
12880: LD_VAR 0 2
12884: PPUSH
12885: CALL 10239 0 1
12889: GO 12907
// if not WasD11e then
12891: LD_EXP 74
12895: NOT
12896: IFFALSE 12907
// Dialog11e ( un ) ;
12898: LD_VAR 0 2
12902: PPUSH
12903: CALL 10434 0 1
// end else
12907: GO 12961
// begin if not WasD11b then
12909: LD_EXP 71
12913: NOT
12914: IFFALSE 12927
// Dialog11b ( un ) else
12916: LD_VAR 0 2
12920: PPUSH
12921: CALL 10184 0 1
12925: GO 12961
// if not WasD11d then
12927: LD_EXP 73
12931: NOT
12932: IFFALSE 12945
// Dialog11d ( un ) else
12934: LD_VAR 0 2
12938: PPUSH
12939: CALL 10379 0 1
12943: GO 12961
// if not WasD11f then
12945: LD_EXP 75
12949: NOT
12950: IFFALSE 12961
// Dialog11f ( un ) ;
12952: LD_VAR 0 2
12956: PPUSH
12957: CALL 10477 0 1
// end ; end ; end ; enable ;
12961: ENABLE
// end ; end ;
12962: PPOPN 4
12964: END
// every 10 10$0 + 2 2$30 trigger start_game do var a4 , b4 , b5 , c4 , d4 , ia4 , max4 , h ;
12965: LD_EXP 55
12969: IFFALSE 13537
12971: GO 12973
12973: DISABLE
12974: LD_INT 0
12976: PPUSH
12977: PPUSH
12978: PPUSH
12979: PPUSH
12980: PPUSH
12981: PPUSH
12982: PPUSH
12983: PPUSH
// begin ne_v_boji ;
12984: CALL 13540 0 0
// repeat wait ( 0 0$3 ) ;
12988: LD_INT 105
12990: PPUSH
12991: CALL_OW 67
// b4 := FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_american ] , [ f_type , unit_human ] , [ f_ok ] , [ f_outside ] ] ) diff [ JMM , Joan ] ;
12995: LD_ADDR_VAR 0 2
12999: PUSH
13000: LD_INT 22
13002: PUSH
13003: LD_EXP 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: LD_INT 23
13014: PUSH
13015: LD_INT 1
13017: PUSH
13018: EMPTY
13019: LIST
13020: LIST
13021: PUSH
13022: LD_INT 21
13024: PUSH
13025: LD_INT 1
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: PUSH
13032: LD_INT 50
13034: PUSH
13035: EMPTY
13036: LIST
13037: PUSH
13038: LD_INT 56
13040: PUSH
13041: EMPTY
13042: LIST
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: PPUSH
13051: CALL_OW 69
13055: PUSH
13056: LD_EXP 15
13060: PUSH
13061: LD_EXP 33
13065: PUSH
13066: EMPTY
13067: LIST
13068: LIST
13069: DIFF
13070: ST_TO_ADDR
// until b4 and not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] , [ f_type , unit_building ] , [ f_occupied ] ] , [ f_dist , JMM , 40 ] ] ) ;
13071: LD_VAR 0 2
13075: IFFALSE 13163
13077: PUSH
13078: LD_INT 22
13080: PUSH
13081: LD_EXP 2
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: PUSH
13090: LD_INT 2
13092: PUSH
13093: LD_INT 21
13095: PUSH
13096: LD_INT 1
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 21
13105: PUSH
13106: LD_INT 2
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: LD_INT 21
13115: PUSH
13116: LD_INT 3
13118: PUSH
13119: EMPTY
13120: LIST
13121: LIST
13122: PUSH
13123: LD_INT 59
13125: PUSH
13126: EMPTY
13127: LIST
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_INT 91
13138: PUSH
13139: LD_EXP 15
13143: PUSH
13144: LD_INT 40
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: LIST
13151: PUSH
13152: EMPTY
13153: LIST
13154: LIST
13155: LIST
13156: PPUSH
13157: CALL_OW 69
13161: NOT
13162: AND
13163: IFFALSE 12988
// max4 := 1000 ;
13165: LD_ADDR_VAR 0 7
13169: PUSH
13170: LD_INT 1000
13172: ST_TO_ADDR
// if Rand ( 1 , 5 ) <= 4 then
13173: LD_INT 1
13175: PPUSH
13176: LD_INT 5
13178: PPUSH
13179: CALL_OW 12
13183: PUSH
13184: LD_INT 4
13186: LESSEQUAL
13187: IFFALSE 13270
// begin for ia4 in b4 do
13189: LD_ADDR_VAR 0 6
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13268
// begin d4 := GetDistUnits ( JMM , ia4 ) ;
13202: LD_ADDR_VAR 0 5
13206: PUSH
13207: LD_EXP 15
13211: PPUSH
13212: LD_VAR 0 6
13216: PPUSH
13217: CALL_OW 296
13221: ST_TO_ADDR
// if d4 > 5 and d4 < max4 then
13222: LD_VAR 0 5
13226: PUSH
13227: LD_INT 5
13229: GREATER
13230: IFFALSE 13244
13232: PUSH
13233: LD_VAR 0 5
13237: PUSH
13238: LD_VAR 0 7
13242: LESS
13243: AND
13244: IFFALSE 13266
// begin max4 := d4 ;
13246: LD_ADDR_VAR 0 7
13250: PUSH
13251: LD_VAR 0 5
13255: ST_TO_ADDR
// c4 := ia4 ;
13256: LD_ADDR_VAR 0 4
13260: PUSH
13261: LD_VAR 0 6
13265: ST_TO_ADDR
// end ; end ;
13266: GO 13199
13268: POP
13269: POP
// end ; if max4 > 11 then
13270: LD_VAR 0 7
13274: PUSH
13275: LD_INT 11
13277: GREATER
13278: IFFALSE 13290
// c4 := JMM ;
13280: LD_ADDR_VAR 0 4
13284: PUSH
13285: LD_EXP 15
13289: ST_TO_ADDR
// a4 := 0 ;
13290: LD_ADDR_VAR 0 1
13294: PUSH
13295: LD_INT 0
13297: ST_TO_ADDR
// if not Kurt_P and not Joan_P then
13298: LD_EXP 47
13302: NOT
13303: IFFALSE 13312
13305: PUSH
13306: LD_EXP 48
13310: NOT
13311: AND
13312: IFFALSE 13330
// a4 := Rand ( 1 , 2 ) ;
13314: LD_ADDR_VAR 0 1
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 2
13324: PPUSH
13325: CALL_OW 12
13329: ST_TO_ADDR
// if ( not Kurt_P and a4 = 0 ) or a4 = 1 then
13330: LD_EXP 47
13334: NOT
13335: IFFALSE 13347
13337: PUSH
13338: LD_VAR 0 1
13342: PUSH
13343: LD_INT 0
13345: EQUAL
13346: AND
13347: IFTRUE 13359
13349: PUSH
13350: LD_VAR 0 1
13354: PUSH
13355: LD_INT 1
13357: EQUAL
13358: OR
13359: IFFALSE 13435
// begin SetAttitude ( arabians , you , att_friend , true ) ;
13361: LD_EXP 3
13365: PPUSH
13366: LD_EXP 1
13370: PPUSH
13371: LD_INT 1
13373: PPUSH
13374: LD_INT 1
13376: PPUSH
13377: CALL_OW 80
// if PlaceUnitXYR ( Kurt , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13381: LD_EXP 43
13385: PPUSH
13386: LD_VAR 0 4
13390: PPUSH
13391: CALL_OW 250
13395: PPUSH
13396: LD_VAR 0 4
13400: PPUSH
13401: CALL_OW 251
13405: PPUSH
13406: LD_INT 8
13408: PPUSH
13409: LD_INT 1
13411: PPUSH
13412: CALL_OW 50
13416: IFFALSE 13435
// begin Kurt_P := true ;
13418: LD_ADDR_EXP 47
13422: PUSH
13423: LD_INT 1
13425: ST_TO_ADDR
// DialogKurt ( c4 ) ;
13426: LD_VAR 0 4
13430: PPUSH
13431: CALL 6861 0 1
// end ; end ; if ( not Joan_P and a4 = 0 ) or a4 = 2 then
13435: LD_EXP 48
13439: NOT
13440: IFFALSE 13452
13442: PUSH
13443: LD_VAR 0 1
13447: PUSH
13448: LD_INT 0
13450: EQUAL
13451: AND
13452: IFTRUE 13464
13454: PUSH
13455: LD_VAR 0 1
13459: PUSH
13460: LD_INT 2
13462: EQUAL
13463: OR
13464: IFFALSE 13520
// begin if PlaceUnitXYR ( Joan , Getx ( c4 ) , Gety ( c4 ) , 8 , true ) then
13466: LD_EXP 33
13470: PPUSH
13471: LD_VAR 0 4
13475: PPUSH
13476: CALL_OW 250
13480: PPUSH
13481: LD_VAR 0 4
13485: PPUSH
13486: CALL_OW 251
13490: PPUSH
13491: LD_INT 8
13493: PPUSH
13494: LD_INT 1
13496: PPUSH
13497: CALL_OW 50
13501: IFFALSE 13520
// begin Joan_P := true ;
13503: LD_ADDR_EXP 48
13507: PUSH
13508: LD_INT 1
13510: ST_TO_ADDR
// DialogJoan ( c4 ) ;
13511: LD_VAR 0 4
13515: PPUSH
13516: CALL 8482 0 1
// end ; end ; if not Kurt_P or not Joan_P then
13520: LD_EXP 47
13524: NOT
13525: IFTRUE 13534
13527: PUSH
13528: LD_EXP 48
13532: NOT
13533: OR
13534: IFFALSE 13537
// enable ;
13536: ENABLE
// end ; end_of_file
13537: PPOPN 8
13539: END
// export function ne_v_boji ; begin
13540: LD_INT 0
13542: PPUSH
// while bojujese do
13543: CALL 13563 0 0
13547: IFFALSE 13558
// wait ( 0 0$4 ) ;
13549: LD_INT 140
13551: PPUSH
13552: CALL_OW 67
13556: GO 13543
// end ;
13558: LD_VAR 0 1
13562: RET
// export function bojujese ; begin
13563: LD_INT 0
13565: PPUSH
// result := true and not FilterAllUnits ( [ [ f_dist , JMM , 40 ] , [ f_side , russians ] ] ) ;
13566: LD_ADDR_VAR 0 1
13570: PUSH
13571: LD_INT 1
13573: IFFALSE 13614
13575: PUSH
13576: LD_INT 91
13578: PUSH
13579: LD_EXP 15
13583: PUSH
13584: LD_INT 40
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: PUSH
13592: LD_INT 22
13594: PUSH
13595: LD_EXP 2
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PPUSH
13608: CALL_OW 69
13612: NOT
13613: AND
13614: ST_TO_ADDR
// end ;
13615: LD_VAR 0 1
13619: RET
// export function TvojiLidi ; begin
13620: LD_INT 0
13622: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] ] ) ;
13623: LD_ADDR_VAR 0 1
13627: PUSH
13628: LD_INT 22
13630: PUSH
13631: LD_EXP 1
13635: PUSH
13636: EMPTY
13637: LIST
13638: LIST
13639: PUSH
13640: LD_INT 21
13642: PUSH
13643: LD_INT 1
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: PPUSH
13654: CALL_OW 69
13658: ST_TO_ADDR
// end ;
13659: LD_VAR 0 1
13663: RET
// export function filter_type_unit ( from_units , human , vehicle , building ) ; var temp1 , temp2 , temp3 ; var un2 ; begin
13664: LD_INT 0
13666: PPUSH
13667: PPUSH
13668: PPUSH
13669: PPUSH
13670: PPUSH
// if human then
13671: LD_VAR 0 2
13675: IFFALSE 13702
// begin temp1 := UnitFilter ( from_units , [ f_type , unit_human ] ) ;
13677: LD_ADDR_VAR 0 6
13681: PUSH
13682: LD_VAR 0 1
13686: PPUSH
13687: LD_INT 21
13689: PUSH
13690: LD_INT 1
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PPUSH
13697: CALL_OW 72
13701: ST_TO_ADDR
// end ; if vehicle then
13702: LD_VAR 0 3
13706: IFFALSE 13733
// begin temp2 := UnitFilter ( from_units , [ f_type , unit_vehicle ] ) ;
13708: LD_ADDR_VAR 0 7
13712: PUSH
13713: LD_VAR 0 1
13717: PPUSH
13718: LD_INT 21
13720: PUSH
13721: LD_INT 2
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PPUSH
13728: CALL_OW 72
13732: ST_TO_ADDR
// end ; if building then
13733: LD_VAR 0 4
13737: IFFALSE 13764
// begin temp3 := UnitFilter ( from_units , [ f_type , unit_building ] ) ;
13739: LD_ADDR_VAR 0 8
13743: PUSH
13744: LD_VAR 0 1
13748: PPUSH
13749: LD_INT 21
13751: PUSH
13752: LD_INT 3
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PPUSH
13759: CALL_OW 72
13763: ST_TO_ADDR
// end ; temp1 := add ( temp1 , temp2 ) ;
13764: LD_ADDR_VAR 0 6
13768: PUSH
13769: LD_VAR 0 6
13773: PPUSH
13774: LD_VAR 0 7
13778: PPUSH
13779: CALL 17574 0 2
13783: ST_TO_ADDR
// temp1 := add ( temp1 , temp3 ) ;
13784: LD_ADDR_VAR 0 6
13788: PUSH
13789: LD_VAR 0 6
13793: PPUSH
13794: LD_VAR 0 8
13798: PPUSH
13799: CALL 17574 0 2
13803: ST_TO_ADDR
// result := temp1 ;
13804: LD_ADDR_VAR 0 5
13808: PUSH
13809: LD_VAR 0 6
13813: ST_TO_ADDR
// end ;
13814: LD_VAR 0 5
13818: RET
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
13819: LD_INT 0
13821: PPUSH
13822: PPUSH
13823: PPUSH
13824: PPUSH
13825: PPUSH
13826: PPUSH
13827: PPUSH
13828: PPUSH
13829: PPUSH
13830: PPUSH
13831: PPUSH
13832: PPUSH
13833: PPUSH
13834: PPUSH
13835: PPUSH
// for for_unit in for_units do
13836: LD_ADDR_VAR 0 22
13840: PUSH
13841: LD_VAR 0 5
13845: PUSH
13846: FOR_IN
13847: IFFALSE 14373
// begin x := px ;
13849: LD_ADDR_VAR 0 9
13853: PUSH
13854: LD_VAR 0 1
13858: ST_TO_ADDR
// y := py ;
13859: LD_ADDR_VAR 0 10
13863: PUSH
13864: LD_VAR 0 2
13868: ST_TO_ADDR
// lx := px ;
13869: LD_ADDR_VAR 0 13
13873: PUSH
13874: LD_VAR 0 1
13878: ST_TO_ADDR
// ly := py ;
13879: LD_ADDR_VAR 0 14
13883: PUSH
13884: LD_VAR 0 2
13888: ST_TO_ADDR
// for j2 := 1 to hloubka do
13889: LD_ADDR_VAR 0 18
13893: PUSH
13894: DOUBLE
13895: LD_INT 1
13897: DEC
13898: ST_TO_ADDR
13899: LD_VAR 0 3
13903: PUSH
13904: FOR_TO
13905: IFFALSE 14239
// begin howgood := 50000 ;
13907: LD_ADDR_VAR 0 15
13911: PUSH
13912: LD_INT 50000
13914: ST_TO_ADDR
// smer := 0 ;
13915: LD_ADDR_VAR 0 16
13919: PUSH
13920: LD_INT 0
13922: ST_TO_ADDR
// kolem := 0 ;
13923: LD_ADDR_VAR 0 21
13927: PUSH
13928: LD_INT 0
13930: ST_TO_ADDR
// for i2 := 0 to 5 do
13931: LD_ADDR_VAR 0 17
13935: PUSH
13936: DOUBLE
13937: LD_INT 0
13939: DEC
13940: ST_TO_ADDR
13941: LD_INT 5
13943: PUSH
13944: FOR_TO
13945: IFFALSE 14141
// begin x2 := ShiftX ( x , i2 , krok ) ;
13947: LD_ADDR_VAR 0 11
13951: PUSH
13952: LD_VAR 0 9
13956: PPUSH
13957: LD_VAR 0 17
13961: PPUSH
13962: LD_VAR 0 4
13966: PPUSH
13967: CALL_OW 272
13971: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
13972: LD_ADDR_VAR 0 12
13976: PUSH
13977: LD_VAR 0 10
13981: PPUSH
13982: LD_VAR 0 17
13986: PPUSH
13987: LD_VAR 0 4
13991: PPUSH
13992: CALL_OW 273
13996: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
13997: LD_ADDR_VAR 0 20
14001: PUSH
14002: LD_VAR 0 6
14006: PPUSH
14007: LD_VAR 0 11
14011: PPUSH
14012: LD_VAR 0 12
14016: PPUSH
14017: CALL_OW 293
14021: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
14022: LD_VAR 0 20
14026: PUSH
14027: LD_VAR 0 15
14031: LESS
14032: IFFALSE 14086
14034: PUSH
14035: LD_VAR 0 1
14039: PPUSH
14040: LD_VAR 0 2
14044: PPUSH
14045: LD_VAR 0 9
14049: PPUSH
14050: LD_VAR 0 10
14054: PPUSH
14055: CALL_OW 298
14059: PUSH
14060: LD_VAR 0 1
14064: PPUSH
14065: LD_VAR 0 2
14069: PPUSH
14070: LD_VAR 0 11
14074: PPUSH
14075: LD_VAR 0 12
14079: PPUSH
14080: CALL_OW 298
14084: LESS
14085: AND
14086: IFFALSE 14123
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
14088: LD_ADDR_VAR 0 15
14092: PUSH
14093: LD_VAR 0 6
14097: PPUSH
14098: LD_VAR 0 11
14102: PPUSH
14103: LD_VAR 0 12
14107: PPUSH
14108: CALL_OW 293
14112: ST_TO_ADDR
// smer := i2 ;
14113: LD_ADDR_VAR 0 16
14117: PUSH
14118: LD_VAR 0 17
14122: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
14123: LD_ADDR_VAR 0 21
14127: PUSH
14128: LD_VAR 0 21
14132: PUSH
14133: LD_VAR 0 20
14137: PLUS
14138: ST_TO_ADDR
// end ;
14139: GO 13944
14141: POP
14142: POP
// x := ShiftX ( x , smer , krok ) ;
14143: LD_ADDR_VAR 0 9
14147: PUSH
14148: LD_VAR 0 9
14152: PPUSH
14153: LD_VAR 0 16
14157: PPUSH
14158: LD_VAR 0 4
14162: PPUSH
14163: CALL_OW 272
14167: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
14168: LD_ADDR_VAR 0 10
14172: PUSH
14173: LD_VAR 0 10
14177: PPUSH
14178: LD_VAR 0 16
14182: PPUSH
14183: LD_VAR 0 4
14187: PPUSH
14188: CALL_OW 273
14192: ST_TO_ADDR
// lx := lx ^ x ;
14193: LD_ADDR_VAR 0 13
14197: PUSH
14198: LD_VAR 0 13
14202: PUSH
14203: LD_VAR 0 9
14207: ADD
14208: ST_TO_ADDR
// ly := ly ^ y ;
14209: LD_ADDR_VAR 0 14
14213: PUSH
14214: LD_VAR 0 14
14218: PUSH
14219: LD_VAR 0 10
14223: ADD
14224: ST_TO_ADDR
// if kolem = 0 then
14225: LD_VAR 0 21
14229: PUSH
14230: LD_INT 0
14232: EQUAL
14233: IFFALSE 14237
// break ;
14235: GO 14239
// end ;
14237: GO 13904
14239: POP
14240: POP
// for j2 := ( lx + 0 ) downto 1 do
14241: LD_ADDR_VAR 0 18
14245: PUSH
14246: DOUBLE
14247: LD_VAR 0 13
14251: PUSH
14252: LD_INT 0
14254: PLUS
14255: INC
14256: ST_TO_ADDR
14257: LD_INT 1
14259: PUSH
14260: FOR_DOWNTO
14261: IFFALSE 14369
// begin if queue and j2 = ( lx + 0 ) then
14263: LD_VAR 0 7
14267: IFFALSE 14285
14269: PUSH
14270: LD_VAR 0 18
14274: PUSH
14275: LD_VAR 0 13
14279: PUSH
14280: LD_INT 0
14282: PLUS
14283: EQUAL
14284: AND
14285: IFFALSE 14320
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
14287: LD_VAR 0 22
14291: PPUSH
14292: LD_VAR 0 13
14296: PUSH
14297: LD_VAR 0 18
14301: ARRAY
14302: PPUSH
14303: LD_VAR 0 14
14307: PUSH
14308: LD_VAR 0 18
14312: ARRAY
14313: PPUSH
14314: CALL_OW 111
14318: GO 14367
// begin com_queue := true ;
14320: LD_ADDR_OWVAR 49
14324: PUSH
14325: LD_INT 1
14327: ST_TO_ADDR
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
14328: LD_VAR 0 22
14332: PPUSH
14333: LD_VAR 0 13
14337: PUSH
14338: LD_VAR 0 18
14342: ARRAY
14343: PPUSH
14344: LD_VAR 0 14
14348: PUSH
14349: LD_VAR 0 18
14353: ARRAY
14354: PPUSH
14355: CALL_OW 111
// com_queue := false ;
14359: LD_ADDR_OWVAR 49
14363: PUSH
14364: LD_INT 0
14366: ST_TO_ADDR
// end ; end ;
14367: GO 14260
14369: POP
14370: POP
// end ;
14371: GO 13846
14373: POP
14374: POP
// end ;
14375: LD_VAR 0 8
14379: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
14380: LD_INT 0
14382: PPUSH
14383: PPUSH
14384: PPUSH
14385: PPUSH
// for for_unit in for_units do
14386: LD_ADDR_VAR 0 5
14390: PUSH
14391: LD_VAR 0 1
14395: PUSH
14396: FOR_IN
14397: IFFALSE 14460
// begin unx := GetX ( for_unit ) ;
14399: LD_ADDR_VAR 0 6
14403: PUSH
14404: LD_VAR 0 5
14408: PPUSH
14409: CALL_OW 250
14413: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
14414: LD_ADDR_VAR 0 7
14418: PUSH
14419: LD_VAR 0 5
14423: PPUSH
14424: CALL_OW 251
14428: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
14429: LD_VAR 0 6
14433: PPUSH
14434: LD_VAR 0 7
14438: PPUSH
14439: LD_VAR 0 5
14443: PPUSH
14444: LD_VAR 0 2
14448: PPUSH
14449: LD_VAR 0 3
14453: PPUSH
14454: CALL 14467 0 5
// end ;
14458: GO 14396
14460: POP
14461: POP
// end ;
14462: LD_VAR 0 4
14466: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
14472: PPUSH
14473: PPUSH
14474: PPUSH
14475: PPUSH
// for for_unit in for_units do
14476: LD_ADDR_VAR 0 12
14480: PUSH
14481: LD_VAR 0 3
14485: PUSH
14486: FOR_IN
14487: IFFALSE 15203
// begin foundswD := 50000 ;
14489: LD_ADDR_VAR 0 9
14493: PUSH
14494: LD_INT 50000
14496: ST_TO_ADDR
// eswTX := 0 ;
14497: LD_ADDR_VAR 0 10
14501: PUSH
14502: LD_INT 0
14504: ST_TO_ADDR
// eswTY := 0 ;
14505: LD_ADDR_VAR 0 11
14509: PUSH
14510: LD_INT 0
14512: ST_TO_ADDR
// while eswTX < map_size_x do
14513: LD_VAR 0 10
14517: PUSH
14518: LD_EXP 53
14522: LESS
14523: IFFALSE 14623
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14525: LD_VAR 0 1
14529: PPUSH
14530: LD_VAR 0 2
14534: PPUSH
14535: LD_VAR 0 10
14539: PPUSH
14540: LD_VAR 0 11
14544: PPUSH
14545: CALL_OW 298
14549: PUSH
14550: LD_VAR 0 9
14554: LESS
14555: IFFALSE 14607
// begin foundswX := eswTX ;
14557: LD_ADDR_VAR 0 7
14561: PUSH
14562: LD_VAR 0 10
14566: ST_TO_ADDR
// foundswY := eswTY ;
14567: LD_ADDR_VAR 0 8
14571: PUSH
14572: LD_VAR 0 11
14576: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14577: LD_ADDR_VAR 0 9
14581: PUSH
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_VAR 0 2
14591: PPUSH
14592: LD_VAR 0 10
14596: PPUSH
14597: LD_VAR 0 11
14601: PPUSH
14602: CALL_OW 298
14606: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14607: LD_ADDR_VAR 0 10
14611: PUSH
14612: LD_VAR 0 10
14616: PUSH
14617: LD_INT 10
14619: PLUS
14620: ST_TO_ADDR
// end ;
14621: GO 14513
// eswTX := map_size_x div 2 ;
14623: LD_ADDR_VAR 0 10
14627: PUSH
14628: LD_EXP 53
14632: PUSH
14633: LD_INT 2
14635: DIV
14636: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
14637: LD_ADDR_VAR 0 11
14641: PUSH
14642: LD_EXP 54
14646: PUSH
14647: LD_INT 1
14649: MINUS
14650: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
14651: LD_VAR 0 10
14655: PUSH
14656: LD_EXP 53
14660: PUSH
14661: LD_EXP 53
14665: PUSH
14666: LD_INT 2
14668: DIV
14669: PLUS
14670: LESS
14671: IFFALSE 14771
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14673: LD_VAR 0 1
14677: PPUSH
14678: LD_VAR 0 2
14682: PPUSH
14683: LD_VAR 0 10
14687: PPUSH
14688: LD_VAR 0 11
14692: PPUSH
14693: CALL_OW 298
14697: PUSH
14698: LD_VAR 0 9
14702: LESS
14703: IFFALSE 14755
// begin foundswX := eswTX ;
14705: LD_ADDR_VAR 0 7
14709: PUSH
14710: LD_VAR 0 10
14714: ST_TO_ADDR
// foundswY := eswTY ;
14715: LD_ADDR_VAR 0 8
14719: PUSH
14720: LD_VAR 0 11
14724: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14725: LD_ADDR_VAR 0 9
14729: PUSH
14730: LD_VAR 0 1
14734: PPUSH
14735: LD_VAR 0 2
14739: PPUSH
14740: LD_VAR 0 10
14744: PPUSH
14745: LD_VAR 0 11
14749: PPUSH
14750: CALL_OW 298
14754: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
14755: LD_ADDR_VAR 0 10
14759: PUSH
14760: LD_VAR 0 10
14764: PUSH
14765: LD_INT 10
14767: PLUS
14768: ST_TO_ADDR
// end ;
14769: GO 14651
// eswTX := 0 ;
14771: LD_ADDR_VAR 0 10
14775: PUSH
14776: LD_INT 0
14778: ST_TO_ADDR
// eswTY := 0 ;
14779: LD_ADDR_VAR 0 11
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14787: LD_VAR 0 11
14791: PUSH
14792: LD_EXP 54
14796: LESS
14797: IFFALSE 14911
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14799: LD_VAR 0 1
14803: PPUSH
14804: LD_VAR 0 2
14808: PPUSH
14809: LD_VAR 0 10
14813: PPUSH
14814: LD_VAR 0 11
14818: PPUSH
14819: CALL_OW 298
14823: PUSH
14824: LD_VAR 0 9
14828: LESS
14829: IFFALSE 14881
// begin foundswX := eswTX ;
14831: LD_ADDR_VAR 0 7
14835: PUSH
14836: LD_VAR 0 10
14840: ST_TO_ADDR
// foundswY := eswTY ;
14841: LD_ADDR_VAR 0 8
14845: PUSH
14846: LD_VAR 0 11
14850: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14851: LD_ADDR_VAR 0 9
14855: PUSH
14856: LD_VAR 0 1
14860: PPUSH
14861: LD_VAR 0 2
14865: PPUSH
14866: LD_VAR 0 10
14870: PPUSH
14871: LD_VAR 0 11
14875: PPUSH
14876: CALL_OW 298
14880: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
14881: LD_ADDR_VAR 0 11
14885: PUSH
14886: LD_VAR 0 11
14890: PUSH
14891: LD_INT 10
14893: PLUS
14894: ST_TO_ADDR
// eswTX := eswTX + 5 ;
14895: LD_ADDR_VAR 0 10
14899: PUSH
14900: LD_VAR 0 10
14904: PUSH
14905: LD_INT 5
14907: PLUS
14908: ST_TO_ADDR
// end ;
14909: GO 14787
// eswTX := map_size_x ;
14911: LD_ADDR_VAR 0 10
14915: PUSH
14916: LD_EXP 53
14920: ST_TO_ADDR
// eswTY := 1 ;
14921: LD_ADDR_VAR 0 11
14925: PUSH
14926: LD_INT 1
14928: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
14929: LD_VAR 0 11
14933: PUSH
14934: LD_EXP 54
14938: LESS
14939: IFFALSE 15053
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
14941: LD_VAR 0 1
14945: PPUSH
14946: LD_VAR 0 2
14950: PPUSH
14951: LD_VAR 0 10
14955: PPUSH
14956: LD_VAR 0 11
14960: PPUSH
14961: CALL_OW 298
14965: PUSH
14966: LD_VAR 0 9
14970: LESS
14971: IFFALSE 15023
// begin foundswX := eswTX ;
14973: LD_ADDR_VAR 0 7
14977: PUSH
14978: LD_VAR 0 10
14982: ST_TO_ADDR
// foundswY := eswTY ;
14983: LD_ADDR_VAR 0 8
14987: PUSH
14988: LD_VAR 0 11
14992: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
14993: LD_ADDR_VAR 0 9
14997: PUSH
14998: LD_VAR 0 1
15002: PPUSH
15003: LD_VAR 0 2
15007: PPUSH
15008: LD_VAR 0 10
15012: PPUSH
15013: LD_VAR 0 11
15017: PPUSH
15018: CALL_OW 298
15022: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
15023: LD_ADDR_VAR 0 11
15027: PUSH
15028: LD_VAR 0 11
15032: PUSH
15033: LD_INT 10
15035: PLUS
15036: ST_TO_ADDR
// eswTX := eswTX + 5 ;
15037: LD_ADDR_VAR 0 10
15041: PUSH
15042: LD_VAR 0 10
15046: PUSH
15047: LD_INT 5
15049: PLUS
15050: ST_TO_ADDR
// end ;
15051: GO 14929
// if queue then
15053: LD_VAR 0 4
15057: IFFALSE 15131
// begin if agressive then
15059: LD_VAR 0 5
15063: IFFALSE 15098
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
15065: LD_VAR 0 12
15069: PPUSH
15070: LD_VAR 0 7
15074: PPUSH
15075: LD_VAR 0 8
15079: PPUSH
15080: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
15084: LD_VAR 0 12
15088: PPUSH
15089: LD_INT 10
15091: PPUSH
15092: CALL_OW 173
// end else
15096: GO 15129
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
15098: LD_VAR 0 12
15102: PPUSH
15103: LD_VAR 0 7
15107: PPUSH
15108: LD_VAR 0 8
15112: PPUSH
15113: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
15117: LD_VAR 0 12
15121: PPUSH
15122: LD_INT 10
15124: PPUSH
15125: CALL_OW 173
// end ; end else
15129: GO 15201
// begin if agressive then
15131: LD_VAR 0 5
15135: IFFALSE 15170
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
15137: LD_VAR 0 12
15141: PPUSH
15142: LD_VAR 0 7
15146: PPUSH
15147: LD_VAR 0 8
15151: PPUSH
15152: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
15156: LD_VAR 0 12
15160: PPUSH
15161: LD_INT 10
15163: PPUSH
15164: CALL_OW 173
// end else
15168: GO 15201
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
15170: LD_VAR 0 12
15174: PPUSH
15175: LD_VAR 0 7
15179: PPUSH
15180: LD_VAR 0 8
15184: PPUSH
15185: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
15189: LD_VAR 0 12
15193: PPUSH
15194: LD_INT 10
15196: PPUSH
15197: CALL_OW 173
// end ; end ; end ;
15201: GO 14486
15203: POP
15204: POP
// end ;
15205: LD_VAR 0 6
15209: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
15210: LD_INT 0
15212: PPUSH
15213: PPUSH
15214: PPUSH
// see_any_r := false ;
15215: LD_ADDR_VAR 0 5
15219: PUSH
15220: LD_INT 0
15222: ST_TO_ADDR
// for sai in sez2 do
15223: LD_ADDR_VAR 0 4
15227: PUSH
15228: LD_VAR 0 2
15232: PUSH
15233: FOR_IN
15234: IFFALSE 15264
// if See ( strana , sai ) then
15236: LD_VAR 0 1
15240: PPUSH
15241: LD_VAR 0 4
15245: PPUSH
15246: CALL_OW 292
15250: IFFALSE 15262
// begin see_any_r := true ;
15252: LD_ADDR_VAR 0 5
15256: PUSH
15257: LD_INT 1
15259: ST_TO_ADDR
// break ;
15260: GO 15264
// end ;
15262: GO 15233
15264: POP
15265: POP
// ; result := see_any_r ;
15266: LD_ADDR_VAR 0 3
15270: PUSH
15271: LD_VAR 0 5
15275: ST_TO_ADDR
// end ;
15276: LD_VAR 0 3
15280: RET
// export function nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ; var list , list2 ; var un1 , vzdal ; var count ; begin
15281: LD_INT 0
15283: PPUSH
15284: PPUSH
15285: PPUSH
15286: PPUSH
15287: PPUSH
15288: PPUSH
// un1 := 1 ;
15289: LD_ADDR_VAR 0 11
15293: PUSH
15294: LD_INT 1
15296: ST_TO_ADDR
// count := 0 ;
15297: LD_ADDR_VAR 0 13
15301: PUSH
15302: LD_INT 0
15304: ST_TO_ADDR
// if pocet > from_units then
15305: LD_VAR 0 5
15309: PUSH
15310: LD_VAR 0 1
15314: GREATER
15315: IFFALSE 15331
// pocet := ( from_units + 0 ) ;
15317: LD_ADDR_VAR 0 5
15321: PUSH
15322: LD_VAR 0 1
15326: PUSH
15327: LD_INT 0
15329: PLUS
15330: ST_TO_ADDR
// while un1 <= pocet or count <= pocet do
15331: LD_VAR 0 11
15335: PUSH
15336: LD_VAR 0 5
15340: LESSEQUAL
15341: IFTRUE 15355
15343: PUSH
15344: LD_VAR 0 13
15348: PUSH
15349: LD_VAR 0 5
15353: LESSEQUAL
15354: OR
15355: IFFALSE 15508
// begin vzdal := GetDistUnitXY ( un1 , x , y ) ;
15357: LD_ADDR_VAR 0 12
15361: PUSH
15362: LD_VAR 0 11
15366: PPUSH
15367: LD_VAR 0 2
15371: PPUSH
15372: LD_VAR 0 3
15376: PPUSH
15377: CALL_OW 297
15381: ST_TO_ADDR
// if vzdal <= max_vzdal then
15382: LD_VAR 0 12
15386: PUSH
15387: LD_VAR 0 7
15391: LESSEQUAL
15392: IFFALSE 15492
// begin if un1 > skip then
15394: LD_VAR 0 11
15398: PUSH
15399: LD_VAR 0 4
15403: GREATER
15404: IFFALSE 15492
// begin if list then
15406: LD_VAR 0 9
15410: IFFALSE 15452
// begin list := list ^ from_units [ un1 ] ;
15412: LD_ADDR_VAR 0 9
15416: PUSH
15417: LD_VAR 0 9
15421: PUSH
15422: LD_VAR 0 1
15426: PUSH
15427: LD_VAR 0 11
15431: ARRAY
15432: ADD
15433: ST_TO_ADDR
// list2 := list2 ^ vzdal ;
15434: LD_ADDR_VAR 0 10
15438: PUSH
15439: LD_VAR 0 10
15443: PUSH
15444: LD_VAR 0 12
15448: ADD
15449: ST_TO_ADDR
// end else
15450: GO 15478
// begin list := from_units [ un1 ] ;
15452: LD_ADDR_VAR 0 9
15456: PUSH
15457: LD_VAR 0 1
15461: PUSH
15462: LD_VAR 0 11
15466: ARRAY
15467: ST_TO_ADDR
// list2 := vzdal ;
15468: LD_ADDR_VAR 0 10
15472: PUSH
15473: LD_VAR 0 12
15477: ST_TO_ADDR
// end ; count := count + 1 ;
15478: LD_ADDR_VAR 0 13
15482: PUSH
15483: LD_VAR 0 13
15487: PUSH
15488: LD_INT 1
15490: PLUS
15491: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
15492: LD_ADDR_VAR 0 11
15496: PUSH
15497: LD_VAR 0 11
15501: PUSH
15502: LD_INT 1
15504: PLUS
15505: ST_TO_ADDR
// end ;
15506: GO 15331
// result := list ;
15508: LD_ADDR_VAR 0 8
15512: PUSH
15513: LD_VAR 0 9
15517: ST_TO_ADDR
// end ;
15518: LD_VAR 0 8
15522: RET
// export function nearest_units_unit ( from_units , for_unit , skip , pocet , min_vzdal , max_vzdal ) ; var x , y ; begin
15523: LD_INT 0
15525: PPUSH
15526: PPUSH
15527: PPUSH
// x := GetX ( for_unit ) ;
15528: LD_ADDR_VAR 0 8
15532: PUSH
15533: LD_VAR 0 2
15537: PPUSH
15538: CALL_OW 250
15542: ST_TO_ADDR
// y := GetY ( for_unit ) ;
15543: LD_ADDR_VAR 0 9
15547: PUSH
15548: LD_VAR 0 2
15552: PPUSH
15553: CALL_OW 251
15557: ST_TO_ADDR
// result := nearest_units_xy ( from_units , x , y , skip , pocet , min_vzdal , max_vzdal ) ;
15558: LD_ADDR_VAR 0 7
15562: PUSH
15563: LD_VAR 0 1
15567: PPUSH
15568: LD_VAR 0 8
15572: PPUSH
15573: LD_VAR 0 9
15577: PPUSH
15578: LD_VAR 0 3
15582: PPUSH
15583: LD_VAR 0 4
15587: PPUSH
15588: LD_VAR 0 5
15592: PPUSH
15593: LD_VAR 0 6
15597: PPUSH
15598: CALL 15281 0 7
15602: ST_TO_ADDR
// end ;
15603: LD_VAR 0 7
15607: RET
// export function nearest_ememies_xy ( side , x , y , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15608: LD_INT 0
15610: PPUSH
15611: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15612: LD_ADDR_VAR 0 11
15616: PUSH
15617: LD_INT 22
15619: PUSH
15620: LD_VAR 0 1
15624: PUSH
15625: EMPTY
15626: LIST
15627: LIST
15628: PPUSH
15629: CALL_OW 69
15633: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15634: LD_ADDR_VAR 0 11
15638: PUSH
15639: LD_VAR 0 11
15643: PPUSH
15644: LD_VAR 0 7
15648: PPUSH
15649: LD_VAR 0 8
15653: PPUSH
15654: LD_VAR 0 9
15658: PPUSH
15659: CALL 13664 0 4
15663: ST_TO_ADDR
// nearest_units_xy ( from_units , x , y , skip , pocet , 1 , max_vzdal ) ;
15664: LD_VAR 0 11
15668: PPUSH
15669: LD_VAR 0 2
15673: PPUSH
15674: LD_VAR 0 3
15678: PPUSH
15679: LD_VAR 0 4
15683: PPUSH
15684: LD_VAR 0 5
15688: PPUSH
15689: LD_INT 1
15691: PPUSH
15692: LD_VAR 0 6
15696: PPUSH
15697: CALL 15281 0 7
// end ;
15701: LD_VAR 0 10
15705: RET
// export function nearest_ememies_unit ( side , for_unit , skip , pocet , max_vzdal , human , vehicle , building ) ; var from_units ; begin
15706: LD_INT 0
15708: PPUSH
15709: PPUSH
// from_units := FilterAllUnits ( [ f_side , side ] ) ;
15710: LD_ADDR_VAR 0 10
15714: PUSH
15715: LD_INT 22
15717: PUSH
15718: LD_VAR 0 1
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: PPUSH
15727: CALL_OW 69
15731: ST_TO_ADDR
// from_units := filter_type_unit ( from_units , human , vehicle , building ) ;
15732: LD_ADDR_VAR 0 10
15736: PUSH
15737: LD_VAR 0 10
15741: PPUSH
15742: LD_VAR 0 6
15746: PPUSH
15747: LD_VAR 0 7
15751: PPUSH
15752: LD_VAR 0 8
15756: PPUSH
15757: CALL 13664 0 4
15761: ST_TO_ADDR
// nearest_units_unit ( from_units , for_unit , skip , pocet , 1 , max_vzdal ) ;
15762: LD_VAR 0 10
15766: PPUSH
15767: LD_VAR 0 2
15771: PPUSH
15772: LD_VAR 0 3
15776: PPUSH
15777: LD_VAR 0 4
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_VAR 0 5
15789: PPUSH
15790: CALL 15523 0 6
// end ;
15794: LD_VAR 0 9
15798: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
15799: LD_INT 0
15801: PPUSH
15802: PPUSH
15803: PPUSH
15804: PPUSH
// for i in who do
15805: LD_ADDR_VAR 0 6
15809: PUSH
15810: LD_VAR 0 1
15814: PUSH
15815: FOR_IN
15816: IFFALSE 15889
// begin for j in what do
15818: LD_ADDR_VAR 0 7
15822: PUSH
15823: LD_VAR 0 3
15827: PUSH
15828: FOR_IN
15829: IFFALSE 15885
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
15831: LD_VAR 0 7
15835: PPUSH
15836: CALL_OW 311
15840: NOT
15841: IFFALSE 15865
15843: PUSH
15844: LD_VAR 0 6
15848: PPUSH
15849: LD_VAR 0 7
15853: PPUSH
15854: CALL_OW 296
15858: PUSH
15859: LD_VAR 0 2
15863: LESSEQUAL
15864: AND
15865: IFFALSE 15883
// begin ComEnterUnit ( i , j ) ;
15867: LD_VAR 0 6
15871: PPUSH
15872: LD_VAR 0 7
15876: PPUSH
15877: CALL_OW 120
// break ;
15881: GO 15885
// end ; end ;
15883: GO 15828
15885: POP
15886: POP
// end ;
15887: GO 15815
15889: POP
15890: POP
// end ;
15891: LD_VAR 0 4
15895: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
15896: LD_INT 0
15898: PPUSH
15899: PPUSH
15900: PPUSH
15901: PPUSH
// for i in who do
15902: LD_ADDR_VAR 0 6
15906: PUSH
15907: LD_VAR 0 1
15911: PUSH
15912: FOR_IN
15913: IFFALSE 16012
// begin add := false ;
15915: LD_ADDR_VAR 0 5
15919: PUSH
15920: LD_INT 0
15922: ST_TO_ADDR
// for j in what do
15923: LD_ADDR_VAR 0 7
15927: PUSH
15928: LD_VAR 0 3
15932: PUSH
15933: FOR_IN
15934: IFFALSE 15968
// begin if GetDistUnits ( i , j ) <= dist then
15936: LD_VAR 0 6
15940: PPUSH
15941: LD_VAR 0 7
15945: PPUSH
15946: CALL_OW 296
15950: PUSH
15951: LD_VAR 0 2
15955: LESSEQUAL
15956: IFFALSE 15966
// begin add := true ;
15958: LD_ADDR_VAR 0 5
15962: PUSH
15963: LD_INT 1
15965: ST_TO_ADDR
// end ; end ;
15966: GO 15933
15968: POP
15969: POP
// if add then
15970: LD_VAR 0 5
15974: IFFALSE 16010
// begin if result then
15976: LD_VAR 0 4
15980: IFFALSE 16000
// result := result ^ i else
15982: LD_ADDR_VAR 0 4
15986: PUSH
15987: LD_VAR 0 4
15991: PUSH
15992: LD_VAR 0 6
15996: ADD
15997: ST_TO_ADDR
15998: GO 16010
// result := i ;
16000: LD_ADDR_VAR 0 4
16004: PUSH
16005: LD_VAR 0 6
16009: ST_TO_ADDR
// end ; end ;
16010: GO 15912
16012: POP
16013: POP
// end ;
16014: LD_VAR 0 4
16018: RET
// export function comqb ; begin
16019: LD_INT 0
16021: PPUSH
// com_queue := true ;
16022: LD_ADDR_OWVAR 49
16026: PUSH
16027: LD_INT 1
16029: ST_TO_ADDR
// end ;
16030: LD_VAR 0 1
16034: RET
// export function comqe ; begin
16035: LD_INT 0
16037: PPUSH
// com_queue := false ;
16038: LD_ADDR_OWVAR 49
16042: PUSH
16043: LD_INT 0
16045: ST_TO_ADDR
// end ;
16046: LD_VAR 0 1
16050: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a , x , y ; begin
16051: LD_INT 0
16053: PPUSH
16054: PPUSH
16055: PPUSH
16056: PPUSH
16057: PPUSH
// for_units := UnitFilter ( for_units , [ f_alive ] ) ;
16058: LD_ADDR_VAR 0 1
16062: PUSH
16063: LD_VAR 0 1
16067: PPUSH
16068: LD_INT 51
16070: PUSH
16071: EMPTY
16072: LIST
16073: PPUSH
16074: CALL_OW 72
16078: ST_TO_ADDR
// i1 := 1 ;
16079: LD_ADDR_VAR 0 5
16083: PUSH
16084: LD_INT 1
16086: ST_TO_ADDR
// while i1 <= path do
16087: LD_VAR 0 5
16091: PUSH
16092: LD_VAR 0 2
16096: LESSEQUAL
16097: IFFALSE 16395
// begin a := path [ i1 ] ;
16099: LD_ADDR_VAR 0 6
16103: PUSH
16104: LD_VAR 0 2
16108: PUSH
16109: LD_VAR 0 5
16113: ARRAY
16114: ST_TO_ADDR
// if a < 0 then
16115: LD_VAR 0 6
16119: PUSH
16120: LD_INT 0
16122: LESS
16123: IFFALSE 16180
// begin while a <= - 1 do
16125: LD_VAR 0 6
16129: PUSH
16130: LD_INT 1
16132: NEG
16133: LESSEQUAL
16134: IFFALSE 16164
// begin a := a + 1 ;
16136: LD_ADDR_VAR 0 6
16140: PUSH
16141: LD_VAR 0 6
16145: PUSH
16146: LD_INT 1
16148: PLUS
16149: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
16150: LD_VAR 0 1
16154: PPUSH
16155: LD_INT 35
16157: PPUSH
16158: CALL_OW 202
// end ;
16162: GO 16125
// i1 := i1 + 1 ;
16164: LD_ADDR_VAR 0 5
16168: PUSH
16169: LD_VAR 0 5
16173: PUSH
16174: LD_INT 1
16176: PLUS
16177: ST_TO_ADDR
// end else
16178: GO 16393
// begin if a = 0 then
16180: LD_VAR 0 6
16184: PUSH
16185: LD_INT 0
16187: EQUAL
16188: IFFALSE 16250
// begin a := path [ i1 + 1 ] ;
16190: LD_ADDR_VAR 0 6
16194: PUSH
16195: LD_VAR 0 2
16199: PUSH
16200: LD_VAR 0 5
16204: PUSH
16205: LD_INT 1
16207: PLUS
16208: ARRAY
16209: ST_TO_ADDR
// if a = 0 then
16210: LD_VAR 0 6
16214: PUSH
16215: LD_INT 0
16217: EQUAL
16218: IFFALSE 16229
// AddComReturn ( for_units ) ;
16220: LD_VAR 0 1
16224: PPUSH
16225: CALL_OW 204
// if a = 1 then
16229: LD_VAR 0 6
16233: PUSH
16234: LD_INT 1
16236: EQUAL
16237: IFFALSE 16248
// AddComRemember ( for_units ) ;
16239: LD_VAR 0 1
16243: PPUSH
16244: CALL_OW 203
// end else
16248: GO 16379
// begin x := path [ i1 ] ;
16250: LD_ADDR_VAR 0 7
16254: PUSH
16255: LD_VAR 0 2
16259: PUSH
16260: LD_VAR 0 5
16264: ARRAY
16265: ST_TO_ADDR
// y := path [ i1 + 1 ] ;
16266: LD_ADDR_VAR 0 8
16270: PUSH
16271: LD_VAR 0 2
16275: PUSH
16276: LD_VAR 0 5
16280: PUSH
16281: LD_INT 1
16283: PLUS
16284: ARRAY
16285: ST_TO_ADDR
// if x <= 3 and y <= 3 then
16286: LD_VAR 0 7
16290: PUSH
16291: LD_INT 3
16293: LESSEQUAL
16294: IFFALSE 16306
16296: PUSH
16297: LD_VAR 0 8
16301: PUSH
16302: LD_INT 3
16304: LESSEQUAL
16305: AND
16306: IFFALSE 16333
// begin Msg ( kam to jedes (take path) ) ;
16308: LD_STRING kam to jedes (take path)
16310: PPUSH
16311: CALL_OW 100
// Msg ( [ x , y ] ) ;
16315: LD_VAR 0 7
16319: PUSH
16320: LD_VAR 0 8
16324: PUSH
16325: EMPTY
16326: LIST
16327: LIST
16328: PPUSH
16329: CALL_OW 100
// end ; if agressive then
16333: LD_VAR 0 3
16337: IFFALSE 16360
// AddComAgressiveMove ( for_units , x , y ) else
16339: LD_VAR 0 1
16343: PPUSH
16344: LD_VAR 0 7
16348: PPUSH
16349: LD_VAR 0 8
16353: PPUSH
16354: CALL_OW 174
16358: GO 16379
// AddComMoveXY ( for_units , x , y ) ;
16360: LD_VAR 0 1
16364: PPUSH
16365: LD_VAR 0 7
16369: PPUSH
16370: LD_VAR 0 8
16374: PPUSH
16375: CALL_OW 171
// end ; i1 := i1 + 2 ;
16379: LD_ADDR_VAR 0 5
16383: PUSH
16384: LD_VAR 0 5
16388: PUSH
16389: LD_INT 2
16391: PLUS
16392: ST_TO_ADDR
// end ; end ;
16393: GO 16087
// end ;
16395: LD_VAR 0 4
16399: RET
// export function find_drivers ( cars , drivers , take_out ) ; var empty , free , i , konec ; begin
16400: LD_INT 0
16402: PPUSH
16403: PPUSH
16404: PPUSH
16405: PPUSH
16406: PPUSH
// cars := UnitFilter ( cars , [ f_alive ] ) union [ ] ;
16407: LD_ADDR_VAR 0 1
16411: PUSH
16412: LD_VAR 0 1
16416: PPUSH
16417: LD_INT 51
16419: PUSH
16420: EMPTY
16421: LIST
16422: PPUSH
16423: CALL_OW 72
16427: PUSH
16428: EMPTY
16429: UNION
16430: ST_TO_ADDR
// drivers := UnitFilter ( drivers , [ f_alive ] ) union [ ] ;
16431: LD_ADDR_VAR 0 2
16435: PUSH
16436: LD_VAR 0 2
16440: PPUSH
16441: LD_INT 51
16443: PUSH
16444: EMPTY
16445: LIST
16446: PPUSH
16447: CALL_OW 72
16451: PUSH
16452: EMPTY
16453: UNION
16454: ST_TO_ADDR
// for i in cars do
16455: LD_ADDR_VAR 0 7
16459: PUSH
16460: LD_VAR 0 1
16464: PUSH
16465: FOR_IN
16466: IFFALSE 16502
// if not IsDrivenBy ( i ) then
16468: LD_VAR 0 7
16472: PPUSH
16473: CALL_OW 311
16477: NOT
16478: IFFALSE 16500
// empty := add ( empty , i ) ;
16480: LD_ADDR_VAR 0 5
16484: PUSH
16485: LD_VAR 0 5
16489: PPUSH
16490: LD_VAR 0 7
16494: PPUSH
16495: CALL 17574 0 2
16499: ST_TO_ADDR
16500: GO 16465
16502: POP
16503: POP
// if take_out then
16504: LD_VAR 0 3
16508: IFFALSE 16567
// begin for i in drivers do
16510: LD_ADDR_VAR 0 7
16514: PUSH
16515: LD_VAR 0 2
16519: PUSH
16520: FOR_IN
16521: IFFALSE 16563
// if not ( IsInUnit ( i ) in cars ) then
16523: LD_VAR 0 7
16527: PPUSH
16528: CALL_OW 310
16532: PUSH
16533: LD_VAR 0 1
16537: IN
16538: NOT
16539: IFFALSE 16561
// free := add ( free , i ) ;
16541: LD_ADDR_VAR 0 6
16545: PUSH
16546: LD_VAR 0 6
16550: PPUSH
16551: LD_VAR 0 7
16555: PPUSH
16556: CALL 17574 0 2
16560: ST_TO_ADDR
16561: GO 16520
16563: POP
16564: POP
// end else
16565: GO 16616
// begin for i in drivers do
16567: LD_ADDR_VAR 0 7
16571: PUSH
16572: LD_VAR 0 2
16576: PUSH
16577: FOR_IN
16578: IFFALSE 16614
// if not IsInUnit ( i ) then
16580: LD_VAR 0 7
16584: PPUSH
16585: CALL_OW 310
16589: NOT
16590: IFFALSE 16612
// free := add ( free , i ) ;
16592: LD_ADDR_VAR 0 6
16596: PUSH
16597: LD_VAR 0 6
16601: PPUSH
16602: LD_VAR 0 7
16606: PPUSH
16607: CALL 17574 0 2
16611: ST_TO_ADDR
16612: GO 16577
16614: POP
16615: POP
// end ; result := cars diff empty ;
16616: LD_ADDR_VAR 0 4
16620: PUSH
16621: LD_VAR 0 1
16625: PUSH
16626: LD_VAR 0 5
16630: DIFF
16631: ST_TO_ADDR
// if empty <= free then
16632: LD_VAR 0 5
16636: PUSH
16637: LD_VAR 0 6
16641: LESSEQUAL
16642: IFFALSE 16656
// konec := empty else
16644: LD_ADDR_VAR 0 8
16648: PUSH
16649: LD_VAR 0 5
16653: ST_TO_ADDR
16654: GO 16666
// konec := free ;
16656: LD_ADDR_VAR 0 8
16660: PUSH
16661: LD_VAR 0 6
16665: ST_TO_ADDR
// for i := 1 to konec do
16666: LD_ADDR_VAR 0 7
16670: PUSH
16671: DOUBLE
16672: LD_INT 1
16674: DEC
16675: ST_TO_ADDR
16676: LD_VAR 0 8
16680: PUSH
16681: FOR_TO
16682: IFFALSE 16738
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16684: LD_VAR 0 6
16688: PUSH
16689: LD_VAR 0 7
16693: ARRAY
16694: PPUSH
16695: LD_VAR 0 5
16699: PUSH
16700: LD_VAR 0 7
16704: ARRAY
16705: PPUSH
16706: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16710: LD_ADDR_VAR 0 4
16714: PUSH
16715: LD_VAR 0 4
16719: PPUSH
16720: LD_VAR 0 5
16724: PUSH
16725: LD_VAR 0 7
16729: ARRAY
16730: PPUSH
16731: CALL 17574 0 2
16735: ST_TO_ADDR
// end ;
16736: GO 16681
16738: POP
16739: POP
// end ;
16740: LD_VAR 0 4
16744: RET
// export function full_forts ( forts , sols ) ; var empty , free , i , konec ; begin
16745: LD_INT 0
16747: PPUSH
16748: PPUSH
16749: PPUSH
16750: PPUSH
16751: PPUSH
// forts := forts union [ ] ;
16752: LD_ADDR_VAR 0 1
16756: PUSH
16757: LD_VAR 0 1
16761: PUSH
16762: EMPTY
16763: UNION
16764: ST_TO_ADDR
// sols := sols union [ ] ;
16765: LD_ADDR_VAR 0 2
16769: PUSH
16770: LD_VAR 0 2
16774: PUSH
16775: EMPTY
16776: UNION
16777: ST_TO_ADDR
// for i in forts do
16778: LD_ADDR_VAR 0 6
16782: PUSH
16783: LD_VAR 0 1
16787: PUSH
16788: FOR_IN
16789: IFFALSE 16825
// if not UnitsInside ( i ) then
16791: LD_VAR 0 6
16795: PPUSH
16796: CALL_OW 313
16800: NOT
16801: IFFALSE 16823
// empty := add ( empty , i ) ;
16803: LD_ADDR_VAR 0 4
16807: PUSH
16808: LD_VAR 0 4
16812: PPUSH
16813: LD_VAR 0 6
16817: PPUSH
16818: CALL 17574 0 2
16822: ST_TO_ADDR
16823: GO 16788
16825: POP
16826: POP
// for i in sols do
16827: LD_ADDR_VAR 0 6
16831: PUSH
16832: LD_VAR 0 2
16836: PUSH
16837: FOR_IN
16838: IFFALSE 16888
// if not IsInUnit ( i ) and not IsBusy ( i ) then
16840: LD_VAR 0 6
16844: PPUSH
16845: CALL_OW 310
16849: NOT
16850: IFFALSE 16864
16852: PUSH
16853: LD_VAR 0 6
16857: PPUSH
16858: CALL_OW 315
16862: NOT
16863: AND
16864: IFFALSE 16886
// free := add ( free , i ) ;
16866: LD_ADDR_VAR 0 5
16870: PUSH
16871: LD_VAR 0 5
16875: PPUSH
16876: LD_VAR 0 6
16880: PPUSH
16881: CALL 17574 0 2
16885: ST_TO_ADDR
16886: GO 16837
16888: POP
16889: POP
// result := forts diff empty ;
16890: LD_ADDR_VAR 0 3
16894: PUSH
16895: LD_VAR 0 1
16899: PUSH
16900: LD_VAR 0 4
16904: DIFF
16905: ST_TO_ADDR
// if empty <= free then
16906: LD_VAR 0 4
16910: PUSH
16911: LD_VAR 0 5
16915: LESSEQUAL
16916: IFFALSE 16930
// konec := empty else
16918: LD_ADDR_VAR 0 7
16922: PUSH
16923: LD_VAR 0 4
16927: ST_TO_ADDR
16928: GO 16940
// konec := free ;
16930: LD_ADDR_VAR 0 7
16934: PUSH
16935: LD_VAR 0 5
16939: ST_TO_ADDR
// for i := 1 to konec do
16940: LD_ADDR_VAR 0 6
16944: PUSH
16945: DOUBLE
16946: LD_INT 1
16948: DEC
16949: ST_TO_ADDR
16950: LD_VAR 0 7
16954: PUSH
16955: FOR_TO
16956: IFFALSE 17012
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
16958: LD_VAR 0 5
16962: PUSH
16963: LD_VAR 0 6
16967: ARRAY
16968: PPUSH
16969: LD_VAR 0 4
16973: PUSH
16974: LD_VAR 0 6
16978: ARRAY
16979: PPUSH
16980: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
16984: LD_ADDR_VAR 0 3
16988: PUSH
16989: LD_VAR 0 3
16993: PPUSH
16994: LD_VAR 0 4
16998: PUSH
16999: LD_VAR 0 6
17003: ARRAY
17004: PPUSH
17005: CALL 17574 0 2
17009: ST_TO_ADDR
// end ;
17010: GO 16955
17012: POP
17013: POP
// end ;
17014: LD_VAR 0 3
17018: RET
// export function depart ( cars , drivers , path , argessive , take_out ) ; var pojedou ; begin
17019: LD_INT 0
17021: PPUSH
17022: PPUSH
// pojedou := find_drivers ( cars , drivers , take_out ) ;
17023: LD_ADDR_VAR 0 7
17027: PUSH
17028: LD_VAR 0 1
17032: PPUSH
17033: LD_VAR 0 2
17037: PPUSH
17038: LD_VAR 0 5
17042: PPUSH
17043: CALL 16400 0 3
17047: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
17048: LD_VAR 0 7
17052: PPUSH
17053: CALL 17081 0 1
// take_path ( pojedou , path , argessive ) ;
17057: LD_VAR 0 7
17061: PPUSH
17062: LD_VAR 0 3
17066: PPUSH
17067: LD_VAR 0 4
17071: PPUSH
17072: CALL 16051 0 3
// end ;
17076: LD_VAR 0 6
17080: RET
// export function wait_for_drivers ( cars ) ; var i , vsichni_ready , k ; begin
17081: LD_INT 0
17083: PPUSH
17084: PPUSH
17085: PPUSH
17086: PPUSH
// k := 0 ;
17087: LD_ADDR_VAR 0 5
17091: PUSH
17092: LD_INT 0
17094: ST_TO_ADDR
// while not vsichni_ready do
17095: LD_VAR 0 4
17099: NOT
17100: IFFALSE 17170
// begin vsichni_ready := true ;
17102: LD_ADDR_VAR 0 4
17106: PUSH
17107: LD_INT 1
17109: ST_TO_ADDR
// k := k + 1 ;
17110: LD_ADDR_VAR 0 5
17114: PUSH
17115: LD_VAR 0 5
17119: PUSH
17120: LD_INT 1
17122: PLUS
17123: ST_TO_ADDR
// for i in cars do
17124: LD_ADDR_VAR 0 3
17128: PUSH
17129: LD_VAR 0 1
17133: PUSH
17134: FOR_IN
17135: IFFALSE 17159
// if not IsDrivenBy ( i ) then
17137: LD_VAR 0 3
17141: PPUSH
17142: CALL_OW 311
17146: NOT
17147: IFFALSE 17157
// vsichni_ready := false ;
17149: LD_ADDR_VAR 0 4
17153: PUSH
17154: LD_INT 0
17156: ST_TO_ADDR
17157: GO 17134
17159: POP
17160: POP
// wait ( 0 0$1.0 ) ;
17161: LD_INT 35
17163: PPUSH
17164: CALL_OW 67
// end ;
17168: GO 17095
// end ;
17170: LD_VAR 0 2
17174: RET
// export function rand_xy_in_map ; var x , y ; begin
17175: LD_INT 0
17177: PPUSH
17178: PPUSH
17179: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
17180: LD_ADDR_VAR 0 3
17184: PUSH
17185: LD_INT 2
17187: PPUSH
17188: LD_EXP 54
17192: PUSH
17193: LD_INT 2
17195: MINUS
17196: PPUSH
17197: CALL_OW 12
17201: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
17202: LD_ADDR_VAR 0 2
17206: PUSH
17207: LD_VAR 0 3
17211: PUSH
17212: LD_INT 2
17214: DIV
17215: PUSH
17216: LD_INT 2
17218: PLUS
17219: PPUSH
17220: LD_EXP 53
17224: PUSH
17225: LD_VAR 0 3
17229: PUSH
17230: LD_INT 2
17232: DIV
17233: PLUS
17234: PUSH
17235: LD_INT 2
17237: MINUS
17238: PPUSH
17239: CALL_OW 12
17243: ST_TO_ADDR
// result := [ x , y ] ;
17244: LD_ADDR_VAR 0 1
17248: PUSH
17249: LD_VAR 0 2
17253: PUSH
17254: LD_VAR 0 3
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: ST_TO_ADDR
// end ;
17263: LD_VAR 0 1
17267: RET
// export function TalkOn ; begin
17268: LD_INT 0
17270: PPUSH
// stop_talking := true ;
17271: LD_ADDR_OWVAR 56
17275: PUSH
17276: LD_INT 1
17278: ST_TO_ADDR
// end ;
17279: LD_VAR 0 1
17283: RET
// export function TalkOff ; begin
17284: LD_INT 0
17286: PPUSH
// stop_talking := false ;
17287: LD_ADDR_OWVAR 56
17291: PUSH
17292: LD_INT 0
17294: ST_TO_ADDR
// end ;
17295: LD_VAR 0 1
17299: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
17300: LD_INT 0
17302: PPUSH
17303: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
17304: LD_ADDR_VAR 0 8
17308: PUSH
17309: LD_VAR 0 1
17313: PPUSH
17314: LD_VAR 0 3
17318: PPUSH
17319: LD_VAR 0 4
17323: PPUSH
17324: LD_VAR 0 5
17328: PPUSH
17329: LD_VAR 0 6
17333: PPUSH
17334: CALL 17380 0 5
17338: ST_TO_ADDR
// if kdo then
17339: LD_VAR 0 8
17343: IFFALSE 17367
// result := Say ( kdo , ident ) else
17345: LD_ADDR_VAR 0 7
17349: PUSH
17350: LD_VAR 0 8
17354: PPUSH
17355: LD_VAR 0 2
17359: PPUSH
17360: CALL_OW 88
17364: ST_TO_ADDR
17365: GO 17375
// result := false ;
17367: LD_ADDR_VAR 0 7
17371: PUSH
17372: LD_INT 0
17374: ST_TO_ADDR
// end ;
17375: LD_VAR 0 7
17379: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
17380: LD_INT 0
17382: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
17383: LD_ADDR_VAR 0 1
17387: PUSH
17388: LD_VAR 0 1
17392: PPUSH
17393: LD_INT 21
17395: PUSH
17396: LD_INT 1
17398: PUSH
17399: EMPTY
17400: LIST
17401: LIST
17402: PUSH
17403: LD_INT 22
17405: PUSH
17406: LD_VAR 0 2
17410: PUSH
17411: EMPTY
17412: LIST
17413: LIST
17414: PUSH
17415: LD_INT 3
17417: PUSH
17418: LD_INT 23
17420: PUSH
17421: LD_INT 0
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: PUSH
17428: EMPTY
17429: LIST
17430: LIST
17431: LIST
17432: LIST
17433: PPUSH
17434: CALL_OW 72
17438: ST_TO_ADDR
// if sex <> 0 then
17439: LD_VAR 0 3
17443: PUSH
17444: LD_INT 0
17446: NONEQUAL
17447: IFFALSE 17476
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
17449: LD_ADDR_VAR 0 1
17453: PUSH
17454: LD_VAR 0 1
17458: PPUSH
17459: LD_INT 26
17461: PUSH
17462: LD_VAR 0 3
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: PPUSH
17471: CALL_OW 72
17475: ST_TO_ADDR
// if Hclass <> 0 then
17476: LD_VAR 0 4
17480: PUSH
17481: LD_INT 0
17483: NONEQUAL
17484: IFFALSE 17513
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
17486: LD_ADDR_VAR 0 1
17490: PUSH
17491: LD_VAR 0 1
17495: PPUSH
17496: LD_INT 25
17498: PUSH
17499: LD_VAR 0 4
17503: PUSH
17504: EMPTY
17505: LIST
17506: LIST
17507: PPUSH
17508: CALL_OW 72
17512: ST_TO_ADDR
// if index <= 0 then
17513: LD_VAR 0 5
17517: PUSH
17518: LD_INT 0
17520: LESSEQUAL
17521: IFFALSE 17531
// index := 1 ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 1
17530: ST_TO_ADDR
// if lidi >= index then
17531: LD_VAR 0 1
17535: PUSH
17536: LD_VAR 0 5
17540: GREATEREQUAL
17541: IFFALSE 17561
// result := lidi [ index ] else
17543: LD_ADDR_VAR 0 6
17547: PUSH
17548: LD_VAR 0 1
17552: PUSH
17553: LD_VAR 0 5
17557: ARRAY
17558: ST_TO_ADDR
17559: GO 17569
// result := 0 ;
17561: LD_ADDR_VAR 0 6
17565: PUSH
17566: LD_INT 0
17568: ST_TO_ADDR
// end ;
17569: LD_VAR 0 6
17573: RET
// export function add ( list , list1 ) ; begin
17574: LD_INT 0
17576: PPUSH
// if list = 0 then
17577: LD_VAR 0 1
17581: PUSH
17582: LD_INT 0
17584: EQUAL
17585: IFFALSE 17594
// list := [ ] ;
17587: LD_ADDR_VAR 0 1
17591: PUSH
17592: EMPTY
17593: ST_TO_ADDR
// if list1 = 0 then
17594: LD_VAR 0 2
17598: PUSH
17599: LD_INT 0
17601: EQUAL
17602: IFFALSE 17611
// list1 := [ ] ;
17604: LD_ADDR_VAR 0 2
17608: PUSH
17609: EMPTY
17610: ST_TO_ADDR
// result := list ^ list1 ;
17611: LD_ADDR_VAR 0 3
17615: PUSH
17616: LD_VAR 0 1
17620: PUSH
17621: LD_VAR 0 2
17625: ADD
17626: ST_TO_ADDR
// end ;
17627: LD_VAR 0 3
17631: RET
// export function split ( list ) ; var l1 , l2 , i ; begin
17632: LD_INT 0
17634: PPUSH
17635: PPUSH
17636: PPUSH
17637: PPUSH
// l1 := [ ] ;
17638: LD_ADDR_VAR 0 3
17642: PUSH
17643: EMPTY
17644: ST_TO_ADDR
// l2 := [ ] ;
17645: LD_ADDR_VAR 0 4
17649: PUSH
17650: EMPTY
17651: ST_TO_ADDR
// for i := 1 to list div 2 do
17652: LD_ADDR_VAR 0 5
17656: PUSH
17657: DOUBLE
17658: LD_INT 1
17660: DEC
17661: ST_TO_ADDR
17662: LD_VAR 0 1
17666: PUSH
17667: LD_INT 2
17669: DIV
17670: PUSH
17671: FOR_TO
17672: IFFALSE 17698
// begin l1 := l1 ^ list [ i ] ;
17674: LD_ADDR_VAR 0 3
17678: PUSH
17679: LD_VAR 0 3
17683: PUSH
17684: LD_VAR 0 1
17688: PUSH
17689: LD_VAR 0 5
17693: ARRAY
17694: ADD
17695: ST_TO_ADDR
// end ;
17696: GO 17671
17698: POP
17699: POP
// l2 := list diff l1 ;
17700: LD_ADDR_VAR 0 4
17704: PUSH
17705: LD_VAR 0 1
17709: PUSH
17710: LD_VAR 0 3
17714: DIFF
17715: ST_TO_ADDR
// result := [ l1 ] ^ [ l2 ] ;
17716: LD_ADDR_VAR 0 2
17720: PUSH
17721: LD_VAR 0 3
17725: PUSH
17726: EMPTY
17727: LIST
17728: PUSH
17729: LD_VAR 0 4
17733: PUSH
17734: EMPTY
17735: LIST
17736: ADD
17737: ST_TO_ADDR
// end ;
17738: LD_VAR 0 2
17742: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
17743: LD_INT 0
17745: PPUSH
// if not hinty_co_byli then
17746: LD_EXP 89
17750: NOT
17751: IFFALSE 17760
// hinty_co_byli := [ ] ;
17753: LD_ADDR_EXP 89
17757: PUSH
17758: EMPTY
17759: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
17760: LD_VAR 0 1
17764: PUSH
17765: LD_EXP 89
17769: IN
17770: NOT
17771: IFFALSE 17798
// begin hinty_co_byli := hinty_co_byli ^ ident ;
17773: LD_ADDR_EXP 89
17777: PUSH
17778: LD_EXP 89
17782: PUSH
17783: LD_VAR 0 1
17787: ADD
17788: ST_TO_ADDR
// Hint ( ident ) ;
17789: LD_VAR 0 1
17793: PPUSH
17794: CALL_OW 339
// end ; end ; end_of_file
17798: LD_VAR 0 2
17802: RET
// export people , sol , sci , mec , eng ; var cars , cargo , scout , attack , defence ; var scout1 , scout2 ; var builds , forts ; var scout1_pb , scout1_pr , scout1_ptr1 , scout1_ptl1 , scout1_ptr2 , scout1_pta , scout1_pl , scout1_pa , scout1_pd1 , scout1_pd2 ; var broken ; var attack_l , attack_m , attack_r ; var to_defence , to_attack , to_scout , to_cargo ; var sec ; every 0 0$0.1 do var temp1 ;
17803: GO 17805
17805: DISABLE
17806: LD_INT 0
17808: PPUSH
// begin to_defence := false ;
17809: LD_ADDR_LOC 25
17813: PUSH
17814: LD_INT 0
17816: ST_TO_ADDR
// to_attack := false ;
17817: LD_ADDR_LOC 26
17821: PUSH
17822: LD_INT 0
17824: ST_TO_ADDR
// to_scout := false ;
17825: LD_ADDR_LOC 27
17829: PUSH
17830: LD_INT 0
17832: ST_TO_ADDR
// temp1 := FilterAllUnits ( [ f_side , russians ] ) ;
17833: LD_ADDR_VAR 0 1
17837: PUSH
17838: LD_INT 22
17840: PUSH
17841: LD_EXP 2
17845: PUSH
17846: EMPTY
17847: LIST
17848: LIST
17849: PPUSH
17850: CALL_OW 69
17854: ST_TO_ADDR
// ComRemember ( temp1 ) ;
17855: LD_VAR 0 1
17859: PPUSH
17860: CALL_OW 143
// people := UnitFilter ( temp1 , [ f_type , unit_human ] ) ;
17864: LD_ADDR_EXP 90
17868: PUSH
17869: LD_VAR 0 1
17873: PPUSH
17874: LD_INT 21
17876: PUSH
17877: LD_INT 1
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: PPUSH
17884: CALL_OW 72
17888: ST_TO_ADDR
// sol := UnitFilter ( people , [ f_class , class_soldier ] ) ;
17889: LD_ADDR_EXP 91
17893: PUSH
17894: LD_EXP 90
17898: PPUSH
17899: LD_INT 25
17901: PUSH
17902: LD_INT 1
17904: PUSH
17905: EMPTY
17906: LIST
17907: LIST
17908: PPUSH
17909: CALL_OW 72
17913: ST_TO_ADDR
// sci := UnitFilter ( people , [ f_class , class_scientistic ] ) ;
17914: LD_ADDR_EXP 92
17918: PUSH
17919: LD_EXP 90
17923: PPUSH
17924: LD_INT 25
17926: PUSH
17927: LD_INT 4
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: PPUSH
17934: CALL_OW 72
17938: ST_TO_ADDR
// mec := UnitFilter ( people , [ f_class , class_mechanic ] ) ;
17939: LD_ADDR_EXP 93
17943: PUSH
17944: LD_EXP 90
17948: PPUSH
17949: LD_INT 25
17951: PUSH
17952: LD_INT 3
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: PPUSH
17959: CALL_OW 72
17963: ST_TO_ADDR
// eng := UnitFilter ( people , [ f_class , class_engineer ] ) ;
17964: LD_ADDR_EXP 94
17968: PUSH
17969: LD_EXP 90
17973: PPUSH
17974: LD_INT 25
17976: PUSH
17977: LD_INT 2
17979: PUSH
17980: EMPTY
17981: LIST
17982: LIST
17983: PPUSH
17984: CALL_OW 72
17988: ST_TO_ADDR
// cars := UnitFilter ( temp1 , [ f_type , unit_vehicle ] ) ;
17989: LD_ADDR_LOC 2
17993: PUSH
17994: LD_VAR 0 1
17998: PPUSH
17999: LD_INT 21
18001: PUSH
18002: LD_INT 2
18004: PUSH
18005: EMPTY
18006: LIST
18007: LIST
18008: PPUSH
18009: CALL_OW 72
18013: ST_TO_ADDR
// broken := [ ] ;
18014: LD_ADDR_LOC 21
18018: PUSH
18019: EMPTY
18020: ST_TO_ADDR
// cargo := [ cargo_1 ] ;
18021: LD_ADDR_LOC 3
18025: PUSH
18026: LD_INT 11
18028: PUSH
18029: EMPTY
18030: LIST
18031: ST_TO_ADDR
// scout := [ scout_1 , scout_2 ] ;
18032: LD_ADDR_LOC 4
18036: PUSH
18037: LD_INT 10
18039: PUSH
18040: LD_INT 42
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: ST_TO_ADDR
// scout1 := [ scout_1 ] ;
18047: LD_ADDR_LOC 7
18051: PUSH
18052: LD_INT 10
18054: PUSH
18055: EMPTY
18056: LIST
18057: ST_TO_ADDR
// scout2 := [ scout_2 ] ;
18058: LD_ADDR_LOC 8
18062: PUSH
18063: LD_INT 42
18065: PUSH
18066: EMPTY
18067: LIST
18068: ST_TO_ADDR
// defence := [ scout_2 , defence_1 , defence_2 ] ;
18069: LD_ADDR_LOC 6
18073: PUSH
18074: LD_INT 42
18076: PUSH
18077: LD_INT 12
18079: PUSH
18080: LD_INT 43
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: LIST
18087: ST_TO_ADDR
// attack := [ scout_1 , scout_2 , defence_1 ] ;
18088: LD_ADDR_LOC 5
18092: PUSH
18093: LD_INT 10
18095: PUSH
18096: LD_INT 42
18098: PUSH
18099: LD_INT 12
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: LIST
18106: ST_TO_ADDR
// builds := UnitFilter ( temp1 , [ f_type , unit_building ] ) ;
18107: LD_ADDR_LOC 9
18111: PUSH
18112: LD_VAR 0 1
18116: PPUSH
18117: LD_INT 21
18119: PUSH
18120: LD_INT 3
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: PPUSH
18127: CALL_OW 72
18131: ST_TO_ADDR
// forts := [ fort1 , fort2 , fort3 , fort4 , fort5 ] ;
18132: LD_ADDR_LOC 10
18136: PUSH
18137: LD_INT 3
18139: PUSH
18140: LD_INT 2
18142: PUSH
18143: LD_INT 39
18145: PUSH
18146: LD_INT 4
18148: PUSH
18149: LD_INT 45
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: LIST
18158: ST_TO_ADDR
// scout1_pb := [ 92 , 53 ] ;
18159: LD_ADDR_LOC 11
18163: PUSH
18164: LD_INT 92
18166: PUSH
18167: LD_INT 53
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: ST_TO_ADDR
// scout1_pr := [ 102 , 56 , 110 , 59 , 119 , 60 , 120 , 64 , 109 , 60 , 98 , 55 ] ;
18174: LD_ADDR_LOC 12
18178: PUSH
18179: LD_INT 102
18181: PUSH
18182: LD_INT 56
18184: PUSH
18185: LD_INT 110
18187: PUSH
18188: LD_INT 59
18190: PUSH
18191: LD_INT 119
18193: PUSH
18194: LD_INT 60
18196: PUSH
18197: LD_INT 120
18199: PUSH
18200: LD_INT 64
18202: PUSH
18203: LD_INT 109
18205: PUSH
18206: LD_INT 60
18208: PUSH
18209: LD_INT 98
18211: PUSH
18212: LD_INT 55
18214: PUSH
18215: EMPTY
18216: LIST
18217: LIST
18218: LIST
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: ST_TO_ADDR
// scout1_ptr1 := [ 95 , 50 , 92 , 46 , 90 , 39 , 87 , 30 , - 8 , 97 , 25 , 80 , 32 , 82 , 42 ] ;
18229: LD_ADDR_LOC 13
18233: PUSH
18234: LD_INT 95
18236: PUSH
18237: LD_INT 50
18239: PUSH
18240: LD_INT 92
18242: PUSH
18243: LD_INT 46
18245: PUSH
18246: LD_INT 90
18248: PUSH
18249: LD_INT 39
18251: PUSH
18252: LD_INT 87
18254: PUSH
18255: LD_INT 30
18257: PUSH
18258: LD_INT 8
18260: NEG
18261: PUSH
18262: LD_INT 97
18264: PUSH
18265: LD_INT 25
18267: PUSH
18268: LD_INT 80
18270: PUSH
18271: LD_INT 32
18273: PUSH
18274: LD_INT 82
18276: PUSH
18277: LD_INT 42
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: LIST
18284: LIST
18285: LIST
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: ST_TO_ADDR
// scout1_ptr2 := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 69 , 21 , 82 , 39 , 87 , 48 ] ;
18297: LD_ADDR_LOC 15
18301: PUSH
18302: LD_INT 90
18304: PUSH
18305: LD_INT 42
18307: PUSH
18308: LD_INT 91
18310: PUSH
18311: LD_INT 30
18313: PUSH
18314: LD_INT 81
18316: PUSH
18317: LD_INT 13
18319: PUSH
18320: LD_INT 68
18322: PUSH
18323: LD_INT 12
18325: PUSH
18326: LD_INT 67
18328: PUSH
18329: LD_INT 21
18331: PUSH
18332: LD_INT 57
18334: PUSH
18335: LD_INT 25
18337: PUSH
18338: LD_INT 69
18340: PUSH
18341: LD_INT 21
18343: PUSH
18344: LD_INT 82
18346: PUSH
18347: LD_INT 39
18349: PUSH
18350: LD_INT 87
18352: PUSH
18353: LD_INT 48
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: LIST
18363: LIST
18364: LIST
18365: LIST
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: LIST
18371: LIST
18372: LIST
18373: LIST
18374: LIST
18375: ST_TO_ADDR
// scout1_pta := [ 90 , 42 , 91 , 30 , 81 , 13 , 68 , 12 , 67 , 21 , 57 , 25 , 41 , 20 , 29 , 23 , 42 , 41 , 85 , 49 ] ;
18376: LD_ADDR_LOC 16
18380: PUSH
18381: LD_INT 90
18383: PUSH
18384: LD_INT 42
18386: PUSH
18387: LD_INT 91
18389: PUSH
18390: LD_INT 30
18392: PUSH
18393: LD_INT 81
18395: PUSH
18396: LD_INT 13
18398: PUSH
18399: LD_INT 68
18401: PUSH
18402: LD_INT 12
18404: PUSH
18405: LD_INT 67
18407: PUSH
18408: LD_INT 21
18410: PUSH
18411: LD_INT 57
18413: PUSH
18414: LD_INT 25
18416: PUSH
18417: LD_INT 41
18419: PUSH
18420: LD_INT 20
18422: PUSH
18423: LD_INT 29
18425: PUSH
18426: LD_INT 23
18428: PUSH
18429: LD_INT 42
18431: PUSH
18432: LD_INT 41
18434: PUSH
18435: LD_INT 85
18437: PUSH
18438: LD_INT 49
18440: PUSH
18441: EMPTY
18442: LIST
18443: LIST
18444: LIST
18445: LIST
18446: LIST
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: LIST
18455: LIST
18456: LIST
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: ST_TO_ADDR
// scout1_ptl1 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 30 , 25 , 31 , 16 , 34 , 36 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18463: LD_ADDR_LOC 14
18467: PUSH
18468: LD_INT 68
18470: PUSH
18471: LD_INT 88
18473: PUSH
18474: LD_INT 51
18476: PUSH
18477: LD_INT 78
18479: PUSH
18480: LD_INT 40
18482: PUSH
18483: LD_INT 57
18485: PUSH
18486: LD_INT 43
18488: PUSH
18489: LD_INT 42
18491: PUSH
18492: LD_INT 30
18494: PUSH
18495: LD_INT 25
18497: PUSH
18498: LD_INT 31
18500: PUSH
18501: LD_INT 16
18503: PUSH
18504: LD_INT 34
18506: PUSH
18507: LD_INT 36
18509: PUSH
18510: LD_INT 45
18512: PUSH
18513: LD_INT 69
18515: PUSH
18516: LD_INT 64
18518: PUSH
18519: LD_INT 87
18521: PUSH
18522: LD_INT 98
18524: PUSH
18525: LD_INT 97
18527: PUSH
18528: EMPTY
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: LIST
18537: LIST
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: ST_TO_ADDR
// scout1_pl := [ 84 , 50 , 70 , 47 , 67 , 46 , 62 , 49 , 55 , 49 , - 5 , 50 , 43 , 60 , 49 , 71 , 47 , 83 , 49 ] ;
18550: LD_ADDR_LOC 17
18554: PUSH
18555: LD_INT 84
18557: PUSH
18558: LD_INT 50
18560: PUSH
18561: LD_INT 70
18563: PUSH
18564: LD_INT 47
18566: PUSH
18567: LD_INT 67
18569: PUSH
18570: LD_INT 46
18572: PUSH
18573: LD_INT 62
18575: PUSH
18576: LD_INT 49
18578: PUSH
18579: LD_INT 55
18581: PUSH
18582: LD_INT 49
18584: PUSH
18585: LD_INT 5
18587: NEG
18588: PUSH
18589: LD_INT 50
18591: PUSH
18592: LD_INT 43
18594: PUSH
18595: LD_INT 60
18597: PUSH
18598: LD_INT 49
18600: PUSH
18601: LD_INT 71
18603: PUSH
18604: LD_INT 47
18606: PUSH
18607: LD_INT 83
18609: PUSH
18610: LD_INT 49
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: LIST
18625: LIST
18626: LIST
18627: LIST
18628: LIST
18629: LIST
18630: LIST
18631: LIST
18632: LIST
18633: ST_TO_ADDR
// scout1_pa := [ 84 , 50 , 70 , 47 , 60 , 44 , 53 , 44 , 43 , 41 , 39 , 57 , 43 , 71 , 52 , 82 , 63 , 87 , 109 , 95 ] ;
18634: LD_ADDR_LOC 18
18638: PUSH
18639: LD_INT 84
18641: PUSH
18642: LD_INT 50
18644: PUSH
18645: LD_INT 70
18647: PUSH
18648: LD_INT 47
18650: PUSH
18651: LD_INT 60
18653: PUSH
18654: LD_INT 44
18656: PUSH
18657: LD_INT 53
18659: PUSH
18660: LD_INT 44
18662: PUSH
18663: LD_INT 43
18665: PUSH
18666: LD_INT 41
18668: PUSH
18669: LD_INT 39
18671: PUSH
18672: LD_INT 57
18674: PUSH
18675: LD_INT 43
18677: PUSH
18678: LD_INT 71
18680: PUSH
18681: LD_INT 52
18683: PUSH
18684: LD_INT 82
18686: PUSH
18687: LD_INT 63
18689: PUSH
18690: LD_INT 87
18692: PUSH
18693: LD_INT 109
18695: PUSH
18696: LD_INT 95
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: LIST
18703: LIST
18704: LIST
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: LIST
18713: LIST
18714: LIST
18715: LIST
18716: LIST
18717: LIST
18718: LIST
18719: LIST
18720: ST_TO_ADDR
// scout1_pd1 := [ 71 , 81 , 62 , 63 , 61 , 74 , 79 , 96 ] ;
18721: LD_ADDR_LOC 19
18725: PUSH
18726: LD_INT 71
18728: PUSH
18729: LD_INT 81
18731: PUSH
18732: LD_INT 62
18734: PUSH
18735: LD_INT 63
18737: PUSH
18738: LD_INT 61
18740: PUSH
18741: LD_INT 74
18743: PUSH
18744: LD_INT 79
18746: PUSH
18747: LD_INT 96
18749: PUSH
18750: EMPTY
18751: LIST
18752: LIST
18753: LIST
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: ST_TO_ADDR
// scout1_pd2 := [ 68 , 88 , 51 , 78 , 40 , 57 , 43 , 42 , 45 , 69 , 64 , 87 , 98 , 97 ] ;
18760: LD_ADDR_LOC 20
18764: PUSH
18765: LD_INT 68
18767: PUSH
18768: LD_INT 88
18770: PUSH
18771: LD_INT 51
18773: PUSH
18774: LD_INT 78
18776: PUSH
18777: LD_INT 40
18779: PUSH
18780: LD_INT 57
18782: PUSH
18783: LD_INT 43
18785: PUSH
18786: LD_INT 42
18788: PUSH
18789: LD_INT 45
18791: PUSH
18792: LD_INT 69
18794: PUSH
18795: LD_INT 64
18797: PUSH
18798: LD_INT 87
18800: PUSH
18801: LD_INT 98
18803: PUSH
18804: LD_INT 97
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: ST_TO_ADDR
// attack_l := [ 60 , 86 , 37 , 44 ] ;
18823: LD_ADDR_LOC 22
18827: PUSH
18828: LD_INT 60
18830: PUSH
18831: LD_INT 86
18833: PUSH
18834: LD_INT 37
18836: PUSH
18837: LD_INT 44
18839: PUSH
18840: EMPTY
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: ST_TO_ADDR
// attack_m := [ 89 , 53 , 41 , 42 ] ;
18846: LD_ADDR_LOC 23
18850: PUSH
18851: LD_INT 89
18853: PUSH
18854: LD_INT 53
18856: PUSH
18857: LD_INT 41
18859: PUSH
18860: LD_INT 42
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: LIST
18867: LIST
18868: ST_TO_ADDR
// attack_r := [ 88 , 55 , 82 , 13 ] ;
18869: LD_ADDR_LOC 24
18873: PUSH
18874: LD_INT 88
18876: PUSH
18877: LD_INT 55
18879: PUSH
18880: LD_INT 82
18882: PUSH
18883: LD_INT 13
18885: PUSH
18886: EMPTY
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: ST_TO_ADDR
// end ;
18892: PPOPN 1
18894: END
// every 0 0$6.0 do
18895: GO 18897
18897: DISABLE
// begin depart ( scout diff broken , sol union mec , scout1_pb , true , false ) ;
18898: LD_LOC 4
18902: PUSH
18903: LD_LOC 21
18907: DIFF
18908: PPUSH
18909: LD_EXP 91
18913: PUSH
18914: LD_EXP 93
18918: UNION
18919: PPUSH
18920: LD_LOC 11
18924: PPUSH
18925: LD_INT 1
18927: PPUSH
18928: LD_INT 0
18930: PPUSH
18931: CALL 17019 0 5
// take_path ( scout1 diff broken , scout1_pr , true ) ;
18935: LD_LOC 7
18939: PUSH
18940: LD_LOC 21
18944: DIFF
18945: PPUSH
18946: LD_LOC 12
18950: PPUSH
18951: LD_INT 1
18953: PPUSH
18954: CALL 16051 0 3
// take_path ( scout2 diff broken , scout1_pl , true ) ;
18958: LD_LOC 8
18962: PUSH
18963: LD_LOC 21
18967: DIFF
18968: PPUSH
18969: LD_LOC 17
18973: PPUSH
18974: LD_INT 1
18976: PPUSH
18977: CALL 16051 0 3
// AddComReturn ( scout diff broken ) ;
18981: LD_LOC 4
18985: PUSH
18986: LD_LOC 21
18990: DIFF
18991: PPUSH
18992: CALL_OW 204
// end ;
18996: END
// every 0 0$56.0 + 0 0$10 do var x , ok , i ;
18997: GO 18999
18999: DISABLE
19000: LD_INT 0
19002: PPUSH
19003: PPUSH
19004: PPUSH
// begin ok := true ;
19005: LD_ADDR_VAR 0 2
19009: PUSH
19010: LD_INT 1
19012: ST_TO_ADDR
// for i in scout do
19013: LD_ADDR_VAR 0 3
19017: PUSH
19018: LD_LOC 4
19022: PUSH
19023: FOR_IN
19024: IFFALSE 19047
// begin if HasTask ( i ) then
19026: LD_VAR 0 3
19030: PPUSH
19031: CALL_OW 314
19035: IFFALSE 19045
// ok := false ;
19037: LD_ADDR_VAR 0 2
19041: PUSH
19042: LD_INT 0
19044: ST_TO_ADDR
// end ;
19045: GO 19023
19047: POP
19048: POP
// if ok then
19049: LD_VAR 0 2
19053: IFFALSE 19945
// begin x := Rand ( 1 , 7 ) ;
19055: LD_ADDR_VAR 0 1
19059: PUSH
19060: LD_INT 1
19062: PPUSH
19063: LD_INT 7
19065: PPUSH
19066: CALL_OW 12
19070: ST_TO_ADDR
// if go_up then
19071: LD_EXP 62
19075: IFFALSE 19101
// begin x := Rand ( 3 , 4 ) ;
19077: LD_ADDR_VAR 0 1
19081: PUSH
19082: LD_INT 3
19084: PPUSH
19085: LD_INT 4
19087: PPUSH
19088: CALL_OW 12
19092: ST_TO_ADDR
// go_up := false ;
19093: LD_ADDR_EXP 62
19097: PUSH
19098: LD_INT 0
19100: ST_TO_ADDR
// end ; case x of 1 :
19101: LD_VAR 0 1
19105: PUSH
19106: LD_INT 1
19108: DOUBLE
19109: EQUAL
19110: IFTRUE 19114
19112: GO 19246
19114: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
19115: LD_LOC 7
19119: PUSH
19120: LD_LOC 21
19124: DIFF
19125: PPUSH
19126: LD_EXP 91
19130: PPUSH
19131: LD_LOC 11
19135: PPUSH
19136: LD_INT 1
19138: PPUSH
19139: LD_INT 0
19141: PPUSH
19142: CALL 17019 0 5
// if more_scouting then
19146: LD_EXP 61
19150: IFFALSE 19175
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19152: LD_LOC 7
19156: PUSH
19157: LD_LOC 21
19161: DIFF
19162: PPUSH
19163: LD_LOC 13
19167: PPUSH
19168: LD_INT 1
19170: PPUSH
19171: CALL 16051 0 3
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19175: LD_LOC 7
19179: PUSH
19180: LD_LOC 21
19184: DIFF
19185: PPUSH
19186: LD_LOC 17
19190: PPUSH
19191: LD_INT 1
19193: PPUSH
19194: CALL 16051 0 3
// depart ( scout2 diff broken , sol , scout1_pd1 , true , false ) ;
19198: LD_LOC 8
19202: PUSH
19203: LD_LOC 21
19207: DIFF
19208: PPUSH
19209: LD_EXP 91
19213: PPUSH
19214: LD_LOC 19
19218: PPUSH
19219: LD_INT 1
19221: PPUSH
19222: LD_INT 0
19224: PPUSH
19225: CALL 17019 0 5
// AddComReturn ( scout diff broken ) ;
19229: LD_LOC 4
19233: PUSH
19234: LD_LOC 21
19238: DIFF
19239: PPUSH
19240: CALL_OW 204
// end ; 2 :
19244: GO 19945
19246: LD_INT 2
19248: DOUBLE
19249: EQUAL
19250: IFTRUE 19254
19252: GO 19363
19254: POP
// begin depart ( scout1 diff broken , sol , scout1_pb , true , false ) ;
19255: LD_LOC 7
19259: PUSH
19260: LD_LOC 21
19264: DIFF
19265: PPUSH
19266: LD_EXP 91
19270: PPUSH
19271: LD_LOC 11
19275: PPUSH
19276: LD_INT 1
19278: PPUSH
19279: LD_INT 0
19281: PPUSH
19282: CALL 17019 0 5
// if more_scouting then
19286: LD_EXP 61
19290: IFFALSE 19315
// take_path ( scout1 diff broken , scout1_ptr1 , true ) ;
19292: LD_LOC 7
19296: PUSH
19297: LD_LOC 21
19301: DIFF
19302: PPUSH
19303: LD_LOC 13
19307: PPUSH
19308: LD_INT 1
19310: PPUSH
19311: CALL 16051 0 3
// depart ( scout2 diff broken , sol , scout1_pd2 , true , false ) ;
19315: LD_LOC 8
19319: PUSH
19320: LD_LOC 21
19324: DIFF
19325: PPUSH
19326: LD_EXP 91
19330: PPUSH
19331: LD_LOC 20
19335: PPUSH
19336: LD_INT 1
19338: PPUSH
19339: LD_INT 0
19341: PPUSH
19342: CALL 17019 0 5
// AddComReturn ( scout1 diff broken ) ;
19346: LD_LOC 7
19350: PUSH
19351: LD_LOC 21
19355: DIFF
19356: PPUSH
19357: CALL_OW 204
// end ; 3 :
19361: GO 19945
19363: LD_INT 3
19365: DOUBLE
19366: EQUAL
19367: IFTRUE 19371
19369: GO 19449
19371: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19372: LD_LOC 4
19376: PUSH
19377: LD_LOC 21
19381: DIFF
19382: PPUSH
19383: LD_EXP 91
19387: PPUSH
19388: LD_LOC 11
19392: PPUSH
19393: LD_INT 1
19395: PPUSH
19396: LD_INT 0
19398: PPUSH
19399: CALL 17019 0 5
// if more_scouting then
19403: LD_EXP 61
19407: IFFALSE 19432
// take_path ( scout diff broken , scout1_ptr2 , true ) ;
19409: LD_LOC 4
19413: PUSH
19414: LD_LOC 21
19418: DIFF
19419: PPUSH
19420: LD_LOC 15
19424: PPUSH
19425: LD_INT 1
19427: PPUSH
19428: CALL 16051 0 3
// AddComReturn ( scout diff broken ) ;
19432: LD_LOC 4
19436: PUSH
19437: LD_LOC 21
19441: DIFF
19442: PPUSH
19443: CALL_OW 204
// end ; 4 :
19447: GO 19945
19449: LD_INT 4
19451: DOUBLE
19452: EQUAL
19453: IFTRUE 19457
19455: GO 19576
19457: POP
// begin if more_scouting then
19458: LD_EXP 61
19462: IFFALSE 19497
// depart ( scout diff broken , sol , scout1_pta , true , false ) else
19464: LD_LOC 4
19468: PUSH
19469: LD_LOC 21
19473: DIFF
19474: PPUSH
19475: LD_EXP 91
19479: PPUSH
19480: LD_LOC 16
19484: PPUSH
19485: LD_INT 1
19487: PPUSH
19488: LD_INT 0
19490: PPUSH
19491: CALL 17019 0 5
19495: GO 19559
// begin depart ( scout1 diff broken , sol , scout1_pd2 , true , false ) ;
19497: LD_LOC 7
19501: PUSH
19502: LD_LOC 21
19506: DIFF
19507: PPUSH
19508: LD_EXP 91
19512: PPUSH
19513: LD_LOC 20
19517: PPUSH
19518: LD_INT 1
19520: PPUSH
19521: LD_INT 0
19523: PPUSH
19524: CALL 17019 0 5
// depart ( scout2 diff broken , sol , scout1_ptr1 , true , false ) ;
19528: LD_LOC 8
19532: PUSH
19533: LD_LOC 21
19537: DIFF
19538: PPUSH
19539: LD_EXP 91
19543: PPUSH
19544: LD_LOC 13
19548: PPUSH
19549: LD_INT 1
19551: PPUSH
19552: LD_INT 0
19554: PPUSH
19555: CALL 17019 0 5
// end ; AddComReturn ( scout diff broken ) ;
19559: LD_LOC 4
19563: PUSH
19564: LD_LOC 21
19568: DIFF
19569: PPUSH
19570: CALL_OW 204
// end ; 5 :
19574: GO 19945
19576: LD_INT 5
19578: DOUBLE
19579: EQUAL
19580: IFTRUE 19584
19582: GO 19728
19584: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19585: LD_LOC 4
19589: PUSH
19590: LD_LOC 21
19594: DIFF
19595: PPUSH
19596: LD_EXP 91
19600: PPUSH
19601: LD_LOC 11
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: LD_INT 0
19611: PPUSH
19612: CALL 17019 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19616: LD_LOC 7
19620: PUSH
19621: LD_LOC 21
19625: DIFF
19626: PPUSH
19627: LD_LOC 17
19631: PPUSH
19632: LD_INT 1
19634: PPUSH
19635: CALL 16051 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19639: LD_LOC 8
19643: PUSH
19644: LD_LOC 21
19648: DIFF
19649: PPUSH
19650: LD_INT 20
19652: PPUSH
19653: CALL_OW 202
// if more_scouting then
19657: LD_EXP 61
19661: IFFALSE 19688
// take_path ( scout2 diff broken , scout1_ptl1 , true ) else
19663: LD_LOC 8
19667: PUSH
19668: LD_LOC 21
19672: DIFF
19673: PPUSH
19674: LD_LOC 14
19678: PPUSH
19679: LD_INT 1
19681: PPUSH
19682: CALL 16051 0 3
19686: GO 19711
// take_path ( scout2 diff broken , scout1_pd2 , true ) ;
19688: LD_LOC 8
19692: PUSH
19693: LD_LOC 21
19697: DIFF
19698: PPUSH
19699: LD_LOC 20
19703: PPUSH
19704: LD_INT 1
19706: PPUSH
19707: CALL 16051 0 3
// AddComReturn ( scout diff broken ) ;
19711: LD_LOC 4
19715: PUSH
19716: LD_LOC 21
19720: DIFF
19721: PPUSH
19722: CALL_OW 204
// end ; 6 :
19726: GO 19945
19728: LD_INT 6
19730: DOUBLE
19731: EQUAL
19732: IFTRUE 19736
19734: GO 19826
19736: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19737: LD_LOC 4
19741: PUSH
19742: LD_LOC 21
19746: DIFF
19747: PPUSH
19748: LD_EXP 91
19752: PPUSH
19753: LD_LOC 11
19757: PPUSH
19758: LD_INT 1
19760: PPUSH
19761: LD_INT 0
19763: PPUSH
19764: CALL 17019 0 5
// take_path ( scout1 diff broken , scout1_pl , true ) ;
19768: LD_LOC 7
19772: PUSH
19773: LD_LOC 21
19777: DIFF
19778: PPUSH
19779: LD_LOC 17
19783: PPUSH
19784: LD_INT 1
19786: PPUSH
19787: CALL 16051 0 3
// AddComWait ( scout2 diff broken , 20 ) ;
19791: LD_LOC 8
19795: PUSH
19796: LD_LOC 21
19800: DIFF
19801: PPUSH
19802: LD_INT 20
19804: PPUSH
19805: CALL_OW 202
// AddComReturn ( scout diff broken ) ;
19809: LD_LOC 4
19813: PUSH
19814: LD_LOC 21
19818: DIFF
19819: PPUSH
19820: CALL_OW 204
// end ; 7 :
19824: GO 19945
19826: LD_INT 7
19828: DOUBLE
19829: EQUAL
19830: IFTRUE 19834
19832: GO 19944
19834: POP
// begin depart ( scout diff broken , sol , scout1_pb , true , false ) ;
19835: LD_LOC 4
19839: PUSH
19840: LD_LOC 21
19844: DIFF
19845: PPUSH
19846: LD_EXP 91
19850: PPUSH
19851: LD_LOC 11
19855: PPUSH
19856: LD_INT 1
19858: PPUSH
19859: LD_INT 0
19861: PPUSH
19862: CALL 17019 0 5
// take_path ( scout1 diff broken , scout1_pa , true ) ;
19866: LD_LOC 7
19870: PUSH
19871: LD_LOC 21
19875: DIFF
19876: PPUSH
19877: LD_LOC 18
19881: PPUSH
19882: LD_INT 1
19884: PPUSH
19885: CALL 16051 0 3
// AddComReturn ( scout2 diff broken ) ;
19889: LD_LOC 8
19893: PUSH
19894: LD_LOC 21
19898: DIFF
19899: PPUSH
19900: CALL_OW 204
// take_path ( scout2 diff broken , scout1_pd1 , true ) ;
19904: LD_LOC 8
19908: PUSH
19909: LD_LOC 21
19913: DIFF
19914: PPUSH
19915: LD_LOC 19
19919: PPUSH
19920: LD_INT 1
19922: PPUSH
19923: CALL 16051 0 3
// AddComReturn ( scout diff broken ) ;
19927: LD_LOC 4
19931: PUSH
19932: LD_LOC 21
19936: DIFF
19937: PPUSH
19938: CALL_OW 204
// end ; end ;
19942: GO 19945
19944: POP
// end ; enable ;
19945: ENABLE
// end ;
19946: PPOPN 3
19948: END
// every 0 0$7.0 do
19949: GO 19951
19951: DISABLE
// begin full_forts ( forts , sol ) ;
19952: LD_LOC 10
19956: PPUSH
19957: LD_EXP 91
19961: PPUSH
19962: CALL 16745 0 2
// enable ;
19966: ENABLE
// end ;
19967: END
// every 0 0$5.0 do var i ;
19968: GO 19970
19970: DISABLE
19971: LD_INT 0
19973: PPUSH
// begin for i in mec do
19974: LD_ADDR_VAR 0 1
19978: PUSH
19979: LD_EXP 93
19983: PUSH
19984: FOR_IN
19985: IFFALSE 20049
// begin if not IsBusy ( i ) or not IsInArea ( i , base ) and GetSide ( i ) <> you then
19987: LD_VAR 0 1
19991: PPUSH
19992: CALL_OW 315
19996: NOT
19997: IFTRUE 20033
19999: PUSH
20000: LD_VAR 0 1
20004: PPUSH
20005: LD_INT 5
20007: PPUSH
20008: CALL_OW 308
20012: NOT
20013: IFFALSE 20032
20015: PUSH
20016: LD_VAR 0 1
20020: PPUSH
20021: CALL_OW 255
20025: PUSH
20026: LD_EXP 1
20030: NONEQUAL
20031: AND
20032: OR
20033: IFFALSE 20047
// ComEnterUnit ( i , fact1 ) ;
20035: LD_VAR 0 1
20039: PPUSH
20040: LD_INT 35
20042: PPUSH
20043: CALL_OW 120
// end ;
20047: GO 19984
20049: POP
20050: POP
// enable ;
20051: ENABLE
// end ;
20052: PPOPN 1
20054: END
// every 0 0$5.0 do var i ;
20055: GO 20057
20057: DISABLE
20058: LD_INT 0
20060: PPUSH
// begin if under_attack then
20061: LD_EXP 64
20065: IFFALSE 20129
// for i in eng do
20067: LD_ADDR_VAR 0 1
20071: PUSH
20072: LD_EXP 94
20076: PUSH
20077: FOR_IN
20078: IFFALSE 20125
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 315
20089: NOT
20090: IFFALSE 20109
20092: PUSH
20093: LD_VAR 0 1
20097: PPUSH
20098: CALL_OW 255
20102: PUSH
20103: LD_EXP 1
20107: NONEQUAL
20108: AND
20109: IFFALSE 20123
// ComEnterUnit ( i , depot1 ) ;
20111: LD_VAR 0 1
20115: PPUSH
20116: LD_INT 1
20118: PPUSH
20119: CALL_OW 120
// end else
20123: GO 20077
20125: POP
20126: POP
20127: GO 20136
// ComExitBuilding ( depot1 ) ;
20129: LD_INT 1
20131: PPUSH
20132: CALL_OW 122
// enable ;
20136: ENABLE
// end ;
20137: PPOPN 1
20139: END
// every 0 0$5.0 do var i ;
20140: GO 20142
20142: DISABLE
20143: LD_INT 0
20145: PPUSH
// begin for i in sci do
20146: LD_ADDR_VAR 0 1
20150: PUSH
20151: LD_EXP 92
20155: PUSH
20156: FOR_IN
20157: IFFALSE 20204
// begin if not IsBusy ( i ) and GetSide ( i ) <> you then
20159: LD_VAR 0 1
20163: PPUSH
20164: CALL_OW 315
20168: NOT
20169: IFFALSE 20188
20171: PUSH
20172: LD_VAR 0 1
20176: PPUSH
20177: CALL_OW 255
20181: PUSH
20182: LD_EXP 1
20186: NONEQUAL
20187: AND
20188: IFFALSE 20202
// ComEnterUnit ( i , lab1 ) ;
20190: LD_VAR 0 1
20194: PPUSH
20195: LD_INT 6
20197: PPUSH
20198: CALL_OW 120
// end ;
20202: GO 20156
20204: POP
20205: POP
// enable ;
20206: ENABLE
// end ;
20207: PPOPN 1
20209: END
// every 0 0$1.0 do var set_fuel , fuel ;
20210: GO 20212
20212: DISABLE
20213: LD_INT 0
20215: PPUSH
20216: PPUSH
// begin for set_fuel in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20217: LD_ADDR_VAR 0 1
20221: PUSH
20222: LD_INT 5
20224: PPUSH
20225: LD_INT 21
20227: PUSH
20228: LD_INT 2
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 22
20237: PUSH
20238: LD_EXP 2
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PPUSH
20251: CALL_OW 70
20255: PUSH
20256: FOR_IN
20257: IFFALSE 20304
// begin fuel := GetFuel ( set_fuel ) ;
20259: LD_ADDR_VAR 0 2
20263: PUSH
20264: LD_VAR 0 1
20268: PPUSH
20269: CALL_OW 261
20273: ST_TO_ADDR
// if fuel <= 80 then
20274: LD_VAR 0 2
20278: PUSH
20279: LD_INT 80
20281: LESSEQUAL
20282: IFFALSE 20302
// SetFuel ( set_fuel , fuel + 20 ) ;
20284: LD_VAR 0 1
20288: PPUSH
20289: LD_VAR 0 2
20293: PUSH
20294: LD_INT 20
20296: PLUS
20297: PPUSH
20298: CALL_OW 240
// end ;
20302: GO 20256
20304: POP
20305: POP
// enable ;
20306: ENABLE
// end ;
20307: PPOPN 2
20309: END
// every 0 0$1.0 do var to_rep , prednost ;
20310: GO 20312
20312: DISABLE
20313: LD_INT 0
20315: PPUSH
20316: PPUSH
// begin prednost := FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) isect broken ;
20317: LD_ADDR_VAR 0 2
20321: PUSH
20322: LD_INT 5
20324: PPUSH
20325: LD_INT 21
20327: PUSH
20328: LD_INT 2
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: PUSH
20335: LD_INT 22
20337: PUSH
20338: LD_EXP 2
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: PUSH
20347: EMPTY
20348: LIST
20349: LIST
20350: PPUSH
20351: CALL_OW 70
20355: PUSH
20356: LD_LOC 21
20360: ISECT
20361: ST_TO_ADDR
// if prednost then
20362: LD_VAR 0 2
20366: IFFALSE 20519
// for to_rep in prednost do
20368: LD_ADDR_VAR 0 1
20372: PUSH
20373: LD_VAR 0 2
20377: PUSH
20378: FOR_IN
20379: IFFALSE 20515
// begin if IsInArea ( to_rep , base ) then
20381: LD_VAR 0 1
20385: PPUSH
20386: LD_INT 5
20388: PPUSH
20389: CALL_OW 308
20393: IFFALSE 20513
// if GetLives ( to_rep ) < 1000 then
20395: LD_VAR 0 1
20399: PPUSH
20400: CALL_OW 256
20404: PUSH
20405: LD_INT 1000
20407: LESS
20408: IFFALSE 20488
// begin ComExitBuilding ( mec ) ;
20410: LD_EXP 93
20414: PPUSH
20415: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20419: LD_EXP 93
20423: PPUSH
20424: LD_VAR 0 1
20428: PPUSH
20429: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20433: LD_VAR 0 1
20437: PPUSH
20438: CALL_OW 311
20442: PPUSH
20443: CALL_OW 257
20447: PUSH
20448: LD_INT 3
20450: EQUAL
20451: IFFALSE 20486
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20453: LD_VAR 0 1
20457: PPUSH
20458: CALL_OW 311
20462: PPUSH
20463: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20467: LD_VAR 0 1
20471: PPUSH
20472: CALL_OW 311
20476: PPUSH
20477: LD_VAR 0 1
20481: PPUSH
20482: CALL_OW 189
// end ; end else
20486: GO 20513
// begin broken := broken diff to_rep ;
20488: LD_ADDR_LOC 21
20492: PUSH
20493: LD_LOC 21
20497: PUSH
20498: LD_VAR 0 1
20502: DIFF
20503: ST_TO_ADDR
// ComReturn ( to_rep ) ;
20504: LD_VAR 0 1
20508: PPUSH
20509: CALL_OW 144
// end ; end else
20513: GO 20378
20515: POP
20516: POP
20517: GO 20670
// for to_rep in FilterUnitsInArea ( base , [ [ f_type , unit_vehicle ] , [ f_side , russians ] ] ) do
20519: LD_ADDR_VAR 0 1
20523: PUSH
20524: LD_INT 5
20526: PPUSH
20527: LD_INT 21
20529: PUSH
20530: LD_INT 2
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: PUSH
20537: LD_INT 22
20539: PUSH
20540: LD_EXP 2
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PPUSH
20553: CALL_OW 70
20557: PUSH
20558: FOR_IN
20559: IFFALSE 20668
// begin if IsInArea ( to_rep , base ) then
20561: LD_VAR 0 1
20565: PPUSH
20566: LD_INT 5
20568: PPUSH
20569: CALL_OW 308
20573: IFFALSE 20666
// if GetLives ( to_rep ) < 1000 then
20575: LD_VAR 0 1
20579: PPUSH
20580: CALL_OW 256
20584: PUSH
20585: LD_INT 1000
20587: LESS
20588: IFFALSE 20666
// begin ComExitBuilding ( mec ) ;
20590: LD_EXP 93
20594: PPUSH
20595: CALL_OW 122
// AddComRepairVehicle ( mec , to_rep ) ;
20599: LD_EXP 93
20603: PPUSH
20604: LD_VAR 0 1
20608: PPUSH
20609: CALL_OW 189
// if GetClass ( IsDrivenBy ( to_rep ) ) = class_mechanic then
20613: LD_VAR 0 1
20617: PPUSH
20618: CALL_OW 311
20622: PPUSH
20623: CALL_OW 257
20627: PUSH
20628: LD_INT 3
20630: EQUAL
20631: IFFALSE 20666
// begin ComExitVehicle ( IsDrivenBy ( to_rep ) ) ;
20633: LD_VAR 0 1
20637: PPUSH
20638: CALL_OW 311
20642: PPUSH
20643: CALL_OW 121
// AddComRepairVehicle ( IsDrivenBy ( to_rep ) , to_rep ) ;
20647: LD_VAR 0 1
20651: PPUSH
20652: CALL_OW 311
20656: PPUSH
20657: LD_VAR 0 1
20661: PPUSH
20662: CALL_OW 189
// end ; end ; end ;
20666: GO 20558
20668: POP
20669: POP
// enable ;
20670: ENABLE
// end ;
20671: PPOPN 2
20673: END
// every 0 0$0.5 do var i , a ;
20674: GO 20676
20676: DISABLE
20677: LD_INT 0
20679: PPUSH
20680: PPUSH
// begin for i in cars do
20681: LD_ADDR_VAR 0 1
20685: PUSH
20686: LD_LOC 2
20690: PUSH
20691: FOR_IN
20692: IFFALSE 20802
// begin if GetLives ( i ) < 550 then
20694: LD_VAR 0 1
20698: PPUSH
20699: CALL_OW 256
20703: PUSH
20704: LD_INT 550
20706: LESS
20707: IFFALSE 20740
// begin ComMoveXY ( i , 112 , 89 ) ;
20709: LD_VAR 0 1
20713: PPUSH
20714: LD_INT 112
20716: PPUSH
20717: LD_INT 89
20719: PPUSH
20720: CALL_OW 111
// broken := broken union i ;
20724: LD_ADDR_LOC 21
20728: PUSH
20729: LD_LOC 21
20733: PUSH
20734: LD_VAR 0 1
20738: UNION
20739: ST_TO_ADDR
// end ; if i in cargo and GetLives ( i ) < 800 then
20740: LD_VAR 0 1
20744: PUSH
20745: LD_LOC 3
20749: IN
20750: IFFALSE 20767
20752: PUSH
20753: LD_VAR 0 1
20757: PPUSH
20758: CALL_OW 256
20762: PUSH
20763: LD_INT 800
20765: LESS
20766: AND
20767: IFFALSE 20800
// begin ComMoveXY ( i , 112 , 89 ) ;
20769: LD_VAR 0 1
20773: PPUSH
20774: LD_INT 112
20776: PPUSH
20777: LD_INT 89
20779: PPUSH
20780: CALL_OW 111
// broken := broken union i ;
20784: LD_ADDR_LOC 21
20788: PUSH
20789: LD_LOC 21
20793: PUSH
20794: LD_VAR 0 1
20798: UNION
20799: ST_TO_ADDR
// end ; end ;
20800: GO 20691
20802: POP
20803: POP
// enable ;
20804: ENABLE
// end ;
20805: PPOPN 2
20807: END
// var zasek_cargo ; every 1 1$0 do var j , pojedou , new ;
20808: GO 20810
20810: DISABLE
20811: LD_INT 0
20813: PPUSH
20814: PPUSH
20815: PPUSH
// begin SetFuel ( cargo , 100 ) ;
20816: LD_LOC 3
20820: PPUSH
20821: LD_INT 100
20823: PPUSH
20824: CALL_OW 240
// if not HasTask ( Cargo ) and GetLives ( Cargo ) >= 900 and crates >= 2 then
20828: LD_LOC 3
20832: PPUSH
20833: CALL_OW 314
20837: NOT
20838: IFFALSE 20855
20840: PUSH
20841: LD_LOC 3
20845: PPUSH
20846: CALL_OW 256
20850: PUSH
20851: LD_INT 900
20853: GREATEREQUAL
20854: AND
20855: IFFALSE 20867
20857: PUSH
20858: LD_EXP 76
20862: PUSH
20863: LD_INT 2
20865: GREATEREQUAL
20866: AND
20867: IFFALSE 21082
// begin new := [ ] ;
20869: LD_ADDR_VAR 0 3
20873: PUSH
20874: EMPTY
20875: ST_TO_ADDR
// pojedou := find_drivers ( cargo , sol , false ) ;
20876: LD_ADDR_VAR 0 2
20880: PUSH
20881: LD_LOC 3
20885: PPUSH
20886: LD_EXP 91
20890: PPUSH
20891: LD_INT 0
20893: PPUSH
20894: CALL 16400 0 3
20898: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
20899: LD_VAR 0 2
20903: PPUSH
20904: CALL 17081 0 1
// for j := 1 to 2 do
20908: LD_ADDR_VAR 0 1
20912: PUSH
20913: DOUBLE
20914: LD_INT 1
20916: DEC
20917: ST_TO_ADDR
20918: LD_INT 2
20920: PUSH
20921: FOR_TO
20922: IFFALSE 21004
// begin if InArea ( crates [ j ] [ 1 ] , crates [ j ] [ 2 ] , pod_cestou ) then
20924: LD_EXP 76
20928: PUSH
20929: LD_VAR 0 1
20933: ARRAY
20934: PUSH
20935: LD_INT 1
20937: ARRAY
20938: PPUSH
20939: LD_EXP 76
20943: PUSH
20944: LD_VAR 0 1
20948: ARRAY
20949: PUSH
20950: LD_INT 2
20952: ARRAY
20953: PPUSH
20954: LD_INT 6
20956: PPUSH
20957: CALL_OW 309
20961: IFFALSE 21002
// begin AddComCollect ( pojedou , crates [ j ] [ 1 ] , crates [ j ] [ 2 ] ) ;
20963: LD_VAR 0 2
20967: PPUSH
20968: LD_EXP 76
20972: PUSH
20973: LD_VAR 0 1
20977: ARRAY
20978: PUSH
20979: LD_INT 1
20981: ARRAY
20982: PPUSH
20983: LD_EXP 76
20987: PUSH
20988: LD_VAR 0 1
20992: ARRAY
20993: PUSH
20994: LD_INT 2
20996: ARRAY
20997: PPUSH
20998: CALL_OW 177
// end ; end ;
21002: GO 20921
21004: POP
21005: POP
// for j := 3 to crates do
21006: LD_ADDR_VAR 0 1
21010: PUSH
21011: DOUBLE
21012: LD_INT 3
21014: DEC
21015: ST_TO_ADDR
21016: LD_EXP 76
21020: PUSH
21021: FOR_TO
21022: IFFALSE 21051
// begin new := new ^ [ crates [ j ] ] ;
21024: LD_ADDR_VAR 0 3
21028: PUSH
21029: LD_VAR 0 3
21033: PUSH
21034: LD_EXP 76
21038: PUSH
21039: LD_VAR 0 1
21043: ARRAY
21044: PUSH
21045: EMPTY
21046: LIST
21047: ADD
21048: ST_TO_ADDR
// end ;
21049: GO 21021
21051: POP
21052: POP
// crates := new ;
21053: LD_ADDR_EXP 76
21057: PUSH
21058: LD_VAR 0 3
21062: ST_TO_ADDR
// AddComReturn ( pojedou ) ;
21063: LD_VAR 0 2
21067: PPUSH
21068: CALL_OW 204
// zasek_cargo := 1 ;
21072: LD_ADDR_LOC 30
21076: PUSH
21077: LD_INT 1
21079: ST_TO_ADDR
// end else
21080: GO 21147
// begin zasek_cargo := zasek_cargo + 1 ;
21082: LD_ADDR_LOC 30
21086: PUSH
21087: LD_LOC 30
21091: PUSH
21092: LD_INT 1
21094: PLUS
21095: ST_TO_ADDR
// if zasek_cargo > 5 then
21096: LD_LOC 30
21100: PUSH
21101: LD_INT 5
21103: GREATER
21104: IFFALSE 21147
// begin pojedou := find_drivers ( cargo , sol , false ) ;
21106: LD_ADDR_VAR 0 2
21110: PUSH
21111: LD_LOC 3
21115: PPUSH
21116: LD_EXP 91
21120: PPUSH
21121: LD_INT 0
21123: PPUSH
21124: CALL 16400 0 3
21128: ST_TO_ADDR
// wait_for_drivers ( pojedou ) ;
21129: LD_VAR 0 2
21133: PPUSH
21134: CALL 17081 0 1
// ComReturn ( cargo ) ;
21138: LD_LOC 3
21142: PPUSH
21143: CALL_OW 144
// end ; end ; enable ;
21147: ENABLE
// end ;
21148: PPOPN 3
21150: END
// every 0 0$1 do var rusi , i ;
21151: GO 21153
21153: DISABLE
21154: LD_INT 0
21156: PPUSH
21157: PPUSH
// begin rusi := FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , russians ] , [ f_see , you ] ] ) ;
21158: LD_ADDR_VAR 0 1
21162: PUSH
21163: LD_INT 3
21165: PUSH
21166: LD_INT 21
21168: PUSH
21169: LD_INT 3
21171: PUSH
21172: EMPTY
21173: LIST
21174: LIST
21175: PUSH
21176: LD_INT 22
21178: PUSH
21179: LD_EXP 2
21183: PUSH
21184: EMPTY
21185: LIST
21186: LIST
21187: PUSH
21188: LD_INT 101
21190: PUSH
21191: LD_EXP 1
21195: PUSH
21196: EMPTY
21197: LIST
21198: LIST
21199: PUSH
21200: EMPTY
21201: LIST
21202: LIST
21203: LIST
21204: LIST
21205: PPUSH
21206: CALL_OW 69
21210: ST_TO_ADDR
// if rusi then
21211: LD_VAR 0 1
21215: IFFALSE 21417
// begin if FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_see , russians ] ] ) diff prilet_tvoji then
21217: LD_INT 3
21219: PUSH
21220: LD_INT 21
21222: PUSH
21223: LD_INT 3
21225: PUSH
21226: EMPTY
21227: LIST
21228: LIST
21229: PUSH
21230: LD_INT 22
21232: PUSH
21233: LD_EXP 1
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PUSH
21242: LD_INT 101
21244: PUSH
21245: LD_EXP 2
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PUSH
21254: EMPTY
21255: LIST
21256: LIST
21257: LIST
21258: LIST
21259: PPUSH
21260: CALL_OW 69
21264: PUSH
21265: LD_EXP 6
21269: DIFF
21270: IFFALSE 21417
// begin attacky := attacky + 1 ;
21272: LD_ADDR_EXP 60
21276: PUSH
21277: LD_EXP 60
21281: PUSH
21282: LD_INT 1
21284: PLUS
21285: ST_TO_ADDR
// if not more_scouting and attacky > attack_to_scouting then
21286: LD_EXP 61
21290: NOT
21291: IFFALSE 21305
21293: PUSH
21294: LD_EXP 60
21298: PUSH
21299: LD_EXP 67
21303: GREATER
21304: AND
21305: IFFALSE 21323
// begin more_scouting := true ;
21307: LD_ADDR_EXP 61
21311: PUSH
21312: LD_INT 1
21314: ST_TO_ADDR
// go_up := true ;
21315: LD_ADDR_EXP 62
21319: PUSH
21320: LD_INT 1
21322: ST_TO_ADDR
// end ; for i in scout diff broken do
21323: LD_ADDR_VAR 0 2
21327: PUSH
21328: LD_LOC 4
21332: PUSH
21333: LD_LOC 21
21337: DIFF
21338: PUSH
21339: FOR_IN
21340: IFFALSE 21415
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_type , unit_building ] , [ f_side , you ] , [ f_dist , i , 8 ] ] ) , i ) ) ;
21342: LD_VAR 0 2
21346: PPUSH
21347: LD_INT 3
21349: PUSH
21350: LD_INT 21
21352: PUSH
21353: LD_INT 3
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PUSH
21360: LD_INT 22
21362: PUSH
21363: LD_EXP 1
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: PUSH
21372: LD_INT 91
21374: PUSH
21375: LD_VAR 0 2
21379: PUSH
21380: LD_INT 8
21382: PUSH
21383: EMPTY
21384: LIST
21385: LIST
21386: LIST
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: LIST
21392: LIST
21393: PPUSH
21394: CALL_OW 69
21398: PPUSH
21399: LD_VAR 0 2
21403: PPUSH
21404: CALL_OW 74
21408: PPUSH
21409: CALL_OW 115
// end ;
21413: GO 21339
21415: POP
21416: POP
// end ; end ; enable ;
21417: ENABLE
// end ;
21418: PPOPN 2
21420: END
// every 13 13$0 do
21421: GO 21423
21423: DISABLE
// begin wait ( start_scouting ) ;
21424: LD_EXP 68
21428: PPUSH
21429: CALL_OW 67
// more_scouting := true ;
21433: LD_ADDR_EXP 61
21437: PUSH
21438: LD_INT 1
21440: ST_TO_ADDR
// go_up := true ;
21441: LD_ADDR_EXP 62
21445: PUSH
21446: LD_INT 1
21448: ST_TO_ADDR
// end ;
21449: END
// every 0 0$3 + 0 0$30 do var all1 , all , parked , ridici , i , rid , c ;
21450: GO 21452
21452: DISABLE
21453: LD_INT 0
21455: PPUSH
21456: PPUSH
21457: PPUSH
21458: PPUSH
21459: PPUSH
21460: PPUSH
21461: PPUSH
// begin all1 := FilterUnitsInArea ( near_base , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21462: LD_ADDR_VAR 0 1
21466: PUSH
21467: LD_INT 4
21469: PPUSH
21470: LD_INT 22
21472: PUSH
21473: LD_EXP 2
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: PUSH
21482: LD_INT 21
21484: PUSH
21485: LD_INT 2
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: PUSH
21492: EMPTY
21493: LIST
21494: LIST
21495: PPUSH
21496: CALL_OW 70
21500: ST_TO_ADDR
// for i in all1 do
21501: LD_ADDR_VAR 0 5
21505: PUSH
21506: LD_VAR 0 1
21510: PUSH
21511: FOR_IN
21512: IFFALSE 21547
// if not UnitsInside ( i ) then
21514: LD_VAR 0 5
21518: PPUSH
21519: CALL_OW 313
21523: NOT
21524: IFFALSE 21545
// all := all ^ [ i ] ;
21526: LD_ADDR_VAR 0 2
21530: PUSH
21531: LD_VAR 0 2
21535: PUSH
21536: LD_VAR 0 5
21540: PUSH
21541: EMPTY
21542: LIST
21543: ADD
21544: ST_TO_ADDR
21545: GO 21511
21547: POP
21548: POP
// parked := FilterUnitsInArea ( parkoviste , [ [ f_side , russians ] , [ f_type , unit_vehicle ] ] ) ;
21549: LD_ADDR_VAR 0 3
21553: PUSH
21554: LD_INT 13
21556: PPUSH
21557: LD_INT 22
21559: PUSH
21560: LD_EXP 2
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: LD_INT 21
21571: PUSH
21572: LD_INT 2
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PPUSH
21583: CALL_OW 70
21587: ST_TO_ADDR
// ridici := UnitFilter ( sol ^ sci ^ eng , [ f_outside ] ) ;
21588: LD_ADDR_VAR 0 4
21592: PUSH
21593: LD_EXP 91
21597: PUSH
21598: LD_EXP 92
21602: ADD
21603: PUSH
21604: LD_EXP 94
21608: ADD
21609: PPUSH
21610: LD_INT 56
21612: PUSH
21613: EMPTY
21614: LIST
21615: PPUSH
21616: CALL_OW 72
21620: ST_TO_ADDR
// all := all diff parked ;
21621: LD_ADDR_VAR 0 2
21625: PUSH
21626: LD_VAR 0 2
21630: PUSH
21631: LD_VAR 0 3
21635: DIFF
21636: ST_TO_ADDR
// all := all diff [ 0 ] ;
21637: LD_ADDR_VAR 0 2
21641: PUSH
21642: LD_VAR 0 2
21646: PUSH
21647: LD_INT 0
21649: PUSH
21650: EMPTY
21651: LIST
21652: DIFF
21653: ST_TO_ADDR
// all := all diff cargo ;
21654: LD_ADDR_VAR 0 2
21658: PUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_LOC 3
21668: DIFF
21669: ST_TO_ADDR
// if ridici then
21670: LD_VAR 0 4
21674: IFFALSE 22403
// for i in all do
21676: LD_ADDR_VAR 0 5
21680: PUSH
21681: LD_VAR 0 2
21685: PUSH
21686: FOR_IN
21687: IFFALSE 22401
// begin rid := ridici [ 1 ] ;
21689: LD_ADDR_VAR 0 6
21693: PUSH
21694: LD_VAR 0 4
21698: PUSH
21699: LD_INT 1
21701: ARRAY
21702: ST_TO_ADDR
// ridici := ridici diff rid ;
21703: LD_ADDR_VAR 0 4
21707: PUSH
21708: LD_VAR 0 4
21712: PUSH
21713: LD_VAR 0 6
21717: DIFF
21718: ST_TO_ADDR
// sol := sol diff rid ;
21719: LD_ADDR_EXP 91
21723: PUSH
21724: LD_EXP 91
21728: PUSH
21729: LD_VAR 0 6
21733: DIFF
21734: ST_TO_ADDR
// sci := sci diff rid ;
21735: LD_ADDR_EXP 92
21739: PUSH
21740: LD_EXP 92
21744: PUSH
21745: LD_VAR 0 6
21749: DIFF
21750: ST_TO_ADDR
// eng := eng diff rid ;
21751: LD_ADDR_EXP 94
21755: PUSH
21756: LD_EXP 94
21760: PUSH
21761: LD_VAR 0 6
21765: DIFF
21766: ST_TO_ADDR
// case true of i in scout1 :
21767: LD_INT 1
21769: PUSH
21770: LD_VAR 0 5
21774: PUSH
21775: LD_LOC 7
21779: IN
21780: DOUBLE
21781: EQUAL
21782: IFTRUE 21786
21784: GO 21813
21786: POP
// begin scout1 := scout1 diff i ;
21787: LD_ADDR_LOC 7
21791: PUSH
21792: LD_LOC 7
21796: PUSH
21797: LD_VAR 0 5
21801: DIFF
21802: ST_TO_ADDR
// c := 1 ;
21803: LD_ADDR_VAR 0 7
21807: PUSH
21808: LD_INT 1
21810: ST_TO_ADDR
// end ; i in scout2 :
21811: GO 22029
21813: LD_VAR 0 5
21817: PUSH
21818: LD_LOC 8
21822: IN
21823: DOUBLE
21824: EQUAL
21825: IFTRUE 21829
21827: GO 21856
21829: POP
// begin scout2 := scout2 diff i ;
21830: LD_ADDR_LOC 8
21834: PUSH
21835: LD_LOC 8
21839: PUSH
21840: LD_VAR 0 5
21844: DIFF
21845: ST_TO_ADDR
// c := 2 ;
21846: LD_ADDR_VAR 0 7
21850: PUSH
21851: LD_INT 2
21853: ST_TO_ADDR
// end ; i in scout :
21854: GO 22029
21856: LD_VAR 0 5
21860: PUSH
21861: LD_LOC 4
21865: IN
21866: DOUBLE
21867: EQUAL
21868: IFTRUE 21872
21870: GO 21899
21872: POP
// begin scout := scout diff i ;
21873: LD_ADDR_LOC 4
21877: PUSH
21878: LD_LOC 4
21882: PUSH
21883: LD_VAR 0 5
21887: DIFF
21888: ST_TO_ADDR
// c := 3 ;
21889: LD_ADDR_VAR 0 7
21893: PUSH
21894: LD_INT 3
21896: ST_TO_ADDR
// end ; i in attack :
21897: GO 22029
21899: LD_VAR 0 5
21903: PUSH
21904: LD_LOC 5
21908: IN
21909: DOUBLE
21910: EQUAL
21911: IFTRUE 21915
21913: GO 21942
21915: POP
// begin attack := attack diff i ;
21916: LD_ADDR_LOC 5
21920: PUSH
21921: LD_LOC 5
21925: PUSH
21926: LD_VAR 0 5
21930: DIFF
21931: ST_TO_ADDR
// c := 4 ;
21932: LD_ADDR_VAR 0 7
21936: PUSH
21937: LD_INT 4
21939: ST_TO_ADDR
// end ; i in defence :
21940: GO 22029
21942: LD_VAR 0 5
21946: PUSH
21947: LD_LOC 6
21951: IN
21952: DOUBLE
21953: EQUAL
21954: IFTRUE 21958
21956: GO 21985
21958: POP
// begin defence := defence diff i ;
21959: LD_ADDR_LOC 6
21963: PUSH
21964: LD_LOC 6
21968: PUSH
21969: LD_VAR 0 5
21973: DIFF
21974: ST_TO_ADDR
// c := 4 ;
21975: LD_ADDR_VAR 0 7
21979: PUSH
21980: LD_INT 4
21982: ST_TO_ADDR
// end ; i in cargo :
21983: GO 22029
21985: LD_VAR 0 5
21989: PUSH
21990: LD_LOC 3
21994: IN
21995: DOUBLE
21996: EQUAL
21997: IFTRUE 22001
21999: GO 22028
22001: POP
// begin cargo := cargo diff i ;
22002: LD_ADDR_LOC 3
22006: PUSH
22007: LD_LOC 3
22011: PUSH
22012: LD_VAR 0 5
22016: DIFF
22017: ST_TO_ADDR
// c := 5 ;
22018: LD_ADDR_VAR 0 7
22022: PUSH
22023: LD_INT 5
22025: ST_TO_ADDR
// end ; end ;
22026: GO 22029
22028: POP
// ComEnterUnit ( rid , i ) ;
22029: LD_VAR 0 6
22033: PPUSH
22034: LD_VAR 0 5
22038: PPUSH
22039: CALL_OW 120
// while not UnitsInside ( i ) do
22043: LD_VAR 0 5
22047: PPUSH
22048: CALL_OW 313
22052: NOT
22053: IFFALSE 22064
// wait ( 0 0$1 ) ;
22055: LD_INT 35
22057: PPUSH
22058: CALL_OW 67
22062: GO 22043
// ComMoveToArea ( i , parkoviste ) ;
22064: LD_VAR 0 5
22068: PPUSH
22069: LD_INT 13
22071: PPUSH
22072: CALL_OW 113
// while not IsInArea ( i , parkoviste ) do
22076: LD_VAR 0 5
22080: PPUSH
22081: LD_INT 13
22083: PPUSH
22084: CALL_OW 308
22088: NOT
22089: IFFALSE 22100
// wait ( 0 0$1 ) ;
22091: LD_INT 35
22093: PPUSH
22094: CALL_OW 67
22098: GO 22076
// ComExitVehicle ( i ) ;
22100: LD_VAR 0 5
22104: PPUSH
22105: CALL_OW 121
// while UnitsInside ( i ) do
22109: LD_VAR 0 5
22113: PPUSH
22114: CALL_OW 313
22118: IFFALSE 22129
// wait ( 0 0$1 ) ;
22120: LD_INT 35
22122: PPUSH
22123: CALL_OW 67
22127: GO 22109
// ComReturn ( rid ) ;
22129: LD_VAR 0 6
22133: PPUSH
22134: CALL_OW 144
// case c of 1 :
22138: LD_VAR 0 7
22142: PUSH
22143: LD_INT 1
22145: DOUBLE
22146: EQUAL
22147: IFTRUE 22151
22149: GO 22170
22151: POP
// begin scout1 := scout1 ^ i ;
22152: LD_ADDR_LOC 7
22156: PUSH
22157: LD_LOC 7
22161: PUSH
22162: LD_VAR 0 5
22166: ADD
22167: ST_TO_ADDR
// end ; 2 :
22168: GO 22306
22170: LD_INT 2
22172: DOUBLE
22173: EQUAL
22174: IFTRUE 22178
22176: GO 22197
22178: POP
// begin scout2 := scout2 ^ i ;
22179: LD_ADDR_LOC 8
22183: PUSH
22184: LD_LOC 8
22188: PUSH
22189: LD_VAR 0 5
22193: ADD
22194: ST_TO_ADDR
// end ; 3 :
22195: GO 22306
22197: LD_INT 3
22199: DOUBLE
22200: EQUAL
22201: IFTRUE 22205
22203: GO 22224
22205: POP
// begin scout := scout ^ i ;
22206: LD_ADDR_LOC 4
22210: PUSH
22211: LD_LOC 4
22215: PUSH
22216: LD_VAR 0 5
22220: ADD
22221: ST_TO_ADDR
// end ; 4 :
22222: GO 22306
22224: LD_INT 4
22226: DOUBLE
22227: EQUAL
22228: IFTRUE 22232
22230: GO 22251
22232: POP
// begin attack := attack ^ i ;
22233: LD_ADDR_LOC 5
22237: PUSH
22238: LD_LOC 5
22242: PUSH
22243: LD_VAR 0 5
22247: ADD
22248: ST_TO_ADDR
// end ; 5 :
22249: GO 22306
22251: LD_INT 5
22253: DOUBLE
22254: EQUAL
22255: IFTRUE 22259
22257: GO 22278
22259: POP
// begin defence := defence ^ i ;
22260: LD_ADDR_LOC 6
22264: PUSH
22265: LD_LOC 6
22269: PUSH
22270: LD_VAR 0 5
22274: ADD
22275: ST_TO_ADDR
// end ; 6 :
22276: GO 22306
22278: LD_INT 6
22280: DOUBLE
22281: EQUAL
22282: IFTRUE 22286
22284: GO 22305
22286: POP
// begin cargo := cargo ^ i ;
22287: LD_ADDR_LOC 3
22291: PUSH
22292: LD_LOC 3
22296: PUSH
22297: LD_VAR 0 5
22301: ADD
22302: ST_TO_ADDR
// end ; end ;
22303: GO 22306
22305: POP
// if GetClass ( rid ) = class_soldier then
22306: LD_VAR 0 6
22310: PPUSH
22311: CALL_OW 257
22315: PUSH
22316: LD_INT 1
22318: EQUAL
22319: IFFALSE 22337
// sol := sol union rid ;
22321: LD_ADDR_EXP 91
22325: PUSH
22326: LD_EXP 91
22330: PUSH
22331: LD_VAR 0 6
22335: UNION
22336: ST_TO_ADDR
// if GetClass ( rid ) = class_scientistic then
22337: LD_VAR 0 6
22341: PPUSH
22342: CALL_OW 257
22346: PUSH
22347: LD_INT 4
22349: EQUAL
22350: IFFALSE 22368
// sci := sci union rid ;
22352: LD_ADDR_EXP 92
22356: PUSH
22357: LD_EXP 92
22361: PUSH
22362: LD_VAR 0 6
22366: UNION
22367: ST_TO_ADDR
// if GetClass ( rid ) = class_engineer then
22368: LD_VAR 0 6
22372: PPUSH
22373: CALL_OW 257
22377: PUSH
22378: LD_INT 2
22380: EQUAL
22381: IFFALSE 22399
// eng := eng union rid ;
22383: LD_ADDR_EXP 94
22387: PUSH
22388: LD_EXP 94
22392: PUSH
22393: LD_VAR 0 6
22397: UNION
22398: ST_TO_ADDR
// end ;
22399: GO 21686
22401: POP
22402: POP
// enable ;
22403: ENABLE
// end ;
22404: PPOPN 7
22406: END
// var add_h ; every 0 0$15.0 do var a ;
22407: GO 22409
22409: DISABLE
22410: LD_INT 0
22412: PPUSH
// begin if not IsBusy ( fact1 ) and GetSide ( fact1 ) <> you then
22413: LD_INT 35
22415: PPUSH
22416: CALL_OW 315
22420: NOT
22421: IFFALSE 22438
22423: PUSH
22424: LD_INT 35
22426: PPUSH
22427: CALL_OW 255
22431: PUSH
22432: LD_EXP 1
22436: NONEQUAL
22437: AND
22438: IFFALSE 23274
// begin if attacky > 70 and defence < 4 then
22440: LD_EXP 60
22444: PUSH
22445: LD_INT 70
22447: GREATER
22448: IFFALSE 22460
22450: PUSH
22451: LD_LOC 6
22455: PUSH
22456: LD_INT 4
22458: LESS
22459: AND
22460: IFFALSE 22530
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22462: LD_INT 5
22464: PPUSH
22465: LD_INT 25
22467: PUSH
22468: LD_INT 3
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PUSH
22475: LD_INT 22
22477: PUSH
22478: LD_EXP 2
22482: PUSH
22483: EMPTY
22484: LIST
22485: LIST
22486: PUSH
22487: EMPTY
22488: LIST
22489: LIST
22490: PPUSH
22491: CALL_OW 70
22495: PPUSH
22496: LD_INT 35
22498: PPUSH
22499: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_gun ) ;
22503: LD_INT 35
22505: PPUSH
22506: LD_INT 24
22508: PPUSH
22509: LD_INT 1
22511: PPUSH
22512: LD_INT 1
22514: PPUSH
22515: LD_INT 46
22517: PPUSH
22518: CALL_OW 125
// to_defence := true ;
22522: LD_ADDR_LOC 25
22526: PUSH
22527: LD_INT 1
22529: ST_TO_ADDR
// end ; if attacky > 30 and scout < 2 then
22530: LD_EXP 60
22534: PUSH
22535: LD_INT 30
22537: GREATER
22538: IFFALSE 22550
22540: PUSH
22541: LD_LOC 4
22545: PUSH
22546: LD_INT 2
22548: LESS
22549: AND
22550: IFFALSE 22628
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22552: LD_INT 5
22554: PPUSH
22555: LD_INT 25
22557: PUSH
22558: LD_INT 3
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 22
22567: PUSH
22568: LD_EXP 2
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PPUSH
22581: CALL_OW 70
22585: PPUSH
22586: LD_INT 35
22588: PPUSH
22589: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22593: LD_INT 35
22595: PPUSH
22596: LD_INT 22
22598: PPUSH
22599: LD_INT 1
22601: PPUSH
22602: LD_INT 1
22604: PPUSH
22605: LD_INT 42
22607: PPUSH
22608: CALL_OW 125
// to_scout := true ;
22612: LD_ADDR_LOC 27
22616: PUSH
22617: LD_INT 1
22619: ST_TO_ADDR
// to_attack := true ;
22620: LD_ADDR_LOC 26
22624: PUSH
22625: LD_INT 1
22627: ST_TO_ADDR
// end ; if attacky > 90 and attack < 4 then
22628: LD_EXP 60
22632: PUSH
22633: LD_INT 90
22635: GREATER
22636: IFFALSE 22648
22638: PUSH
22639: LD_LOC 5
22643: PUSH
22644: LD_INT 4
22646: LESS
22647: AND
22648: IFFALSE 22718
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22650: LD_INT 5
22652: PPUSH
22653: LD_INT 25
22655: PUSH
22656: LD_INT 3
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 22
22665: PUSH
22666: LD_EXP 2
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: PPUSH
22679: CALL_OW 70
22683: PPUSH
22684: LD_INT 35
22686: PPUSH
22687: CALL_OW 120
// ComConstruct ( fact1 , ru_heavy_tracked , control_manual , engine_combustion , ru_heavy_machine_gun ) ;
22691: LD_INT 35
22693: PPUSH
22694: LD_INT 24
22696: PPUSH
22697: LD_INT 1
22699: PPUSH
22700: LD_INT 1
22702: PPUSH
22703: LD_INT 42
22705: PPUSH
22706: CALL_OW 125
// to_attack := true ;
22710: LD_ADDR_LOC 26
22714: PUSH
22715: LD_INT 1
22717: ST_TO_ADDR
// end ; if cargo < 1 then
22718: LD_LOC 3
22722: PUSH
22723: LD_INT 1
22725: LESS
22726: IFFALSE 22796
// begin ComEnterUnit ( FilterUnitsInArea ( base , [ [ f_class , class_mechanic ] , [ f_side , russians ] ] ) , fact1 ) ;
22728: LD_INT 5
22730: PPUSH
22731: LD_INT 25
22733: PUSH
22734: LD_INT 3
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 22
22743: PUSH
22744: LD_EXP 2
22748: PUSH
22749: EMPTY
22750: LIST
22751: LIST
22752: PUSH
22753: EMPTY
22754: LIST
22755: LIST
22756: PPUSH
22757: CALL_OW 70
22761: PPUSH
22762: LD_INT 35
22764: PPUSH
22765: CALL_OW 120
// ComConstruct ( fact1 , ru_medium_tracked , control_manual , engine_combustion , ru_cargo_bay ) ;
22769: LD_INT 35
22771: PPUSH
22772: LD_INT 22
22774: PPUSH
22775: LD_INT 1
22777: PPUSH
22778: LD_INT 1
22780: PPUSH
22781: LD_INT 51
22783: PPUSH
22784: CALL_OW 125
// to_cargo := true ;
22788: LD_ADDR_LOC 28
22792: PUSH
22793: LD_INT 1
22795: ST_TO_ADDR
// end ; if ( sol + mec + eng + sci > 8 ) and ( add_h < 6 ) then
22796: LD_EXP 91
22800: PUSH
22801: LD_EXP 93
22805: PLUS
22806: PUSH
22807: LD_EXP 94
22811: PLUS
22812: PUSH
22813: LD_EXP 92
22817: PLUS
22818: PUSH
22819: LD_INT 8
22821: GREATER
22822: IFFALSE 22834
22824: PUSH
22825: LD_LOC 31
22829: PUSH
22830: LD_INT 6
22832: LESS
22833: AND
22834: IFFALSE 23274
// begin add_h := add_h + 1 ;
22836: LD_ADDR_LOC 31
22840: PUSH
22841: LD_LOC 31
22845: PUSH
22846: LD_INT 1
22848: PLUS
22849: ST_TO_ADDR
// if sol < 8 then
22850: LD_EXP 91
22854: PUSH
22855: LD_INT 8
22857: LESS
22858: IFFALSE 22964
// begin InitUc ;
22860: CALL_OW 18
// InitHc ;
22864: CALL_OW 19
// uc_nation := nation_russian ;
22868: LD_ADDR_OWVAR 21
22872: PUSH
22873: LD_INT 3
22875: ST_TO_ADDR
// uc_side := russians ;
22876: LD_ADDR_OWVAR 20
22880: PUSH
22881: LD_EXP 2
22885: ST_TO_ADDR
// PrepareSoldier ( 0 , 6 ) ;
22886: LD_INT 0
22888: PPUSH
22889: LD_INT 6
22891: PPUSH
22892: CALL_OW 381
// a := CreateHuman ;
22896: LD_ADDR_VAR 0 1
22900: PUSH
22901: CALL_OW 44
22905: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
22906: LD_VAR 0 1
22910: PPUSH
22911: LD_INT 119
22913: PPUSH
22914: LD_INT 98
22916: PPUSH
22917: LD_INT 5
22919: PPUSH
22920: LD_INT 0
22922: PPUSH
22923: CALL_OW 50
// wait ( 0 0$6 ) ;
22927: LD_INT 210
22929: PPUSH
22930: CALL_OW 67
// sol := sol ^ a ;
22934: LD_ADDR_EXP 91
22938: PUSH
22939: LD_EXP 91
22943: PUSH
22944: LD_VAR 0 1
22948: ADD
22949: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
22950: LD_VAR 0 1
22954: PPUSH
22955: LD_INT 5
22957: PPUSH
22958: CALL_OW 113
// end else
22962: GO 23274
// if mec < 2 then
22964: LD_EXP 93
22968: PUSH
22969: LD_INT 2
22971: LESS
22972: IFFALSE 23068
// begin InitUc ;
22974: CALL_OW 18
// InitHc ;
22978: CALL_OW 19
// uc_nation := nation_russian ;
22982: LD_ADDR_OWVAR 21
22986: PUSH
22987: LD_INT 3
22989: ST_TO_ADDR
// PrepareMechanic ( 0 , 6 ) ;
22990: LD_INT 0
22992: PPUSH
22993: LD_INT 6
22995: PPUSH
22996: CALL_OW 383
// a := CreateHuman ;
23000: LD_ADDR_VAR 0 1
23004: PUSH
23005: CALL_OW 44
23009: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 98 , 5 , false ) ;
23010: LD_VAR 0 1
23014: PPUSH
23015: LD_INT 119
23017: PPUSH
23018: LD_INT 98
23020: PPUSH
23021: LD_INT 5
23023: PPUSH
23024: LD_INT 0
23026: PPUSH
23027: CALL_OW 50
// wait ( 0 0$6 ) ;
23031: LD_INT 210
23033: PPUSH
23034: CALL_OW 67
// mec := mec ^ a ;
23038: LD_ADDR_EXP 93
23042: PUSH
23043: LD_EXP 93
23047: PUSH
23048: LD_VAR 0 1
23052: ADD
23053: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
23054: LD_VAR 0 1
23058: PPUSH
23059: LD_INT 5
23061: PPUSH
23062: CALL_OW 113
// end else
23066: GO 23274
// if eng < 1 then
23068: LD_EXP 94
23072: PUSH
23073: LD_INT 1
23075: LESS
23076: IFFALSE 23172
// begin InitUc ;
23078: CALL_OW 18
// InitHc ;
23082: CALL_OW 19
// uc_nation := nation_russian ;
23086: LD_ADDR_OWVAR 21
23090: PUSH
23091: LD_INT 3
23093: ST_TO_ADDR
// PrepareEngineer ( 0 , 6 ) ;
23094: LD_INT 0
23096: PPUSH
23097: LD_INT 6
23099: PPUSH
23100: CALL_OW 382
// a := CreateHuman ;
23104: LD_ADDR_VAR 0 1
23108: PUSH
23109: CALL_OW 44
23113: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
23114: LD_VAR 0 1
23118: PPUSH
23119: LD_INT 119
23121: PPUSH
23122: LD_INT 99
23124: PPUSH
23125: LD_INT 5
23127: PPUSH
23128: LD_INT 0
23130: PPUSH
23131: CALL_OW 50
// wait ( 0 0$6 ) ;
23135: LD_INT 210
23137: PPUSH
23138: CALL_OW 67
// eng := eng ^ a ;
23142: LD_ADDR_EXP 94
23146: PUSH
23147: LD_EXP 94
23151: PUSH
23152: LD_VAR 0 1
23156: ADD
23157: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
23158: LD_VAR 0 1
23162: PPUSH
23163: LD_INT 5
23165: PPUSH
23166: CALL_OW 113
// end else
23170: GO 23274
// if sci < 1 then
23172: LD_EXP 92
23176: PUSH
23177: LD_INT 1
23179: LESS
23180: IFFALSE 23274
// begin InitUc ;
23182: CALL_OW 18
// InitHc ;
23186: CALL_OW 19
// uc_nation := nation_russian ;
23190: LD_ADDR_OWVAR 21
23194: PUSH
23195: LD_INT 3
23197: ST_TO_ADDR
// PrepareScientist ( 0 , 6 ) ;
23198: LD_INT 0
23200: PPUSH
23201: LD_INT 6
23203: PPUSH
23204: CALL_OW 384
// a := CreateHuman ;
23208: LD_ADDR_VAR 0 1
23212: PUSH
23213: CALL_OW 44
23217: ST_TO_ADDR
// PlaceUnitXYR ( a , 119 , 99 , 5 , false ) ;
23218: LD_VAR 0 1
23222: PPUSH
23223: LD_INT 119
23225: PPUSH
23226: LD_INT 99
23228: PPUSH
23229: LD_INT 5
23231: PPUSH
23232: LD_INT 0
23234: PPUSH
23235: CALL_OW 50
// wait ( 0 0$6 ) ;
23239: LD_INT 210
23241: PPUSH
23242: CALL_OW 67
// sci := sci ^ a ;
23246: LD_ADDR_EXP 92
23250: PUSH
23251: LD_EXP 92
23255: PUSH
23256: LD_VAR 0 1
23260: ADD
23261: ST_TO_ADDR
// ComMoveToArea ( a , base ) ;
23262: LD_VAR 0 1
23266: PPUSH
23267: LD_INT 5
23269: PPUSH
23270: CALL_OW 113
// end ; end ; end ; enable ;
23274: ENABLE
// end ;
23275: PPOPN 1
23277: END
// every 0 0$3 do var sc ;
23278: GO 23280
23280: DISABLE
23281: LD_INT 0
23283: PPUSH
// begin sol := UnitFilter ( sol , [ f_alive ] ) ;
23284: LD_ADDR_EXP 91
23288: PUSH
23289: LD_EXP 91
23293: PPUSH
23294: LD_INT 51
23296: PUSH
23297: EMPTY
23298: LIST
23299: PPUSH
23300: CALL_OW 72
23304: ST_TO_ADDR
// eng := UnitFilter ( eng , [ f_alive ] ) ;
23305: LD_ADDR_EXP 94
23309: PUSH
23310: LD_EXP 94
23314: PPUSH
23315: LD_INT 51
23317: PUSH
23318: EMPTY
23319: LIST
23320: PPUSH
23321: CALL_OW 72
23325: ST_TO_ADDR
// mec := UnitFilter ( mec , [ f_alive ] ) ;
23326: LD_ADDR_EXP 93
23330: PUSH
23331: LD_EXP 93
23335: PPUSH
23336: LD_INT 51
23338: PUSH
23339: EMPTY
23340: LIST
23341: PPUSH
23342: CALL_OW 72
23346: ST_TO_ADDR
// sci := UnitFilter ( sci , [ f_alive ] ) ;
23347: LD_ADDR_EXP 92
23351: PUSH
23352: LD_EXP 92
23356: PPUSH
23357: LD_INT 51
23359: PUSH
23360: EMPTY
23361: LIST
23362: PPUSH
23363: CALL_OW 72
23367: ST_TO_ADDR
// defence := UnitFilter ( defence , [ f_alive ] ) ;
23368: LD_ADDR_LOC 6
23372: PUSH
23373: LD_LOC 6
23377: PPUSH
23378: LD_INT 51
23380: PUSH
23381: EMPTY
23382: LIST
23383: PPUSH
23384: CALL_OW 72
23388: ST_TO_ADDR
// cargo := UnitFilter ( cargo , [ f_alive ] ) ;
23389: LD_ADDR_LOC 3
23393: PUSH
23394: LD_LOC 3
23398: PPUSH
23399: LD_INT 51
23401: PUSH
23402: EMPTY
23403: LIST
23404: PPUSH
23405: CALL_OW 72
23409: ST_TO_ADDR
// attack := UnitFilter ( attack , [ f_alive ] ) ;
23410: LD_ADDR_LOC 5
23414: PUSH
23415: LD_LOC 5
23419: PPUSH
23420: LD_INT 51
23422: PUSH
23423: EMPTY
23424: LIST
23425: PPUSH
23426: CALL_OW 72
23430: ST_TO_ADDR
// scout := UnitFilter ( scout , [ f_alive ] ) ;
23431: LD_ADDR_LOC 4
23435: PUSH
23436: LD_LOC 4
23440: PPUSH
23441: LD_INT 51
23443: PUSH
23444: EMPTY
23445: LIST
23446: PPUSH
23447: CALL_OW 72
23451: ST_TO_ADDR
// broken := UnitFilter ( broken , [ f_alive ] ) ;
23452: LD_ADDR_LOC 21
23456: PUSH
23457: LD_LOC 21
23461: PPUSH
23462: LD_INT 51
23464: PUSH
23465: EMPTY
23466: LIST
23467: PPUSH
23468: CALL_OW 72
23472: ST_TO_ADDR
// sc := split ( scout ) ;
23473: LD_ADDR_VAR 0 1
23477: PUSH
23478: LD_LOC 4
23482: PPUSH
23483: CALL 17632 0 1
23487: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
23488: LD_ADDR_LOC 7
23492: PUSH
23493: LD_VAR 0 1
23497: PUSH
23498: LD_INT 1
23500: ARRAY
23501: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
23502: LD_ADDR_LOC 8
23506: PUSH
23507: LD_VAR 0 1
23511: PUSH
23512: LD_INT 2
23514: ARRAY
23515: ST_TO_ADDR
// forts := UnitFilter ( forts , [ f_alive ] ) ;
23516: LD_ADDR_LOC 10
23520: PUSH
23521: LD_LOC 10
23525: PPUSH
23526: LD_INT 51
23528: PUSH
23529: EMPTY
23530: LIST
23531: PPUSH
23532: CALL_OW 72
23536: ST_TO_ADDR
// end ;
23537: PPOPN 1
23539: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = russians then
23540: LD_VAR 0 3
23544: PUSH
23545: LD_EXP 2
23549: EQUAL
23550: IFFALSE 23728
// begin sol := sol diff vehold ;
23552: LD_ADDR_EXP 91
23556: PUSH
23557: LD_EXP 91
23561: PUSH
23562: LD_VAR 0 2
23566: DIFF
23567: ST_TO_ADDR
// eng := eng diff vehold ;
23568: LD_ADDR_EXP 94
23572: PUSH
23573: LD_EXP 94
23577: PUSH
23578: LD_VAR 0 2
23582: DIFF
23583: ST_TO_ADDR
// mec := mec diff vehold ;
23584: LD_ADDR_EXP 93
23588: PUSH
23589: LD_EXP 93
23593: PUSH
23594: LD_VAR 0 2
23598: DIFF
23599: ST_TO_ADDR
// sci := sci diff vehold ;
23600: LD_ADDR_EXP 92
23604: PUSH
23605: LD_EXP 92
23609: PUSH
23610: LD_VAR 0 2
23614: DIFF
23615: ST_TO_ADDR
// defence := defence diff vehold ;
23616: LD_ADDR_LOC 6
23620: PUSH
23621: LD_LOC 6
23625: PUSH
23626: LD_VAR 0 2
23630: DIFF
23631: ST_TO_ADDR
// cargo := cargo diff vehold ;
23632: LD_ADDR_LOC 3
23636: PUSH
23637: LD_LOC 3
23641: PUSH
23642: LD_VAR 0 2
23646: DIFF
23647: ST_TO_ADDR
// attack := attack diff vehold ;
23648: LD_ADDR_LOC 5
23652: PUSH
23653: LD_LOC 5
23657: PUSH
23658: LD_VAR 0 2
23662: DIFF
23663: ST_TO_ADDR
// scout := scout diff vehold ;
23664: LD_ADDR_LOC 4
23668: PUSH
23669: LD_LOC 4
23673: PUSH
23674: LD_VAR 0 2
23678: DIFF
23679: ST_TO_ADDR
// broken := broken diff vehold ;
23680: LD_ADDR_LOC 21
23684: PUSH
23685: LD_LOC 21
23689: PUSH
23690: LD_VAR 0 2
23694: DIFF
23695: ST_TO_ADDR
// scout1 := scout1 diff vehold ;
23696: LD_ADDR_LOC 7
23700: PUSH
23701: LD_LOC 7
23705: PUSH
23706: LD_VAR 0 2
23710: DIFF
23711: ST_TO_ADDR
// scout2 := scout2 diff vehold ;
23712: LD_ADDR_LOC 8
23716: PUSH
23717: LD_LOC 8
23721: PUSH
23722: LD_VAR 0 2
23726: DIFF
23727: ST_TO_ADDR
// end ; end ;
23728: PPOPN 4
23730: END
// on UnitDestroyed ( un ) do begin if un = JMM then
23731: LD_VAR 0 1
23735: PUSH
23736: LD_EXP 15
23740: EQUAL
23741: IFFALSE 23753
// begin disable ( 0 ) ;
23743: LD_INT 0
23745: DISABLE_MARKED
// YouLost ( JMM ) ;
23746: LD_STRING JMM
23748: PPUSH
23749: CALL_OW 104
// end ; if un = Kurt then
23753: LD_VAR 0 1
23757: PUSH
23758: LD_EXP 43
23762: EQUAL
23763: IFFALSE 23771
// begin SA_OnKurtKilled ;
23765: CALL 27246 0 0
// exit ;
23769: GO 23999
// end ; if un = Joan then
23771: LD_VAR 0 1
23775: PUSH
23776: LD_EXP 33
23780: EQUAL
23781: IFFALSE 23787
// SA_JoanDead ;
23783: CALL 27311 0 0
// if un in NavicLidi then
23787: LD_VAR 0 1
23791: PUSH
23792: LD_EXP 84
23796: IN
23797: IFFALSE 23807
// noBodyLeft := false ;
23799: LD_ADDR_EXP 86
23803: PUSH
23804: LD_INT 0
23806: ST_TO_ADDR
// sol := sol diff un ;
23807: LD_ADDR_EXP 91
23811: PUSH
23812: LD_EXP 91
23816: PUSH
23817: LD_VAR 0 1
23821: DIFF
23822: ST_TO_ADDR
// eng := eng diff un ;
23823: LD_ADDR_EXP 94
23827: PUSH
23828: LD_EXP 94
23832: PUSH
23833: LD_VAR 0 1
23837: DIFF
23838: ST_TO_ADDR
// mec := mec diff un ;
23839: LD_ADDR_EXP 93
23843: PUSH
23844: LD_EXP 93
23848: PUSH
23849: LD_VAR 0 1
23853: DIFF
23854: ST_TO_ADDR
// sci := sci diff un ;
23855: LD_ADDR_EXP 92
23859: PUSH
23860: LD_EXP 92
23864: PUSH
23865: LD_VAR 0 1
23869: DIFF
23870: ST_TO_ADDR
// defence := defence diff un ;
23871: LD_ADDR_LOC 6
23875: PUSH
23876: LD_LOC 6
23880: PUSH
23881: LD_VAR 0 1
23885: DIFF
23886: ST_TO_ADDR
// cargo := cargo diff un ;
23887: LD_ADDR_LOC 3
23891: PUSH
23892: LD_LOC 3
23896: PUSH
23897: LD_VAR 0 1
23901: DIFF
23902: ST_TO_ADDR
// attack := attack diff un ;
23903: LD_ADDR_LOC 5
23907: PUSH
23908: LD_LOC 5
23912: PUSH
23913: LD_VAR 0 1
23917: DIFF
23918: ST_TO_ADDR
// scout := scout diff un ;
23919: LD_ADDR_LOC 4
23923: PUSH
23924: LD_LOC 4
23928: PUSH
23929: LD_VAR 0 1
23933: DIFF
23934: ST_TO_ADDR
// broken := broken diff un ;
23935: LD_ADDR_LOC 21
23939: PUSH
23940: LD_LOC 21
23944: PUSH
23945: LD_VAR 0 1
23949: DIFF
23950: ST_TO_ADDR
// scout1 := scout1 diff un ;
23951: LD_ADDR_LOC 7
23955: PUSH
23956: LD_LOC 7
23960: PUSH
23961: LD_VAR 0 1
23965: DIFF
23966: ST_TO_ADDR
// scout2 := scout2 diff un ;
23967: LD_ADDR_LOC 8
23971: PUSH
23972: LD_LOC 8
23976: PUSH
23977: LD_VAR 0 1
23981: DIFF
23982: ST_TO_ADDR
// forts := forts diff un ;
23983: LD_ADDR_LOC 10
23987: PUSH
23988: LD_LOC 10
23992: PUSH
23993: LD_VAR 0 1
23997: DIFF
23998: ST_TO_ADDR
// end ;
23999: PPOPN 1
24001: END
// on VehicleConstructed ( veh , fact ) do var i , sc ;
24002: LD_INT 0
24004: PPUSH
24005: PPUSH
// begin if GetSide ( fact ) = russians then
24006: LD_VAR 0 2
24010: PPUSH
24011: CALL_OW 255
24015: PUSH
24016: LD_EXP 2
24020: EQUAL
24021: IFFALSE 24240
// begin ComMoveToArea ( veh , parkoviste ) ;
24023: LD_VAR 0 1
24027: PPUSH
24028: LD_INT 13
24030: PPUSH
24031: CALL_OW 113
// while not IsInArea ( veh , parkoviste ) do
24035: LD_VAR 0 1
24039: PPUSH
24040: LD_INT 13
24042: PPUSH
24043: CALL_OW 308
24047: NOT
24048: IFFALSE 24059
// Wait ( 0 0$1 ) ;
24050: LD_INT 35
24052: PPUSH
24053: CALL_OW 67
24057: GO 24035
// ComExitVehicle ( veh ) ;
24059: LD_VAR 0 1
24063: PPUSH
24064: CALL_OW 121
// ComRemember ( veh ) ;
24068: LD_VAR 0 1
24072: PPUSH
24073: CALL_OW 143
// if to_defence then
24077: LD_LOC 25
24081: IFFALSE 24099
// begin defence := defence union veh ;
24083: LD_ADDR_LOC 6
24087: PUSH
24088: LD_LOC 6
24092: PUSH
24093: LD_VAR 0 1
24097: UNION
24098: ST_TO_ADDR
// end ; if to_cargo then
24099: LD_LOC 28
24103: IFFALSE 24121
// begin cargo := cargo union veh ;
24105: LD_ADDR_LOC 3
24109: PUSH
24110: LD_LOC 3
24114: PUSH
24115: LD_VAR 0 1
24119: UNION
24120: ST_TO_ADDR
// end ; if to_attack then
24121: LD_LOC 26
24125: IFFALSE 24143
// begin attack := attack union veh ;
24127: LD_ADDR_LOC 5
24131: PUSH
24132: LD_LOC 5
24136: PUSH
24137: LD_VAR 0 1
24141: UNION
24142: ST_TO_ADDR
// end ; if to_scout then
24143: LD_LOC 27
24147: IFFALSE 24208
// begin scout := scout union veh ;
24149: LD_ADDR_LOC 4
24153: PUSH
24154: LD_LOC 4
24158: PUSH
24159: LD_VAR 0 1
24163: UNION
24164: ST_TO_ADDR
// sc := split ( scout ) ;
24165: LD_ADDR_VAR 0 4
24169: PUSH
24170: LD_LOC 4
24174: PPUSH
24175: CALL 17632 0 1
24179: ST_TO_ADDR
// scout1 := sc [ 1 ] ;
24180: LD_ADDR_LOC 7
24184: PUSH
24185: LD_VAR 0 4
24189: PUSH
24190: LD_INT 1
24192: ARRAY
24193: ST_TO_ADDR
// scout2 := sc [ 2 ] ;
24194: LD_ADDR_LOC 8
24198: PUSH
24199: LD_VAR 0 4
24203: PUSH
24204: LD_INT 2
24206: ARRAY
24207: ST_TO_ADDR
// end ; to_cargo := false ;
24208: LD_ADDR_LOC 28
24212: PUSH
24213: LD_INT 0
24215: ST_TO_ADDR
// to_scout := false ;
24216: LD_ADDR_LOC 27
24220: PUSH
24221: LD_INT 0
24223: ST_TO_ADDR
// to_attack := false ;
24224: LD_ADDR_LOC 26
24228: PUSH
24229: LD_INT 0
24231: ST_TO_ADDR
// to_defence := false ;
24232: LD_ADDR_LOC 25
24236: PUSH
24237: LD_INT 0
24239: ST_TO_ADDR
// end ; end ;
24240: PPOPN 4
24242: END
// every 0 0$30 trigger attacky > odplata_1 do var ubase ;
24243: LD_EXP 60
24247: PUSH
24248: LD_EXP 65
24252: GREATER
24253: IFFALSE 24500
24255: GO 24257
24257: DISABLE
24258: LD_INT 0
24260: PPUSH
// begin attacky := 0 ;
24261: LD_ADDR_EXP 60
24265: PUSH
24266: LD_INT 0
24268: ST_TO_ADDR
// more_scouting := false ;
24269: LD_ADDR_EXP 61
24273: PUSH
24274: LD_INT 0
24276: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24277: LD_ADDR_VAR 0 1
24281: PUSH
24282: LD_INT 21
24284: PUSH
24285: LD_INT 3
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: LD_INT 22
24294: PUSH
24295: LD_EXP 1
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: PUSH
24304: EMPTY
24305: LIST
24306: LIST
24307: PPUSH
24308: CALL_OW 69
24312: ST_TO_ADDR
// if ubase then
24313: LD_VAR 0 1
24317: IFFALSE 24500
// begin case Rand ( 1 , 3 ) of 1 :
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 3
24324: PPUSH
24325: CALL_OW 12
24329: PUSH
24330: LD_INT 1
24332: DOUBLE
24333: EQUAL
24334: IFTRUE 24338
24336: GO 24372
24338: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24339: LD_LOC 5
24343: PUSH
24344: LD_LOC 21
24348: DIFF
24349: PPUSH
24350: LD_EXP 91
24354: PPUSH
24355: LD_LOC 22
24359: PPUSH
24360: LD_INT 1
24362: PPUSH
24363: LD_INT 0
24365: PPUSH
24366: CALL 17019 0 5
24370: GO 24457
24372: LD_INT 2
24374: DOUBLE
24375: EQUAL
24376: IFTRUE 24380
24378: GO 24414
24380: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24381: LD_LOC 5
24385: PUSH
24386: LD_LOC 21
24390: DIFF
24391: PPUSH
24392: LD_EXP 91
24396: PPUSH
24397: LD_LOC 23
24401: PPUSH
24402: LD_INT 1
24404: PPUSH
24405: LD_INT 0
24407: PPUSH
24408: CALL 17019 0 5
24412: GO 24457
24414: LD_INT 3
24416: DOUBLE
24417: EQUAL
24418: IFTRUE 24422
24420: GO 24456
24422: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24423: LD_LOC 5
24427: PUSH
24428: LD_LOC 21
24432: DIFF
24433: PPUSH
24434: LD_EXP 91
24438: PPUSH
24439: LD_LOC 24
24443: PPUSH
24444: LD_INT 1
24446: PPUSH
24447: LD_INT 0
24449: PPUSH
24450: CALL 17019 0 5
24454: GO 24457
24456: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24457: LD_LOC 5
24461: PUSH
24462: LD_LOC 21
24466: DIFF
24467: PPUSH
24468: LD_VAR 0 1
24472: PUSH
24473: LD_INT 1
24475: ARRAY
24476: PPUSH
24477: CALL_OW 250
24481: PPUSH
24482: LD_VAR 0 1
24486: PUSH
24487: LD_INT 1
24489: ARRAY
24490: PPUSH
24491: CALL_OW 251
24495: PPUSH
24496: CALL_OW 174
// end ; end ;
24500: PPOPN 1
24502: END
// every 4 4$30 trigger attacky > odplata_2 do var ubase ;
24503: LD_EXP 60
24507: PUSH
24508: LD_EXP 66
24512: GREATER
24513: IFFALSE 24753
24515: GO 24517
24517: DISABLE
24518: LD_INT 0
24520: PPUSH
// begin attacky := 0 ;
24521: LD_ADDR_EXP 60
24525: PUSH
24526: LD_INT 0
24528: ST_TO_ADDR
// ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24529: LD_ADDR_VAR 0 1
24533: PUSH
24534: LD_INT 21
24536: PUSH
24537: LD_INT 3
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: PUSH
24544: LD_INT 22
24546: PUSH
24547: LD_EXP 1
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PPUSH
24560: CALL_OW 69
24564: ST_TO_ADDR
// if ubase then
24565: LD_VAR 0 1
24569: IFFALSE 24752
// begin case Rand ( 1 , 3 ) of 1 :
24571: LD_INT 1
24573: PPUSH
24574: LD_INT 3
24576: PPUSH
24577: CALL_OW 12
24581: PUSH
24582: LD_INT 1
24584: DOUBLE
24585: EQUAL
24586: IFTRUE 24590
24588: GO 24624
24590: POP
// depart ( attack diff broken , sol , attack_l , true , false ) ; 2 :
24591: LD_LOC 5
24595: PUSH
24596: LD_LOC 21
24600: DIFF
24601: PPUSH
24602: LD_EXP 91
24606: PPUSH
24607: LD_LOC 22
24611: PPUSH
24612: LD_INT 1
24614: PPUSH
24615: LD_INT 0
24617: PPUSH
24618: CALL 17019 0 5
24622: GO 24709
24624: LD_INT 2
24626: DOUBLE
24627: EQUAL
24628: IFTRUE 24632
24630: GO 24666
24632: POP
// depart ( attack diff broken , sol , attack_m , true , false ) ; 3 :
24633: LD_LOC 5
24637: PUSH
24638: LD_LOC 21
24642: DIFF
24643: PPUSH
24644: LD_EXP 91
24648: PPUSH
24649: LD_LOC 23
24653: PPUSH
24654: LD_INT 1
24656: PPUSH
24657: LD_INT 0
24659: PPUSH
24660: CALL 17019 0 5
24664: GO 24709
24666: LD_INT 3
24668: DOUBLE
24669: EQUAL
24670: IFTRUE 24674
24672: GO 24708
24674: POP
// depart ( attack diff broken , sol , attack_r , true , false ) ; end ;
24675: LD_LOC 5
24679: PUSH
24680: LD_LOC 21
24684: DIFF
24685: PPUSH
24686: LD_EXP 91
24690: PPUSH
24691: LD_LOC 24
24695: PPUSH
24696: LD_INT 1
24698: PPUSH
24699: LD_INT 0
24701: PPUSH
24702: CALL 17019 0 5
24706: GO 24709
24708: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24709: LD_LOC 5
24713: PUSH
24714: LD_LOC 21
24718: DIFF
24719: PPUSH
24720: LD_VAR 0 1
24724: PUSH
24725: LD_INT 1
24727: ARRAY
24728: PPUSH
24729: CALL_OW 250
24733: PPUSH
24734: LD_VAR 0 1
24738: PUSH
24739: LD_INT 1
24741: ARRAY
24742: PPUSH
24743: CALL_OW 251
24747: PPUSH
24748: CALL_OW 174
// end ; enable ;
24752: ENABLE
// end ;
24753: PPOPN 1
24755: END
// every 8 8$30 trigger more_scouting do var ubase , a ;
24756: LD_EXP 61
24760: IFFALSE 25003
24762: GO 24764
24764: DISABLE
24765: LD_INT 0
24767: PPUSH
24768: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
24769: LD_ADDR_VAR 0 1
24773: PUSH
24774: LD_INT 21
24776: PUSH
24777: LD_INT 3
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: LD_INT 22
24786: PUSH
24787: LD_EXP 1
24791: PUSH
24792: EMPTY
24793: LIST
24794: LIST
24795: PUSH
24796: EMPTY
24797: LIST
24798: LIST
24799: PPUSH
24800: CALL_OW 69
24804: ST_TO_ADDR
// a := attack diff broken ;
24805: LD_ADDR_VAR 0 2
24809: PUSH
24810: LD_LOC 5
24814: PUSH
24815: LD_LOC 21
24819: DIFF
24820: ST_TO_ADDR
// a := split ( a ) ;
24821: LD_ADDR_VAR 0 2
24825: PUSH
24826: LD_VAR 0 2
24830: PPUSH
24831: CALL 17632 0 1
24835: ST_TO_ADDR
// if ubase then
24836: LD_VAR 0 1
24840: IFFALSE 25003
// begin case Rand ( 1 , 3 ) of 1 :
24842: LD_INT 1
24844: PPUSH
24845: LD_INT 3
24847: PPUSH
24848: CALL_OW 12
24852: PUSH
24853: LD_INT 1
24855: DOUBLE
24856: EQUAL
24857: IFTRUE 24861
24859: GO 24889
24861: POP
// depart ( a , sol , attack_l , true , false ) ; 2 :
24862: LD_VAR 0 2
24866: PPUSH
24867: LD_EXP 91
24871: PPUSH
24872: LD_LOC 22
24876: PPUSH
24877: LD_INT 1
24879: PPUSH
24880: LD_INT 0
24882: PPUSH
24883: CALL 17019 0 5
24887: GO 24962
24889: LD_INT 2
24891: DOUBLE
24892: EQUAL
24893: IFTRUE 24897
24895: GO 24925
24897: POP
// depart ( a , sol , attack_m , true , false ) ; 3 :
24898: LD_VAR 0 2
24902: PPUSH
24903: LD_EXP 91
24907: PPUSH
24908: LD_LOC 23
24912: PPUSH
24913: LD_INT 1
24915: PPUSH
24916: LD_INT 0
24918: PPUSH
24919: CALL 17019 0 5
24923: GO 24962
24925: LD_INT 3
24927: DOUBLE
24928: EQUAL
24929: IFTRUE 24933
24931: GO 24961
24933: POP
// depart ( a , sol , attack_r , true , false ) ; end ;
24934: LD_VAR 0 2
24938: PPUSH
24939: LD_EXP 91
24943: PPUSH
24944: LD_LOC 24
24948: PPUSH
24949: LD_INT 1
24951: PPUSH
24952: LD_INT 0
24954: PPUSH
24955: CALL 17019 0 5
24959: GO 24962
24961: POP
// AddComAgressiveMove ( a [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
24962: LD_VAR 0 2
24966: PUSH
24967: LD_INT 1
24969: ARRAY
24970: PPUSH
24971: LD_VAR 0 1
24975: PUSH
24976: LD_INT 1
24978: ARRAY
24979: PPUSH
24980: CALL_OW 250
24984: PPUSH
24985: LD_VAR 0 1
24989: PUSH
24990: LD_INT 1
24992: ARRAY
24993: PPUSH
24994: CALL_OW 251
24998: PPUSH
24999: CALL_OW 174
// end ; end ;
25003: PPOPN 2
25005: END
// every 16 16$30 trigger more_scouting do var ubase , at ;
25006: LD_EXP 61
25010: IFFALSE 25428
25012: GO 25014
25014: DISABLE
25015: LD_INT 0
25017: PPUSH
25018: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25019: LD_ADDR_VAR 0 1
25023: PUSH
25024: LD_INT 21
25026: PUSH
25027: LD_INT 3
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PUSH
25034: LD_INT 22
25036: PUSH
25037: LD_EXP 1
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: PUSH
25046: EMPTY
25047: LIST
25048: LIST
25049: PPUSH
25050: CALL_OW 69
25054: ST_TO_ADDR
// if ubase then
25055: LD_VAR 0 1
25059: IFFALSE 25428
// begin at := split ( attack diff broken ) ;
25061: LD_ADDR_VAR 0 2
25065: PUSH
25066: LD_LOC 5
25070: PUSH
25071: LD_LOC 21
25075: DIFF
25076: PPUSH
25077: CALL 17632 0 1
25081: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
25082: LD_INT 1
25084: PPUSH
25085: LD_INT 3
25087: PPUSH
25088: CALL_OW 12
25092: PUSH
25093: LD_INT 1
25095: DOUBLE
25096: EQUAL
25097: IFTRUE 25101
25099: GO 25133
25101: POP
// depart ( at [ 1 ] , sol , attack_l , true , false ) ; 2 :
25102: LD_VAR 0 2
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PPUSH
25111: LD_EXP 91
25115: PPUSH
25116: LD_LOC 22
25120: PPUSH
25121: LD_INT 1
25123: PPUSH
25124: LD_INT 0
25126: PPUSH
25127: CALL 17019 0 5
25131: GO 25214
25133: LD_INT 2
25135: DOUBLE
25136: EQUAL
25137: IFTRUE 25141
25139: GO 25173
25141: POP
// depart ( at [ 1 ] , sol , attack_m , true , false ) ; 3 :
25142: LD_VAR 0 2
25146: PUSH
25147: LD_INT 1
25149: ARRAY
25150: PPUSH
25151: LD_EXP 91
25155: PPUSH
25156: LD_LOC 23
25160: PPUSH
25161: LD_INT 1
25163: PPUSH
25164: LD_INT 0
25166: PPUSH
25167: CALL 17019 0 5
25171: GO 25214
25173: LD_INT 3
25175: DOUBLE
25176: EQUAL
25177: IFTRUE 25181
25179: GO 25213
25181: POP
// depart ( at [ 1 ] , sol , attack_r , true , false ) ; end ;
25182: LD_VAR 0 2
25186: PUSH
25187: LD_INT 1
25189: ARRAY
25190: PPUSH
25191: LD_EXP 91
25195: PPUSH
25196: LD_LOC 24
25200: PPUSH
25201: LD_INT 1
25203: PPUSH
25204: LD_INT 0
25206: PPUSH
25207: CALL 17019 0 5
25211: GO 25214
25213: POP
// case Rand ( 1 , 3 ) of 1 :
25214: LD_INT 1
25216: PPUSH
25217: LD_INT 3
25219: PPUSH
25220: CALL_OW 12
25224: PUSH
25225: LD_INT 1
25227: DOUBLE
25228: EQUAL
25229: IFTRUE 25233
25231: GO 25265
25233: POP
// depart ( at [ 2 ] , sol , attack_l , true , false ) ; 2 :
25234: LD_VAR 0 2
25238: PUSH
25239: LD_INT 2
25241: ARRAY
25242: PPUSH
25243: LD_EXP 91
25247: PPUSH
25248: LD_LOC 22
25252: PPUSH
25253: LD_INT 1
25255: PPUSH
25256: LD_INT 0
25258: PPUSH
25259: CALL 17019 0 5
25263: GO 25346
25265: LD_INT 2
25267: DOUBLE
25268: EQUAL
25269: IFTRUE 25273
25271: GO 25305
25273: POP
// depart ( at [ 2 ] , sol , attack_m , true , false ) ; 3 :
25274: LD_VAR 0 2
25278: PUSH
25279: LD_INT 2
25281: ARRAY
25282: PPUSH
25283: LD_EXP 91
25287: PPUSH
25288: LD_LOC 23
25292: PPUSH
25293: LD_INT 1
25295: PPUSH
25296: LD_INT 0
25298: PPUSH
25299: CALL 17019 0 5
25303: GO 25346
25305: LD_INT 3
25307: DOUBLE
25308: EQUAL
25309: IFTRUE 25313
25311: GO 25345
25313: POP
// depart ( at [ 2 ] , sol , attack_r , true , false ) ; end ;
25314: LD_VAR 0 2
25318: PUSH
25319: LD_INT 2
25321: ARRAY
25322: PPUSH
25323: LD_EXP 91
25327: PPUSH
25328: LD_LOC 24
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: LD_INT 0
25338: PPUSH
25339: CALL 17019 0 5
25343: GO 25346
25345: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25346: LD_VAR 0 2
25350: PUSH
25351: LD_INT 1
25353: ARRAY
25354: PPUSH
25355: LD_VAR 0 1
25359: PUSH
25360: LD_INT 1
25362: ARRAY
25363: PPUSH
25364: CALL_OW 250
25368: PPUSH
25369: LD_VAR 0 1
25373: PUSH
25374: LD_INT 1
25376: ARRAY
25377: PPUSH
25378: CALL_OW 251
25382: PPUSH
25383: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25387: LD_VAR 0 2
25391: PUSH
25392: LD_INT 2
25394: ARRAY
25395: PPUSH
25396: LD_VAR 0 1
25400: PUSH
25401: LD_INT 1
25403: ARRAY
25404: PPUSH
25405: CALL_OW 250
25409: PPUSH
25410: LD_VAR 0 1
25414: PUSH
25415: LD_INT 1
25417: ARRAY
25418: PPUSH
25419: CALL_OW 251
25423: PPUSH
25424: CALL_OW 174
// end ; end ;
25428: PPOPN 2
25430: END
// every 32 32$30 do var ubase ;
25431: GO 25433
25433: DISABLE
25434: LD_INT 0
25436: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25437: LD_ADDR_VAR 0 1
25441: PUSH
25442: LD_INT 21
25444: PUSH
25445: LD_INT 3
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: PUSH
25452: LD_INT 22
25454: PUSH
25455: LD_EXP 1
25459: PUSH
25460: EMPTY
25461: LIST
25462: LIST
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PPUSH
25468: CALL_OW 69
25472: ST_TO_ADDR
// if ubase then
25473: LD_VAR 0 1
25477: IFFALSE 25678
// begin case Rand ( 1 , 3 ) of 1 :
25479: LD_INT 1
25481: PPUSH
25482: LD_INT 3
25484: PPUSH
25485: CALL_OW 12
25489: PUSH
25490: LD_INT 1
25492: DOUBLE
25493: EQUAL
25494: IFTRUE 25498
25496: GO 25538
25498: POP
// depart ( attack diff broken , sol ^ sci , attack_l , true , false ) ; 2 :
25499: LD_LOC 5
25503: PUSH
25504: LD_LOC 21
25508: DIFF
25509: PPUSH
25510: LD_EXP 91
25514: PUSH
25515: LD_EXP 92
25519: ADD
25520: PPUSH
25521: LD_LOC 22
25525: PPUSH
25526: LD_INT 1
25528: PPUSH
25529: LD_INT 0
25531: PPUSH
25532: CALL 17019 0 5
25536: GO 25635
25538: LD_INT 2
25540: DOUBLE
25541: EQUAL
25542: IFTRUE 25546
25544: GO 25586
25546: POP
// depart ( attack diff broken , sol ^ sci , attack_m , true , false ) ; 3 :
25547: LD_LOC 5
25551: PUSH
25552: LD_LOC 21
25556: DIFF
25557: PPUSH
25558: LD_EXP 91
25562: PUSH
25563: LD_EXP 92
25567: ADD
25568: PPUSH
25569: LD_LOC 23
25573: PPUSH
25574: LD_INT 1
25576: PPUSH
25577: LD_INT 0
25579: PPUSH
25580: CALL 17019 0 5
25584: GO 25635
25586: LD_INT 3
25588: DOUBLE
25589: EQUAL
25590: IFTRUE 25594
25592: GO 25634
25594: POP
// depart ( attack diff broken , sol ^ sci , attack_r , true , false ) ; end ;
25595: LD_LOC 5
25599: PUSH
25600: LD_LOC 21
25604: DIFF
25605: PPUSH
25606: LD_EXP 91
25610: PUSH
25611: LD_EXP 92
25615: ADD
25616: PPUSH
25617: LD_LOC 24
25621: PPUSH
25622: LD_INT 1
25624: PPUSH
25625: LD_INT 0
25627: PPUSH
25628: CALL 17019 0 5
25632: GO 25635
25634: POP
// AddComAgressiveMove ( attack diff broken , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
25635: LD_LOC 5
25639: PUSH
25640: LD_LOC 21
25644: DIFF
25645: PPUSH
25646: LD_VAR 0 1
25650: PUSH
25651: LD_INT 1
25653: ARRAY
25654: PPUSH
25655: CALL_OW 250
25659: PPUSH
25660: LD_VAR 0 1
25664: PUSH
25665: LD_INT 1
25667: ARRAY
25668: PPUSH
25669: CALL_OW 251
25673: PPUSH
25674: CALL_OW 174
// end ; end ;
25678: PPOPN 1
25680: END
// every 40 40$30 do var ubase , at ;
25681: GO 25683
25683: DISABLE
25684: LD_INT 0
25686: PPUSH
25687: PPUSH
// begin ubase := FilterAllUnits ( [ [ f_type , unit_building ] , [ f_side , you ] ] ) ;
25688: LD_ADDR_VAR 0 1
25692: PUSH
25693: LD_INT 21
25695: PUSH
25696: LD_INT 3
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 22
25705: PUSH
25706: LD_EXP 1
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PPUSH
25719: CALL_OW 69
25723: ST_TO_ADDR
// if ubase then
25724: LD_VAR 0 1
25728: IFFALSE 26175
// begin at := split ( ( attack union scout ) diff broken ) ;
25730: LD_ADDR_VAR 0 2
25734: PUSH
25735: LD_LOC 5
25739: PUSH
25740: LD_LOC 4
25744: UNION
25745: PUSH
25746: LD_LOC 21
25750: DIFF
25751: PPUSH
25752: CALL 17632 0 1
25756: ST_TO_ADDR
// case Rand ( 1 , 3 ) of 1 :
25757: LD_INT 1
25759: PPUSH
25760: LD_INT 3
25762: PPUSH
25763: CALL_OW 12
25767: PUSH
25768: LD_INT 1
25770: DOUBLE
25771: EQUAL
25772: IFTRUE 25776
25774: GO 25820
25776: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25777: LD_VAR 0 2
25781: PUSH
25782: LD_INT 1
25784: ARRAY
25785: PPUSH
25786: LD_EXP 91
25790: PUSH
25791: LD_EXP 92
25795: ADD
25796: PUSH
25797: LD_EXP 94
25801: ADD
25802: PPUSH
25803: LD_LOC 22
25807: PPUSH
25808: LD_INT 1
25810: PPUSH
25811: LD_INT 0
25813: PPUSH
25814: CALL 17019 0 5
25818: GO 25925
25820: LD_INT 2
25822: DOUBLE
25823: EQUAL
25824: IFTRUE 25828
25826: GO 25872
25828: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25829: LD_VAR 0 2
25833: PUSH
25834: LD_INT 1
25836: ARRAY
25837: PPUSH
25838: LD_EXP 91
25842: PUSH
25843: LD_EXP 92
25847: ADD
25848: PUSH
25849: LD_EXP 94
25853: ADD
25854: PPUSH
25855: LD_LOC 23
25859: PPUSH
25860: LD_INT 1
25862: PPUSH
25863: LD_INT 0
25865: PPUSH
25866: CALL 17019 0 5
25870: GO 25925
25872: LD_INT 3
25874: DOUBLE
25875: EQUAL
25876: IFTRUE 25880
25878: GO 25924
25880: POP
// depart ( at [ 1 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
25881: LD_VAR 0 2
25885: PUSH
25886: LD_INT 1
25888: ARRAY
25889: PPUSH
25890: LD_EXP 91
25894: PUSH
25895: LD_EXP 92
25899: ADD
25900: PUSH
25901: LD_EXP 94
25905: ADD
25906: PPUSH
25907: LD_LOC 24
25911: PPUSH
25912: LD_INT 1
25914: PPUSH
25915: LD_INT 0
25917: PPUSH
25918: CALL 17019 0 5
25922: GO 25925
25924: POP
// case Rand ( 1 , 3 ) of 1 :
25925: LD_INT 1
25927: PPUSH
25928: LD_INT 3
25930: PPUSH
25931: CALL_OW 12
25935: PUSH
25936: LD_INT 1
25938: DOUBLE
25939: EQUAL
25940: IFTRUE 25944
25942: GO 25988
25944: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_l , true , false ) ; 2 :
25945: LD_VAR 0 2
25949: PUSH
25950: LD_INT 2
25952: ARRAY
25953: PPUSH
25954: LD_EXP 91
25958: PUSH
25959: LD_EXP 92
25963: ADD
25964: PUSH
25965: LD_EXP 94
25969: ADD
25970: PPUSH
25971: LD_LOC 22
25975: PPUSH
25976: LD_INT 1
25978: PPUSH
25979: LD_INT 0
25981: PPUSH
25982: CALL 17019 0 5
25986: GO 26093
25988: LD_INT 2
25990: DOUBLE
25991: EQUAL
25992: IFTRUE 25996
25994: GO 26040
25996: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_m , true , false ) ; 3 :
25997: LD_VAR 0 2
26001: PUSH
26002: LD_INT 2
26004: ARRAY
26005: PPUSH
26006: LD_EXP 91
26010: PUSH
26011: LD_EXP 92
26015: ADD
26016: PUSH
26017: LD_EXP 94
26021: ADD
26022: PPUSH
26023: LD_LOC 23
26027: PPUSH
26028: LD_INT 1
26030: PPUSH
26031: LD_INT 0
26033: PPUSH
26034: CALL 17019 0 5
26038: GO 26093
26040: LD_INT 3
26042: DOUBLE
26043: EQUAL
26044: IFTRUE 26048
26046: GO 26092
26048: POP
// depart ( at [ 2 ] , sol ^ sci ^ eng , attack_r , true , false ) ; end ;
26049: LD_VAR 0 2
26053: PUSH
26054: LD_INT 2
26056: ARRAY
26057: PPUSH
26058: LD_EXP 91
26062: PUSH
26063: LD_EXP 92
26067: ADD
26068: PUSH
26069: LD_EXP 94
26073: ADD
26074: PPUSH
26075: LD_LOC 24
26079: PPUSH
26080: LD_INT 1
26082: PPUSH
26083: LD_INT 0
26085: PPUSH
26086: CALL 17019 0 5
26090: GO 26093
26092: POP
// AddComAgressiveMove ( at [ 1 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
26093: LD_VAR 0 2
26097: PUSH
26098: LD_INT 1
26100: ARRAY
26101: PPUSH
26102: LD_VAR 0 1
26106: PUSH
26107: LD_INT 1
26109: ARRAY
26110: PPUSH
26111: CALL_OW 250
26115: PPUSH
26116: LD_VAR 0 1
26120: PUSH
26121: LD_INT 1
26123: ARRAY
26124: PPUSH
26125: CALL_OW 251
26129: PPUSH
26130: CALL_OW 174
// AddComAgressiveMove ( at [ 2 ] , GetX ( ubase [ 1 ] ) , GetY ( ubase [ 1 ] ) ) ;
26134: LD_VAR 0 2
26138: PUSH
26139: LD_INT 2
26141: ARRAY
26142: PPUSH
26143: LD_VAR 0 1
26147: PUSH
26148: LD_INT 1
26150: ARRAY
26151: PPUSH
26152: CALL_OW 250
26156: PPUSH
26157: LD_VAR 0 1
26161: PUSH
26162: LD_INT 1
26164: ARRAY
26165: PPUSH
26166: CALL_OW 251
26170: PPUSH
26171: CALL_OW 174
// end ; end ;
26175: PPOPN 2
26177: END
// export function count_crates ; var deps , i ; begin
26178: LD_INT 0
26180: PPUSH
26181: PPUSH
26182: PPUSH
// deps := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26183: LD_ADDR_VAR 0 2
26187: PUSH
26188: LD_INT 22
26190: PUSH
26191: LD_EXP 1
26195: PUSH
26196: EMPTY
26197: LIST
26198: LIST
26199: PUSH
26200: LD_INT 2
26202: PUSH
26203: LD_INT 30
26205: PUSH
26206: LD_INT 0
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: PUSH
26213: LD_INT 30
26215: PUSH
26216: LD_INT 1
26218: PUSH
26219: EMPTY
26220: LIST
26221: LIST
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: LIST
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PPUSH
26232: CALL_OW 69
26236: ST_TO_ADDR
// for i in deps do
26237: LD_ADDR_VAR 0 3
26241: PUSH
26242: LD_VAR 0 2
26246: PUSH
26247: FOR_IN
26248: IFFALSE 26281
// result := result + GetResourceType ( GetBase ( i ) , mat_cans ) ;
26250: LD_ADDR_VAR 0 1
26254: PUSH
26255: LD_VAR 0 1
26259: PUSH
26260: LD_VAR 0 3
26264: PPUSH
26265: CALL_OW 274
26269: PPUSH
26270: LD_INT 1
26272: PPUSH
26273: CALL_OW 275
26277: PLUS
26278: ST_TO_ADDR
26279: GO 26247
26281: POP
26282: POP
// end ;
26283: LD_VAR 0 1
26287: RET
// every 0 0$1 do var zbyva , prebyva ;
26288: GO 26290
26290: DISABLE
26291: LD_INT 0
26293: PPUSH
26294: PPUSH
// begin sec := sec + 1 ;
26295: LD_ADDR_LOC 29
26299: PUSH
26300: LD_LOC 29
26304: PUSH
26305: LD_INT 1
26307: PLUS
26308: ST_TO_ADDR
// zbyva := MaterialNavic - count_crates ;
26309: LD_ADDR_VAR 0 1
26313: PUSH
26314: LD_EXP 51
26318: PUSH
26319: CALL 26178 0 0
26323: MINUS
26324: ST_TO_ADDR
// if zbyva < 0 then
26325: LD_VAR 0 1
26329: PUSH
26330: LD_INT 0
26332: LESS
26333: IFFALSE 26358
// begin prebyva := zbyva * ( - 1 ) ;
26335: LD_ADDR_VAR 0 2
26339: PUSH
26340: LD_VAR 0 1
26344: PUSH
26345: LD_INT 1
26347: NEG
26348: MUL
26349: ST_TO_ADDR
// zbyva := 0 ;
26350: LD_ADDR_VAR 0 1
26354: PUSH
26355: LD_INT 0
26357: ST_TO_ADDR
// end ; display_strings := [ #Am06-1 , zbyva , #Am06-2 , 50 50$0 - ( tick - mytick ) ] ;
26358: LD_ADDR_OWVAR 47
26362: PUSH
26363: LD_STRING #Am06-1
26365: PUSH
26366: LD_VAR 0 1
26370: PUSH
26371: LD_STRING #Am06-2
26373: PUSH
26374: LD_INT 105000
26376: PUSH
26377: LD_OWVAR 1
26381: PUSH
26382: LD_EXP 87
26386: MINUS
26387: MINUS
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: LIST
26393: LIST
26394: ST_TO_ADDR
// enable ;
26395: ENABLE
// end ;
26396: PPOPN 2
26398: END
// every 0 0$2 trigger FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26399: LD_INT 4
26401: PPUSH
26402: LD_INT 22
26404: PUSH
26405: LD_EXP 1
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PPUSH
26414: CALL_OW 70
26418: IFFALSE 26493
26420: GO 26422
26422: DISABLE
26423: LD_INT 0
26425: PPUSH
// begin under_attack := true ;
26426: LD_ADDR_EXP 64
26430: PUSH
26431: LD_INT 1
26433: ST_TO_ADDR
// for i in FilterUnitsInArea ( near_base , [ f_side , you ] ) do
26434: LD_ADDR_VAR 0 1
26438: PUSH
26439: LD_INT 4
26441: PPUSH
26442: LD_INT 22
26444: PUSH
26445: LD_EXP 1
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PPUSH
26454: CALL_OW 70
26458: PUSH
26459: FOR_IN
26460: IFFALSE 26490
// ComAttackUnit ( defence union attack union scout , i ) ;
26462: LD_LOC 6
26466: PUSH
26467: LD_LOC 5
26471: UNION
26472: PUSH
26473: LD_LOC 4
26477: UNION
26478: PPUSH
26479: LD_VAR 0 1
26483: PPUSH
26484: CALL_OW 115
26488: GO 26459
26490: POP
26491: POP
// enable ;
26492: ENABLE
// end ;
26493: PPOPN 1
26495: END
// every 0 0$10 trigger not FilterUnitsInArea ( near_base , [ f_side , you ] ) do var i ;
26496: LD_INT 4
26498: PPUSH
26499: LD_INT 22
26501: PUSH
26502: LD_EXP 1
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PPUSH
26511: CALL_OW 70
26515: NOT
26516: IFFALSE 26533
26518: GO 26520
26520: DISABLE
26521: LD_INT 0
26523: PPUSH
// begin under_attack := false ;
26524: LD_ADDR_EXP 64
26528: PUSH
26529: LD_INT 0
26531: ST_TO_ADDR
// enable ;
26532: ENABLE
// end ; end_of_file
26533: PPOPN 1
26535: END
// var BaseBuild ; every 0 0$1.0 do var set_fuel , fuel , depot ;
26536: GO 26538
26538: DISABLE
26539: LD_INT 0
26541: PPUSH
26542: PPUSH
26543: PPUSH
// begin for depot in FilterAllUnits ( [ [ f_btype , b_depot ] , [ f_side , you ] ] ) do
26544: LD_ADDR_VAR 0 3
26548: PUSH
26549: LD_INT 30
26551: PUSH
26552: LD_INT 0
26554: PUSH
26555: EMPTY
26556: LIST
26557: LIST
26558: PUSH
26559: LD_INT 22
26561: PUSH
26562: LD_EXP 1
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PPUSH
26575: CALL_OW 69
26579: PUSH
26580: FOR_IN
26581: IFFALSE 26688
// for set_fuel in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] , [ f_dist , depot , 8 ] ] ) do
26583: LD_ADDR_VAR 0 1
26587: PUSH
26588: LD_INT 21
26590: PUSH
26591: LD_INT 2
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: LD_INT 22
26600: PUSH
26601: LD_EXP 1
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: PUSH
26610: LD_INT 91
26612: PUSH
26613: LD_VAR 0 3
26617: PUSH
26618: LD_INT 8
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: LIST
26625: PUSH
26626: EMPTY
26627: LIST
26628: LIST
26629: LIST
26630: PPUSH
26631: CALL_OW 69
26635: PUSH
26636: FOR_IN
26637: IFFALSE 26684
// begin fuel := GetFuel ( set_fuel ) ;
26639: LD_ADDR_VAR 0 2
26643: PUSH
26644: LD_VAR 0 1
26648: PPUSH
26649: CALL_OW 261
26653: ST_TO_ADDR
// if fuel <= 80 then
26654: LD_VAR 0 2
26658: PUSH
26659: LD_INT 80
26661: LESSEQUAL
26662: IFFALSE 26682
// SetFuel ( set_fuel , fuel + 20 ) ;
26664: LD_VAR 0 1
26668: PPUSH
26669: LD_VAR 0 2
26673: PUSH
26674: LD_INT 20
26676: PLUS
26677: PPUSH
26678: CALL_OW 240
// end ;
26682: GO 26636
26684: POP
26685: POP
26686: GO 26580
26688: POP
26689: POP
// enable ;
26690: ENABLE
// end ;
26691: PPOPN 3
26693: END
// export maj_ct ; on BuildingComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) then
26694: LD_VAR 0 1
26698: PPUSH
26699: LD_INT 22
26701: PUSH
26702: LD_EXP 1
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 30
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: EMPTY
26718: LIST
26719: LIST
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: PPUSH
26725: CALL_OW 72
26729: IFFALSE 26793
// begin BaseBuild := true ;
26731: LD_ADDR_LOC 32
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
26739: LD_STRING M1a
26741: PPUSH
26742: CALL_OW 337
// Setbname ( UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_depot ] ] ) [ 1 ] , epsilon ) ;
26746: LD_VAR 0 1
26750: PPUSH
26751: LD_INT 22
26753: PUSH
26754: LD_EXP 1
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PUSH
26763: LD_INT 30
26765: PUSH
26766: LD_INT 0
26768: PUSH
26769: EMPTY
26770: LIST
26771: LIST
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PPUSH
26777: CALL_OW 72
26781: PUSH
26782: LD_INT 1
26784: ARRAY
26785: PPUSH
26786: LD_STRING epsilon
26788: PPUSH
26789: CALL_OW 500
// end ; if GetBType ( build ) = b_control_tower then
26793: LD_VAR 0 1
26797: PPUSH
26798: CALL_OW 266
26802: PUSH
26803: LD_INT 36
26805: EQUAL
26806: IFFALSE 26816
// maj_ct := true ;
26808: LD_ADDR_EXP 95
26812: PUSH
26813: LD_INT 1
26815: ST_TO_ADDR
// end ;
26816: PPOPN 1
26818: END
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_side , you ] , [ f_btype , b_factory ] ] ) then
26819: LD_VAR 0 1
26823: PPUSH
26824: LD_INT 22
26826: PUSH
26827: LD_EXP 1
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 30
26838: PUSH
26839: LD_INT 3
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PPUSH
26850: CALL_OW 72
26854: IFFALSE 26863
// MyHint ( NonCombat ) ;
26856: LD_STRING NonCombat
26858: PPUSH
26859: CALL 17743 0 1
// end ;
26863: PPOPN 1
26865: END
// every 0 0$3 do var ok , sez , i ;
26866: GO 26868
26868: DISABLE
26869: LD_INT 0
26871: PPUSH
26872: PPUSH
26873: PPUSH
// begin sez := [ ] ;
26874: LD_ADDR_VAR 0 2
26878: PUSH
26879: EMPTY
26880: ST_TO_ADDR
// ok := false ;
26881: LD_ADDR_VAR 0 1
26885: PUSH
26886: LD_INT 0
26888: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_control , control_remote ] ) do
26889: LD_ADDR_VAR 0 3
26893: PUSH
26894: LD_INT 33
26896: PUSH
26897: LD_INT 2
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: PPUSH
26904: CALL_OW 69
26908: PUSH
26909: FOR_IN
26910: IFFALSE 26959
// begin if IsControledBy ( i ) in sez then
26912: LD_VAR 0 3
26916: PPUSH
26917: CALL_OW 312
26921: PUSH
26922: LD_VAR 0 2
26926: IN
26927: IFFALSE 26941
// begin ok := true ;
26929: LD_ADDR_VAR 0 1
26933: PUSH
26934: LD_INT 1
26936: ST_TO_ADDR
// break ;
26937: GO 26959
// end else
26939: GO 26957
// sez := sez ^ i ;
26941: LD_ADDR_VAR 0 2
26945: PUSH
26946: LD_VAR 0 2
26950: PUSH
26951: LD_VAR 0 3
26955: ADD
26956: ST_TO_ADDR
// end ;
26957: GO 26909
26959: POP
26960: POP
// if ok then
26961: LD_VAR 0 1
26965: IFFALSE 26976
// begin ChangeMissionObjectives ( MRa ) ;
26967: LD_STRING MRa
26969: PPUSH
26970: CALL_OW 337
// end else
26974: GO 26977
// enable ;
26976: ENABLE
// end ;
26977: PPOPN 3
26979: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_RemCont and GetSide ( lab ) = you then
26980: LD_VAR 0 1
26984: PUSH
26985: LD_INT 15
26987: EQUAL
26988: IFFALSE 27007
26990: PUSH
26991: LD_VAR 0 2
26995: PPUSH
26996: CALL_OW 255
27000: PUSH
27001: LD_EXP 1
27005: EQUAL
27006: AND
27007: IFFALSE 27020
// begin DialogR2 ;
27009: CALL 6612 0 0
// MyHint ( RemoteControlTower ) ;
27013: LD_STRING RemoteControlTower
27015: PPUSH
27016: CALL 17743 0 1
// end ; if tech = tech_MatDet and GetSide ( lab ) = you then
27020: LD_VAR 0 1
27024: PUSH
27025: LD_INT 7
27027: EQUAL
27028: IFFALSE 27047
27030: PUSH
27031: LD_VAR 0 2
27035: PPUSH
27036: CALL_OW 255
27040: PUSH
27041: LD_EXP 1
27045: EQUAL
27046: AND
27047: IFFALSE 27056
// begin MyHint ( MaterialisationDetection ) ;
27049: LD_STRING MaterialisationDetection
27051: PPUSH
27052: CALL 17743 0 1
// end ; end ; end_of_file
27056: PPOPN 2
27058: END
// every 0 0$2 + 0 0$0.1 do
27059: GO 27061
27061: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
27062: LD_INT 22
27064: PUSH
27065: LD_INT 1
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: LD_INT 2
27074: PUSH
27075: LD_INT 25
27077: PUSH
27078: LD_INT 12
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: LD_INT 25
27087: PUSH
27088: LD_INT 16
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: LD_INT 25
27097: PUSH
27098: LD_INT 15
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 25
27107: PUSH
27108: LD_INT 17
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: LIST
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: PPUSH
27126: CALL_OW 69
27130: PUSH
27131: LD_INT 22
27133: PUSH
27134: LD_INT 1
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 21
27143: PUSH
27144: LD_INT 1
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 3
27153: PUSH
27154: LD_INT 2
27156: PUSH
27157: LD_INT 25
27159: PUSH
27160: LD_INT 12
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: PUSH
27167: LD_INT 25
27169: PUSH
27170: LD_INT 16
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PUSH
27177: LD_INT 25
27179: PUSH
27180: LD_INT 15
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 25
27189: PUSH
27190: LD_INT 17
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: LIST
27201: LIST
27202: LIST
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: LIST
27212: PPUSH
27213: CALL_OW 69
27217: GREATER
27218: IFFALSE 27229
// begin SetAchievement ( ACH_POTA ) ;
27220: LD_STRING ACH_POTA
27222: PPUSH
27223: CALL_OW 543
// exit ;
27227: GO 27230
// end ; enable ;
27229: ENABLE
// end ;
27230: END
// export function SA_OnKurtSpared ; begin
27231: LD_INT 0
27233: PPUSH
// SetAchievement ( ACH_MER ) ;
27234: LD_STRING ACH_MER
27236: PPUSH
27237: CALL_OW 543
// end ;
27241: LD_VAR 0 1
27245: RET
// export function SA_OnKurtKilled ; begin
27246: LD_INT 0
27248: PPUSH
// SetAchievement ( ACH_MEL ) ;
27249: LD_STRING ACH_MEL
27251: PPUSH
27252: CALL_OW 543
// end ;
27256: LD_VAR 0 1
27260: RET
// export function SA_On1000CratesGathered ; begin
27261: LD_INT 0
27263: PPUSH
// SetAchievement ( ACH_CAP ) ;
27264: LD_STRING ACH_CAP
27266: PPUSH
27267: CALL_OW 543
// end ;
27271: LD_VAR 0 1
27275: RET
// export function SA_CratesGathered ( count_crates ) ; begin
27276: LD_INT 0
27278: PPUSH
// SetAchievementEX ( ACH_CAP , count_crates ) ;
27279: LD_STRING ACH_CAP
27281: PPUSH
27282: LD_VAR 0 1
27286: PPUSH
27287: CALL_OW 564
// end ;
27291: LD_VAR 0 2
27295: RET
// export function SA_NobodyLeft ; begin
27296: LD_INT 0
27298: PPUSH
// SetAchievement ( ACH_NLB ) ;
27299: LD_STRING ACH_NLB
27301: PPUSH
27302: CALL_OW 543
// end ;
27306: LD_VAR 0 1
27310: RET
// export function SA_JoanDead ; begin
27311: LD_INT 0
27313: PPUSH
// SetAchievement ( ACH_IFL ) ;
27314: LD_STRING ACH_IFL
27316: PPUSH
27317: CALL_OW 543
// end ; end_of_file
27321: LD_VAR 0 1
27325: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
27326: LD_INT 0
27328: PPUSH
27329: PPUSH
// if not missionNumber then
27330: LD_VAR 0 2
27334: NOT
27335: IFFALSE 27339
// exit ;
27337: GO 27477
// achiv := false ;
27339: LD_ADDR_VAR 0 7
27343: PUSH
27344: LD_INT 0
27346: ST_TO_ADDR
// case campaignNumber of 1 :
27347: LD_VAR 0 1
27351: PUSH
27352: LD_INT 1
27354: DOUBLE
27355: EQUAL
27356: IFTRUE 27360
27358: GO 27371
27360: POP
// achiv := ACH_GOTA ; 2 :
27361: LD_ADDR_VAR 0 7
27365: PUSH
27366: LD_STRING ACH_GOTA
27368: ST_TO_ADDR
27369: GO 27421
27371: LD_INT 2
27373: DOUBLE
27374: EQUAL
27375: IFTRUE 27379
27377: GO 27382
27379: POP
// ; 3 :
27380: GO 27421
27382: LD_INT 3
27384: DOUBLE
27385: EQUAL
27386: IFTRUE 27390
27388: GO 27401
27390: POP
// achiv := ACH_MOTSU ; 4 :
27391: LD_ADDR_VAR 0 7
27395: PUSH
27396: LD_STRING ACH_MOTSU
27398: ST_TO_ADDR
27399: GO 27421
27401: LD_INT 4
27403: DOUBLE
27404: EQUAL
27405: IFTRUE 27409
27407: GO 27420
27409: POP
// achiv := ACH_LOP ; end ;
27410: LD_ADDR_VAR 0 7
27414: PUSH
27415: LD_STRING ACH_LOP
27417: ST_TO_ADDR
27418: GO 27421
27420: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
27421: LD_OWVAR 67
27425: PUSH
27426: LD_INT 3
27428: EQUAL
27429: IFFALSE 27437
27431: PUSH
27432: LD_VAR 0 7
27436: AND
27437: IFFALSE 27445
27439: PUSH
27440: LD_VAR 0 3
27444: AND
27445: IFFALSE 27453
27447: PUSH
27448: LD_VAR 0 4
27452: AND
27453: IFFALSE 27461
27455: PUSH
27456: LD_VAR 0 5
27460: AND
27461: IFFALSE 27477
// SetAchievementEX ( achiv , missionNumber ) ;
27463: LD_VAR 0 7
27467: PPUSH
27468: LD_VAR 0 2
27472: PPUSH
27473: CALL_OW 564
// end ;
27477: LD_VAR 0 6
27481: RET
// export function SA_BehemothConstructed ; begin
27482: LD_INT 0
27484: PPUSH
// SetAchievement ( ACH_SMC ) ;
27485: LD_STRING ACH_SMC
27487: PPUSH
27488: CALL_OW 543
// end ;
27492: LD_VAR 0 1
27496: RET
