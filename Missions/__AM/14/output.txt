// export MacMillan , Powell , Joan , Lisa , Anezka ; export survivor , who_survive ; export truck1 , ukradle_auto ; export time_crates_us , time_crates_ru ; export other_survivors ; export on_optolab ; export you , russians , neutral ; export double_laser , double_hint ; export selected_opto_lab ; export veh_jmm , veh_surv ; export fastEscape ; export kappa_saved ; var russians_eliminated , doublelasers_turrets ; function prepare_units ; var un , i ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
// uc_nation := nation_american ;
   5: LD_ADDR_OWVAR 21
   9: PUSH
  10: LD_INT 1
  12: ST_TO_ADDR
// uc_side := you ;
  13: LD_ADDR_OWVAR 20
  17: PUSH
  18: LD_EXP 14
  22: ST_TO_ADDR
// hc_class := class_soldier ;
  23: LD_ADDR_OWVAR 28
  27: PUSH
  28: LD_INT 1
  30: ST_TO_ADDR
// MacMillan := CreateCharacter ( JMM ) ;
  31: LD_ADDR_EXP 1
  35: PUSH
  36: LD_STRING JMM
  38: PPUSH
  39: CALL_OW 34
  43: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_STRING Powell
  51: PPUSH
  52: CALL_OW 25
  56: ST_TO_ADDR
// uc_side := neutral ;
  57: LD_ADDR_OWVAR 20
  61: PUSH
  62: LD_EXP 16
  66: ST_TO_ADDR
// if TestCharacters ( Joan ) and CheckCharacterSet ( Joan ) then
  67: LD_STRING Joan
  69: PPUSH
  70: CALL_OW 28
  74: PUSH
  75: LD_STRING Joan
  77: PPUSH
  78: CALL_OW 29
  82: AND
  83: IFFALSE 126
// begin hc_class := class_scientistic ;
  85: LD_ADDR_OWVAR 28
  89: PUSH
  90: LD_INT 4
  92: ST_TO_ADDR
// Joan := CreateCharacter ( Joan ) ;
  93: LD_ADDR_EXP 3
  97: PUSH
  98: LD_STRING Joan
 100: PPUSH
 101: CALL_OW 34
 105: ST_TO_ADDR
// survivor := Joan ;
 106: LD_ADDR_EXP 6
 110: PUSH
 111: LD_EXP 3
 115: ST_TO_ADDR
// who_survive := 1 ;
 116: LD_ADDR_EXP 7
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// end else
 124: GO 216
// if TestCharacters ( Lisa ) and CheckCharacterSet ( Lisa ) then
 126: LD_STRING Lisa
 128: PPUSH
 129: CALL_OW 28
 133: PUSH
 134: LD_STRING Lisa
 136: PPUSH
 137: CALL_OW 29
 141: AND
 142: IFFALSE 185
// begin hc_class := class_soldier ;
 144: LD_ADDR_OWVAR 28
 148: PUSH
 149: LD_INT 1
 151: ST_TO_ADDR
// Lisa := CreateCharacter ( Lisa ) ;
 152: LD_ADDR_EXP 4
 156: PUSH
 157: LD_STRING Lisa
 159: PPUSH
 160: CALL_OW 34
 164: ST_TO_ADDR
// survivor := Lisa ;
 165: LD_ADDR_EXP 6
 169: PUSH
 170: LD_EXP 4
 174: ST_TO_ADDR
// who_survive := 2 ;
 175: LD_ADDR_EXP 7
 179: PUSH
 180: LD_INT 2
 182: ST_TO_ADDR
// end else
 183: GO 216
// begin Anezka := NewCharacter ( Coonie ) ;
 185: LD_ADDR_EXP 5
 189: PUSH
 190: LD_STRING Coonie
 192: PPUSH
 193: CALL_OW 25
 197: ST_TO_ADDR
// survivor := Anezka ;
 198: LD_ADDR_EXP 6
 202: PUSH
 203: LD_EXP 5
 207: ST_TO_ADDR
// who_survive := 3 ;
 208: LD_ADDR_EXP 7
 212: PUSH
 213: LD_INT 3
 215: ST_TO_ADDR
// end ; uc_side := you ;
 216: LD_ADDR_OWVAR 20
 220: PUSH
 221: LD_EXP 14
 225: ST_TO_ADDR
// if TestCharacters ( other_survivors ) then
 226: LD_STRING other_survivors
 228: PPUSH
 229: CALL_OW 28
 233: IFFALSE 250
// other_survivors := CreateCharacterSet ( other_survivors ) else
 235: LD_ADDR_EXP 12
 239: PUSH
 240: LD_STRING other_survivors
 242: PPUSH
 243: CALL_OW 31
 247: ST_TO_ADDR
 248: GO 257
// other_survivors := [ ] ;
 250: LD_ADDR_EXP 12
 254: PUSH
 255: EMPTY
 256: ST_TO_ADDR
// uc_direction := 1 ;
 257: LD_ADDR_OWVAR 24
 261: PUSH
 262: LD_INT 1
 264: ST_TO_ADDR
// vc_chassis := us_morphling ;
 265: LD_ADDR_OWVAR 37
 269: PUSH
 270: LD_INT 5
 272: ST_TO_ADDR
// vc_control := control_manual ;
 273: LD_ADDR_OWVAR 38
 277: PUSH
 278: LD_INT 1
 280: ST_TO_ADDR
// vc_engine := engine_siberite ;
 281: LD_ADDR_OWVAR 39
 285: PUSH
 286: LD_INT 3
 288: ST_TO_ADDR
// vc_weapon := us_laser ;
 289: LD_ADDR_OWVAR 40
 293: PUSH
 294: LD_INT 9
 296: ST_TO_ADDR
// truck1 := CreateVehicle ;
 297: LD_ADDR_EXP 8
 301: PUSH
 302: CALL_OW 45
 306: ST_TO_ADDR
// uc_direction = rand ( 0 , 5 ) ;
 307: LD_ADDR_OWVAR 24
 311: PUSH
 312: LD_INT 0
 314: PPUSH
 315: LD_INT 5
 317: PPUSH
 318: CALL_OW 12
 322: ST_TO_ADDR
// PlaceHumanInUnit ( MacMillan , truck1 ) ;
 323: LD_EXP 1
 327: PPUSH
 328: LD_EXP 8
 332: PPUSH
 333: CALL_OW 52
// uc_nation = nation_russian ;
 337: LD_ADDR_OWVAR 21
 341: PUSH
 342: LD_INT 3
 344: ST_TO_ADDR
// uc_side = russians ;
 345: LD_ADDR_OWVAR 20
 349: PUSH
 350: LD_EXP 15
 354: ST_TO_ADDR
// PlaceUnitXY ( truck1 , 6 , 6 , false ) ;
 355: LD_EXP 8
 359: PPUSH
 360: LD_INT 6
 362: PPUSH
 363: LD_INT 6
 365: PPUSH
 366: LD_INT 0
 368: PPUSH
 369: CALL_OW 48
// PlaceUnitXY ( survivor , 65 , 108 , false ) ;
 373: LD_EXP 6
 377: PPUSH
 378: LD_INT 65
 380: PPUSH
 381: LD_INT 108
 383: PPUSH
 384: LD_INT 0
 386: PPUSH
 387: CALL_OW 48
// ComFree ( [ MacMillan , survivor ] ) ;
 391: LD_EXP 1
 395: PUSH
 396: LD_EXP 6
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: PPUSH
 405: CALL_OW 139
// end ;
 409: LD_VAR 0 1
 413: RET
// function prepare_sides ; begin
 414: LD_INT 0
 416: PPUSH
// you = 1 ;
 417: LD_ADDR_EXP 14
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// neutral = 4 ;
 425: LD_ADDR_EXP 16
 429: PUSH
 430: LD_INT 4
 432: ST_TO_ADDR
// russians = 3 ;
 433: LD_ADDR_EXP 15
 437: PUSH
 438: LD_INT 3
 440: ST_TO_ADDR
// visit_base := false ;
 441: LD_ADDR_EXP 34
 445: PUSH
 446: LD_INT 0
 448: ST_TO_ADDR
// on_optolab := false ;
 449: LD_ADDR_EXP 13
 453: PUSH
 454: LD_INT 0
 456: ST_TO_ADDR
// russians_eliminated := false ;
 457: LD_ADDR_LOC 1
 461: PUSH
 462: LD_INT 0
 464: ST_TO_ADDR
// double_laser := 0 ;
 465: LD_ADDR_EXP 17
 469: PUSH
 470: LD_INT 0
 472: ST_TO_ADDR
// double_hint := false ;
 473: LD_ADDR_EXP 18
 477: PUSH
 478: LD_INT 0
 480: ST_TO_ADDR
// doublelasers_turrets := [ ] ;
 481: LD_ADDR_LOC 2
 485: PUSH
 486: EMPTY
 487: ST_TO_ADDR
// selected_opto_lab := false ;
 488: LD_ADDR_EXP 19
 492: PUSH
 493: LD_INT 0
 495: ST_TO_ADDR
// SetAttitude ( you , russians , att_enemy , true ) ;
 496: LD_EXP 14
 500: PPUSH
 501: LD_EXP 15
 505: PPUSH
 506: LD_INT 2
 508: PPUSH
 509: LD_INT 1
 511: PPUSH
 512: CALL_OW 80
// SetAttitude ( you , neutral , att_friend , true ) ;
 516: LD_EXP 14
 520: PPUSH
 521: LD_EXP 16
 525: PPUSH
 526: LD_INT 1
 528: PPUSH
 529: LD_INT 1
 531: PPUSH
 532: CALL_OW 80
// enable ( 1 ) ;
 536: LD_INT 1
 538: ENABLE_MARKED
// disable ( 5 ) ;
 539: LD_INT 5
 541: DISABLE_MARKED
// disable ( 11 ) ;
 542: LD_INT 11
 544: DISABLE_MARKED
// end ;
 545: LD_VAR 0 1
 549: RET
// starting begin RandomizeAll ;
 550: CALL_OW 11
// fastEscape = 0 ;
 554: LD_ADDR_EXP 22
 558: PUSH
 559: LD_INT 0
 561: ST_TO_ADDR
// prepare_sides ;
 562: CALL 414 0 0
// prepare_units ;
 566: CALL 0 0 0
// starting_scene ;
 570: CALL 5281 0 0
// prepare_ru_base ;
 574: CALL 2920 0 0
// prepare_us_base ;
 578: CALL 8048 0 0
// ru_scientistic_priority ;
 582: CALL 8648 0 0
// startup_manufacturing ;
 586: CALL 10248 0 0
// startup_war_definition ;
 590: CALL 11681 0 0
// init_keep_base ;
 594: CALL 16897 0 0
// start_defend ;
 598: CALL 16295 0 0
// time_crates_us := Rand ( 0 0$20 , 0 0$40 ) ;
 602: LD_ADDR_EXP 10
 606: PUSH
 607: LD_INT 700
 609: PPUSH
 610: LD_INT 1400
 612: PPUSH
 613: CALL_OW 12
 617: ST_TO_ADDR
// time_crates_ru := Rand ( 0 0$30 , 0 0$60 ) ;
 618: LD_ADDR_EXP 11
 622: PUSH
 623: LD_INT 1050
 625: PPUSH
 626: LD_INT 2100
 628: PPUSH
 629: CALL_OW 12
 633: ST_TO_ADDR
// end ;
 634: END
// every 0 0$5 trigger TICK >= time_crates_us do
 635: LD_OWVAR 1
 639: PUSH
 640: LD_EXP 10
 644: GREATEREQUAL
 645: IFFALSE 694
 647: GO 649
 649: DISABLE
// begin CreateCratesArea ( Rand ( 2 , 5 ) , inner_base , true ) ;
 650: LD_INT 2
 652: PPUSH
 653: LD_INT 5
 655: PPUSH
 656: CALL_OW 12
 660: PPUSH
 661: LD_INT 4
 663: PPUSH
 664: LD_INT 1
 666: PPUSH
 667: CALL_OW 55
// time_crates_us := TICK + Rand ( 0 0$60 , 0 0$100 ) ;
 671: LD_ADDR_EXP 10
 675: PUSH
 676: LD_OWVAR 1
 680: PUSH
 681: LD_INT 2100
 683: PPUSH
 684: LD_INT 3500
 686: PPUSH
 687: CALL_OW 12
 691: PLUS
 692: ST_TO_ADDR
// enable ;
 693: ENABLE
// end ;
 694: END
// every 0 0$5 trigger TICK >= time_crates_ru do
 695: LD_OWVAR 1
 699: PUSH
 700: LD_EXP 11
 704: GREATEREQUAL
 705: IFFALSE 754
 707: GO 709
 709: DISABLE
// begin CreateCratesArea ( Rand ( 3 , 5 ) , ru_crates , true ) ;
 710: LD_INT 3
 712: PPUSH
 713: LD_INT 5
 715: PPUSH
 716: CALL_OW 12
 720: PPUSH
 721: LD_INT 10
 723: PPUSH
 724: LD_INT 1
 726: PPUSH
 727: CALL_OW 55
// time_crates_ru := TICK + Rand ( 0 0$30 , 0 0$60 ) ;
 731: LD_ADDR_EXP 11
 735: PUSH
 736: LD_OWVAR 1
 740: PUSH
 741: LD_INT 1050
 743: PPUSH
 744: LD_INT 2100
 746: PPUSH
 747: CALL_OW 12
 751: PLUS
 752: ST_TO_ADDR
// enable ;
 753: ENABLE
// end ;
 754: END
// export function konec_mise ; var saved , un , medal1 , medal2 , medal3 ; begin
 755: LD_INT 0
 757: PPUSH
 758: PPUSH
 759: PPUSH
 760: PPUSH
 761: PPUSH
 762: PPUSH
// medal1 := false ;
 763: LD_ADDR_VAR 0 4
 767: PUSH
 768: LD_INT 0
 770: ST_TO_ADDR
// medal2 := false ;
 771: LD_ADDR_VAR 0 5
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// medal3 := false ;
 779: LD_ADDR_VAR 0 6
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// if IsOK ( MacMillan ) and not russians_eliminated then
 787: LD_EXP 1
 791: PPUSH
 792: CALL_OW 302
 796: PUSH
 797: LD_LOC 1
 801: NOT
 802: AND
 803: IFFALSE 901
// begin un := IsInUnit ( MacMillan ) ;
 805: LD_ADDR_VAR 0 3
 809: PUSH
 810: LD_EXP 1
 814: PPUSH
 815: CALL_OW 310
 819: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 820: LD_VAR 0 3
 824: PPUSH
 825: CALL_OW 247
 829: PUSH
 830: LD_INT 2
 832: EQUAL
 833: IFFALSE 886
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
 835: LD_ADDR_EXP 20
 839: PUSH
 840: LD_VAR 0 3
 844: PPUSH
 845: CALL_OW 265
 849: PUSH
 850: LD_VAR 0 3
 854: PPUSH
 855: CALL_OW 262
 859: PUSH
 860: LD_VAR 0 3
 864: PPUSH
 865: CALL_OW 263
 869: PUSH
 870: LD_VAR 0 3
 874: PPUSH
 875: CALL_OW 264
 879: PUSH
 880: EMPTY
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: ST_TO_ADDR
// if GetType ( un ) = unit_vehicle then
 886: LD_VAR 0 3
 890: PPUSH
 891: CALL_OW 247
 895: PUSH
 896: LD_INT 2
 898: EQUAL
 899: IFFALSE 901
// end ; if IsDead ( MacMillan ) or ( GetLives ( MacMillan ) < 250 ) then
 901: LD_EXP 1
 905: PPUSH
 906: CALL_OW 301
 910: PUSH
 911: LD_EXP 1
 915: PPUSH
 916: CALL_OW 256
 920: PUSH
 921: LD_INT 250
 923: LESS
 924: OR
 925: IFFALSE 936
// begin YouLost ( JMM ) ;
 927: LD_STRING JMM
 929: PPUSH
 930: CALL_OW 104
// exit ;
 934: GO 1655
// end ; if ( GetLives ( survivor ) > 250 ) and visit_base then
 936: LD_EXP 6
 940: PPUSH
 941: CALL_OW 256
 945: PUSH
 946: LD_INT 250
 948: GREATER
 949: PUSH
 950: LD_EXP 34
 954: AND
 955: IFFALSE 979
// begin medal1 := true ;
 957: LD_ADDR_VAR 0 4
 961: PUSH
 962: LD_INT 1
 964: ST_TO_ADDR
// AddMedal ( protect , who_survive ) ;
 965: LD_STRING protect
 967: PPUSH
 968: LD_EXP 7
 972: PPUSH
 973: CALL_OW 101
// end else
 977: GO 1051
// case who_survive of 1 :
 979: LD_EXP 7
 983: PUSH
 984: LD_INT 1
 986: DOUBLE
 987: EQUAL
 988: IFTRUE 992
 990: GO 1006
 992: POP
// AddMedal ( protect , - 1 ) ; 2 :
 993: LD_STRING protect
 995: PPUSH
 996: LD_INT 1
 998: NEG
 999: PPUSH
1000: CALL_OW 101
1004: GO 1051
1006: LD_INT 2
1008: DOUBLE
1009: EQUAL
1010: IFTRUE 1014
1012: GO 1028
1014: POP
// AddMedal ( protect , - 2 ) ; 3 :
1015: LD_STRING protect
1017: PPUSH
1018: LD_INT 2
1020: NEG
1021: PPUSH
1022: CALL_OW 101
1026: GO 1051
1028: LD_INT 3
1030: DOUBLE
1031: EQUAL
1032: IFTRUE 1036
1034: GO 1050
1036: POP
// AddMedal ( protect , - 3 ) ; end ;
1037: LD_STRING protect
1039: PPUSH
1040: LD_INT 3
1042: NEG
1043: PPUSH
1044: CALL_OW 101
1048: GO 1051
1050: POP
// if ( GetLives ( survivor ) > 250 ) and visit_base then
1051: LD_EXP 6
1055: PPUSH
1056: CALL_OW 256
1060: PUSH
1061: LD_INT 250
1063: GREATER
1064: PUSH
1065: LD_EXP 34
1069: AND
1070: IFFALSE 1093
// saved := [ MacMillan , survivor ] else
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: LD_EXP 1
1081: PUSH
1082: LD_EXP 6
1086: PUSH
1087: EMPTY
1088: LIST
1089: LIST
1090: ST_TO_ADDR
1091: GO 1106
// saved := [ MacMillan ] ;
1093: LD_ADDR_VAR 0 2
1097: PUSH
1098: LD_EXP 1
1102: PUSH
1103: EMPTY
1104: LIST
1105: ST_TO_ADDR
// double_laser := double_laser + doublelasers_turrets ;
1106: LD_ADDR_EXP 17
1110: PUSH
1111: LD_EXP 17
1115: PUSH
1116: LD_LOC 2
1120: PLUS
1121: ST_TO_ADDR
// if visit_base then
1122: LD_EXP 34
1126: IFFALSE 1218
// begin if not selected_opto_lab then
1128: LD_EXP 19
1132: NOT
1133: IFFALSE 1148
// AddMedal ( double , - 1 ) else
1135: LD_STRING double
1137: PPUSH
1138: LD_INT 1
1140: NEG
1141: PPUSH
1142: CALL_OW 101
1146: GO 1216
// case double_laser of 0 :
1148: LD_EXP 17
1152: PUSH
1153: LD_INT 0
1155: DOUBLE
1156: EQUAL
1157: IFTRUE 1161
1159: GO 1175
1161: POP
// AddMedal ( double , - 2 ) ; 1 :
1162: LD_STRING double
1164: PPUSH
1165: LD_INT 2
1167: NEG
1168: PPUSH
1169: CALL_OW 101
1173: GO 1216
1175: LD_INT 1
1177: DOUBLE
1178: EQUAL
1179: IFTRUE 1183
1181: GO 1197
1183: POP
// AddMedal ( double , - 3 ) ; else
1184: LD_STRING double
1186: PPUSH
1187: LD_INT 3
1189: NEG
1190: PPUSH
1191: CALL_OW 101
1195: GO 1216
1197: POP
// begin medal2 := true ;
1198: LD_ADDR_VAR 0 5
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// Addmedal ( double , 1 ) ;
1206: LD_STRING double
1208: PPUSH
1209: LD_INT 1
1211: PPUSH
1212: CALL_OW 101
// end ; end ; end else
1216: GO 1229
// AddMedal ( double , - 2 ) ;
1218: LD_STRING double
1220: PPUSH
1221: LD_INT 2
1223: NEG
1224: PPUSH
1225: CALL_OW 101
// if russians_eliminated then
1229: LD_LOC 1
1233: IFFALSE 1296
// begin AddMedal ( base , 1 ) ;
1235: LD_STRING base
1237: PPUSH
1238: LD_INT 1
1240: PPUSH
1241: CALL_OW 101
// medal3 := true ;
1245: LD_ADDR_VAR 0 6
1249: PUSH
1250: LD_INT 1
1252: ST_TO_ADDR
// SA_EndMission ( 1 , 14 , medal1 , medal2 , medal3 ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 14
1258: PPUSH
1259: LD_VAR 0 4
1263: PPUSH
1264: LD_VAR 0 5
1268: PPUSH
1269: LD_VAR 0 6
1273: PPUSH
1274: CALL 17287 0 5
// GiveMedals ( Eliminate ) ;
1278: LD_STRING Eliminate
1280: PPUSH
1281: CALL_OW 102
// RewardPeople ( saved ) ;
1285: LD_VAR 0 2
1289: PPUSH
1290: CALL_OW 43
// end else
1294: GO 1343
// begin if not visit_base then
1296: LD_EXP 34
1300: NOT
1301: IFFALSE 1316
// AddMedal ( base , - 2 ) else
1303: LD_STRING base
1305: PPUSH
1306: LD_INT 2
1308: NEG
1309: PPUSH
1310: CALL_OW 101
1314: GO 1327
// AddMedal ( base , - 1 ) ;
1316: LD_STRING base
1318: PPUSH
1319: LD_INT 1
1321: NEG
1322: PPUSH
1323: CALL_OW 101
// GiveMedals ( Reach ) ;
1327: LD_STRING Reach
1329: PPUSH
1330: CALL_OW 102
// RewardPeople ( saved ) ;
1334: LD_VAR 0 2
1338: PPUSH
1339: CALL_OW 43
// end ; kappa_saved := false ;
1343: LD_ADDR_EXP 23
1347: PUSH
1348: LD_INT 0
1350: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1351: LD_EXP 1
1355: PPUSH
1356: LD_STRING JMM
1358: PPUSH
1359: CALL_OW 38
// if not visit_base then
1363: LD_EXP 34
1367: NOT
1368: IFFALSE 1379
// KillUnit ( survivor ) ;
1370: LD_EXP 6
1374: PPUSH
1375: CALL_OW 66
// case who_survive of 1 :
1379: LD_EXP 7
1383: PUSH
1384: LD_INT 1
1386: DOUBLE
1387: EQUAL
1388: IFTRUE 1392
1390: GO 1407
1392: POP
// SaveCharacters ( Joan , Joan ) ; 2 :
1393: LD_EXP 3
1397: PPUSH
1398: LD_STRING Joan
1400: PPUSH
1401: CALL_OW 38
1405: GO 1454
1407: LD_INT 2
1409: DOUBLE
1410: EQUAL
1411: IFTRUE 1415
1413: GO 1430
1415: POP
// SaveCharacters ( Lisa , Lisa ) ; 3 :
1416: LD_EXP 4
1420: PPUSH
1421: LD_STRING Lisa
1423: PPUSH
1424: CALL_OW 38
1428: GO 1454
1430: LD_INT 3
1432: DOUBLE
1433: EQUAL
1434: IFTRUE 1438
1436: GO 1453
1438: POP
// SaveCharacters ( Anezka , Coonie ) ; end ;
1439: LD_EXP 5
1443: PPUSH
1444: LD_STRING Coonie
1446: PPUSH
1447: CALL_OW 38
1451: GO 1454
1453: POP
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1454: LD_EXP 6
1458: PPUSH
1459: CALL_OW 256
1463: PUSH
1464: LD_INT 250
1466: GREATER
1467: PUSH
1468: LD_EXP 22
1472: PUSH
1473: LD_INT 0
1475: EQUAL
1476: AND
1477: IFFALSE 1496
// SaveVariable ( IsLive ( survivor ) , woman_saved ) ;
1479: LD_EXP 6
1483: PPUSH
1484: CALL_OW 300
1488: PPUSH
1489: LD_STRING woman_saved
1491: PPUSH
1492: CALL_OW 39
// kappa_saved = russians_eliminated and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) ;
1496: LD_ADDR_EXP 23
1500: PUSH
1501: LD_LOC 1
1505: PUSH
1506: LD_INT 22
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: LD_INT 21
1518: PUSH
1519: LD_INT 3
1521: PUSH
1522: EMPTY
1523: LIST
1524: LIST
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL_OW 69
1534: AND
1535: ST_TO_ADDR
// SaveVariable ( kappa_saved , kappa_saved ) ;
1536: LD_EXP 23
1540: PPUSH
1541: LD_STRING kappa_saved
1543: PPUSH
1544: CALL_OW 39
// SaveVariable ( visit_base , kappa_delayed ) ;
1548: LD_EXP 34
1552: PPUSH
1553: LD_STRING kappa_delayed
1555: PPUSH
1556: CALL_OW 39
// if GetLives ( survivor ) > 250 and fastEscape = 0 then
1560: LD_EXP 6
1564: PPUSH
1565: CALL_OW 256
1569: PUSH
1570: LD_INT 250
1572: GREATER
1573: PUSH
1574: LD_EXP 22
1578: PUSH
1579: LD_INT 0
1581: EQUAL
1582: AND
1583: IFFALSE 1608
// SaveVariable ( ( visit_base and IsOK ( survivor ) ) , woman_alive ) ;
1585: LD_EXP 34
1589: PUSH
1590: LD_EXP 6
1594: PPUSH
1595: CALL_OW 302
1599: AND
1600: PPUSH
1601: LD_STRING woman_alive
1603: PPUSH
1604: CALL_OW 39
// SaveVariable ( who_survive , woman_in_am14 ) ;
1608: LD_EXP 7
1612: PPUSH
1613: LD_STRING woman_in_am14
1615: PPUSH
1616: CALL_OW 39
// if not russians_eliminated then
1620: LD_LOC 1
1624: NOT
1625: IFFALSE 1651
// begin SaveVariable ( veh_jmm , veh_jmm ) ;
1627: LD_EXP 20
1631: PPUSH
1632: LD_STRING veh_jmm
1634: PPUSH
1635: CALL_OW 39
// SaveVariable ( veh_surv , veh_surv ) ;
1639: LD_EXP 21
1643: PPUSH
1644: LD_STRING veh_surv
1646: PPUSH
1647: CALL_OW 39
// end ; YouWin ;
1651: CALL_OW 103
// end ;
1655: LD_VAR 0 1
1659: RET
// function almost_done_macmillan ; var odpoved , vysledek , un ; begin
1660: LD_INT 0
1662: PPUSH
1663: PPUSH
1664: PPUSH
1665: PPUSH
// vysledek := true ;
1666: LD_ADDR_VAR 0 3
1670: PUSH
1671: LD_INT 1
1673: ST_TO_ADDR
// un := IsInUnit ( MacMillan ) ;
1674: LD_ADDR_VAR 0 4
1678: PUSH
1679: LD_EXP 1
1683: PPUSH
1684: CALL_OW 310
1688: ST_TO_ADDR
// if not IsOK ( survivor ) or ( IsInArea ( survivor , near_exit ) and IsInUnit ( survivor ) ) then
1689: LD_EXP 6
1693: PPUSH
1694: CALL_OW 302
1698: NOT
1699: PUSH
1700: LD_EXP 6
1704: PPUSH
1705: LD_INT 26
1707: PPUSH
1708: CALL_OW 308
1712: PUSH
1713: LD_EXP 6
1717: PPUSH
1718: CALL_OW 310
1722: AND
1723: OR
1724: IFFALSE 1807
// begin fastEscape = 1 ;
1726: LD_ADDR_EXP 22
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// SaveCharacters ( MacMillan , JMM ) ;
1734: LD_EXP 1
1738: PPUSH
1739: LD_STRING JMM
1741: PPUSH
1742: CALL_OW 38
// CheckSurvivorStatus ;
1746: CALL 2769 0 0
// veh_jmm := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
1750: LD_ADDR_EXP 20
1754: PUSH
1755: LD_VAR 0 4
1759: PPUSH
1760: CALL_OW 265
1764: PUSH
1765: LD_VAR 0 4
1769: PPUSH
1770: CALL_OW 262
1774: PUSH
1775: LD_VAR 0 4
1779: PPUSH
1780: CALL_OW 263
1784: PUSH
1785: LD_VAR 0 4
1789: PPUSH
1790: CALL_OW 264
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: ST_TO_ADDR
// konec_mise ;
1801: CALL 755 0 0
// end else
1805: GO 1885
// begin case who_survive of 1 :
1807: LD_EXP 7
1811: PUSH
1812: LD_INT 1
1814: DOUBLE
1815: EQUAL
1816: IFTRUE 1820
1818: GO 1836
1820: POP
// odpoved := Query ( Q3bJ ) ; 2 :
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: LD_STRING Q3bJ
1828: PPUSH
1829: CALL_OW 97
1833: ST_TO_ADDR
1834: GO 1885
1836: LD_INT 2
1838: DOUBLE
1839: EQUAL
1840: IFTRUE 1844
1842: GO 1860
1844: POP
// odpoved := Query ( Q3bL ) ; 3 :
1845: LD_ADDR_VAR 0 2
1849: PUSH
1850: LD_STRING Q3bL
1852: PPUSH
1853: CALL_OW 97
1857: ST_TO_ADDR
1858: GO 1885
1860: LD_INT 3
1862: DOUBLE
1863: EQUAL
1864: IFTRUE 1868
1866: GO 1884
1868: POP
// odpoved := Query ( Q3bX ) ; end ;
1869: LD_ADDR_VAR 0 2
1873: PUSH
1874: LD_STRING Q3bX
1876: PPUSH
1877: CALL_OW 97
1881: ST_TO_ADDR
1882: GO 1885
1884: POP
// end ; if odpoved = 1 then
1885: LD_VAR 0 2
1889: PUSH
1890: LD_INT 1
1892: EQUAL
1893: IFFALSE 1901
// konec_mise else
1895: CALL 755 0 0
1899: GO 1909
// vysledek := false ;
1901: LD_ADDR_VAR 0 3
1905: PUSH
1906: LD_INT 0
1908: ST_TO_ADDR
// result := vysledek ;
1909: LD_ADDR_VAR 0 1
1913: PUSH
1914: LD_VAR 0 3
1918: ST_TO_ADDR
// end ;
1919: LD_VAR 0 1
1923: RET
// function almost_done_survivor ; var odpoved , vysledek , un ; begin
1924: LD_INT 0
1926: PPUSH
1927: PPUSH
1928: PPUSH
1929: PPUSH
// odpoved := false ;
1930: LD_ADDR_VAR 0 2
1934: PUSH
1935: LD_INT 0
1937: ST_TO_ADDR
// vysledek := true ;
1938: LD_ADDR_VAR 0 3
1942: PUSH
1943: LD_INT 1
1945: ST_TO_ADDR
// un := IsInUnit ( survivor ) ;
1946: LD_ADDR_VAR 0 4
1950: PUSH
1951: LD_EXP 6
1955: PPUSH
1956: CALL_OW 310
1960: ST_TO_ADDR
// if IsOK ( MacMillan ) then
1961: LD_EXP 1
1965: PPUSH
1966: CALL_OW 302
1970: IFFALSE 1987
// odpoved := Query ( Q3b ) else
1972: LD_ADDR_VAR 0 2
1976: PUSH
1977: LD_STRING Q3b
1979: PPUSH
1980: CALL_OW 97
1984: ST_TO_ADDR
1985: GO 1995
// odpoved := true ;
1987: LD_ADDR_VAR 0 2
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// if odpoved then
1995: LD_VAR 0 2
1999: IFFALSE 2007
// begin CheckSurvivorStatus ;
2001: CALL 2769 0 0
// end else
2005: GO 2015
// vysledek := false ;
2007: LD_ADDR_VAR 0 3
2011: PUSH
2012: LD_INT 0
2014: ST_TO_ADDR
// result := vysledek ;
2015: LD_ADDR_VAR 0 1
2019: PUSH
2020: LD_VAR 0 3
2024: ST_TO_ADDR
// end ;
2025: LD_VAR 0 1
2029: RET
// every 0 0$2 trigger IsInArea ( MacMillan , exit_area ) do var odpoved ;
2030: LD_EXP 1
2034: PPUSH
2035: LD_INT 25
2037: PPUSH
2038: CALL_OW 308
2042: IFFALSE 2144
2044: GO 2046
2046: DISABLE
2047: LD_INT 0
2049: PPUSH
// begin if IsInUnit ( MacMillan ) then
2050: LD_EXP 1
2054: PPUSH
2055: CALL_OW 310
2059: IFFALSE 2103
// begin if not almost_done_macmillan then
2061: CALL 1660 0 0
2065: NOT
2066: IFFALSE 2101
// repeat wait ( 0 0$1 ) ;
2068: LD_INT 35
2070: PPUSH
2071: CALL_OW 67
// until not ( IsInArea ( MacMillan , exit_area ) and IsInUnit ( MacMillan ) ) ;
2075: LD_EXP 1
2079: PPUSH
2080: LD_INT 25
2082: PPUSH
2083: CALL_OW 308
2087: PUSH
2088: LD_EXP 1
2092: PPUSH
2093: CALL_OW 310
2097: AND
2098: NOT
2099: IFFALSE 2068
// end else
2101: GO 2143
// begin Query ( Q3a ) ;
2103: LD_STRING Q3a
2105: PPUSH
2106: CALL_OW 97
// repeat wait ( 0 0$1 ) ;
2110: LD_INT 35
2112: PPUSH
2113: CALL_OW 67
// until IsInUnit ( MacMillan ) or ( not IsInArea ( MacMillan , exit_area ) ) ;
2117: LD_EXP 1
2121: PPUSH
2122: CALL_OW 310
2126: PUSH
2127: LD_EXP 1
2131: PPUSH
2132: LD_INT 25
2134: PPUSH
2135: CALL_OW 308
2139: NOT
2140: OR
2141: IFFALSE 2110
// end ; enable ;
2143: ENABLE
// end ;
2144: PPOPN 1
2146: END
// every 0 0$2 trigger IsInArea ( survivor , exit_area ) do var odpoved , un ;
2147: LD_EXP 6
2151: PPUSH
2152: LD_INT 25
2154: PPUSH
2155: CALL_OW 308
2159: IFFALSE 2326
2161: GO 2163
2163: DISABLE
2164: LD_INT 0
2166: PPUSH
2167: PPUSH
// begin if IsInUnit ( survivor ) then
2168: LD_EXP 6
2172: PPUSH
2173: CALL_OW 310
2177: IFFALSE 2221
// begin if not almost_done_survivor then
2179: CALL 1924 0 0
2183: NOT
2184: IFFALSE 2219
// repeat wait ( 0 0$1 ) ;
2186: LD_INT 35
2188: PPUSH
2189: CALL_OW 67
// until not ( IsInArea ( survivor , exit_area ) and IsInUnit ( survivor ) ) ;
2193: LD_EXP 6
2197: PPUSH
2198: LD_INT 25
2200: PPUSH
2201: CALL_OW 308
2205: PUSH
2206: LD_EXP 6
2210: PPUSH
2211: CALL_OW 310
2215: AND
2216: NOT
2217: IFFALSE 2186
// end else
2219: GO 2314
// begin case who_survive of 1 :
2221: LD_EXP 7
2225: PUSH
2226: LD_INT 1
2228: DOUBLE
2229: EQUAL
2230: IFTRUE 2234
2232: GO 2244
2234: POP
// Query ( Q3aJ ) ; 2 :
2235: LD_STRING Q3aJ
2237: PPUSH
2238: CALL_OW 97
2242: GO 2281
2244: LD_INT 2
2246: DOUBLE
2247: EQUAL
2248: IFTRUE 2252
2250: GO 2262
2252: POP
// Query ( Q3aL ) ; 3 :
2253: LD_STRING Q3aL
2255: PPUSH
2256: CALL_OW 97
2260: GO 2281
2262: LD_INT 3
2264: DOUBLE
2265: EQUAL
2266: IFTRUE 2270
2268: GO 2280
2270: POP
// Query ( Q3aX ) ; end ;
2271: LD_STRING Q3aX
2273: PPUSH
2274: CALL_OW 97
2278: GO 2281
2280: POP
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until IsInUnit ( survivor ) or ( not IsInArea ( survivor , exit_area ) ) ;
2288: LD_EXP 6
2292: PPUSH
2293: CALL_OW 310
2297: PUSH
2298: LD_EXP 6
2302: PPUSH
2303: LD_INT 25
2305: PPUSH
2306: CALL_OW 308
2310: NOT
2311: OR
2312: IFFALSE 2281
// end ; if IsLive ( survivor ) then
2314: LD_EXP 6
2318: PPUSH
2319: CALL_OW 300
2323: IFFALSE 2326
// enable ;
2325: ENABLE
// end ;
2326: PPOPN 2
2328: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) do var vozidla , lide ;
2329: LD_INT 22
2331: PUSH
2332: LD_EXP 15
2336: PUSH
2337: EMPTY
2338: LIST
2339: LIST
2340: PUSH
2341: LD_INT 2
2343: PUSH
2344: LD_INT 30
2346: PUSH
2347: LD_INT 0
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: PUSH
2354: LD_INT 30
2356: PUSH
2357: LD_INT 1
2359: PUSH
2360: EMPTY
2361: LIST
2362: LIST
2363: PUSH
2364: EMPTY
2365: LIST
2366: LIST
2367: LIST
2368: PUSH
2369: EMPTY
2370: LIST
2371: LIST
2372: PPUSH
2373: CALL_OW 69
2377: NOT
2378: IFFALSE 2631
2380: GO 2382
2382: DISABLE
2383: LD_INT 0
2385: PPUSH
2386: PPUSH
// begin repeat vozidla := FilterAllUnits ( [ [ f_side , russians ] , [ [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] , [ f_ok ] ] ) ;
2387: LD_ADDR_VAR 0 1
2391: PUSH
2392: LD_INT 22
2394: PUSH
2395: LD_EXP 15
2399: PUSH
2400: EMPTY
2401: LIST
2402: LIST
2403: PUSH
2404: LD_INT 21
2406: PUSH
2407: LD_INT 2
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: PUSH
2414: LD_INT 33
2416: PUSH
2417: LD_INT 3
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: PUSH
2424: EMPTY
2425: LIST
2426: LIST
2427: PUSH
2428: LD_INT 50
2430: PUSH
2431: EMPTY
2432: LIST
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: LIST
2438: PPUSH
2439: CALL_OW 69
2443: ST_TO_ADDR
// lide := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_ok ] ] ) ;
2444: LD_ADDR_VAR 0 2
2448: PUSH
2449: LD_INT 22
2451: PUSH
2452: LD_EXP 15
2456: PUSH
2457: EMPTY
2458: LIST
2459: LIST
2460: PUSH
2461: LD_INT 21
2463: PUSH
2464: LD_INT 1
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 50
2473: PUSH
2474: EMPTY
2475: LIST
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: LIST
2481: PPUSH
2482: CALL_OW 69
2486: ST_TO_ADDR
// if not ( lide or vozidla ) then
2487: LD_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: OR
2497: NOT
2498: IFFALSE 2508
// russians_eliminated := true ;
2500: LD_ADDR_LOC 1
2504: PUSH
2505: LD_INT 1
2507: ST_TO_ADDR
// wait ( 0 0$1 ) ;
2508: LD_INT 35
2510: PPUSH
2511: CALL_OW 67
// until IsOk ( MacMillan ) and russians_eliminated ;
2515: LD_EXP 1
2519: PPUSH
2520: CALL_OW 302
2524: PUSH
2525: LD_LOC 1
2529: AND
2530: IFFALSE 2387
// DialogueOn ;
2532: CALL_OW 6
// Say ( MacMillan , DEnd-JMM-1 ) ;
2536: LD_EXP 1
2540: PPUSH
2541: LD_STRING DEnd-JMM-1
2543: PPUSH
2544: CALL_OW 88
// case who_survive of 1 :
2548: LD_EXP 7
2552: PUSH
2553: LD_INT 1
2555: DOUBLE
2556: EQUAL
2557: IFTRUE 2561
2559: GO 2576
2561: POP
// Say ( Joan , DEnd-Joan-1 ) ; 2 :
2562: LD_EXP 3
2566: PPUSH
2567: LD_STRING DEnd-Joan-1
2569: PPUSH
2570: CALL_OW 88
2574: GO 2623
2576: LD_INT 2
2578: DOUBLE
2579: EQUAL
2580: IFTRUE 2584
2582: GO 2599
2584: POP
// Say ( Lisa , DEnd-Lisa-1 ) ; 3 :
2585: LD_EXP 4
2589: PPUSH
2590: LD_STRING DEnd-Lisa-1
2592: PPUSH
2593: CALL_OW 88
2597: GO 2623
2599: LD_INT 3
2601: DOUBLE
2602: EQUAL
2603: IFTRUE 2607
2605: GO 2622
2607: POP
// Say ( Anezka , DEnd-Con-1 ) ; end ;
2608: LD_EXP 5
2612: PPUSH
2613: LD_STRING DEnd-Con-1
2615: PPUSH
2616: CALL_OW 88
2620: GO 2623
2622: POP
// DialogueOff ;
2623: CALL_OW 7
// konec_mise ;
2627: CALL 755 0 0
// end ;
2631: PPOPN 2
2633: END
// every 0 0$3 do var un , list ;
2634: GO 2636
2636: DISABLE
2637: LD_INT 0
2639: PPUSH
2640: PPUSH
// begin list := FilterAllUnits ( [ [ f_side , you ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
2641: LD_ADDR_VAR 0 2
2645: PUSH
2646: LD_INT 22
2648: PUSH
2649: LD_EXP 14
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: LD_INT 30
2663: PUSH
2664: LD_INT 32
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: PUSH
2671: LD_INT 30
2673: PUSH
2674: LD_INT 33
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: LIST
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PPUSH
2690: CALL_OW 69
2694: ST_TO_ADDR
// for un in list do
2695: LD_ADDR_VAR 0 1
2699: PUSH
2700: LD_VAR 0 2
2704: PUSH
2705: FOR_IN
2706: IFFALSE 2763
// if GetBWeapon ( un ) = us_double_laser then
2708: LD_VAR 0 1
2712: PPUSH
2713: CALL_OW 269
2717: PUSH
2718: LD_INT 10
2720: EQUAL
2721: IFFALSE 2761
// begin if not double_hint then
2723: LD_EXP 18
2727: NOT
2728: IFFALSE 2745
// begin Hint ( DoubleLaser ) ;
2730: LD_STRING DoubleLaser
2732: PPUSH
2733: CALL_OW 339
// double_hint := true ;
2737: LD_ADDR_EXP 18
2741: PUSH
2742: LD_INT 1
2744: ST_TO_ADDR
// end ; doublelasers_turrets := doublelasers_turrets union un ;
2745: LD_ADDR_LOC 2
2749: PUSH
2750: LD_LOC 2
2754: PUSH
2755: LD_VAR 0 1
2759: UNION
2760: ST_TO_ADDR
// end ;
2761: GO 2705
2763: POP
2764: POP
// enable ;
2765: ENABLE
// end ;
2766: PPOPN 2
2768: END
// export function CheckSurvivorStatus ; var un ; begin
2769: LD_INT 0
2771: PPUSH
2772: PPUSH
// if IsOK ( survivor ) then
2773: LD_EXP 6
2777: PPUSH
2778: CALL_OW 302
2782: IFFALSE 2915
// begin repeat un := IsInUnit ( survivor ) ;
2784: LD_ADDR_VAR 0 2
2788: PUSH
2789: LD_EXP 6
2793: PPUSH
2794: CALL_OW 310
2798: ST_TO_ADDR
// ComMoveXY ( survivor , 147 , 16 ) ;
2799: LD_EXP 6
2803: PPUSH
2804: LD_INT 147
2806: PPUSH
2807: LD_INT 16
2809: PPUSH
2810: CALL_OW 111
// wait ( 0 0$1 ) ;
2814: LD_INT 35
2816: PPUSH
2817: CALL_OW 67
// until IsInArea ( survivor , exit_area ) or IsInArea ( un , exit_area ) ;
2821: LD_EXP 6
2825: PPUSH
2826: LD_INT 25
2828: PPUSH
2829: CALL_OW 308
2833: PUSH
2834: LD_VAR 0 2
2838: PPUSH
2839: LD_INT 25
2841: PPUSH
2842: CALL_OW 308
2846: OR
2847: IFFALSE 2784
// un := IsInUnit ( survivor ) ;
2849: LD_ADDR_VAR 0 2
2853: PUSH
2854: LD_EXP 6
2858: PPUSH
2859: CALL_OW 310
2863: ST_TO_ADDR
// veh_surv := [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
2864: LD_ADDR_EXP 21
2868: PUSH
2869: LD_VAR 0 2
2873: PPUSH
2874: CALL_OW 265
2878: PUSH
2879: LD_VAR 0 2
2883: PPUSH
2884: CALL_OW 262
2888: PUSH
2889: LD_VAR 0 2
2893: PPUSH
2894: CALL_OW 263
2898: PUSH
2899: LD_VAR 0 2
2903: PPUSH
2904: CALL_OW 264
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: ST_TO_ADDR
// end ; end ; end_of_file
2915: LD_VAR 0 1
2919: RET
// export ru_ing , ru_sol , ru_sci , ru_mec ; export russians_forces ; export ru_collector ; export checking ; export reserved_people ; export function prepare_ru_base ; var un , i , num_sol , num_ing , num_sci , num_mec , lev ; begin
2920: LD_INT 0
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// RevealFogArea ( russians , ru_crates ) ;
2930: LD_EXP 15
2934: PPUSH
2935: LD_INT 10
2937: PPUSH
2938: CALL_OW 332
// num_ing := [ 1 , 2 , 2 ] [ difficulty ] ;
2942: LD_ADDR_VAR 0 5
2946: PUSH
2947: LD_INT 1
2949: PUSH
2950: LD_INT 2
2952: PUSH
2953: LD_INT 2
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: PUSH
2961: LD_OWVAR 67
2965: ARRAY
2966: ST_TO_ADDR
// num_sol := [ 2 , 2 , 3 ] [ difficulty ] ;
2967: LD_ADDR_VAR 0 4
2971: PUSH
2972: LD_INT 2
2974: PUSH
2975: LD_INT 2
2977: PUSH
2978: LD_INT 3
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: PUSH
2986: LD_OWVAR 67
2990: ARRAY
2991: ST_TO_ADDR
// num_sci := [ 1 , 3 , 6 ] [ difficulty ] ;
2992: LD_ADDR_VAR 0 6
2996: PUSH
2997: LD_INT 1
2999: PUSH
3000: LD_INT 3
3002: PUSH
3003: LD_INT 6
3005: PUSH
3006: EMPTY
3007: LIST
3008: LIST
3009: LIST
3010: PUSH
3011: LD_OWVAR 67
3015: ARRAY
3016: ST_TO_ADDR
// num_mec := [ 2 , 2 , 4 ] [ difficulty ] ;
3017: LD_ADDR_VAR 0 7
3021: PUSH
3022: LD_INT 2
3024: PUSH
3025: LD_INT 2
3027: PUSH
3028: LD_INT 4
3030: PUSH
3031: EMPTY
3032: LIST
3033: LIST
3034: LIST
3035: PUSH
3036: LD_OWVAR 67
3040: ARRAY
3041: ST_TO_ADDR
// lev := [ 6 , 8 , 10 ] [ difficulty ] ;
3042: LD_ADDR_VAR 0 8
3046: PUSH
3047: LD_INT 6
3049: PUSH
3050: LD_INT 8
3052: PUSH
3053: LD_INT 10
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: PUSH
3061: LD_OWVAR 67
3065: ARRAY
3066: ST_TO_ADDR
// russians_forces := [ ] ;
3067: LD_ADDR_EXP 28
3071: PUSH
3072: EMPTY
3073: ST_TO_ADDR
// ru_ing := [ ] ;
3074: LD_ADDR_EXP 24
3078: PUSH
3079: EMPTY
3080: ST_TO_ADDR
// ru_sol := [ ] ;
3081: LD_ADDR_EXP 25
3085: PUSH
3086: EMPTY
3087: ST_TO_ADDR
// ru_sci := [ ] ;
3088: LD_ADDR_EXP 26
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// ru_mec := [ ] ;
3095: LD_ADDR_EXP 27
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// reserved_people := [ ] ;
3102: LD_ADDR_EXP 31
3106: PUSH
3107: EMPTY
3108: ST_TO_ADDR
// uc_nation = nation_russian ;
3109: LD_ADDR_OWVAR 21
3113: PUSH
3114: LD_INT 3
3116: ST_TO_ADDR
// uc_side = russians ;
3117: LD_ADDR_OWVAR 20
3121: PUSH
3122: LD_EXP 15
3126: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
3127: LD_ADDR_OWVAR 24
3131: PUSH
3132: LD_INT 0
3134: PPUSH
3135: LD_INT 5
3137: PPUSH
3138: CALL_OW 12
3142: ST_TO_ADDR
// hc_gallery :=  ;
3143: LD_ADDR_OWVAR 33
3147: PUSH
3148: LD_STRING 
3150: ST_TO_ADDR
// hc_name :=  ;
3151: LD_ADDR_OWVAR 26
3155: PUSH
3156: LD_STRING 
3158: ST_TO_ADDR
// hc_importance := 0 ;
3159: LD_ADDR_OWVAR 32
3163: PUSH
3164: LD_INT 0
3166: ST_TO_ADDR
// for i := 1 to num_ing do
3167: LD_ADDR_VAR 0 3
3171: PUSH
3172: DOUBLE
3173: LD_INT 1
3175: DEC
3176: ST_TO_ADDR
3177: LD_VAR 0 5
3181: PUSH
3182: FOR_TO
3183: IFFALSE 3291
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3185: LD_ADDR_OWVAR 36
3189: PUSH
3190: LD_INT 2
3192: PPUSH
3193: LD_INT 5
3195: PPUSH
3196: CALL_OW 12
3200: ST_TO_ADDR
// PrepareEngineer ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3201: LD_INT 2
3203: PPUSH
3204: LD_INT 4
3206: PPUSH
3207: CALL_OW 12
3211: PUSH
3212: LD_INT 2
3214: MOD
3215: PUSH
3216: LD_INT 1
3218: PLUS
3219: PPUSH
3220: LD_VAR 0 8
3224: PUSH
3225: LD_INT 0
3227: PPUSH
3228: LD_INT 3
3230: PPUSH
3231: CALL_OW 12
3235: PLUS
3236: PPUSH
3237: CALL_OW 382
// un := CreateHuman ;
3241: LD_ADDR_VAR 0 2
3245: PUSH
3246: CALL_OW 44
3250: ST_TO_ADDR
// ru_ing := ru_ing ^ un ;
3251: LD_ADDR_EXP 24
3255: PUSH
3256: LD_EXP 24
3260: PUSH
3261: LD_VAR 0 2
3265: ADD
3266: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3267: LD_VAR 0 2
3271: PPUSH
3272: LD_INT 8
3274: PPUSH
3275: LD_INT 0
3277: PPUSH
3278: CALL_OW 49
// wait ( 1 ) ;
3282: LD_INT 1
3284: PPUSH
3285: CALL_OW 67
// end ;
3289: GO 3182
3291: POP
3292: POP
// for i := 1 to num_sol do
3293: LD_ADDR_VAR 0 3
3297: PUSH
3298: DOUBLE
3299: LD_INT 1
3301: DEC
3302: ST_TO_ADDR
3303: LD_VAR 0 4
3307: PUSH
3308: FOR_TO
3309: IFFALSE 3417
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3311: LD_ADDR_OWVAR 36
3315: PUSH
3316: LD_INT 2
3318: PPUSH
3319: LD_INT 5
3321: PPUSH
3322: CALL_OW 12
3326: ST_TO_ADDR
// PrepareSoldier ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3327: LD_INT 2
3329: PPUSH
3330: LD_INT 4
3332: PPUSH
3333: CALL_OW 12
3337: PUSH
3338: LD_INT 2
3340: MOD
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: LD_VAR 0 8
3350: PUSH
3351: LD_INT 0
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 12
3361: PLUS
3362: PPUSH
3363: CALL_OW 381
// un := CreateHuman ;
3367: LD_ADDR_VAR 0 2
3371: PUSH
3372: CALL_OW 44
3376: ST_TO_ADDR
// ru_sol := ru_sol ^ un ;
3377: LD_ADDR_EXP 25
3381: PUSH
3382: LD_EXP 25
3386: PUSH
3387: LD_VAR 0 2
3391: ADD
3392: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3393: LD_VAR 0 2
3397: PPUSH
3398: LD_INT 8
3400: PPUSH
3401: LD_INT 0
3403: PPUSH
3404: CALL_OW 49
// wait ( 1 ) ;
3408: LD_INT 1
3410: PPUSH
3411: CALL_OW 67
// end ;
3415: GO 3308
3417: POP
3418: POP
// for i := 1 to num_sci do
3419: LD_ADDR_VAR 0 3
3423: PUSH
3424: DOUBLE
3425: LD_INT 1
3427: DEC
3428: ST_TO_ADDR
3429: LD_VAR 0 6
3433: PUSH
3434: FOR_TO
3435: IFFALSE 3543
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3437: LD_ADDR_OWVAR 36
3441: PUSH
3442: LD_INT 2
3444: PPUSH
3445: LD_INT 5
3447: PPUSH
3448: CALL_OW 12
3452: ST_TO_ADDR
// PrepareScientist ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3453: LD_INT 2
3455: PPUSH
3456: LD_INT 4
3458: PPUSH
3459: CALL_OW 12
3463: PUSH
3464: LD_INT 2
3466: MOD
3467: PUSH
3468: LD_INT 1
3470: PLUS
3471: PPUSH
3472: LD_VAR 0 8
3476: PUSH
3477: LD_INT 0
3479: PPUSH
3480: LD_INT 3
3482: PPUSH
3483: CALL_OW 12
3487: PLUS
3488: PPUSH
3489: CALL_OW 384
// un := CreateHuman ;
3493: LD_ADDR_VAR 0 2
3497: PUSH
3498: CALL_OW 44
3502: ST_TO_ADDR
// ru_sci := ru_sci ^ un ;
3503: LD_ADDR_EXP 26
3507: PUSH
3508: LD_EXP 26
3512: PUSH
3513: LD_VAR 0 2
3517: ADD
3518: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3519: LD_VAR 0 2
3523: PPUSH
3524: LD_INT 8
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// wait ( 1 ) ;
3534: LD_INT 1
3536: PPUSH
3537: CALL_OW 67
// end ;
3541: GO 3434
3543: POP
3544: POP
// for i := 1 to num_mec do
3545: LD_ADDR_VAR 0 3
3549: PUSH
3550: DOUBLE
3551: LD_INT 1
3553: DEC
3554: ST_TO_ADDR
3555: LD_VAR 0 7
3559: PUSH
3560: FOR_TO
3561: IFFALSE 3669
// begin hc_last_mission := Rand ( 2 , 5 ) ;
3563: LD_ADDR_OWVAR 36
3567: PUSH
3568: LD_INT 2
3570: PPUSH
3571: LD_INT 5
3573: PPUSH
3574: CALL_OW 12
3578: ST_TO_ADDR
// PrepareMechanic ( ( Rand ( 2 , 4 ) mod 2 ) + 1 , lev + Rand ( 0 , 3 ) ) ;
3579: LD_INT 2
3581: PPUSH
3582: LD_INT 4
3584: PPUSH
3585: CALL_OW 12
3589: PUSH
3590: LD_INT 2
3592: MOD
3593: PUSH
3594: LD_INT 1
3596: PLUS
3597: PPUSH
3598: LD_VAR 0 8
3602: PUSH
3603: LD_INT 0
3605: PPUSH
3606: LD_INT 3
3608: PPUSH
3609: CALL_OW 12
3613: PLUS
3614: PPUSH
3615: CALL_OW 383
// un := CreateHuman ;
3619: LD_ADDR_VAR 0 2
3623: PUSH
3624: CALL_OW 44
3628: ST_TO_ADDR
// ru_mec := ru_mec ^ un ;
3629: LD_ADDR_EXP 27
3633: PUSH
3634: LD_EXP 27
3638: PUSH
3639: LD_VAR 0 2
3643: ADD
3644: ST_TO_ADDR
// PlaceUnitArea ( un , russians_start , false ) ;
3645: LD_VAR 0 2
3649: PPUSH
3650: LD_INT 8
3652: PPUSH
3653: LD_INT 0
3655: PPUSH
3656: CALL_OW 49
// wait ( 1 ) ;
3660: LD_INT 1
3662: PPUSH
3663: CALL_OW 67
// end ;
3667: GO 3560
3669: POP
3670: POP
// russians_forces := ru_ing ^ ru_sol ^ ru_sci ^ ru_mec ;
3671: LD_ADDR_EXP 28
3675: PUSH
3676: LD_EXP 24
3680: PUSH
3681: LD_EXP 25
3685: ADD
3686: PUSH
3687: LD_EXP 26
3691: ADD
3692: PUSH
3693: LD_EXP 27
3697: ADD
3698: ST_TO_ADDR
// i := 1 ;
3699: LD_ADDR_VAR 0 3
3703: PUSH
3704: LD_INT 1
3706: ST_TO_ADDR
// for un in ru_mec do
3707: LD_ADDR_VAR 0 2
3711: PUSH
3712: LD_EXP 27
3716: PUSH
3717: FOR_IN
3718: IFFALSE 3783
// begin if ( i mod 2 ) = 0 then
3720: LD_VAR 0 3
3724: PUSH
3725: LD_INT 2
3727: MOD
3728: PUSH
3729: LD_INT 0
3731: EQUAL
3732: IFFALSE 3748
// ComEnterUnit ( un , ru_fact2 ) else
3734: LD_VAR 0 2
3738: PPUSH
3739: LD_INT 40
3741: PPUSH
3742: CALL_OW 120
3746: GO 3760
// ComEnterUnit ( un , ru_fact1 ) ;
3748: LD_VAR 0 2
3752: PPUSH
3753: LD_INT 1
3755: PPUSH
3756: CALL_OW 120
// i := i + 1 ;
3760: LD_ADDR_VAR 0 3
3764: PUSH
3765: LD_VAR 0 3
3769: PUSH
3770: LD_INT 1
3772: PLUS
3773: ST_TO_ADDR
// wait ( 1 ) ;
3774: LD_INT 1
3776: PPUSH
3777: CALL_OW 67
// end ;
3781: GO 3717
3783: POP
3784: POP
// for un in ru_sci do
3785: LD_ADDR_VAR 0 2
3789: PUSH
3790: LD_EXP 26
3794: PUSH
3795: FOR_IN
3796: IFFALSE 3847
// begin if ( un mod 2 ) = 0 then
3798: LD_VAR 0 2
3802: PUSH
3803: LD_INT 2
3805: MOD
3806: PUSH
3807: LD_INT 0
3809: EQUAL
3810: IFFALSE 3826
// ComEnterUnit ( un , ru_lab1 ) else
3812: LD_VAR 0 2
3816: PPUSH
3817: LD_INT 14
3819: PPUSH
3820: CALL_OW 120
3824: GO 3838
// ComEnterunit ( un , ru_lab2 ) ;
3826: LD_VAR 0 2
3830: PPUSH
3831: LD_INT 15
3833: PPUSH
3834: CALL_OW 120
// wait ( 1 ) ;
3838: LD_INT 1
3840: PPUSH
3841: CALL_OW 67
// end ;
3845: GO 3795
3847: POP
3848: POP
// uc_direction := Rand ( 0 , 5 ) ;
3849: LD_ADDR_OWVAR 24
3853: PUSH
3854: LD_INT 0
3856: PPUSH
3857: LD_INT 5
3859: PPUSH
3860: CALL_OW 12
3864: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
3865: LD_ADDR_OWVAR 37
3869: PUSH
3870: LD_INT 21
3872: ST_TO_ADDR
// vc_control := control_manual ;
3873: LD_ADDR_OWVAR 38
3877: PUSH
3878: LD_INT 1
3880: ST_TO_ADDR
// vc_engine := engine_combustion ;
3881: LD_ADDR_OWVAR 39
3885: PUSH
3886: LD_INT 1
3888: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
3889: LD_ADDR_OWVAR 40
3893: PUSH
3894: LD_INT 51
3896: ST_TO_ADDR
// ru_collector := CreateVehicle ;
3897: LD_ADDR_EXP 29
3901: PUSH
3902: CALL_OW 45
3906: ST_TO_ADDR
// PlaceUnitXYR ( ru_collector , ShiftX ( GetX ( ru_depot ) , 4 , 5 ) , GetY ( ru_depot ) , 5 , false ) ;
3907: LD_EXP 29
3911: PPUSH
3912: LD_INT 22
3914: PPUSH
3915: CALL_OW 250
3919: PPUSH
3920: LD_INT 4
3922: PPUSH
3923: LD_INT 5
3925: PPUSH
3926: CALL_OW 272
3930: PPUSH
3931: LD_INT 22
3933: PPUSH
3934: CALL_OW 251
3938: PPUSH
3939: LD_INT 5
3941: PPUSH
3942: LD_INT 0
3944: PPUSH
3945: CALL_OW 50
// end ;
3949: LD_VAR 0 1
3953: RET
// export crate_list ; every 0 0$5 trigger GetListOfCratesInArea ( ru_crates ) do var un , free_unit , x , y , max , i , clear_crates , old_class , attempt ;
3954: LD_INT 10
3956: PPUSH
3957: CALL_OW 435
3961: IFFALSE 4809
3963: GO 3965
3965: DISABLE
3966: LD_INT 0
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
3973: PPUSH
3974: PPUSH
3975: PPUSH
3976: PPUSH
// begin crate_list := GetListOfCratesInArea ( ru_crates ) ;
3977: LD_ADDR_EXP 32
3981: PUSH
3982: LD_INT 10
3984: PPUSH
3985: CALL_OW 435
3989: ST_TO_ADDR
// free_unit := false ;
3990: LD_ADDR_VAR 0 2
3994: PUSH
3995: LD_INT 0
3997: ST_TO_ADDR
// i := russians_forces diff reserved_people ;
3998: LD_ADDR_VAR 0 6
4002: PUSH
4003: LD_EXP 28
4007: PUSH
4008: LD_EXP 31
4012: DIFF
4013: ST_TO_ADDR
// for un in i do
4014: LD_ADDR_VAR 0 1
4018: PUSH
4019: LD_VAR 0 6
4023: PUSH
4024: FOR_IN
4025: IFFALSE 4064
// begin if not ( HasTask ( un ) or GetUnitMc ( un ) ) then
4027: LD_VAR 0 1
4031: PPUSH
4032: CALL_OW 314
4036: PUSH
4037: LD_VAR 0 1
4041: PPUSH
4042: CALL_OW 388
4046: OR
4047: NOT
4048: IFFALSE 4062
// begin free_unit := un ;
4050: LD_ADDR_VAR 0 2
4054: PUSH
4055: LD_VAR 0 1
4059: ST_TO_ADDR
// break ;
4060: GO 4064
// end ; end ;
4062: GO 4024
4064: POP
4065: POP
// if free_unit and IsOK ( free_unit ) then
4066: LD_VAR 0 2
4070: PUSH
4071: LD_VAR 0 2
4075: PPUSH
4076: CALL_OW 302
4080: AND
4081: IFFALSE 4808
// begin reserved_people := reserved_people ^ free_unit ;
4083: LD_ADDR_EXP 31
4087: PUSH
4088: LD_EXP 31
4092: PUSH
4093: LD_VAR 0 2
4097: ADD
4098: ST_TO_ADDR
// ComRemember ( free_unit ) ;
4099: LD_VAR 0 2
4103: PPUSH
4104: CALL_OW 143
// if IsLive ( ru_collector ) then
4108: LD_EXP 29
4112: PPUSH
4113: CALL_OW 300
4117: IFFALSE 4263
// begin repeat ComEnterUnit ( free_unit , ru_collector ) ;
4119: LD_VAR 0 2
4123: PPUSH
4124: LD_EXP 29
4128: PPUSH
4129: CALL_OW 120
// wait ( 0 0$1 ) ;
4133: LD_INT 35
4135: PPUSH
4136: CALL_OW 67
// until ( IsInUnit ( free_unit ) ) or not IsLive ( ru_collector ) ;
4140: LD_VAR 0 2
4144: PPUSH
4145: CALL_OW 310
4149: PUSH
4150: LD_EXP 29
4154: PPUSH
4155: CALL_OW 300
4159: NOT
4160: OR
4161: IFFALSE 4119
// if not IsLive ( ru_collector ) then
4163: LD_EXP 29
4167: PPUSH
4168: CALL_OW 300
4172: NOT
4173: IFFALSE 4251
// begin un := free_unit ;
4175: LD_ADDR_VAR 0 1
4179: PUSH
4180: LD_VAR 0 2
4184: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4185: LD_ADDR_VAR 0 8
4189: PUSH
4190: LD_VAR 0 1
4194: PPUSH
4195: CALL_OW 257
4199: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4200: LD_VAR 0 1
4204: PPUSH
4205: CALL_OW 257
4209: PUSH
4210: LD_INT 2
4212: EQUAL
4213: NOT
4214: IFFALSE 4249
// begin ComEnterUnit ( un , ru_depot ) ;
4216: LD_VAR 0 1
4220: PPUSH
4221: LD_INT 22
4223: PPUSH
4224: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4228: LD_VAR 0 1
4232: PPUSH
4233: LD_INT 2
4235: PPUSH
4236: CALL_OW 183
// wait ( 0 0$1 ) ;
4240: LD_INT 35
4242: PPUSH
4243: CALL_OW 67
// end ;
4247: GO 4200
// end else
4249: GO 4261
// un := ru_collector ;
4251: LD_ADDR_VAR 0 1
4255: PUSH
4256: LD_EXP 29
4260: ST_TO_ADDR
// end else
4261: GO 4337
// begin un := free_unit ;
4263: LD_ADDR_VAR 0 1
4267: PUSH
4268: LD_VAR 0 2
4272: ST_TO_ADDR
// old_class := GetClass ( un ) ;
4273: LD_ADDR_VAR 0 8
4277: PUSH
4278: LD_VAR 0 1
4282: PPUSH
4283: CALL_OW 257
4287: ST_TO_ADDR
// while not ( GetClass ( un ) = class_engineer ) do
4288: LD_VAR 0 1
4292: PPUSH
4293: CALL_OW 257
4297: PUSH
4298: LD_INT 2
4300: EQUAL
4301: NOT
4302: IFFALSE 4337
// begin ComEnterUnit ( un , ru_depot ) ;
4304: LD_VAR 0 1
4308: PPUSH
4309: LD_INT 22
4311: PPUSH
4312: CALL_OW 120
// AddComChangeProfession ( un , class_engineer ) ;
4316: LD_VAR 0 1
4320: PPUSH
4321: LD_INT 2
4323: PPUSH
4324: CALL_OW 183
// wait ( 0 0$1 ) ;
4328: LD_INT 35
4330: PPUSH
4331: CALL_OW 67
// end ;
4335: GO 4288
// end ; if IsLive ( ru_collector ) then
4337: LD_EXP 29
4341: PPUSH
4342: CALL_OW 300
4346: IFFALSE 4377
// ComCollect ( un , crate_list [ 1 ] , crate_list [ 2 ] ) else
4348: LD_VAR 0 1
4352: PPUSH
4353: LD_EXP 32
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: LD_EXP 32
4366: PUSH
4367: LD_INT 2
4369: ARRAY
4370: PPUSH
4371: CALL_OW 117
4375: GO 4404
// ComGet ( un , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4377: LD_VAR 0 1
4381: PPUSH
4382: LD_EXP 32
4386: PUSH
4387: LD_INT 1
4389: ARRAY
4390: PPUSH
4391: LD_EXP 32
4395: PUSH
4396: LD_INT 2
4398: ARRAY
4399: PPUSH
4400: CALL_OW 160
// clear_crates := false ;
4404: LD_ADDR_VAR 0 7
4408: PUSH
4409: LD_INT 0
4411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4412: LD_INT 35
4414: PPUSH
4415: CALL_OW 67
// if IsLive ( ru_collector ) and GetFuel ( un ) < 25 then
4419: LD_EXP 29
4423: PPUSH
4424: CALL_OW 300
4428: PUSH
4429: LD_VAR 0 1
4433: PPUSH
4434: CALL_OW 261
4438: PUSH
4439: LD_INT 25
4441: LESS
4442: AND
4443: IFFALSE 4536
// begin clear_crates := true ;
4445: LD_ADDR_VAR 0 7
4449: PUSH
4450: LD_INT 1
4452: ST_TO_ADDR
// if not SeeXY ( you , crate_list [ 1 ] , crate_list [ 2 ] ) then
4453: LD_EXP 14
4457: PPUSH
4458: LD_EXP 32
4462: PUSH
4463: LD_INT 1
4465: ARRAY
4466: PPUSH
4467: LD_EXP 32
4471: PUSH
4472: LD_INT 2
4474: ARRAY
4475: PPUSH
4476: CALL_OW 293
4480: NOT
4481: IFFALSE 4536
// begin MoveAreaXY ( crates_end , crate_list [ 1 ] , crate_list [ 2 ] ) ;
4483: LD_INT 34
4485: PPUSH
4486: LD_EXP 32
4490: PUSH
4491: LD_INT 1
4493: ARRAY
4494: PPUSH
4495: LD_EXP 32
4499: PUSH
4500: LD_INT 2
4502: ARRAY
4503: PPUSH
4504: CALL_OW 425
// EraseResourceArea ( crates_end , mat_cans ) ;
4508: LD_INT 34
4510: PPUSH
4511: LD_INT 1
4513: PPUSH
4514: CALL_OW 286
// AddResourceType ( GetBase ( ru_depot ) , mat_cans , 50 ) ;
4518: LD_INT 22
4520: PPUSH
4521: CALL_OW 274
4525: PPUSH
4526: LD_INT 1
4528: PPUSH
4529: LD_INT 50
4531: PPUSH
4532: CALL_OW 276
// end ; end ; until ( not IsBusy ( un ) ) or clear_crates ;
4536: LD_VAR 0 1
4540: PPUSH
4541: CALL_OW 315
4545: NOT
4546: PUSH
4547: LD_VAR 0 7
4551: OR
4552: IFFALSE 4412
// if IsLive ( ru_collector ) then
4554: LD_EXP 29
4558: PPUSH
4559: CALL_OW 300
4563: IFFALSE 4597
// begin ComMoveUnit ( ru_collector , ru_depot ) ;
4565: LD_EXP 29
4569: PPUSH
4570: LD_INT 22
4572: PPUSH
4573: CALL_OW 112
// AddComExitVehicle ( ru_collector ) ;
4577: LD_EXP 29
4581: PPUSH
4582: CALL_OW 181
// ComReturn ( free_unit ) ;
4586: LD_VAR 0 2
4590: PPUSH
4591: CALL_OW 144
// end else
4595: GO 4792
// begin case old_class of class_mechanic :
4597: LD_VAR 0 8
4601: PUSH
4602: LD_INT 3
4604: DOUBLE
4605: EQUAL
4606: IFTRUE 4610
4608: GO 4662
4610: POP
// begin if IsOK ( ru_fact1 ) then
4611: LD_INT 1
4613: PPUSH
4614: CALL_OW 302
4618: IFFALSE 4634
// ComEnterUnit ( un , ru_fact1 ) else
4620: LD_VAR 0 1
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: CALL_OW 120
4632: GO 4646
// ComEnterUnit ( un , ru_fact2 ) ;
4634: LD_VAR 0 1
4638: PPUSH
4639: LD_INT 40
4641: PPUSH
4642: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4646: LD_VAR 0 1
4650: PPUSH
4651: LD_VAR 0 8
4655: PPUSH
4656: CALL_OW 183
// end ; class_scientistic :
4660: GO 4783
4662: LD_INT 4
4664: DOUBLE
4665: EQUAL
4666: IFTRUE 4670
4668: GO 4722
4670: POP
// begin if IsOK ( ru_lab1 ) then
4671: LD_INT 14
4673: PPUSH
4674: CALL_OW 302
4678: IFFALSE 4694
// ComEnterUnit ( un , ru_lab1 ) else
4680: LD_VAR 0 1
4684: PPUSH
4685: LD_INT 14
4687: PPUSH
4688: CALL_OW 120
4692: GO 4706
// ComEnterUnit ( un , ru_lab2 ) ;
4694: LD_VAR 0 1
4698: PPUSH
4699: LD_INT 15
4701: PPUSH
4702: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4706: LD_VAR 0 1
4710: PPUSH
4711: LD_VAR 0 8
4715: PPUSH
4716: CALL_OW 183
// end ; class_soldier :
4720: GO 4783
4722: LD_INT 1
4724: DOUBLE
4725: EQUAL
4726: IFTRUE 4730
4728: GO 4759
4730: POP
// begin ComEnterUnit ( un , ru_barac ) ;
4731: LD_VAR 0 1
4735: PPUSH
4736: LD_INT 45
4738: PPUSH
4739: CALL_OW 120
// AddComChangeProfession ( un , old_class ) ;
4743: LD_VAR 0 1
4747: PPUSH
4748: LD_VAR 0 8
4752: PPUSH
4753: CALL_OW 183
// end ; class_engineer :
4757: GO 4783
4759: LD_INT 2
4761: DOUBLE
4762: EQUAL
4763: IFTRUE 4767
4765: GO 4782
4767: POP
// ComMoveUnit ( un , ru_depot ) ; end ;
4768: LD_VAR 0 1
4772: PPUSH
4773: LD_INT 22
4775: PPUSH
4776: CALL_OW 112
4780: GO 4783
4782: POP
// AddComReturn ( un ) ;
4783: LD_VAR 0 1
4787: PPUSH
4788: CALL_OW 204
// end ; reserved_people := reserved_people diff free_unit ;
4792: LD_ADDR_EXP 31
4796: PUSH
4797: LD_EXP 31
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// end ; enable ;
4808: ENABLE
// end ;
4809: PPOPN 9
4811: END
// function ukradni_macmillanovi_auto ; var un ; begin
4812: LD_INT 0
4814: PPUSH
4815: PPUSH
// for un in ru_sol do
4816: LD_ADDR_VAR 0 2
4820: PUSH
4821: LD_EXP 25
4825: PUSH
4826: FOR_IN
4827: IFFALSE 4856
// if IsOK ( un ) then
4829: LD_VAR 0 2
4833: PPUSH
4834: CALL_OW 302
4838: IFFALSE 4854
// ComEnterUnit ( un , truck1 ) ;
4840: LD_VAR 0 2
4844: PPUSH
4845: LD_EXP 8
4849: PPUSH
4850: CALL_OW 120
4854: GO 4826
4856: POP
4857: POP
// AddComAgressiveMove ( ru_sol , 69 , 35 ) ;
4858: LD_EXP 25
4862: PPUSH
4863: LD_INT 69
4865: PPUSH
4866: LD_INT 35
4868: PPUSH
4869: CALL_OW 174
// AddComReturn ( ru_sol ) ;
4873: LD_EXP 25
4877: PPUSH
4878: CALL_OW 204
// wait ( 0 0$20 ) ;
4882: LD_INT 700
4884: PPUSH
4885: CALL_OW 67
// end ;
4889: LD_VAR 0 1
4893: RET
// every 6 6$0 do var way_ru_patrol , x , y , i , max ;
4894: GO 4896
4896: DISABLE
4897: LD_INT 0
4899: PPUSH
4900: PPUSH
4901: PPUSH
4902: PPUSH
4903: PPUSH
// begin way_ru_patrol := [ 88 , 47 , 69 , 36 , 42 , 16 , 33 , 14 , 16 , 6 , 6 , 6 , 19 , 29 , 34 , 38 , 47 , 42 , 44 , 27 , 61 , 45 , 66 , 33 , 110 , 58 ] ;
4904: LD_ADDR_VAR 0 1
4908: PUSH
4909: LD_INT 88
4911: PUSH
4912: LD_INT 47
4914: PUSH
4915: LD_INT 69
4917: PUSH
4918: LD_INT 36
4920: PUSH
4921: LD_INT 42
4923: PUSH
4924: LD_INT 16
4926: PUSH
4927: LD_INT 33
4929: PUSH
4930: LD_INT 14
4932: PUSH
4933: LD_INT 16
4935: PUSH
4936: LD_INT 6
4938: PUSH
4939: LD_INT 6
4941: PUSH
4942: LD_INT 6
4944: PUSH
4945: LD_INT 19
4947: PUSH
4948: LD_INT 29
4950: PUSH
4951: LD_INT 34
4953: PUSH
4954: LD_INT 38
4956: PUSH
4957: LD_INT 47
4959: PUSH
4960: LD_INT 42
4962: PUSH
4963: LD_INT 44
4965: PUSH
4966: LD_INT 27
4968: PUSH
4969: LD_INT 61
4971: PUSH
4972: LD_INT 45
4974: PUSH
4975: LD_INT 66
4977: PUSH
4978: LD_INT 33
4980: PUSH
4981: LD_INT 110
4983: PUSH
4984: LD_INT 58
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: ST_TO_ADDR
// ComRemember ( ru_sol ) ;
5015: LD_EXP 25
5019: PPUSH
5020: CALL_OW 143
// reserved_people := reserved_people ^ ru_sol ;
5024: LD_ADDR_EXP 31
5028: PUSH
5029: LD_EXP 31
5033: PUSH
5034: LD_EXP 25
5038: ADD
5039: ST_TO_ADDR
// max := 0 + way_ru_patrol ;
5040: LD_ADDR_VAR 0 5
5044: PUSH
5045: LD_INT 0
5047: PUSH
5048: LD_VAR 0 1
5052: PLUS
5053: ST_TO_ADDR
// for i := 1 to ( max div 2 ) do
5054: LD_ADDR_VAR 0 4
5058: PUSH
5059: DOUBLE
5060: LD_INT 1
5062: DEC
5063: ST_TO_ADDR
5064: LD_VAR 0 5
5068: PUSH
5069: LD_INT 2
5071: DIV
5072: PUSH
5073: FOR_TO
5074: IFFALSE 5141
// begin x := way_ru_patrol [ ( 2 * i ) - 1 ] ;
5076: LD_ADDR_VAR 0 2
5080: PUSH
5081: LD_VAR 0 1
5085: PUSH
5086: LD_INT 2
5088: PUSH
5089: LD_VAR 0 4
5093: MUL
5094: PUSH
5095: LD_INT 1
5097: MINUS
5098: ARRAY
5099: ST_TO_ADDR
// y := way_ru_patrol [ ( 2 * i ) ] ;
5100: LD_ADDR_VAR 0 3
5104: PUSH
5105: LD_VAR 0 1
5109: PUSH
5110: LD_INT 2
5112: PUSH
5113: LD_VAR 0 4
5117: MUL
5118: ARRAY
5119: ST_TO_ADDR
// AddComAgressiveMove ( ru_sol , x , y ) ;
5120: LD_EXP 25
5124: PPUSH
5125: LD_VAR 0 2
5129: PPUSH
5130: LD_VAR 0 3
5134: PPUSH
5135: CALL_OW 174
// end ;
5139: GO 5073
5141: POP
5142: POP
// repeat if See ( russians , truck1 ) then
5143: LD_EXP 15
5147: PPUSH
5148: LD_EXP 8
5152: PPUSH
5153: CALL_OW 292
5157: IFFALSE 5163
// ukradni_macmillanovi_auto ;
5159: CALL 4812 0 0
// wait ( 0 0$1 ) ;
5163: LD_INT 35
5165: PPUSH
5166: CALL_OW 67
// until at_home ( ru_sol ) ;
5170: LD_EXP 25
5174: PPUSH
5175: CALL 5200 0 1
5179: IFFALSE 5143
// reserved_people := reserved_people diff ru_sol ;
5181: LD_ADDR_EXP 31
5185: PUSH
5186: LD_EXP 31
5190: PUSH
5191: LD_EXP 25
5195: DIFF
5196: ST_TO_ADDR
// end ;
5197: PPOPN 5
5199: END
// function at_home ( list ) ; var un , vysledek ; begin
5200: LD_INT 0
5202: PPUSH
5203: PPUSH
5204: PPUSH
// vysledek := true ;
5205: LD_ADDR_VAR 0 4
5209: PUSH
5210: LD_INT 1
5212: ST_TO_ADDR
// for un in list do
5213: LD_ADDR_VAR 0 3
5217: PUSH
5218: LD_VAR 0 1
5222: PUSH
5223: FOR_IN
5224: IFFALSE 5264
// if IsOK ( un ) and not IsInArea ( un , RU_Base ) then
5226: LD_VAR 0 3
5230: PPUSH
5231: CALL_OW 302
5235: PUSH
5236: LD_VAR 0 3
5240: PPUSH
5241: LD_INT 2
5243: PPUSH
5244: CALL_OW 308
5248: NOT
5249: AND
5250: IFFALSE 5262
// begin vysledek := false ;
5252: LD_ADDR_VAR 0 4
5256: PUSH
5257: LD_INT 0
5259: ST_TO_ADDR
// break ;
5260: GO 5264
// end ;
5262: GO 5223
5264: POP
5265: POP
// result := vysledek ;
5266: LD_ADDR_VAR 0 2
5270: PUSH
5271: LD_VAR 0 4
5275: ST_TO_ADDR
// end ; end_of_file
5276: LD_VAR 0 2
5280: RET
// export odpoved ; export visit_base ; var dialogue_running ; export function starting_scene ; var x , y ; begin
5281: LD_INT 0
5283: PPUSH
5284: PPUSH
5285: PPUSH
// CenterNowOnUnits ( truck1 ) ;
5286: LD_EXP 8
5290: PPUSH
5291: CALL_OW 87
// interface_hidden := true ;
5295: LD_ADDR_OWVAR 54
5299: PUSH
5300: LD_INT 1
5302: ST_TO_ADDR
// InGameOn ;
5303: CALL_OW 8
// ComMoveXY ( truck1 , 20 , 7 ) ;
5307: LD_EXP 8
5311: PPUSH
5312: LD_INT 20
5314: PPUSH
5315: LD_INT 7
5317: PPUSH
5318: CALL_OW 111
// AddComMoveXY ( truck1 , 27 , 10 ) ;
5322: LD_EXP 8
5326: PPUSH
5327: LD_INT 27
5329: PPUSH
5330: LD_INT 10
5332: PPUSH
5333: CALL_OW 171
// AddComMoveXY ( truck1 , 37 , 16 ) ;
5337: LD_EXP 8
5341: PPUSH
5342: LD_INT 37
5344: PPUSH
5345: LD_INT 16
5347: PPUSH
5348: CALL_OW 171
// wait ( 0 0$3 ) ;
5352: LD_INT 105
5354: PPUSH
5355: CALL_OW 67
// async ;
5359: ASYNC
// SayRadio ( Powell , D1-Pow-1 ) ;
5360: LD_EXP 2
5364: PPUSH
5365: LD_STRING D1-Pow-1
5367: PPUSH
5368: CALL_OW 94
// sync ;
5372: SYNC
// wait ( 0 0$2 ) ;
5373: LD_INT 70
5375: PPUSH
5376: CALL_OW 67
// ComStop ( MacMillan ) ;
5380: LD_EXP 1
5384: PPUSH
5385: CALL_OW 141
// ComExitVehicle ( truck1 ) ;
5389: LD_EXP 8
5393: PPUSH
5394: CALL_OW 121
// x := GetX ( MacMillan ) + 10 ;
5398: LD_ADDR_VAR 0 2
5402: PUSH
5403: LD_EXP 1
5407: PPUSH
5408: CALL_OW 250
5412: PUSH
5413: LD_INT 10
5415: PLUS
5416: ST_TO_ADDR
// y := GetY ( MacMillan ) + 10 ;
5417: LD_ADDR_VAR 0 3
5421: PUSH
5422: LD_EXP 1
5426: PPUSH
5427: CALL_OW 251
5431: PUSH
5432: LD_INT 10
5434: PLUS
5435: ST_TO_ADDR
// ComMoveXY ( MacMillan , x , y ) ;
5436: LD_EXP 1
5440: PPUSH
5441: LD_VAR 0 2
5445: PPUSH
5446: LD_VAR 0 3
5450: PPUSH
5451: CALL_OW 111
// wait ( 0 0$2 ) ;
5455: LD_INT 70
5457: PPUSH
5458: CALL_OW 67
// InGameOff ;
5462: CALL_OW 9
// DialogueOn ;
5466: CALL_OW 6
// interface_hidden := true ;
5470: LD_ADDR_OWVAR 54
5474: PUSH
5475: LD_INT 1
5477: ST_TO_ADDR
// Say ( MacMillan , D1-JMM-1 ) ;
5478: LD_EXP 1
5482: PPUSH
5483: LD_STRING D1-JMM-1
5485: PPUSH
5486: CALL_OW 88
// SayRadio ( Powell , D1-Pow-2 ) ;
5490: LD_EXP 2
5494: PPUSH
5495: LD_STRING D1-Pow-2
5497: PPUSH
5498: CALL_OW 94
// Say ( MacMillan , D1-JMM-2 ) ;
5502: LD_EXP 1
5506: PPUSH
5507: LD_STRING D1-JMM-2
5509: PPUSH
5510: CALL_OW 88
// SaveForQuickRestart ;
5514: CALL_OW 22
// wait ( 0 0$0.5 ) ;
5518: LD_INT 18
5520: PPUSH
5521: CALL_OW 67
// ChangeMissionObjectives ( M1 ) ;
5525: LD_STRING M1
5527: PPUSH
5528: CALL_OW 337
// DialogueOff ;
5532: CALL_OW 7
// interface_hidden := false ;
5536: LD_ADDR_OWVAR 54
5540: PUSH
5541: LD_INT 0
5543: ST_TO_ADDR
// dialogue_running := false ;
5544: LD_ADDR_LOC 3
5548: PUSH
5549: LD_INT 0
5551: ST_TO_ADDR
// end ;
5552: LD_VAR 0 1
5556: RET
// function odpoved_joan ; begin
5557: LD_INT 0
5559: PPUSH
// case odpoved of 1 :
5560: LD_EXP 33
5564: PUSH
5565: LD_INT 1
5567: DOUBLE
5568: EQUAL
5569: IFTRUE 5573
5571: GO 5612
5573: POP
// begin Say ( MacMillan , D2Ja-JMM-1 ) ;
5574: LD_EXP 1
5578: PPUSH
5579: LD_STRING D2Ja-JMM-1
5581: PPUSH
5582: CALL_OW 88
// SayRadio ( Joan , D2Ja-Joan-1 ) ;
5586: LD_EXP 3
5590: PPUSH
5591: LD_STRING D2Ja-Joan-1
5593: PPUSH
5594: CALL_OW 94
// Say ( MacMillan , D2Ja-JMM-2 ) ;
5598: LD_EXP 1
5602: PPUSH
5603: LD_STRING D2Ja-JMM-2
5605: PPUSH
5606: CALL_OW 88
// end ; 2 :
5610: GO 5707
5612: LD_INT 2
5614: DOUBLE
5615: EQUAL
5616: IFTRUE 5620
5618: GO 5683
5620: POP
// begin Say ( MacMillan , D2Jb-JMM-1 ) ;
5621: LD_EXP 1
5625: PPUSH
5626: LD_STRING D2Jb-JMM-1
5628: PPUSH
5629: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-1 ) ;
5633: LD_EXP 3
5637: PPUSH
5638: LD_STRING D2Jb-Joan-1
5640: PPUSH
5641: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-2 ) ;
5645: LD_EXP 1
5649: PPUSH
5650: LD_STRING D2Jb-JMM-2
5652: PPUSH
5653: CALL_OW 88
// SayRadio ( Joan , D2Jb-Joan-2 ) ;
5657: LD_EXP 3
5661: PPUSH
5662: LD_STRING D2Jb-Joan-2
5664: PPUSH
5665: CALL_OW 94
// Say ( MacMillan , D2Jb-JMM-3 ) ;
5669: LD_EXP 1
5673: PPUSH
5674: LD_STRING D2Jb-JMM-3
5676: PPUSH
5677: CALL_OW 88
// end ; 3 :
5681: GO 5707
5683: LD_INT 3
5685: DOUBLE
5686: EQUAL
5687: IFTRUE 5691
5689: GO 5706
5691: POP
// begin SayRadio ( Joan , D2Jc-Joan-1 ) ;
5692: LD_EXP 3
5696: PPUSH
5697: LD_STRING D2Jc-Joan-1
5699: PPUSH
5700: CALL_OW 94
// end ; end ;
5704: GO 5707
5706: POP
// end ;
5707: LD_VAR 0 1
5711: RET
// function odpoved_lisa ; begin
5712: LD_INT 0
5714: PPUSH
// case odpoved of 1 :
5715: LD_EXP 33
5719: PUSH
5720: LD_INT 1
5722: DOUBLE
5723: EQUAL
5724: IFTRUE 5728
5726: GO 5791
5728: POP
// begin Say ( MacMillan , D2La-JMM-1 ) ;
5729: LD_EXP 1
5733: PPUSH
5734: LD_STRING D2La-JMM-1
5736: PPUSH
5737: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-1 ) ;
5741: LD_EXP 4
5745: PPUSH
5746: LD_STRING D2La-Lisa-1
5748: PPUSH
5749: CALL_OW 94
// Say ( MacMillan , D2La-JMM-2 ) ;
5753: LD_EXP 1
5757: PPUSH
5758: LD_STRING D2La-JMM-2
5760: PPUSH
5761: CALL_OW 88
// SayRadio ( Lisa , D2La-Lisa-2 ) ;
5765: LD_EXP 4
5769: PPUSH
5770: LD_STRING D2La-Lisa-2
5772: PPUSH
5773: CALL_OW 94
// Say ( MacMillan , D2La-JMM-3 ) ;
5777: LD_EXP 1
5781: PPUSH
5782: LD_STRING D2La-JMM-3
5784: PPUSH
5785: CALL_OW 88
// end ; 2 :
5789: GO 5874
5791: LD_INT 2
5793: DOUBLE
5794: EQUAL
5795: IFTRUE 5799
5797: GO 5850
5799: POP
// begin Say ( MacMillan , D2Lb-JMM-1 ) ;
5800: LD_EXP 1
5804: PPUSH
5805: LD_STRING D2Lb-JMM-1
5807: PPUSH
5808: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-1 ) ;
5812: LD_EXP 4
5816: PPUSH
5817: LD_STRING D2Lb-Lisa-1
5819: PPUSH
5820: CALL_OW 94
// Say ( MacMillan , D2Lb-JMM-2 ) ;
5824: LD_EXP 1
5828: PPUSH
5829: LD_STRING D2Lb-JMM-2
5831: PPUSH
5832: CALL_OW 88
// SayRadio ( Lisa , D2Lb-Lisa-2 ) ;
5836: LD_EXP 4
5840: PPUSH
5841: LD_STRING D2Lb-Lisa-2
5843: PPUSH
5844: CALL_OW 94
// end ; 3 :
5848: GO 5874
5850: LD_INT 3
5852: DOUBLE
5853: EQUAL
5854: IFTRUE 5858
5856: GO 5873
5858: POP
// begin SayRadio ( Lisa , D2Lc-Lisa-1 ) ;
5859: LD_EXP 4
5863: PPUSH
5864: LD_STRING D2Lc-Lisa-1
5866: PPUSH
5867: CALL_OW 94
// end ; end ;
5871: GO 5874
5873: POP
// end ;
5874: LD_VAR 0 1
5878: RET
// function odpoved_anezka ; begin
5879: LD_INT 0
5881: PPUSH
// case odpoved of 1 :
5882: LD_EXP 33
5886: PUSH
5887: LD_INT 1
5889: DOUBLE
5890: EQUAL
5891: IFTRUE 5895
5893: GO 5910
5895: POP
// begin Say ( MacMillan , D2Xa-JMM-1 ) ;
5896: LD_EXP 1
5900: PPUSH
5901: LD_STRING D2Xa-JMM-1
5903: PPUSH
5904: CALL_OW 88
// end ; 2 :
5908: GO 5969
5910: LD_INT 2
5912: DOUBLE
5913: EQUAL
5914: IFTRUE 5918
5916: GO 5945
5918: POP
// begin Say ( MacMillan , D2Xb-JMM-1 ) ;
5919: LD_EXP 1
5923: PPUSH
5924: LD_STRING D2Xb-JMM-1
5926: PPUSH
5927: CALL_OW 88
// SayRadio ( anezka , D2Xb-Con-1 ) ;
5931: LD_EXP 5
5935: PPUSH
5936: LD_STRING D2Xb-Con-1
5938: PPUSH
5939: CALL_OW 94
// end ; 3 :
5943: GO 5969
5945: LD_INT 3
5947: DOUBLE
5948: EQUAL
5949: IFTRUE 5953
5951: GO 5968
5953: POP
// begin SayRadio ( anezka , D2Xc-Con-1 ) ;
5954: LD_EXP 5
5958: PPUSH
5959: LD_STRING D2Xc-Con-1
5961: PPUSH
5962: CALL_OW 94
// end ; end ;
5966: GO 5969
5968: POP
// end ;
5969: LD_VAR 0 1
5973: RET
// every 0 0$1 trigger IsInArea ( MacMillan , help_calling ) and ( not visit_base ) do
5974: LD_EXP 1
5978: PPUSH
5979: LD_INT 5
5981: PPUSH
5982: CALL_OW 308
5986: PUSH
5987: LD_EXP 34
5991: NOT
5992: AND
5993: IFFALSE 6399
5995: GO 5997
5997: DISABLE
// begin DialogueOn ;
5998: CALL_OW 6
// interface_hidden := true ;
6002: LD_ADDR_OWVAR 54
6006: PUSH
6007: LD_INT 1
6009: ST_TO_ADDR
// case who_survive of 1 :
6010: LD_EXP 7
6014: PUSH
6015: LD_INT 1
6017: DOUBLE
6018: EQUAL
6019: IFTRUE 6023
6021: GO 6038
6023: POP
// SayRadio ( Joan , D2J-Joan-1 ) ; 2 :
6024: LD_EXP 3
6028: PPUSH
6029: LD_STRING D2J-Joan-1
6031: PPUSH
6032: CALL_OW 94
6036: GO 6085
6038: LD_INT 2
6040: DOUBLE
6041: EQUAL
6042: IFTRUE 6046
6044: GO 6061
6046: POP
// SayRadio ( Lisa , D2L-Lisa-1 ) ; 3 :
6047: LD_EXP 4
6051: PPUSH
6052: LD_STRING D2L-Lisa-1
6054: PPUSH
6055: CALL_OW 94
6059: GO 6085
6061: LD_INT 3
6063: DOUBLE
6064: EQUAL
6065: IFTRUE 6069
6067: GO 6084
6069: POP
// SayRadio ( anezka , D2X-Con-1 ) ; end ;
6070: LD_EXP 5
6074: PPUSH
6075: LD_STRING D2X-Con-1
6077: PPUSH
6078: CALL_OW 94
6082: GO 6085
6084: POP
// if Query ( Q1 ) = 2 then
6085: LD_STRING Q1
6087: PPUSH
6088: CALL_OW 97
6092: PUSH
6093: LD_INT 2
6095: EQUAL
6096: IFFALSE 6112
// begin DialogueOff ;
6098: CALL_OW 7
// interface_hidden := false ;
6102: LD_ADDR_OWVAR 54
6106: PUSH
6107: LD_INT 0
6109: ST_TO_ADDR
// exit ;
6110: GO 6399
// end ; case who_survive of 1 :
6112: LD_EXP 7
6116: PUSH
6117: LD_INT 1
6119: DOUBLE
6120: EQUAL
6121: IFTRUE 6125
6123: GO 6176
6125: POP
// begin Say ( MacMillan , D2J-JMM-1 ) ;
6126: LD_EXP 1
6130: PPUSH
6131: LD_STRING D2J-JMM-1
6133: PPUSH
6134: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-2 ) ;
6138: LD_EXP 3
6142: PPUSH
6143: LD_STRING D2J-Joan-2
6145: PPUSH
6146: CALL_OW 94
// Say ( MacMillan , D2J-JMM-2 ) ;
6150: LD_EXP 1
6154: PPUSH
6155: LD_STRING D2J-JMM-2
6157: PPUSH
6158: CALL_OW 88
// SayRadio ( Joan , D2J-Joan-3 ) ;
6162: LD_EXP 3
6166: PPUSH
6167: LD_STRING D2J-Joan-3
6169: PPUSH
6170: CALL_OW 94
// end ; 2 :
6174: GO 6271
6176: LD_INT 2
6178: DOUBLE
6179: EQUAL
6180: IFTRUE 6184
6182: GO 6235
6184: POP
// begin Say ( MacMillan , D2L-JMM-1 ) ;
6185: LD_EXP 1
6189: PPUSH
6190: LD_STRING D2L-JMM-1
6192: PPUSH
6193: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-2 ) ;
6197: LD_EXP 4
6201: PPUSH
6202: LD_STRING D2L-Lisa-2
6204: PPUSH
6205: CALL_OW 94
// Say ( MacMillan , D2L-JMM-2 ) ;
6209: LD_EXP 1
6213: PPUSH
6214: LD_STRING D2L-JMM-2
6216: PPUSH
6217: CALL_OW 88
// SayRadio ( Lisa , D2L-Lisa-3 ) ;
6221: LD_EXP 4
6225: PPUSH
6226: LD_STRING D2L-Lisa-3
6228: PPUSH
6229: CALL_OW 94
// end ; 3 :
6233: GO 6271
6235: LD_INT 3
6237: DOUBLE
6238: EQUAL
6239: IFTRUE 6243
6241: GO 6270
6243: POP
// begin Say ( MacMillan , D2X-JMM-1 ) ;
6244: LD_EXP 1
6248: PPUSH
6249: LD_STRING D2X-JMM-1
6251: PPUSH
6252: CALL_OW 88
// SayRadio ( anezka , D2X-Con-2 ) ;
6256: LD_EXP 5
6260: PPUSH
6261: LD_STRING D2X-Con-2
6263: PPUSH
6264: CALL_OW 94
// end ; end ;
6268: GO 6271
6270: POP
// wait ( 0 0$1 ) ;
6271: LD_INT 35
6273: PPUSH
6274: CALL_OW 67
// SayRadio ( Powell , DPowell-Pow-1 ) ;
6278: LD_EXP 2
6282: PPUSH
6283: LD_STRING DPowell-Pow-1
6285: PPUSH
6286: CALL_OW 94
// wait ( 0 0$1 ) ;
6290: LD_INT 35
6292: PPUSH
6293: CALL_OW 67
// case who_survive of 1 :
6297: LD_EXP 7
6301: PUSH
6302: LD_INT 1
6304: DOUBLE
6305: EQUAL
6306: IFTRUE 6310
6308: GO 6330
6310: POP
// begin odpoved := Query ( Q2J ) ;
6311: LD_ADDR_EXP 33
6315: PUSH
6316: LD_STRING Q2J
6318: PPUSH
6319: CALL_OW 97
6323: ST_TO_ADDR
// odpoved_joan ;
6324: CALL 5557 0 0
// end ; 2 :
6328: GO 6387
6330: LD_INT 2
6332: DOUBLE
6333: EQUAL
6334: IFTRUE 6338
6336: GO 6358
6338: POP
// begin odpoved := Query ( Q2L ) ;
6339: LD_ADDR_EXP 33
6343: PUSH
6344: LD_STRING Q2L
6346: PPUSH
6347: CALL_OW 97
6351: ST_TO_ADDR
// odpoved_lisa ;
6352: CALL 5712 0 0
// end ; 3 :
6356: GO 6387
6358: LD_INT 3
6360: DOUBLE
6361: EQUAL
6362: IFTRUE 6366
6364: GO 6386
6366: POP
// begin odpoved := Query ( Q2X ) ;
6367: LD_ADDR_EXP 33
6371: PUSH
6372: LD_STRING Q2X
6374: PPUSH
6375: CALL_OW 97
6379: ST_TO_ADDR
// odpoved_anezka ;
6380: CALL 5879 0 0
// end ; end ;
6384: GO 6387
6386: POP
// DialogueOff ;
6387: CALL_OW 7
// interface_hidden := false ;
6391: LD_ADDR_OWVAR 54
6395: PUSH
6396: LD_INT 0
6398: ST_TO_ADDR
// end ;
6399: END
// every 0 0$1 trigger IsInArea ( MacMillan , US_base ) do var dist , list ;
6400: LD_EXP 1
6404: PPUSH
6405: LD_INT 1
6407: PPUSH
6408: CALL_OW 308
6412: IFFALSE 7127
6414: GO 6416
6416: DISABLE
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
// begin ComMoveUnit ( survivor , MacMillan ) ;
6421: LD_EXP 6
6425: PPUSH
6426: LD_EXP 1
6430: PPUSH
6431: CALL_OW 112
// repeat wait ( 0 0$1 ) ;
6435: LD_INT 35
6437: PPUSH
6438: CALL_OW 67
// until See ( you , survivor ) ;
6442: LD_EXP 14
6446: PPUSH
6447: LD_EXP 6
6451: PPUSH
6452: CALL_OW 292
6456: IFFALSE 6435
// SetSideBase ( GetBase ( us_depot ) , you ) ;
6458: LD_INT 48
6460: PPUSH
6461: CALL_OW 274
6465: PPUSH
6466: LD_EXP 14
6470: PPUSH
6471: CALL_OW 236
// SetSide ( survivor , you ) ;
6475: LD_EXP 6
6479: PPUSH
6480: LD_EXP 14
6484: PPUSH
6485: CALL_OW 235
// SetSide ( us_trucks , you ) ;
6489: LD_EXP 35
6493: PPUSH
6494: LD_EXP 14
6498: PPUSH
6499: CALL_OW 235
// list := FilterAllUnits ( [ [ f_side , neutral ] , [ f_class , class_apeman_engineer ] ] ) ;
6503: LD_ADDR_VAR 0 2
6507: PUSH
6508: LD_INT 22
6510: PUSH
6511: LD_EXP 16
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 25
6522: PUSH
6523: LD_INT 16
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PPUSH
6534: CALL_OW 69
6538: ST_TO_ADDR
// SetSide ( list , you ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_EXP 14
6548: PPUSH
6549: CALL_OW 235
// visit_base := true ;
6553: LD_ADDR_EXP 34
6557: PUSH
6558: LD_INT 1
6560: ST_TO_ADDR
// InGameOn ;
6561: CALL_OW 8
// if IsOK ( Joan ) then
6565: LD_EXP 3
6569: PPUSH
6570: CALL_OW 302
6574: IFFALSE 6590
// begin dist := 1 ;
6576: LD_ADDR_VAR 0 1
6580: PUSH
6581: LD_INT 1
6583: ST_TO_ADDR
// SA_HelpJoan ;
6584: CALL 17272 0 0
// end else
6588: GO 6598
// dist := 3 ;
6590: LD_ADDR_VAR 0 1
6594: PUSH
6595: LD_INT 3
6597: ST_TO_ADDR
// list := TICK ;
6598: LD_ADDR_VAR 0 2
6602: PUSH
6603: LD_OWVAR 1
6607: ST_TO_ADDR
// while ( GetDistUnits ( MacMillan , survivor ) > dist ) and ( ( list + 0 0$6 ) > TICK ) do
6608: LD_EXP 1
6612: PPUSH
6613: LD_EXP 6
6617: PPUSH
6618: CALL_OW 296
6622: PUSH
6623: LD_VAR 0 1
6627: GREATER
6628: PUSH
6629: LD_VAR 0 2
6633: PUSH
6634: LD_INT 210
6636: PLUS
6637: PUSH
6638: LD_OWVAR 1
6642: GREATER
6643: AND
6644: IFFALSE 6701
// begin ComMoveUnit ( survivor , MacMillan ) ;
6646: LD_EXP 6
6650: PPUSH
6651: LD_EXP 1
6655: PPUSH
6656: CALL_OW 112
// ComMoveUnit ( MacMillan , survivor ) ;
6660: LD_EXP 1
6664: PPUSH
6665: LD_EXP 6
6669: PPUSH
6670: CALL_OW 112
// wait ( 20 ) ;
6674: LD_INT 20
6676: PPUSH
6677: CALL_OW 67
// CenterOnUnits ( [ MacMillan , survivor ] ) ;
6681: LD_EXP 1
6685: PUSH
6686: LD_EXP 6
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: PPUSH
6695: CALL_OW 85
// end ;
6699: GO 6608
// ComStop ( [ MacMillan , survivor ] ) ;
6701: LD_EXP 1
6705: PUSH
6706: LD_EXP 6
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: PPUSH
6715: CALL_OW 141
// ComTurnUnit ( survivor , MacMillan ) ;
6719: LD_EXP 6
6723: PPUSH
6724: LD_EXP 1
6728: PPUSH
6729: CALL_OW 119
// ComTurnUnit ( MacMillan , survivor ) ;
6733: LD_EXP 1
6737: PPUSH
6738: LD_EXP 6
6742: PPUSH
6743: CALL_OW 119
// wait ( 5 ) ;
6747: LD_INT 5
6749: PPUSH
6750: CALL_OW 67
// InGameOff ;
6754: CALL_OW 9
// DialogueOn ;
6758: CALL_OW 6
// interface_hidden := true ;
6762: LD_ADDR_OWVAR 54
6766: PUSH
6767: LD_INT 1
6769: ST_TO_ADDR
// case who_survive of 1 :
6770: LD_EXP 7
6774: PUSH
6775: LD_INT 1
6777: DOUBLE
6778: EQUAL
6779: IFTRUE 6783
6781: GO 6841
6783: POP
// begin Say ( Joan , D3J-Joan-1 ) ;
6784: LD_EXP 3
6788: PPUSH
6789: LD_STRING D3J-Joan-1
6791: PPUSH
6792: CALL_OW 88
// Say ( MacMillan , D3J-JMM-1 ) ;
6796: LD_EXP 1
6800: PPUSH
6801: LD_STRING D3J-JMM-1
6803: PPUSH
6804: CALL_OW 88
// Say ( Joan , D3J-Joan-2 ) ;
6808: LD_EXP 3
6812: PPUSH
6813: LD_STRING D3J-Joan-2
6815: PPUSH
6816: CALL_OW 88
// Say ( MacMillan , D3J-JMM-2 ) ;
6820: LD_EXP 1
6824: PPUSH
6825: LD_STRING D3J-JMM-2
6827: PPUSH
6828: CALL_OW 88
// ChangeMissionObjectives ( M2J ) ;
6832: LD_STRING M2J
6834: PPUSH
6835: CALL_OW 337
// end ; 2 :
6839: GO 6938
6841: LD_INT 2
6843: DOUBLE
6844: EQUAL
6845: IFTRUE 6849
6847: GO 6907
6849: POP
// begin Say ( Lisa , D3L-Lisa-1 ) ;
6850: LD_EXP 4
6854: PPUSH
6855: LD_STRING D3L-Lisa-1
6857: PPUSH
6858: CALL_OW 88
// Say ( MacMillan , D3L-JMM-1 ) ;
6862: LD_EXP 1
6866: PPUSH
6867: LD_STRING D3L-JMM-1
6869: PPUSH
6870: CALL_OW 88
// Say ( Lisa , D3L-Lisa-2 ) ;
6874: LD_EXP 4
6878: PPUSH
6879: LD_STRING D3L-Lisa-2
6881: PPUSH
6882: CALL_OW 88
// Say ( MacMillan , D3L-JMM-2 ) ;
6886: LD_EXP 1
6890: PPUSH
6891: LD_STRING D3L-JMM-2
6893: PPUSH
6894: CALL_OW 88
// ChangeMissionObjectives ( M2L ) ;
6898: LD_STRING M2L
6900: PPUSH
6901: CALL_OW 337
// end ; 3 :
6905: GO 6938
6907: LD_INT 3
6909: DOUBLE
6910: EQUAL
6911: IFTRUE 6915
6913: GO 6937
6915: POP
// begin Say ( anezka , D3X-Con-1 ) ;
6916: LD_EXP 5
6920: PPUSH
6921: LD_STRING D3X-Con-1
6923: PPUSH
6924: CALL_OW 88
// ChangeMissionObjectives ( M2X ) ;
6928: LD_STRING M2X
6930: PPUSH
6931: CALL_OW 337
// end ; end ;
6935: GO 6938
6937: POP
// Say ( MacMillan , D4-JMM-1 ) ;
6938: LD_EXP 1
6942: PPUSH
6943: LD_STRING D4-JMM-1
6945: PPUSH
6946: CALL_OW 88
// case who_survive of 1 :
6950: LD_EXP 7
6954: PUSH
6955: LD_INT 1
6957: DOUBLE
6958: EQUAL
6959: IFTRUE 6963
6961: GO 6978
6963: POP
// Say ( Joan , D4-Joan-1 ) ; 2 :
6964: LD_EXP 3
6968: PPUSH
6969: LD_STRING D4-Joan-1
6971: PPUSH
6972: CALL_OW 88
6976: GO 7025
6978: LD_INT 2
6980: DOUBLE
6981: EQUAL
6982: IFTRUE 6986
6984: GO 7001
6986: POP
// Say ( Lisa , D4-Lisa-1 ) ; 3 :
6987: LD_EXP 4
6991: PPUSH
6992: LD_STRING D4-Lisa-1
6994: PPUSH
6995: CALL_OW 88
6999: GO 7025
7001: LD_INT 3
7003: DOUBLE
7004: EQUAL
7005: IFTRUE 7009
7007: GO 7024
7009: POP
// Say ( Anezka , D4-Con-1 ) ; end ;
7010: LD_EXP 5
7014: PPUSH
7015: LD_STRING D4-Con-1
7017: PPUSH
7018: CALL_OW 88
7022: GO 7025
7024: POP
// Say ( MacMillan , D4-JMM-2 ) ;
7025: LD_EXP 1
7029: PPUSH
7030: LD_STRING D4-JMM-2
7032: PPUSH
7033: CALL_OW 88
// case who_survive of 1 :
7037: LD_EXP 7
7041: PUSH
7042: LD_INT 1
7044: DOUBLE
7045: EQUAL
7046: IFTRUE 7050
7048: GO 7065
7050: POP
// Say ( Joan , D4-Joan-2 ) ; 2 :
7051: LD_EXP 3
7055: PPUSH
7056: LD_STRING D4-Joan-2
7058: PPUSH
7059: CALL_OW 88
7063: GO 7112
7065: LD_INT 2
7067: DOUBLE
7068: EQUAL
7069: IFTRUE 7073
7071: GO 7088
7073: POP
// Say ( Lisa , D4-Lisa-2 ) ; 3 :
7074: LD_EXP 4
7078: PPUSH
7079: LD_STRING D4-Lisa-2
7081: PPUSH
7082: CALL_OW 88
7086: GO 7112
7088: LD_INT 3
7090: DOUBLE
7091: EQUAL
7092: IFTRUE 7096
7094: GO 7111
7096: POP
// Say ( Anezka , D4-Con-2 ) ; end ;
7097: LD_EXP 5
7101: PPUSH
7102: LD_STRING D4-Con-2
7104: PPUSH
7105: CALL_OW 88
7109: GO 7112
7111: POP
// DialogueOff ;
7112: CALL_OW 7
// interface_hidden := false ;
7116: LD_ADDR_OWVAR 54
7120: PUSH
7121: LD_INT 0
7123: ST_TO_ADDR
// enable ( 11 ) ;
7124: LD_INT 11
7126: ENABLE_MARKED
// end ;
7127: PPOPN 2
7129: END
// every 0 0$1 trigger IsSelected ( us_trucks ) marked 11 do
7130: LD_EXP 35
7134: PPUSH
7135: CALL_OW 306
7139: IFFALSE 7314
7141: GO 7143
7143: DISABLE
// begin if FilterAllUnits ( [ [ f_side , you ] , [ f_btype , b_control_tower ] ] ) then
7144: LD_INT 22
7146: PUSH
7147: LD_EXP 14
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 30
7158: PUSH
7159: LD_INT 36
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PPUSH
7170: CALL_OW 69
7174: IFFALSE 7178
// exit ;
7176: GO 7314
// while dialogue_running do
7178: LD_LOC 3
7182: IFFALSE 7193
// wait ( 0 0$1 ) ;
7184: LD_INT 35
7186: PPUSH
7187: CALL_OW 67
7191: GO 7178
// dialogue_running := true ;
7193: LD_ADDR_LOC 3
7197: PUSH
7198: LD_INT 1
7200: ST_TO_ADDR
// DisableExclamations ;
7201: CALL_OW 474
// Say ( MacMillan , D5-JMM-1 ) ;
7205: LD_EXP 1
7209: PPUSH
7210: LD_STRING D5-JMM-1
7212: PPUSH
7213: CALL_OW 88
// CenterOnXY ( 77 , 87 ) ;
7217: LD_INT 77
7219: PPUSH
7220: LD_INT 87
7222: PPUSH
7223: CALL_OW 84
// case who_survive of 1 :
7227: LD_EXP 7
7231: PUSH
7232: LD_INT 1
7234: DOUBLE
7235: EQUAL
7236: IFTRUE 7240
7238: GO 7255
7240: POP
// Say ( Joan , D5-Joan-1 ) ; 2 :
7241: LD_EXP 3
7245: PPUSH
7246: LD_STRING D5-Joan-1
7248: PPUSH
7249: CALL_OW 88
7253: GO 7302
7255: LD_INT 2
7257: DOUBLE
7258: EQUAL
7259: IFTRUE 7263
7261: GO 7278
7263: POP
// Say ( Lisa , D5-Lisa-1 ) ; 3 :
7264: LD_EXP 4
7268: PPUSH
7269: LD_STRING D5-Lisa-1
7271: PPUSH
7272: CALL_OW 88
7276: GO 7302
7278: LD_INT 3
7280: DOUBLE
7281: EQUAL
7282: IFTRUE 7286
7284: GO 7301
7286: POP
// Say ( Anezka , D5-Con-1 ) ; end ;
7287: LD_EXP 5
7291: PPUSH
7292: LD_STRING D5-Con-1
7294: PPUSH
7295: CALL_OW 88
7299: GO 7302
7301: POP
// EnableExclamations ;
7302: CALL_OW 473
// dialogue_running := false ;
7306: LD_ADDR_LOC 3
7310: PUSH
7311: LD_INT 0
7313: ST_TO_ADDR
// end ;
7314: END
// every 0 0$1 trigger IsSelected ( us_lab1 ) marked 11 do
7315: LD_INT 32
7317: PPUSH
7318: CALL_OW 306
7322: IFFALSE 7680
7324: GO 7326
7326: DISABLE
// begin while dialogue_running do
7327: LD_LOC 3
7331: IFFALSE 7342
// wait ( 0 0$1 ) ;
7333: LD_INT 35
7335: PPUSH
7336: CALL_OW 67
7340: GO 7327
// dialogue_running := true ;
7342: LD_ADDR_LOC 3
7346: PUSH
7347: LD_INT 1
7349: ST_TO_ADDR
// DisableExclamations ;
7350: CALL_OW 474
// selected_opto_lab := true ;
7354: LD_ADDR_EXP 19
7358: PUSH
7359: LD_INT 1
7361: ST_TO_ADDR
// case who_survive of 1 :
7362: LD_EXP 7
7366: PUSH
7367: LD_INT 1
7369: DOUBLE
7370: EQUAL
7371: IFTRUE 7375
7373: GO 7482
7375: POP
// begin Say ( MacMillan , D6J-JMM-1 ) ;
7376: LD_EXP 1
7380: PPUSH
7381: LD_STRING D6J-JMM-1
7383: PPUSH
7384: CALL_OW 88
// if TestCharacters ( Denis ) and CheckCharacterSet ( Denis ) then
7388: LD_STRING Denis
7390: PPUSH
7391: CALL_OW 28
7395: PUSH
7396: LD_STRING Denis
7398: PPUSH
7399: CALL_OW 29
7403: AND
7404: IFFALSE 7444
// begin Say ( Joan , D6J-Joan-1 ) ;
7406: LD_EXP 3
7410: PPUSH
7411: LD_STRING D6J-Joan-1
7413: PPUSH
7414: CALL_OW 88
// Say ( MacMillan , D6J-JMM-2 ) ;
7418: LD_EXP 1
7422: PPUSH
7423: LD_STRING D6J-JMM-2
7425: PPUSH
7426: CALL_OW 88
// Say ( Joan , D6J-Joan-2 ) ;
7430: LD_EXP 3
7434: PPUSH
7435: LD_STRING D6J-Joan-2
7437: PPUSH
7438: CALL_OW 88
// end else
7442: GO 7456
// Say ( Joan , D6J-Joan-2a ) ;
7444: LD_EXP 3
7448: PPUSH
7449: LD_STRING D6J-Joan-2a
7451: PPUSH
7452: CALL_OW 88
// Say ( MacMillan , D6J-JMM-3 ) ;
7456: LD_EXP 1
7460: PPUSH
7461: LD_STRING D6J-JMM-3
7463: PPUSH
7464: CALL_OW 88
// Say ( Joan , D6J-Joan-3 ) ;
7468: LD_EXP 3
7472: PPUSH
7473: LD_STRING D6J-Joan-3
7475: PPUSH
7476: CALL_OW 88
// end ; 2 :
7480: GO 7661
7482: LD_INT 2
7484: DOUBLE
7485: EQUAL
7486: IFTRUE 7490
7488: GO 7541
7490: POP
// begin Say ( MacMillan , D6L-JMM-1 ) ;
7491: LD_EXP 1
7495: PPUSH
7496: LD_STRING D6L-JMM-1
7498: PPUSH
7499: CALL_OW 88
// Say ( Lisa , D6L-Lisa-1 ) ;
7503: LD_EXP 4
7507: PPUSH
7508: LD_STRING D6L-Lisa-1
7510: PPUSH
7511: CALL_OW 88
// Say ( MacMillan , D6L-JMM-2 ) ;
7515: LD_EXP 1
7519: PPUSH
7520: LD_STRING D6L-JMM-2
7522: PPUSH
7523: CALL_OW 88
// Say ( Lisa , D6L-Lisa-2 ) ;
7527: LD_EXP 4
7531: PPUSH
7532: LD_STRING D6L-Lisa-2
7534: PPUSH
7535: CALL_OW 88
// end ; 3 :
7539: GO 7661
7541: LD_INT 3
7543: DOUBLE
7544: EQUAL
7545: IFTRUE 7549
7547: GO 7660
7549: POP
// begin Say ( MacMillan , D6X-JMM-1 ) ;
7550: LD_EXP 1
7554: PPUSH
7555: LD_STRING D6X-JMM-1
7557: PPUSH
7558: CALL_OW 88
// Say ( Anezka , D6X-Con-1 ) ;
7562: LD_EXP 5
7566: PPUSH
7567: LD_STRING D6X-Con-1
7569: PPUSH
7570: CALL_OW 88
// Say ( MacMillan , D6X-JMM-2 ) ;
7574: LD_EXP 1
7578: PPUSH
7579: LD_STRING D6X-JMM-2
7581: PPUSH
7582: CALL_OW 88
// Say ( Anezka , D6X-Con-2 ) ;
7586: LD_EXP 5
7590: PPUSH
7591: LD_STRING D6X-Con-2
7593: PPUSH
7594: CALL_OW 88
// Say ( MacMillan , D6X-JMM-3 ) ;
7598: LD_EXP 1
7602: PPUSH
7603: LD_STRING D6X-JMM-3
7605: PPUSH
7606: CALL_OW 88
// Say ( Anezka , D6X-Con-3 ) ;
7610: LD_EXP 5
7614: PPUSH
7615: LD_STRING D6X-Con-3
7617: PPUSH
7618: CALL_OW 88
// Say ( MacMillan , D6X-JMM-4 ) ;
7622: LD_EXP 1
7626: PPUSH
7627: LD_STRING D6X-JMM-4
7629: PPUSH
7630: CALL_OW 88
// Say ( Anezka , D6X-Con-4 ) ;
7634: LD_EXP 5
7638: PPUSH
7639: LD_STRING D6X-Con-4
7641: PPUSH
7642: CALL_OW 88
// Say ( MacMillan , D6X-JMM-5 ) ;
7646: LD_EXP 1
7650: PPUSH
7651: LD_STRING D6X-JMM-5
7653: PPUSH
7654: CALL_OW 88
// end ; end ;
7658: GO 7661
7660: POP
// ChangeMissionObjectives ( M3 ) ;
7661: LD_STRING M3
7663: PPUSH
7664: CALL_OW 337
// EnableExclamations ;
7668: CALL_OW 473
// dialogue_running := false ;
7672: LD_ADDR_LOC 3
7676: PUSH
7677: LD_INT 0
7679: ST_TO_ADDR
// end ;
7680: END
// every 10 10$0 do
7681: GO 7683
7683: DISABLE
// begin DialogueOn ;
7684: CALL_OW 6
// interface_hidden := true ;
7688: LD_ADDR_OWVAR 54
7692: PUSH
7693: LD_INT 1
7695: ST_TO_ADDR
// Say ( Powell , D7-Pow-1 ) ;
7696: LD_EXP 2
7700: PPUSH
7701: LD_STRING D7-Pow-1
7703: PPUSH
7704: CALL_OW 88
// Say ( MacMillan , D7-JMM-1 ) ;
7708: LD_EXP 1
7712: PPUSH
7713: LD_STRING D7-JMM-1
7715: PPUSH
7716: CALL_OW 88
// Say ( Powell , D7-Pow-2 ) ;
7720: LD_EXP 2
7724: PPUSH
7725: LD_STRING D7-Pow-2
7727: PPUSH
7728: CALL_OW 88
// if IsLive ( survivor ) then
7732: LD_EXP 6
7736: PPUSH
7737: CALL_OW 300
7741: IFFALSE 7757
// Say ( MacMillan , D7-JMM-2 ) else
7743: LD_EXP 1
7747: PPUSH
7748: LD_STRING D7-JMM-2
7750: PPUSH
7751: CALL_OW 88
7755: GO 7769
// Say ( MacMillan , D7-JMM-2a ) ;
7757: LD_EXP 1
7761: PPUSH
7762: LD_STRING D7-JMM-2a
7764: PPUSH
7765: CALL_OW 88
// Say ( Powell , D7-Pow-3 ) ;
7769: LD_EXP 2
7773: PPUSH
7774: LD_STRING D7-Pow-3
7776: PPUSH
7777: CALL_OW 88
// Say ( MacMillan , D7-JMM-3 ) ;
7781: LD_EXP 1
7785: PPUSH
7786: LD_STRING D7-JMM-3
7788: PPUSH
7789: CALL_OW 88
// Say ( Powell , D7-Pow-4 ) ;
7793: LD_EXP 2
7797: PPUSH
7798: LD_STRING D7-Pow-4
7800: PPUSH
7801: CALL_OW 88
// DialogueOff ;
7805: CALL_OW 7
// interface_hidden := false ;
7809: LD_ADDR_OWVAR 54
7813: PUSH
7814: LD_INT 0
7816: ST_TO_ADDR
// end ;
7817: END
// every 0 0$20 do
7818: GO 7820
7820: DISABLE
// begin ukradle_auto := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_vehicle ] , [ f_chassis , us_morphling ] ] ) ;
7821: LD_ADDR_EXP 9
7825: PUSH
7826: LD_INT 22
7828: PUSH
7829: LD_EXP 15
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PUSH
7838: LD_INT 21
7840: PUSH
7841: LD_INT 2
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 31
7850: PUSH
7851: LD_INT 5
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 69
7867: ST_TO_ADDR
// mm_vehicle := ukradle_auto ;
7868: LD_ADDR_EXP 63
7872: PUSH
7873: LD_EXP 9
7877: ST_TO_ADDR
// manual_forces := manual_forces ^ mm_vehicle ;
7878: LD_ADDR_EXP 59
7882: PUSH
7883: LD_EXP 59
7887: PUSH
7888: LD_EXP 63
7892: ADD
7893: ST_TO_ADDR
// if ukradle_auto then
7894: LD_EXP 9
7898: IFFALSE 7903
// enable ( 5 ) ;
7900: LD_INT 5
7902: ENABLE_MARKED
// end ;
7903: END
// function vzdalenost_macmillana_od_auta ; var v_x , v_y ; begin
7904: LD_INT 0
7906: PPUSH
7907: PPUSH
7908: PPUSH
// v_x := GetX ( ukradle_auto ) - GetX ( MacMillan ) ;
7909: LD_ADDR_VAR 0 2
7913: PUSH
7914: LD_EXP 9
7918: PPUSH
7919: CALL_OW 250
7923: PUSH
7924: LD_EXP 1
7928: PPUSH
7929: CALL_OW 250
7933: MINUS
7934: ST_TO_ADDR
// v_x := GetY ( ukradle_auto ) - GetY ( MacMillan ) ;
7935: LD_ADDR_VAR 0 2
7939: PUSH
7940: LD_EXP 9
7944: PPUSH
7945: CALL_OW 251
7949: PUSH
7950: LD_EXP 1
7954: PPUSH
7955: CALL_OW 251
7959: MINUS
7960: ST_TO_ADDR
// if ( ( v_x > - 6 ) and ( v_x < 6 ) ) and ( ( v_y > - 6 ) and ( v_y < 6 ) ) then
7961: LD_VAR 0 2
7965: PUSH
7966: LD_INT 6
7968: NEG
7969: GREATER
7970: PUSH
7971: LD_VAR 0 2
7975: PUSH
7976: LD_INT 6
7978: LESS
7979: AND
7980: PUSH
7981: LD_VAR 0 3
7985: PUSH
7986: LD_INT 6
7988: NEG
7989: GREATER
7990: PUSH
7991: LD_VAR 0 3
7995: PUSH
7996: LD_INT 6
7998: LESS
7999: AND
8000: AND
8001: IFFALSE 8013
// result := true else
8003: LD_ADDR_VAR 0 1
8007: PUSH
8008: LD_INT 1
8010: ST_TO_ADDR
8011: GO 8021
// result := false ;
8013: LD_ADDR_VAR 0 1
8017: PUSH
8018: LD_INT 0
8020: ST_TO_ADDR
// end ;
8021: LD_VAR 0 1
8025: RET
// every 0 0$1 trigger vzdalenost_macmillana_od_auta marked 5 do
8026: CALL 7904 0 0
8030: IFFALSE 8047
8032: GO 8034
8034: DISABLE
// begin Say ( MacMillan , D8-JMM-1 ) ;
8035: LD_EXP 1
8039: PPUSH
8040: LD_STRING D8-JMM-1
8042: PPUSH
8043: CALL_OW 88
// end ; end_of_file
8047: END
// export us_trucks ; export number_us_trucks ; export heavy_trucks , medium_trucks , light_trucks ; export function prepare_us_base ; var un , i ; begin
8048: LD_INT 0
8050: PPUSH
8051: PPUSH
8052: PPUSH
// SetBName ( us_depot , deltakappa ) ;
8053: LD_INT 48
8055: PPUSH
8056: LD_STRING deltakappa
8058: PPUSH
8059: CALL_OW 500
// number_us_trucks := 4 ;
8063: LD_ADDR_EXP 36
8067: PUSH
8068: LD_INT 4
8070: ST_TO_ADDR
// light_trucks := Rand ( 1 , ( number_us_trucks div 2 ) ) ;
8071: LD_ADDR_EXP 39
8075: PUSH
8076: LD_INT 1
8078: PPUSH
8079: LD_EXP 36
8083: PUSH
8084: LD_INT 2
8086: DIV
8087: PPUSH
8088: CALL_OW 12
8092: ST_TO_ADDR
// heavy_trucks := Rand ( 0 , ( number_us_trucks div 2 ) ) ;
8093: LD_ADDR_EXP 37
8097: PUSH
8098: LD_INT 0
8100: PPUSH
8101: LD_EXP 36
8105: PUSH
8106: LD_INT 2
8108: DIV
8109: PPUSH
8110: CALL_OW 12
8114: ST_TO_ADDR
// medium_trucks := number_us_trucks - ( light_trucks + heavy_trucks ) ;
8115: LD_ADDR_EXP 38
8119: PUSH
8120: LD_EXP 36
8124: PUSH
8125: LD_EXP 39
8129: PUSH
8130: LD_EXP 37
8134: PLUS
8135: MINUS
8136: ST_TO_ADDR
// us_trucks := [ ] ;
8137: LD_ADDR_EXP 35
8141: PUSH
8142: EMPTY
8143: ST_TO_ADDR
// uc_nation = nation_american ;
8144: LD_ADDR_OWVAR 21
8148: PUSH
8149: LD_INT 1
8151: ST_TO_ADDR
// uc_side = neutral ;
8152: LD_ADDR_OWVAR 20
8156: PUSH
8157: LD_EXP 16
8161: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
8162: LD_ADDR_OWVAR 24
8166: PUSH
8167: LD_INT 0
8169: PPUSH
8170: LD_INT 5
8172: PPUSH
8173: CALL_OW 12
8177: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
8178: LD_ADDR_OWVAR 37
8182: PUSH
8183: LD_INT 2
8185: ST_TO_ADDR
// vc_control := control_remote ;
8186: LD_ADDR_OWVAR 38
8190: PUSH
8191: LD_INT 2
8193: ST_TO_ADDR
// vc_engine := engine_solar ;
8194: LD_ADDR_OWVAR 39
8198: PUSH
8199: LD_INT 2
8201: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
8202: LD_ADDR_OWVAR 40
8206: PUSH
8207: LD_INT 12
8209: ST_TO_ADDR
// un := CreateVehicle ;
8210: LD_ADDR_VAR 0 2
8214: PUSH
8215: CALL_OW 45
8219: ST_TO_ADDR
// PlaceUnitXY ( un , 84 , 119 , false ) ;
8220: LD_VAR 0 2
8224: PPUSH
8225: LD_INT 84
8227: PPUSH
8228: LD_INT 119
8230: PPUSH
8231: LD_INT 0
8233: PPUSH
8234: CALL_OW 48
// us_trucks := us_trucks ^ un ;
8238: LD_ADDR_EXP 35
8242: PUSH
8243: LD_EXP 35
8247: PUSH
8248: LD_VAR 0 2
8252: ADD
8253: ST_TO_ADDR
// for i := 1 to light_trucks do
8254: LD_ADDR_VAR 0 3
8258: PUSH
8259: DOUBLE
8260: LD_INT 1
8262: DEC
8263: ST_TO_ADDR
8264: LD_EXP 39
8268: PUSH
8269: FOR_TO
8270: IFFALSE 8363
// begin uc_direction := Rand ( 0 , 5 ) ;
8272: LD_ADDR_OWVAR 24
8276: PUSH
8277: LD_INT 0
8279: PPUSH
8280: LD_INT 5
8282: PPUSH
8283: CALL_OW 12
8287: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
8288: LD_ADDR_OWVAR 37
8292: PUSH
8293: LD_INT 1
8295: ST_TO_ADDR
// vc_control := control_remote ;
8296: LD_ADDR_OWVAR 38
8300: PUSH
8301: LD_INT 2
8303: ST_TO_ADDR
// vc_engine := engine_solar ;
8304: LD_ADDR_OWVAR 39
8308: PUSH
8309: LD_INT 2
8311: ST_TO_ADDR
// vc_weapon := us_light_gun ;
8312: LD_ADDR_OWVAR 40
8316: PUSH
8317: LD_INT 3
8319: ST_TO_ADDR
// un := CreateVehicle ;
8320: LD_ADDR_VAR 0 2
8324: PUSH
8325: CALL_OW 45
8329: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8330: LD_VAR 0 2
8334: PPUSH
8335: LD_INT 9
8337: PPUSH
8338: LD_INT 0
8340: PPUSH
8341: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8345: LD_ADDR_EXP 35
8349: PUSH
8350: LD_EXP 35
8354: PUSH
8355: LD_VAR 0 2
8359: ADD
8360: ST_TO_ADDR
// end ;
8361: GO 8269
8363: POP
8364: POP
// for i := 1 to medium_trucks do
8365: LD_ADDR_VAR 0 3
8369: PUSH
8370: DOUBLE
8371: LD_INT 1
8373: DEC
8374: ST_TO_ADDR
8375: LD_EXP 38
8379: PUSH
8380: FOR_TO
8381: IFFALSE 8506
// begin uc_direction := Rand ( 0 , 5 ) ;
8383: LD_ADDR_OWVAR 24
8387: PUSH
8388: LD_INT 0
8390: PPUSH
8391: LD_INT 5
8393: PPUSH
8394: CALL_OW 12
8398: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8399: LD_VAR 0 3
8403: PUSH
8404: LD_INT 2
8406: MOD
8407: PUSH
8408: LD_INT 1
8410: EQUAL
8411: IFFALSE 8431
// begin vc_chassis := us_medium_wheeled ;
8413: LD_ADDR_OWVAR 37
8417: PUSH
8418: LD_INT 2
8420: ST_TO_ADDR
// vc_weapon := us_gatling_gun ;
8421: LD_ADDR_OWVAR 40
8425: PUSH
8426: LD_INT 4
8428: ST_TO_ADDR
// end else
8429: GO 8447
// begin vc_chassis := us_medium_tracked ;
8431: LD_ADDR_OWVAR 37
8435: PUSH
8436: LD_INT 3
8438: ST_TO_ADDR
// vc_weapon := us_double_gun ;
8439: LD_ADDR_OWVAR 40
8443: PUSH
8444: LD_INT 5
8446: ST_TO_ADDR
// end ; vc_control := control_remote ;
8447: LD_ADDR_OWVAR 38
8451: PUSH
8452: LD_INT 2
8454: ST_TO_ADDR
// vc_engine := engine_combustion ;
8455: LD_ADDR_OWVAR 39
8459: PUSH
8460: LD_INT 1
8462: ST_TO_ADDR
// un := CreateVehicle ;
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: CALL_OW 45
8472: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8473: LD_VAR 0 2
8477: PPUSH
8478: LD_INT 9
8480: PPUSH
8481: LD_INT 0
8483: PPUSH
8484: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8488: LD_ADDR_EXP 35
8492: PUSH
8493: LD_EXP 35
8497: PUSH
8498: LD_VAR 0 2
8502: ADD
8503: ST_TO_ADDR
// end ;
8504: GO 8380
8506: POP
8507: POP
// for i := 1 to heavy_trucks do
8508: LD_ADDR_VAR 0 3
8512: PUSH
8513: DOUBLE
8514: LD_INT 1
8516: DEC
8517: ST_TO_ADDR
8518: LD_EXP 37
8522: PUSH
8523: FOR_TO
8524: IFFALSE 8641
// begin uc_direction := Rand ( 0 , 5 ) ;
8526: LD_ADDR_OWVAR 24
8530: PUSH
8531: LD_INT 0
8533: PPUSH
8534: LD_INT 5
8536: PPUSH
8537: CALL_OW 12
8541: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
8542: LD_ADDR_OWVAR 37
8546: PUSH
8547: LD_INT 4
8549: ST_TO_ADDR
// vc_control := control_remote ;
8550: LD_ADDR_OWVAR 38
8554: PUSH
8555: LD_INT 2
8557: ST_TO_ADDR
// if ( i mod 2 ) = 1 then
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 2
8565: MOD
8566: PUSH
8567: LD_INT 1
8569: EQUAL
8570: IFFALSE 8582
// vc_engine := engine_siberite else
8572: LD_ADDR_OWVAR 39
8576: PUSH
8577: LD_INT 3
8579: ST_TO_ADDR
8580: GO 8590
// vc_engine := engine_combustion ;
8582: LD_ADDR_OWVAR 39
8586: PUSH
8587: LD_INT 1
8589: ST_TO_ADDR
// vc_weapon := us_heavy_gun ;
8590: LD_ADDR_OWVAR 40
8594: PUSH
8595: LD_INT 6
8597: ST_TO_ADDR
// un := CreateVehicle ;
8598: LD_ADDR_VAR 0 2
8602: PUSH
8603: CALL_OW 45
8607: ST_TO_ADDR
// PlaceUnitArea ( un , place_trucks , false ) ;
8608: LD_VAR 0 2
8612: PPUSH
8613: LD_INT 9
8615: PPUSH
8616: LD_INT 0
8618: PPUSH
8619: CALL_OW 49
// us_trucks := us_trucks ^ un ;
8623: LD_ADDR_EXP 35
8627: PUSH
8628: LD_EXP 35
8632: PUSH
8633: LD_VAR 0 2
8637: ADD
8638: ST_TO_ADDR
// end ;
8639: GO 8523
8641: POP
8642: POP
// end ; end_of_file
8643: LD_VAR 0 1
8647: RET
// export ru_lab1_queue , ru_lab2_queue ; export ru_lab1_upgrade , ru_lab2_upgrade ; export research_1 , research_2 ; var research_done , laboratory ; var finished_1 , finished_2 ; var soucet1 , soucet2 ; export function ru_scientistic_priority ; begin
8648: LD_INT 0
8650: PPUSH
// ru_lab1_queue := [ tech_AdvRocket ] ;
8651: LD_ADDR_EXP 40
8655: PUSH
8656: LD_INT 71
8658: PUSH
8659: EMPTY
8660: LIST
8661: ST_TO_ADDR
// ru_lab2_queue := [ tech_TauRad , tech_SpacAnom , tech_LimTeleport , tech_MatPred , tech_TargTeleport ] ;
8662: LD_ADDR_EXP 41
8666: PUSH
8667: LD_INT 28
8669: PUSH
8670: LD_INT 29
8672: PUSH
8673: LD_INT 37
8675: PUSH
8676: LD_INT 9
8678: PUSH
8679: LD_INT 38
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: ST_TO_ADDR
// ru_lab1_upgrade := [ tech_Tech1 , tech_Weap1 , tech_Sib1 , tech_Tech2 , tech_Weap2 , tech_Sib2 , tech_Tech3 , tech_Weap3 , tech_Sib3 ] ;
8689: LD_ADDR_EXP 42
8693: PUSH
8694: LD_INT 48
8696: PUSH
8697: LD_INT 51
8699: PUSH
8700: LD_INT 54
8702: PUSH
8703: LD_INT 49
8705: PUSH
8706: LD_INT 52
8708: PUSH
8709: LD_INT 55
8711: PUSH
8712: LD_INT 50
8714: PUSH
8715: LD_INT 53
8717: PUSH
8718: LD_INT 56
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: LIST
8725: LIST
8726: LIST
8727: LIST
8728: LIST
8729: LIST
8730: LIST
8731: ST_TO_ADDR
// ru_lab2_upgrade := [ tech_Comp1 , tech_ST1 , tech_Comp2 , tech_ST2 , tech_Comp3 , tech_ST3 ] ;
8732: LD_ADDR_EXP 43
8736: PUSH
8737: LD_INT 57
8739: PUSH
8740: LD_INT 63
8742: PUSH
8743: LD_INT 58
8745: PUSH
8746: LD_INT 64
8748: PUSH
8749: LD_INT 59
8751: PUSH
8752: LD_INT 65
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: ST_TO_ADDR
// research_1 := false ;
8763: LD_ADDR_EXP 44
8767: PUSH
8768: LD_INT 0
8770: ST_TO_ADDR
// research_2 := false ;
8771: LD_ADDR_EXP 45
8775: PUSH
8776: LD_INT 0
8778: ST_TO_ADDR
// finished_1 := false ;
8779: LD_ADDR_LOC 6
8783: PUSH
8784: LD_INT 0
8786: ST_TO_ADDR
// finished_2 := false ;
8787: LD_ADDR_LOC 7
8791: PUSH
8792: LD_INT 0
8794: ST_TO_ADDR
// end ;
8795: LD_VAR 0 1
8799: RET
// function change_technology_lab1 ; var i , j , pom ; begin
8800: LD_INT 0
8802: PPUSH
8803: PPUSH
8804: PPUSH
8805: PPUSH
// j := 1 ;
8806: LD_ADDR_VAR 0 3
8810: PUSH
8811: LD_INT 1
8813: ST_TO_ADDR
// pom := [ ] ;
8814: LD_ADDR_VAR 0 4
8818: PUSH
8819: EMPTY
8820: ST_TO_ADDR
// for i in ru_lab1_queue do
8821: LD_ADDR_VAR 0 2
8825: PUSH
8826: LD_EXP 40
8830: PUSH
8831: FOR_IN
8832: IFFALSE 8876
// begin if j > 1 then
8834: LD_VAR 0 3
8838: PUSH
8839: LD_INT 1
8841: GREATER
8842: IFFALSE 8860
// pom := pom ^ i ;
8844: LD_ADDR_VAR 0 4
8848: PUSH
8849: LD_VAR 0 4
8853: PUSH
8854: LD_VAR 0 2
8858: ADD
8859: ST_TO_ADDR
// j := j + 1 ;
8860: LD_ADDR_VAR 0 3
8864: PUSH
8865: LD_VAR 0 3
8869: PUSH
8870: LD_INT 1
8872: PLUS
8873: ST_TO_ADDR
// end ;
8874: GO 8831
8876: POP
8877: POP
// ru_lab1_queue := pom ;
8878: LD_ADDR_EXP 40
8882: PUSH
8883: LD_VAR 0 4
8887: ST_TO_ADDR
// if not ru_lab1_queue then
8888: LD_EXP 40
8892: NOT
8893: IFFALSE 8912
// begin ru_lab1_queue := ru_lab1_upgrade ;
8895: LD_ADDR_EXP 40
8899: PUSH
8900: LD_EXP 42
8904: ST_TO_ADDR
// ru_lab1_upgrade := [ ] ;
8905: LD_ADDR_EXP 42
8909: PUSH
8910: EMPTY
8911: ST_TO_ADDR
// end ; end ;
8912: LD_VAR 0 1
8916: RET
// function change_technology_lab2 ; var i , j , pom ; begin
8917: LD_INT 0
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// j := 1 ;
8923: LD_ADDR_VAR 0 3
8927: PUSH
8928: LD_INT 1
8930: ST_TO_ADDR
// pom := [ ] ;
8931: LD_ADDR_VAR 0 4
8935: PUSH
8936: EMPTY
8937: ST_TO_ADDR
// for i in ru_lab2_queue do
8938: LD_ADDR_VAR 0 2
8942: PUSH
8943: LD_EXP 41
8947: PUSH
8948: FOR_IN
8949: IFFALSE 8993
// begin if j > 1 then
8951: LD_VAR 0 3
8955: PUSH
8956: LD_INT 1
8958: GREATER
8959: IFFALSE 8977
// pom := pom ^ i ;
8961: LD_ADDR_VAR 0 4
8965: PUSH
8966: LD_VAR 0 4
8970: PUSH
8971: LD_VAR 0 2
8975: ADD
8976: ST_TO_ADDR
// j := j + 1 ;
8977: LD_ADDR_VAR 0 3
8981: PUSH
8982: LD_VAR 0 3
8986: PUSH
8987: LD_INT 1
8989: PLUS
8990: ST_TO_ADDR
// end ;
8991: GO 8948
8993: POP
8994: POP
// ru_lab2_queue := pom ;
8995: LD_ADDR_EXP 41
8999: PUSH
9000: LD_VAR 0 4
9004: ST_TO_ADDR
// if not ru_lab2_queue then
9005: LD_EXP 41
9009: NOT
9010: IFFALSE 9029
// begin ru_lab2_queue := ru_lab2_upgrade ;
9012: LD_ADDR_EXP 41
9016: PUSH
9017: LD_EXP 43
9021: ST_TO_ADDR
// ru_lab2_upgrade := [ ] ;
9022: LD_ADDR_EXP 43
9026: PUSH
9027: EMPTY
9028: ST_TO_ADDR
// end ; end ;
9029: LD_VAR 0 1
9033: RET
// on ResearchComplete ( research_done , laboratory ) do begin case laboratory of ru_lab1 :
9034: LD_VAR 0 2
9038: PUSH
9039: LD_INT 14
9041: DOUBLE
9042: EQUAL
9043: IFTRUE 9047
9045: GO 9058
9047: POP
// research_1 := false ; ru_lab2 :
9048: LD_ADDR_EXP 44
9052: PUSH
9053: LD_INT 0
9055: ST_TO_ADDR
9056: GO 9078
9058: LD_INT 15
9060: DOUBLE
9061: EQUAL
9062: IFTRUE 9066
9064: GO 9077
9066: POP
// research_2 := false ; end ;
9067: LD_ADDR_EXP 45
9071: PUSH
9072: LD_INT 0
9074: ST_TO_ADDR
9075: GO 9078
9077: POP
// end ;
9078: PPOPN 2
9080: END
// function vyrovnej_vedecke_sily ; var un , un1 , un2 , i , move_to , how_much ; begin
9081: LD_INT 0
9083: PPUSH
9084: PPUSH
9085: PPUSH
9086: PPUSH
9087: PPUSH
9088: PPUSH
9089: PPUSH
// un1 := 0 + UnitsInside ( ru_lab1 ) ;
9090: LD_ADDR_VAR 0 3
9094: PUSH
9095: LD_INT 0
9097: PUSH
9098: LD_INT 14
9100: PPUSH
9101: CALL_OW 313
9105: PLUS
9106: ST_TO_ADDR
// un2 := 0 + UnitsInside ( ru_lab2 ) ;
9107: LD_ADDR_VAR 0 4
9111: PUSH
9112: LD_INT 0
9114: PUSH
9115: LD_INT 15
9117: PPUSH
9118: CALL_OW 313
9122: PLUS
9123: ST_TO_ADDR
// if un1 >= un2 then
9124: LD_VAR 0 3
9128: PUSH
9129: LD_VAR 0 4
9133: GREATEREQUAL
9134: IFFALSE 9177
// begin move_to := ru_lab2 ;
9136: LD_ADDR_VAR 0 6
9140: PUSH
9141: LD_INT 15
9143: ST_TO_ADDR
// how_much := ( un1 - un2 ) div 2 ;
9144: LD_ADDR_VAR 0 7
9148: PUSH
9149: LD_VAR 0 3
9153: PUSH
9154: LD_VAR 0 4
9158: MINUS
9159: PUSH
9160: LD_INT 2
9162: DIV
9163: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9164: LD_ADDR_VAR 0 2
9168: PUSH
9169: LD_INT 14
9171: PPUSH
9172: CALL_OW 313
9176: ST_TO_ADDR
// end ; if un1 < un2 then
9177: LD_VAR 0 3
9181: PUSH
9182: LD_VAR 0 4
9186: LESS
9187: IFFALSE 9230
// begin move_to := ru_lab1 ;
9189: LD_ADDR_VAR 0 6
9193: PUSH
9194: LD_INT 14
9196: ST_TO_ADDR
// how_much := ( un2 - un1 ) div 2 ;
9197: LD_ADDR_VAR 0 7
9201: PUSH
9202: LD_VAR 0 4
9206: PUSH
9207: LD_VAR 0 3
9211: MINUS
9212: PUSH
9213: LD_INT 2
9215: DIV
9216: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
9217: LD_ADDR_VAR 0 2
9221: PUSH
9222: LD_INT 15
9224: PPUSH
9225: CALL_OW 313
9229: ST_TO_ADDR
// end ; for i := 1 to how_much do
9230: LD_ADDR_VAR 0 5
9234: PUSH
9235: DOUBLE
9236: LD_INT 1
9238: DEC
9239: ST_TO_ADDR
9240: LD_VAR 0 7
9244: PUSH
9245: FOR_TO
9246: IFFALSE 9285
// begin ComExitBuilding ( un [ i ] ) ;
9248: LD_VAR 0 2
9252: PUSH
9253: LD_VAR 0 5
9257: ARRAY
9258: PPUSH
9259: CALL_OW 122
// AddComEnterUnit ( un [ i ] , move_to ) ;
9263: LD_VAR 0 2
9267: PUSH
9268: LD_VAR 0 5
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 6
9278: PPUSH
9279: CALL_OW 180
// end ;
9283: GO 9245
9285: POP
9286: POP
// end ;
9287: LD_VAR 0 1
9291: RET
// every 0 0$15 trigger UnitsInside ( ru_lab1 ) and not research_1 do var un , i , j ;
9292: LD_INT 14
9294: PPUSH
9295: CALL_OW 313
9299: PUSH
9300: LD_EXP 44
9304: NOT
9305: AND
9306: IFFALSE 9627
9308: GO 9310
9310: DISABLE
9311: LD_INT 0
9313: PPUSH
9314: PPUSH
9315: PPUSH
// begin un := UnitsInside ( ru_lab1 ) ;
9316: LD_ADDR_VAR 0 1
9320: PUSH
9321: LD_INT 14
9323: PPUSH
9324: CALL_OW 313
9328: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9329: LD_VAR 0 1
9333: PPUSH
9334: LD_INT 4
9336: PPUSH
9337: CALL_OW 336
// if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9341: LD_EXP 40
9345: PUSH
9346: LD_EXP 42
9350: AND
9351: IFFALSE 9377
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9353: LD_INT 14
9355: PPUSH
9356: LD_EXP 40
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: CALL_OW 124
// research_1 := true ;
9369: LD_ADDR_EXP 44
9373: PUSH
9374: LD_INT 1
9376: ST_TO_ADDR
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9377: LD_EXP 40
9381: PUSH
9382: LD_EXP 42
9386: NOT
9387: AND
9388: IFFALSE 9521
// begin if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9390: LD_EXP 41
9394: PUSH
9395: LD_EXP 43
9399: AND
9400: IFFALSE 9436
// begin un := UnitsInside ( ru_lab1 ) ;
9402: LD_ADDR_VAR 0 1
9406: PUSH
9407: LD_INT 14
9409: PPUSH
9410: CALL_OW 313
9414: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9415: LD_VAR 0 1
9419: PPUSH
9420: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9424: LD_VAR 0 1
9428: PPUSH
9429: LD_INT 15
9431: PPUSH
9432: CALL_OW 180
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9436: LD_EXP 41
9440: PUSH
9441: LD_EXP 43
9445: NOT
9446: AND
9447: IFFALSE 9484
// begin vyrovnej_vedecke_sily ;
9449: CALL 9081 0 0
// wait ( 0 0$5 ) ;
9453: LD_INT 175
9455: PPUSH
9456: CALL_OW 67
// ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9460: LD_INT 14
9462: PPUSH
9463: LD_EXP 40
9467: PUSH
9468: LD_INT 1
9470: ARRAY
9471: PPUSH
9472: CALL_OW 124
// research_1 := true ;
9476: LD_ADDR_EXP 44
9480: PUSH
9481: LD_INT 1
9483: ST_TO_ADDR
// end ; if not ( ru_lab2_queue or ru_lab2_upgrade ) then
9484: LD_EXP 41
9488: PUSH
9489: LD_EXP 43
9493: OR
9494: NOT
9495: IFFALSE 9521
// begin ComResearch ( ru_lab1 , ru_lab1_queue [ 1 ] ) ;
9497: LD_INT 14
9499: PPUSH
9500: LD_EXP 40
9504: PUSH
9505: LD_INT 1
9507: ARRAY
9508: PPUSH
9509: CALL_OW 124
// research_1 := true ;
9513: LD_ADDR_EXP 44
9517: PUSH
9518: LD_INT 1
9520: ST_TO_ADDR
// end ; end ; if research_1 then
9521: LD_EXP 44
9525: IFFALSE 9531
// change_technology_lab1 ;
9527: CALL 8800 0 0
// soucet1 := 0 + ru_lab1_queue + ru_lab1_upgrade ;
9531: LD_ADDR_LOC 8
9535: PUSH
9536: LD_INT 0
9538: PUSH
9539: LD_EXP 40
9543: PLUS
9544: PUSH
9545: LD_EXP 42
9549: PLUS
9550: ST_TO_ADDR
// if ( soucet1 = 0 ) and ( not research_1 ) then
9551: LD_LOC 8
9555: PUSH
9556: LD_INT 0
9558: EQUAL
9559: PUSH
9560: LD_EXP 44
9564: NOT
9565: AND
9566: IFFALSE 9610
// begin finished_1 := true ;
9568: LD_ADDR_LOC 6
9572: PUSH
9573: LD_INT 1
9575: ST_TO_ADDR
// un := UnitsInside ( ru_lab1 ) ;
9576: LD_ADDR_VAR 0 1
9580: PUSH
9581: LD_INT 14
9583: PPUSH
9584: CALL_OW 313
9588: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9589: LD_VAR 0 1
9593: PPUSH
9594: CALL_OW 122
// AddComEnterUnit ( un , ru_lab2 ) ;
9598: LD_VAR 0 1
9602: PPUSH
9603: LD_INT 15
9605: PPUSH
9606: CALL_OW 180
// end ; if ( soucet1 > 0 ) or research_1 then
9610: LD_LOC 8
9614: PUSH
9615: LD_INT 0
9617: GREATER
9618: PUSH
9619: LD_EXP 44
9623: OR
9624: IFFALSE 9627
// enable ;
9626: ENABLE
// end ;
9627: PPOPN 3
9629: END
// every 0 0$15 trigger UnitsInside ( ru_lab2 ) and not research_2 do var un , i , j ;
9630: LD_INT 15
9632: PPUSH
9633: CALL_OW 313
9637: PUSH
9638: LD_EXP 45
9642: NOT
9643: AND
9644: IFFALSE 9965
9646: GO 9648
9648: DISABLE
9649: LD_INT 0
9651: PPUSH
9652: PPUSH
9653: PPUSH
// begin un := UnitsInside ( ru_lab2 ) ;
9654: LD_ADDR_VAR 0 1
9658: PUSH
9659: LD_INT 15
9661: PPUSH
9662: CALL_OW 313
9666: ST_TO_ADDR
// SetClass ( un , class_scientistic ) ;
9667: LD_VAR 0 1
9671: PPUSH
9672: LD_INT 4
9674: PPUSH
9675: CALL_OW 336
// if ( ru_lab2_queue ) and ( ru_lab2_upgrade ) then
9679: LD_EXP 41
9683: PUSH
9684: LD_EXP 43
9688: AND
9689: IFFALSE 9715
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9691: LD_INT 15
9693: PPUSH
9694: LD_EXP 41
9698: PUSH
9699: LD_INT 1
9701: ARRAY
9702: PPUSH
9703: CALL_OW 124
// research_2 := true ;
9707: LD_ADDR_EXP 45
9711: PUSH
9712: LD_INT 1
9714: ST_TO_ADDR
// end ; if ( ru_lab2_queue ) and ( not ru_lab2_upgrade ) then
9715: LD_EXP 41
9719: PUSH
9720: LD_EXP 43
9724: NOT
9725: AND
9726: IFFALSE 9859
// begin if ( ru_lab1_queue ) and ( ru_lab1_upgrade ) then
9728: LD_EXP 40
9732: PUSH
9733: LD_EXP 42
9737: AND
9738: IFFALSE 9774
// begin un := UnitsInside ( ru_lab2 ) ;
9740: LD_ADDR_VAR 0 1
9744: PUSH
9745: LD_INT 15
9747: PPUSH
9748: CALL_OW 313
9752: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9753: LD_VAR 0 1
9757: PPUSH
9758: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
9762: LD_VAR 0 1
9766: PPUSH
9767: LD_INT 14
9769: PPUSH
9770: CALL_OW 180
// end ; if ( ru_lab1_queue ) and ( not ru_lab1_upgrade ) then
9774: LD_EXP 40
9778: PUSH
9779: LD_EXP 42
9783: NOT
9784: AND
9785: IFFALSE 9822
// begin vyrovnej_vedecke_sily ;
9787: CALL 9081 0 0
// wait ( 0 0$5 ) ;
9791: LD_INT 175
9793: PPUSH
9794: CALL_OW 67
// ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9798: LD_INT 15
9800: PPUSH
9801: LD_EXP 41
9805: PUSH
9806: LD_INT 1
9808: ARRAY
9809: PPUSH
9810: CALL_OW 124
// research_2 := true ;
9814: LD_ADDR_EXP 45
9818: PUSH
9819: LD_INT 1
9821: ST_TO_ADDR
// end ; if not ( ru_lab1_queue or ru_lab1_upgrade ) then
9822: LD_EXP 40
9826: PUSH
9827: LD_EXP 42
9831: OR
9832: NOT
9833: IFFALSE 9859
// begin ComResearch ( ru_lab2 , ru_lab2_queue [ 1 ] ) ;
9835: LD_INT 15
9837: PPUSH
9838: LD_EXP 41
9842: PUSH
9843: LD_INT 1
9845: ARRAY
9846: PPUSH
9847: CALL_OW 124
// research_2 := true ;
9851: LD_ADDR_EXP 45
9855: PUSH
9856: LD_INT 1
9858: ST_TO_ADDR
// end ; end ; if research_2 then
9859: LD_EXP 45
9863: IFFALSE 9869
// change_technology_lab2 ;
9865: CALL 8917 0 0
// soucet2 := 0 + ru_lab2_queue + ru_lab2_upgrade ;
9869: LD_ADDR_LOC 9
9873: PUSH
9874: LD_INT 0
9876: PUSH
9877: LD_EXP 41
9881: PLUS
9882: PUSH
9883: LD_EXP 43
9887: PLUS
9888: ST_TO_ADDR
// if ( soucet2 = 0 ) and ( not research_2 ) then
9889: LD_LOC 9
9893: PUSH
9894: LD_INT 0
9896: EQUAL
9897: PUSH
9898: LD_EXP 45
9902: NOT
9903: AND
9904: IFFALSE 9948
// begin finished_2 := true ;
9906: LD_ADDR_LOC 7
9910: PUSH
9911: LD_INT 1
9913: ST_TO_ADDR
// un := UnitsInside ( ru_lab2 ) ;
9914: LD_ADDR_VAR 0 1
9918: PUSH
9919: LD_INT 15
9921: PPUSH
9922: CALL_OW 313
9926: ST_TO_ADDR
// ComExitBuilding ( un ) ;
9927: LD_VAR 0 1
9931: PPUSH
9932: CALL_OW 122
// AddComEnterUnit ( un , ru_lab1 ) ;
9936: LD_VAR 0 1
9940: PPUSH
9941: LD_INT 14
9943: PPUSH
9944: CALL_OW 180
// end ; if ( soucet2 > 0 ) or research_2 then
9948: LD_LOC 9
9952: PUSH
9953: LD_INT 0
9955: GREATER
9956: PUSH
9957: LD_EXP 45
9961: OR
9962: IFFALSE 9965
// enable ;
9964: ENABLE
// end ;
9965: PPOPN 3
9967: END
// every 0 0$10 trigger finished_1 and finished_2 do var un , sci , i , build ;
9968: LD_LOC 6
9972: PUSH
9973: LD_LOC 7
9977: AND
9978: IFFALSE 10245
9980: GO 9982
9982: DISABLE
9983: LD_INT 0
9985: PPUSH
9986: PPUSH
9987: PPUSH
9988: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
9989: LD_ADDR_VAR 0 2
9993: PUSH
9994: LD_INT 22
9996: PUSH
9997: LD_EXP 15
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 25
10008: PUSH
10009: LD_INT 4
10011: PUSH
10012: EMPTY
10013: LIST
10014: LIST
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: PPUSH
10020: CALL_OW 69
10024: ST_TO_ADDR
// ComExitBuilding ( sci ) ;
10025: LD_VAR 0 2
10029: PPUSH
10030: CALL_OW 122
// build := FilterAllUnits ( [ [ f_side , russians ] , [ f_btype , b_factory ] ] ) ;
10034: LD_ADDR_VAR 0 4
10038: PUSH
10039: LD_INT 22
10041: PUSH
10042: LD_EXP 15
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: LD_INT 30
10053: PUSH
10054: LD_INT 3
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: PPUSH
10065: CALL_OW 69
10069: ST_TO_ADDR
// if build then
10070: LD_VAR 0 4
10074: IFFALSE 10147
// begin i := 1 ;
10076: LD_ADDR_VAR 0 3
10080: PUSH
10081: LD_INT 1
10083: ST_TO_ADDR
// for un in sci do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10143
// begin ComEnterUnit ( un , build [ ( i mod build ) + 1 ] ) ;
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_VAR 0 4
10106: PUSH
10107: LD_VAR 0 3
10111: PUSH
10112: LD_VAR 0 4
10116: MOD
10117: PUSH
10118: LD_INT 1
10120: PLUS
10121: ARRAY
10122: PPUSH
10123: CALL_OW 120
// i := i + 1 ;
10127: LD_ADDR_VAR 0 3
10131: PUSH
10132: LD_VAR 0 3
10136: PUSH
10137: LD_INT 1
10139: PLUS
10140: ST_TO_ADDR
// end ;
10141: GO 10094
10143: POP
10144: POP
// end else
10145: GO 10245
// begin build := FilterAllUnits ( [ [ f_side , russians ] , [ f_or , [ f_btype , b_barracks ] , [ f_btype , b_armoury ] ] ] ) ;
10147: LD_ADDR_VAR 0 4
10151: PUSH
10152: LD_INT 22
10154: PUSH
10155: LD_EXP 15
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 2
10166: PUSH
10167: LD_INT 30
10169: PUSH
10170: LD_INT 5
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: PUSH
10177: LD_INT 30
10179: PUSH
10180: LD_INT 4
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: EMPTY
10193: LIST
10194: LIST
10195: PPUSH
10196: CALL_OW 69
10200: ST_TO_ADDR
// if build then
10201: LD_VAR 0 4
10205: IFFALSE 10245
// begin ComEnterUnit ( sci , build ) ;
10207: LD_VAR 0 2
10211: PPUSH
10212: LD_VAR 0 4
10216: PPUSH
10217: CALL_OW 120
// AddComChangeProfession ( sci , class_soldier ) ;
10221: LD_VAR 0 2
10225: PPUSH
10226: LD_INT 1
10228: PPUSH
10229: CALL_OW 183
// AddComChangeProfession ( sci , class_bazooker ) ;
10233: LD_VAR 0 2
10237: PPUSH
10238: LD_INT 9
10240: PPUSH
10241: CALL_OW 183
// end ; end ; end ; end_of_file
10245: PPOPN 4
10247: END
// export base_crates , base_oil , base_siberit ; export busy_fact1 , busy_fact2 ; export vyber_pro_tovarnu ; var hotove_vozidlo , volna_tovarna ; var cekat_dodavku ; var time_fact1 , time_fact2 ; var no_siberit ; var factory1_idle , factory2_idle ; export function startup_manufacturing ; begin
10248: LD_INT 0
10250: PPUSH
// busy_fact1 := false ;
10251: LD_ADDR_EXP 49
10255: PUSH
10256: LD_INT 0
10258: ST_TO_ADDR
// busy_fact2 := false ;
10259: LD_ADDR_EXP 50
10263: PUSH
10264: LD_INT 0
10266: ST_TO_ADDR
// time_fact1 := Rand ( 0 0$2 , 0 0$10 ) ;
10267: LD_ADDR_LOC 13
10271: PUSH
10272: LD_INT 70
10274: PPUSH
10275: LD_INT 350
10277: PPUSH
10278: CALL_OW 12
10282: ST_TO_ADDR
// time_fact2 := Rand ( 0 0$2 , 0 0$10 ) ;
10283: LD_ADDR_LOC 14
10287: PUSH
10288: LD_INT 70
10290: PPUSH
10291: LD_INT 350
10293: PPUSH
10294: CALL_OW 12
10298: ST_TO_ADDR
// end ;
10299: LD_VAR 0 1
10303: RET
// function zjisti_zdroje ; var base ; begin
10304: LD_INT 0
10306: PPUSH
10307: PPUSH
// base := GetBase ( ru_depot ) ;
10308: LD_ADDR_VAR 0 2
10312: PUSH
10313: LD_INT 22
10315: PPUSH
10316: CALL_OW 274
10320: ST_TO_ADDR
// base_crates := GetResourceType ( base , mat_cans ) ;
10321: LD_ADDR_EXP 46
10325: PUSH
10326: LD_VAR 0 2
10330: PPUSH
10331: LD_INT 1
10333: PPUSH
10334: CALL_OW 275
10338: ST_TO_ADDR
// base_oil := GetResourceType ( base , mat_oil ) ;
10339: LD_ADDR_EXP 47
10343: PUSH
10344: LD_VAR 0 2
10348: PPUSH
10349: LD_INT 2
10351: PPUSH
10352: CALL_OW 275
10356: ST_TO_ADDR
// base_siberit := GetResourceType ( base , mat_siberit ) ;
10357: LD_ADDR_EXP 48
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: LD_INT 3
10369: PPUSH
10370: CALL_OW 275
10374: ST_TO_ADDR
// end ;
10375: LD_VAR 0 1
10379: RET
// every 0 0$2 trigger UnitsInside ( ru_fact1 ) and UnitsInside ( ru_fact2 ) marked 1 do var un ;
10380: LD_INT 1
10382: PPUSH
10383: CALL_OW 313
10387: PUSH
10388: LD_INT 40
10390: PPUSH
10391: CALL_OW 313
10395: AND
10396: IFFALSE 10428
10398: GO 10400
10400: DISABLE
10401: LD_INT 0
10403: PPUSH
// begin ComRemember ( UnitsInside ( ru_fact1 ) ) ;
10404: LD_INT 1
10406: PPUSH
10407: CALL_OW 313
10411: PPUSH
10412: CALL_OW 143
// ComRemember ( UnitsInside ( ru_fact2 ) ) ;
10416: LD_INT 40
10418: PPUSH
10419: CALL_OW 313
10423: PPUSH
10424: CALL_OW 143
// end ;
10428: PPOPN 1
10430: END
// function vyber_komponenty ; var specialni ; begin
10431: LD_INT 0
10433: PPUSH
10434: PPUSH
// cekat_dodavku := true ;
10435: LD_ADDR_LOC 12
10439: PUSH
10440: LD_INT 1
10442: ST_TO_ADDR
// specialni := false ;
10443: LD_ADDR_VAR 0 2
10447: PUSH
10448: LD_INT 0
10450: ST_TO_ADDR
// no_siberit := false ;
10451: LD_ADDR_LOC 15
10455: PUSH
10456: LD_INT 0
10458: ST_TO_ADDR
// zjisti_pozadavky ;
10459: CALL 11852 0 0
// if 1 = 2 then
10463: LD_INT 1
10465: PUSH
10466: LD_INT 2
10468: EQUAL
10469: IFFALSE 10726
// begin case chybi of 1 :
10471: LD_EXP 62
10475: PUSH
10476: LD_INT 1
10478: DOUBLE
10479: EQUAL
10480: IFTRUE 10484
10482: GO 10559
10484: POP
// begin if ( base_crates >= 55 ) then
10485: LD_EXP 46
10489: PUSH
10490: LD_INT 55
10492: GREATEREQUAL
10493: IFFALSE 10505
// vc_chassis := ru_heavy_tracked else
10495: LD_ADDR_OWVAR 37
10499: PUSH
10500: LD_INT 24
10502: ST_TO_ADDR
10503: GO 10513
// vc_chassis := ru_heavy_wheeled ;
10505: LD_ADDR_OWVAR 37
10509: PUSH
10510: LD_INT 23
10512: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10513: LD_ADDR_OWVAR 40
10517: PUSH
10518: LD_INT 49
10520: ST_TO_ADDR
// vc_control := control_computer ;
10521: LD_ADDR_OWVAR 38
10525: PUSH
10526: LD_INT 3
10528: ST_TO_ADDR
// if ( base_siberit >= 60 ) then
10529: LD_EXP 48
10533: PUSH
10534: LD_INT 60
10536: GREATEREQUAL
10537: IFFALSE 10549
// vc_engine := engine_siberite else
10539: LD_ADDR_OWVAR 39
10543: PUSH
10544: LD_INT 3
10546: ST_TO_ADDR
10547: GO 10557
// vc_engine := engine_combustion ;
10549: LD_ADDR_OWVAR 39
10553: PUSH
10554: LD_INT 1
10556: ST_TO_ADDR
// end ; 2 :
10557: GO 10716
10559: LD_INT 2
10561: DOUBLE
10562: EQUAL
10563: IFTRUE 10567
10565: GO 10602
10567: POP
// begin vc_chassis := ru_heavy_tracked ;
10568: LD_ADDR_OWVAR 37
10572: PUSH
10573: LD_INT 24
10575: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10576: LD_ADDR_OWVAR 40
10580: PUSH
10581: LD_INT 49
10583: ST_TO_ADDR
// vc_control := control_manual ;
10584: LD_ADDR_OWVAR 38
10588: PUSH
10589: LD_INT 1
10591: ST_TO_ADDR
// vc_engine := engine_siberite ;
10592: LD_ADDR_OWVAR 39
10596: PUSH
10597: LD_INT 3
10599: ST_TO_ADDR
// end ; 3 :
10600: GO 10716
10602: LD_INT 3
10604: DOUBLE
10605: EQUAL
10606: IFTRUE 10610
10608: GO 10715
10610: POP
// begin vc_chassis := ru_heavy_tracked ;
10611: LD_ADDR_OWVAR 37
10615: PUSH
10616: LD_INT 24
10618: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
10619: LD_ADDR_OWVAR 40
10623: PUSH
10624: LD_INT 46
10626: ST_TO_ADDR
// if base_crates < 70 then
10627: LD_EXP 46
10631: PUSH
10632: LD_INT 70
10634: LESS
10635: IFFALSE 10645
// vc_chassis := ru_heavy_wheeled ;
10637: LD_ADDR_OWVAR 37
10641: PUSH
10642: LD_INT 23
10644: ST_TO_ADDR
// if base_crates < 60 then
10645: LD_EXP 46
10649: PUSH
10650: LD_INT 60
10652: LESS
10653: IFFALSE 10671
// begin vc_weapon := ru_rocket ;
10655: LD_ADDR_OWVAR 40
10659: PUSH
10660: LD_INT 47
10662: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10663: LD_ADDR_OWVAR 37
10667: PUSH
10668: LD_INT 24
10670: ST_TO_ADDR
// end ; if base_crates < 55 then
10671: LD_EXP 46
10675: PUSH
10676: LD_INT 55
10678: LESS
10679: IFFALSE 10689
// vc_chassis := ru_heavy_wheeled ;
10681: LD_ADDR_OWVAR 37
10685: PUSH
10686: LD_INT 23
10688: ST_TO_ADDR
// vc_weapon := ru_time_lapser ;
10689: LD_ADDR_OWVAR 40
10693: PUSH
10694: LD_INT 49
10696: ST_TO_ADDR
// vc_control := control_manual ;
10697: LD_ADDR_OWVAR 38
10701: PUSH
10702: LD_INT 1
10704: ST_TO_ADDR
// vc_engine := engine_siberite ;
10705: LD_ADDR_OWVAR 39
10709: PUSH
10710: LD_INT 3
10712: ST_TO_ADDR
// end ; end ;
10713: GO 10716
10715: POP
// specialni := true ;
10716: LD_ADDR_VAR 0 2
10720: PUSH
10721: LD_INT 1
10723: ST_TO_ADDR
// end else
10724: GO 10726
// begin end ; if ( base_crates < 65 ) and ( not specialni ) then
10726: LD_EXP 46
10730: PUSH
10731: LD_INT 65
10733: LESS
10734: PUSH
10735: LD_VAR 0 2
10739: NOT
10740: AND
10741: IFFALSE 10829
// begin cekat_dodavku := false ;
10743: LD_ADDR_LOC 12
10747: PUSH
10748: LD_INT 0
10750: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
10751: LD_ADDR_OWVAR 40
10755: PUSH
10756: LD_INT 45
10758: ST_TO_ADDR
// vc_chassis := ru_medium_tracked ;
10759: LD_ADDR_OWVAR 37
10763: PUSH
10764: LD_INT 22
10766: ST_TO_ADDR
// if base_crates < 60 then
10767: LD_EXP 46
10771: PUSH
10772: LD_INT 60
10774: LESS
10775: IFFALSE 10785
// vc_chassis := ru_medium_wheeled ;
10777: LD_ADDR_OWVAR 37
10781: PUSH
10782: LD_INT 21
10784: ST_TO_ADDR
// if base_crates < 55 then
10785: LD_EXP 46
10789: PUSH
10790: LD_INT 55
10792: LESS
10793: IFFALSE 10811
// begin vc_chassis := ru_medium_tracked ;
10795: LD_ADDR_OWVAR 37
10799: PUSH
10800: LD_INT 22
10802: ST_TO_ADDR
// vc_weapon := ru_gatling_gun ;
10803: LD_ADDR_OWVAR 40
10807: PUSH
10808: LD_INT 43
10810: ST_TO_ADDR
// end ; if base_crates < 50 then
10811: LD_EXP 46
10815: PUSH
10816: LD_INT 50
10818: LESS
10819: IFFALSE 10829
// vc_chassis := ru_medium_wheeled ;
10821: LD_ADDR_OWVAR 37
10825: PUSH
10826: LD_INT 21
10828: ST_TO_ADDR
// end ; if ( base_crates >= 65 ) and ( vyber_pro_tovarnu = 1 ) and ( not specialni ) then
10829: LD_EXP 46
10833: PUSH
10834: LD_INT 65
10836: GREATEREQUAL
10837: PUSH
10838: LD_EXP 51
10842: PUSH
10843: LD_INT 1
10845: EQUAL
10846: AND
10847: PUSH
10848: LD_VAR 0 2
10852: NOT
10853: AND
10854: IFFALSE 10942
// begin cekat_dodavku := false ;
10856: LD_ADDR_LOC 12
10860: PUSH
10861: LD_INT 0
10863: ST_TO_ADDR
// vc_weapon := ru_heavy_gun ;
10864: LD_ADDR_OWVAR 40
10868: PUSH
10869: LD_INT 46
10871: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10872: LD_ADDR_OWVAR 37
10876: PUSH
10877: LD_INT 24
10879: ST_TO_ADDR
// if base_crates < 80 then
10880: LD_EXP 46
10884: PUSH
10885: LD_INT 80
10887: LESS
10888: IFFALSE 10898
// vc_chassis := ru_heavy_wheeled ;
10890: LD_ADDR_OWVAR 37
10894: PUSH
10895: LD_INT 23
10897: ST_TO_ADDR
// if base_crates < 70 then
10898: LD_EXP 46
10902: PUSH
10903: LD_INT 70
10905: LESS
10906: IFFALSE 10924
// begin vc_weapon := ru_rocket ;
10908: LD_ADDR_OWVAR 40
10912: PUSH
10913: LD_INT 47
10915: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10916: LD_ADDR_OWVAR 37
10920: PUSH
10921: LD_INT 24
10923: ST_TO_ADDR
// end ; if base_crates < 65 then
10924: LD_EXP 46
10928: PUSH
10929: LD_INT 65
10931: LESS
10932: IFFALSE 10942
// vc_chassis := ru_heavy_wheeled ;
10934: LD_ADDR_OWVAR 37
10938: PUSH
10939: LD_INT 23
10941: ST_TO_ADDR
// end ; if ( base_crates >= 70 ) and ( vyber_pro_tovarnu = 2 ) and ( not specialni ) then
10942: LD_EXP 46
10946: PUSH
10947: LD_INT 70
10949: GREATEREQUAL
10950: PUSH
10951: LD_EXP 51
10955: PUSH
10956: LD_INT 2
10958: EQUAL
10959: AND
10960: PUSH
10961: LD_VAR 0 2
10965: NOT
10966: AND
10967: IFFALSE 11011
// begin cekat_dodavku := false ;
10969: LD_ADDR_LOC 12
10973: PUSH
10974: LD_INT 0
10976: ST_TO_ADDR
// vc_weapon := ru_rocket ;
10977: LD_ADDR_OWVAR 40
10981: PUSH
10982: LD_INT 47
10984: ST_TO_ADDR
// vc_chassis := ru_heavy_tracked ;
10985: LD_ADDR_OWVAR 37
10989: PUSH
10990: LD_INT 24
10992: ST_TO_ADDR
// if base_crates < 75 then
10993: LD_EXP 46
10997: PUSH
10998: LD_INT 75
11000: LESS
11001: IFFALSE 11011
// vc_chassis := ru_heavy_wheeled ;
11003: LD_ADDR_OWVAR 37
11007: PUSH
11008: LD_INT 23
11010: ST_TO_ADDR
// end ; if not specialni then
11011: LD_VAR 0 2
11015: NOT
11016: IFFALSE 11097
// begin vc_control := control_computer ;
11018: LD_ADDR_OWVAR 38
11022: PUSH
11023: LD_INT 3
11025: ST_TO_ADDR
// if ( vc_chassis > 22 ) and ( base_siberit >= 10 ) and ( not no_siberit ) then
11026: LD_OWVAR 37
11030: PUSH
11031: LD_INT 22
11033: GREATER
11034: PUSH
11035: LD_EXP 48
11039: PUSH
11040: LD_INT 10
11042: GREATEREQUAL
11043: AND
11044: PUSH
11045: LD_LOC 15
11049: NOT
11050: AND
11051: IFFALSE 11071
// begin vc_engine := engine_siberite ;
11053: LD_ADDR_OWVAR 39
11057: PUSH
11058: LD_INT 3
11060: ST_TO_ADDR
// cekat_dodavku := false ;
11061: LD_ADDR_LOC 12
11065: PUSH
11066: LD_INT 0
11068: ST_TO_ADDR
// end else
11069: GO 11097
// if base_oil >= 30 then
11071: LD_EXP 47
11075: PUSH
11076: LD_INT 30
11078: GREATEREQUAL
11079: IFFALSE 11097
// begin vc_engine := engine_combustion ;
11081: LD_ADDR_OWVAR 39
11085: PUSH
11086: LD_INT 1
11088: ST_TO_ADDR
// cekat_dodavku := false ;
11089: LD_ADDR_LOC 12
11093: PUSH
11094: LD_INT 0
11096: ST_TO_ADDR
// end ; end ; end ;
11097: LD_VAR 0 1
11101: RET
// on VehicleConstructed ( hotove_vozidlo , volna_tovarna ) do begin if GetSide ( hotove_vozidlo ) = russians then
11102: LD_VAR 0 1
11106: PPUSH
11107: CALL_OW 255
11111: PUSH
11112: LD_EXP 15
11116: EQUAL
11117: IFFALSE 11216
// begin if GetControl ( hotove_vozidlo ) = control_manual then
11119: LD_VAR 0 1
11123: PPUSH
11124: CALL_OW 263
11128: PUSH
11129: LD_INT 1
11131: EQUAL
11132: IFFALSE 11150
// zaparkuj_vozidlo ( volna_tovarna , hotove_vozidlo ) else
11134: LD_VAR 0 2
11138: PPUSH
11139: LD_VAR 0 1
11143: PPUSH
11144: CALL 12005 0 2
11148: GO 11166
// war_forces := war_forces ^ hotove_vozidlo ;
11150: LD_ADDR_EXP 52
11154: PUSH
11155: LD_EXP 52
11159: PUSH
11160: LD_VAR 0 1
11164: ADD
11165: ST_TO_ADDR
// collect_war_forces ;
11166: CALL 12153 0 0
// case volna_tovarna of ru_fact1 :
11170: LD_VAR 0 2
11174: PUSH
11175: LD_INT 1
11177: DOUBLE
11178: EQUAL
11179: IFTRUE 11183
11181: GO 11194
11183: POP
// busy_fact1 := false ; ru_fact2 :
11184: LD_ADDR_EXP 49
11188: PUSH
11189: LD_INT 0
11191: ST_TO_ADDR
11192: GO 11214
11194: LD_INT 40
11196: DOUBLE
11197: EQUAL
11198: IFTRUE 11202
11200: GO 11213
11202: POP
// busy_fact2 := false ; end ;
11203: LD_ADDR_EXP 50
11207: PUSH
11208: LD_INT 0
11210: ST_TO_ADDR
11211: GO 11214
11213: POP
// end else
11214: GO 11284
// if GetWeapon ( hotove_vozidlo ) = us_double_laser then
11216: LD_VAR 0 1
11220: PPUSH
11221: CALL_OW 264
11225: PUSH
11226: LD_INT 10
11228: EQUAL
11229: IFFALSE 11284
// begin double_laser := double_laser + 1 ;
11231: LD_ADDR_EXP 17
11235: PUSH
11236: LD_EXP 17
11240: PUSH
11241: LD_INT 1
11243: PLUS
11244: ST_TO_ADDR
// if not double_hint then
11245: LD_EXP 18
11249: NOT
11250: IFFALSE 11267
// begin Hint ( DoubleLaser ) ;
11252: LD_STRING DoubleLaser
11254: PPUSH
11255: CALL_OW 339
// double_hint := true ;
11259: LD_ADDR_EXP 18
11263: PUSH
11264: LD_INT 1
11266: ST_TO_ADDR
// end ; if double_laser = 2 then
11267: LD_EXP 17
11271: PUSH
11272: LD_INT 2
11274: EQUAL
11275: IFFALSE 11284
// ChangeMissionObjectives ( M3a ) ;
11277: LD_STRING M3a
11279: PPUSH
11280: CALL_OW 337
// end ; end ;
11284: PPOPN 2
11286: END
// every 0 0$10 trigger UnitsInside ( ru_fact1 ) and ( not busy_fact1 ) and ( TICK >= time_fact1 ) do var un ;
11287: LD_INT 1
11289: PPUSH
11290: CALL_OW 313
11294: PUSH
11295: LD_EXP 49
11299: NOT
11300: AND
11301: PUSH
11302: LD_OWVAR 1
11306: PUSH
11307: LD_LOC 13
11311: GREATEREQUAL
11312: AND
11313: IFFALSE 11421
11315: GO 11317
11317: DISABLE
11318: LD_INT 0
11320: PPUSH
// begin zjisti_zdroje ;
11321: CALL 10304 0 0
// if base_crates >= 40 then
11325: LD_EXP 46
11329: PUSH
11330: LD_INT 40
11332: GREATEREQUAL
11333: IFFALSE 11398
// begin vyber_pro_tovarnu := 1 ;
11335: LD_ADDR_EXP 51
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// vyber_komponenty ;
11343: CALL 10431 0 0
// if not cekat_dodavku then
11347: LD_LOC 12
11351: NOT
11352: IFFALSE 11398
// begin ComConstruct ( ru_fact1 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11354: LD_INT 1
11356: PPUSH
11357: LD_OWVAR 37
11361: PPUSH
11362: LD_OWVAR 39
11366: PPUSH
11367: LD_OWVAR 38
11371: PPUSH
11372: LD_OWVAR 40
11376: PPUSH
11377: CALL_OW 125
// if IsBusy ( ru_fact1 ) then
11381: LD_INT 1
11383: PPUSH
11384: CALL_OW 315
11388: IFFALSE 11398
// busy_fact1 := true ;
11390: LD_ADDR_EXP 49
11394: PUSH
11395: LD_INT 1
11397: ST_TO_ADDR
// end ; end ; time_fact1 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11398: LD_ADDR_LOC 13
11402: PUSH
11403: LD_OWVAR 1
11407: PUSH
11408: LD_INT 1400
11410: PPUSH
11411: LD_INT 2100
11413: PPUSH
11414: CALL_OW 12
11418: PLUS
11419: ST_TO_ADDR
// enable ;
11420: ENABLE
// end ;
11421: PPOPN 1
11423: END
// every 0 0$10 trigger UnitsInside ( ru_fact2 ) and ( not busy_fact2 ) and ( TICK >= time_fact2 ) do var un ;
11424: LD_INT 40
11426: PPUSH
11427: CALL_OW 313
11431: PUSH
11432: LD_EXP 50
11436: NOT
11437: AND
11438: PUSH
11439: LD_OWVAR 1
11443: PUSH
11444: LD_LOC 14
11448: GREATEREQUAL
11449: AND
11450: IFFALSE 11558
11452: GO 11454
11454: DISABLE
11455: LD_INT 0
11457: PPUSH
// begin zjisti_zdroje ;
11458: CALL 10304 0 0
// if base_crates >= 40 then
11462: LD_EXP 46
11466: PUSH
11467: LD_INT 40
11469: GREATEREQUAL
11470: IFFALSE 11535
// begin vyber_pro_tovarnu := 2 ;
11472: LD_ADDR_EXP 51
11476: PUSH
11477: LD_INT 2
11479: ST_TO_ADDR
// vyber_komponenty ;
11480: CALL 10431 0 0
// if not cekat_dodavku then
11484: LD_LOC 12
11488: NOT
11489: IFFALSE 11535
// begin ComConstruct ( ru_fact2 , vc_chassis , vc_engine , vc_control , vc_weapon ) ;
11491: LD_INT 40
11493: PPUSH
11494: LD_OWVAR 37
11498: PPUSH
11499: LD_OWVAR 39
11503: PPUSH
11504: LD_OWVAR 38
11508: PPUSH
11509: LD_OWVAR 40
11513: PPUSH
11514: CALL_OW 125
// if IsBusy ( ru_fact2 ) then
11518: LD_INT 40
11520: PPUSH
11521: CALL_OW 315
11525: IFFALSE 11535
// busy_fact2 := true ;
11527: LD_ADDR_EXP 50
11531: PUSH
11532: LD_INT 1
11534: ST_TO_ADDR
// end ; end ; time_fact2 := TICK + Rand ( 0 0$40 , 0 0$60 ) ;
11535: LD_ADDR_LOC 14
11539: PUSH
11540: LD_OWVAR 1
11544: PUSH
11545: LD_INT 1400
11547: PPUSH
11548: LD_INT 2100
11550: PPUSH
11551: CALL_OW 12
11555: PLUS
11556: ST_TO_ADDR
// enable ;
11557: ENABLE
// end ;
11558: PPOPN 1
11560: END
// every 0 0$10 trigger ( busy_fact1 ) and ( base_crates > 40 ) do
11561: LD_EXP 49
11565: PUSH
11566: LD_EXP 46
11570: PUSH
11571: LD_INT 40
11573: GREATER
11574: AND
11575: IFFALSE 11620
11577: GO 11579
11579: DISABLE
// begin factory1_idle := factory1_idle + 1 ;
11580: LD_ADDR_LOC 16
11584: PUSH
11585: LD_LOC 16
11589: PUSH
11590: LD_INT 1
11592: PLUS
11593: ST_TO_ADDR
// if factory1_idle > 10 then
11594: LD_LOC 16
11598: PUSH
11599: LD_INT 10
11601: GREATER
11602: IFFALSE 11620
// begin factory1_idle := 0 ;
11604: LD_ADDR_LOC 16
11608: PUSH
11609: LD_INT 0
11611: ST_TO_ADDR
// busy_fact1 := false ;
11612: LD_ADDR_EXP 49
11616: PUSH
11617: LD_INT 0
11619: ST_TO_ADDR
// end ; end ;
11620: END
// every 0 0$10 trigger ( busy_fact2 ) and ( base_crates > 40 ) do
11621: LD_EXP 50
11625: PUSH
11626: LD_EXP 46
11630: PUSH
11631: LD_INT 40
11633: GREATER
11634: AND
11635: IFFALSE 11680
11637: GO 11639
11639: DISABLE
// begin factory2_idle := factory2_idle + 1 ;
11640: LD_ADDR_LOC 17
11644: PUSH
11645: LD_LOC 17
11649: PUSH
11650: LD_INT 1
11652: PLUS
11653: ST_TO_ADDR
// if factory2_idle > 10 then
11654: LD_LOC 17
11658: PUSH
11659: LD_INT 10
11661: GREATER
11662: IFFALSE 11680
// begin factory2_idle := 0 ;
11664: LD_ADDR_LOC 17
11668: PUSH
11669: LD_INT 0
11671: ST_TO_ADDR
// busy_fact2 := false ;
11672: LD_ADDR_EXP 50
11676: PUSH
11677: LD_INT 0
11679: ST_TO_ADDR
// end ; end ; end_of_file
11680: END
// export war_forces , war_lapser , war_count ; export attack_forces ; export backup_forces , backup_lapser , backup_count ; export manual_forces , manual_lapser ; export fuel_tank ; export chybi ; export mm_vehicle ; export defend_forces ; export us_important ; var klic_area_1 , klic_area_2 ; var klic_area_3 , klic_area_4 ; var klic_area_5 , klic_area_6 ; var klic_area_7 , klic_area_8 ; var klic_area_9 ; var destroy_now ; var important ; var multi ; var skrivanek ; var kolibrik ; var attack_begin ; var cislo_utoku ; var now_area , next_area ; var event_unit ; export function startup_war_definition ; begin
11681: LD_INT 0
11683: PPUSH
// war_forces := [ ] ;
11684: LD_ADDR_EXP 52
11688: PUSH
11689: EMPTY
11690: ST_TO_ADDR
// war_lapser := 0 ;
11691: LD_ADDR_EXP 53
11695: PUSH
11696: LD_INT 0
11698: ST_TO_ADDR
// war_count := Rand ( 2 , 3 ) ;
11699: LD_ADDR_EXP 54
11703: PUSH
11704: LD_INT 2
11706: PPUSH
11707: LD_INT 3
11709: PPUSH
11710: CALL_OW 12
11714: ST_TO_ADDR
// backup_forces := [ ] ;
11715: LD_ADDR_EXP 56
11719: PUSH
11720: EMPTY
11721: ST_TO_ADDR
// backup_lapser := 0 ;
11722: LD_ADDR_EXP 57
11726: PUSH
11727: LD_INT 0
11729: ST_TO_ADDR
// backup_count := Rand ( 2 , 3 ) ;
11730: LD_ADDR_EXP 58
11734: PUSH
11735: LD_INT 2
11737: PPUSH
11738: LD_INT 3
11740: PPUSH
11741: CALL_OW 12
11745: ST_TO_ADDR
// manual_forces := [ ] ;
11746: LD_ADDR_EXP 59
11750: PUSH
11751: EMPTY
11752: ST_TO_ADDR
// manual_lapser := 0 ;
11753: LD_ADDR_EXP 60
11757: PUSH
11758: LD_INT 0
11760: ST_TO_ADDR
// defend_forces := [ ] ;
11761: LD_ADDR_EXP 64
11765: PUSH
11766: EMPTY
11767: ST_TO_ADDR
// klic_area_1 := [ ] ;
11768: LD_ADDR_LOC 18
11772: PUSH
11773: EMPTY
11774: ST_TO_ADDR
// klic_area_2 := [ ] ;
11775: LD_ADDR_LOC 19
11779: PUSH
11780: EMPTY
11781: ST_TO_ADDR
// klic_area_3 := [ ] ;
11782: LD_ADDR_LOC 20
11786: PUSH
11787: EMPTY
11788: ST_TO_ADDR
// klic_area_4 := [ ] ;
11789: LD_ADDR_LOC 21
11793: PUSH
11794: EMPTY
11795: ST_TO_ADDR
// klic_area_5 := [ ] ;
11796: LD_ADDR_LOC 22
11800: PUSH
11801: EMPTY
11802: ST_TO_ADDR
// klic_area_6 := [ ] ;
11803: LD_ADDR_LOC 23
11807: PUSH
11808: EMPTY
11809: ST_TO_ADDR
// klic_area_7 := [ ] ;
11810: LD_ADDR_LOC 24
11814: PUSH
11815: EMPTY
11816: ST_TO_ADDR
// klic_area_8 := [ ] ;
11817: LD_ADDR_LOC 25
11821: PUSH
11822: EMPTY
11823: ST_TO_ADDR
// klic_area_9 := [ ] ;
11824: LD_ADDR_LOC 26
11828: PUSH
11829: EMPTY
11830: ST_TO_ADDR
// cislo_utoku := 1 ;
11831: LD_ADDR_LOC 33
11835: PUSH
11836: LD_INT 1
11838: ST_TO_ADDR
// mm_vehicle := 0 ;
11839: LD_ADDR_EXP 63
11843: PUSH
11844: LD_INT 0
11846: ST_TO_ADDR
// end ;
11847: LD_VAR 0 1
11851: RET
// export function zjisti_pozadavky ; var vybrano ; var i ; begin
11852: LD_INT 0
11854: PPUSH
11855: PPUSH
11856: PPUSH
// chybi := 0 ;
11857: LD_ADDR_EXP 62
11861: PUSH
11862: LD_INT 0
11864: ST_TO_ADDR
// if manual_forces < russians_forces then
11865: LD_EXP 59
11869: PUSH
11870: LD_EXP 28
11874: LESS
11875: IFFALSE 11885
// chybi := 3 ;
11877: LD_ADDR_EXP 62
11881: PUSH
11882: LD_INT 3
11884: ST_TO_ADDR
// end ;
11885: LD_VAR 0 1
11889: RET
// every 5 5$0 trigger ( backup_forces < backup_count ) and ( war_forces > 0 ) do var hex ;
11890: LD_EXP 56
11894: PUSH
11895: LD_EXP 58
11899: LESS
11900: PUSH
11901: LD_EXP 52
11905: PUSH
11906: LD_INT 0
11908: GREATER
11909: AND
11910: IFFALSE 12002
11912: GO 11914
11914: DISABLE
11915: LD_INT 0
11917: PPUSH
// begin hex := RandHexArea ( parking_place , true ) ;
11918: LD_ADDR_VAR 0 1
11922: PUSH
11923: LD_INT 11
11925: PPUSH
11926: LD_INT 1
11928: PPUSH
11929: CALL_OW 16
11933: ST_TO_ADDR
// backup_forces := backup_forces ^ ( war_forces [ 1 ] ) ;
11934: LD_ADDR_EXP 56
11938: PUSH
11939: LD_EXP 56
11943: PUSH
11944: LD_EXP 52
11948: PUSH
11949: LD_INT 1
11951: ARRAY
11952: ADD
11953: ST_TO_ADDR
// ComAgressiveMove ( war_forces [ 1 ] , hex [ 1 ] , hex [ 2 ] ) ;
11954: LD_EXP 52
11958: PUSH
11959: LD_INT 1
11961: ARRAY
11962: PPUSH
11963: LD_VAR 0 1
11967: PUSH
11968: LD_INT 1
11970: ARRAY
11971: PPUSH
11972: LD_VAR 0 1
11976: PUSH
11977: LD_INT 2
11979: ARRAY
11980: PPUSH
11981: CALL_OW 114
// war_forces := war_forces diff backup_forces ;
11985: LD_ADDR_EXP 52
11989: PUSH
11990: LD_EXP 52
11994: PUSH
11995: LD_EXP 56
11999: DIFF
12000: ST_TO_ADDR
// enable ;
12001: ENABLE
// end ;
12002: PPOPN 1
12004: END
// export function zaparkuj_vozidlo ( puvod_ridice , vozidlo ) ; var ridic , hex ; begin
12005: LD_INT 0
12007: PPUSH
12008: PPUSH
12009: PPUSH
// manual_forces := manual_forces ^ vozidlo ;
12010: LD_ADDR_EXP 59
12014: PUSH
12015: LD_EXP 59
12019: PUSH
12020: LD_VAR 0 2
12024: ADD
12025: ST_TO_ADDR
// hex := RandHexArea ( parking_place , true ) ;
12026: LD_ADDR_VAR 0 5
12030: PUSH
12031: LD_INT 11
12033: PPUSH
12034: LD_INT 1
12036: PPUSH
12037: CALL_OW 16
12041: ST_TO_ADDR
// if ( manual_forces < 2 ) then
12042: LD_EXP 59
12046: PUSH
12047: LD_INT 2
12049: LESS
12050: IFFALSE 12069
// ComMoveXY ( vozidlo , 103 , 59 ) else
12052: LD_VAR 0 2
12056: PPUSH
12057: LD_INT 103
12059: PPUSH
12060: LD_INT 59
12062: PPUSH
12063: CALL_OW 111
12067: GO 12096
// ComMoveXY ( vozidlo , hex [ 1 ] , hex [ 2 ] ) ;
12069: LD_VAR 0 2
12073: PPUSH
12074: LD_VAR 0 5
12078: PUSH
12079: LD_INT 1
12081: ARRAY
12082: PPUSH
12083: LD_VAR 0 5
12087: PUSH
12088: LD_INT 2
12090: ARRAY
12091: PPUSH
12092: CALL_OW 111
// repeat wait ( 0 0$5 ) ;
12096: LD_INT 175
12098: PPUSH
12099: CALL_OW 67
// until not IsBusy ( vozidlo ) ;
12103: LD_VAR 0 2
12107: PPUSH
12108: CALL_OW 315
12112: NOT
12113: IFFALSE 12096
// ridic := IsDrivenBy ( vozidlo ) ;
12115: LD_ADDR_VAR 0 4
12119: PUSH
12120: LD_VAR 0 2
12124: PPUSH
12125: CALL_OW 311
12129: ST_TO_ADDR
// ComExitVehicle ( ridic ) ;
12130: LD_VAR 0 4
12134: PPUSH
12135: CALL_OW 121
// AddComReturn ( ridic ) ;
12139: LD_VAR 0 4
12143: PPUSH
12144: CALL_OW 204
// end ;
12148: LD_VAR 0 3
12152: RET
// export function collect_war_forces ; begin
12153: LD_INT 0
12155: PPUSH
// ComAgressiveMove ( war_forces , 103 , 65 ) ;
12156: LD_EXP 52
12160: PPUSH
12161: LD_INT 103
12163: PPUSH
12164: LD_INT 65
12166: PPUSH
12167: CALL_OW 114
// end ;
12171: LD_VAR 0 1
12175: RET
// function zjisti_cilove_misto ( cislo_arei ) ; var vysledek ; begin
12176: LD_INT 0
12178: PPUSH
12179: PPUSH
// case cislo_arei of 1 :
12180: LD_VAR 0 1
12184: PUSH
12185: LD_INT 1
12187: DOUBLE
12188: EQUAL
12189: IFTRUE 12193
12191: GO 12211
12193: POP
// vysledek := [ 75 , 83 ] ; 2 :
12194: LD_ADDR_VAR 0 3
12198: PUSH
12199: LD_INT 75
12201: PUSH
12202: LD_INT 83
12204: PUSH
12205: EMPTY
12206: LIST
12207: LIST
12208: ST_TO_ADDR
12209: GO 12420
12211: LD_INT 2
12213: DOUBLE
12214: EQUAL
12215: IFTRUE 12219
12217: GO 12237
12219: POP
// vysledek := [ 82 , 102 ] ; 3 :
12220: LD_ADDR_VAR 0 3
12224: PUSH
12225: LD_INT 82
12227: PUSH
12228: LD_INT 102
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: ST_TO_ADDR
12235: GO 12420
12237: LD_INT 3
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12263
12245: POP
// vysledek := [ 85 , 116 ] ; 4 :
12246: LD_ADDR_VAR 0 3
12250: PUSH
12251: LD_INT 85
12253: PUSH
12254: LD_INT 116
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: ST_TO_ADDR
12261: GO 12420
12263: LD_INT 4
12265: DOUBLE
12266: EQUAL
12267: IFTRUE 12271
12269: GO 12289
12271: POP
// vysledek := [ 95 , 107 ] ; 5 :
12272: LD_ADDR_VAR 0 3
12276: PUSH
12277: LD_INT 95
12279: PUSH
12280: LD_INT 107
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: ST_TO_ADDR
12287: GO 12420
12289: LD_INT 5
12291: DOUBLE
12292: EQUAL
12293: IFTRUE 12297
12295: GO 12315
12297: POP
// vysledek := [ 108 , 116 ] ; 6 :
12298: LD_ADDR_VAR 0 3
12302: PUSH
12303: LD_INT 108
12305: PUSH
12306: LD_INT 116
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: ST_TO_ADDR
12313: GO 12420
12315: LD_INT 6
12317: DOUBLE
12318: EQUAL
12319: IFTRUE 12323
12321: GO 12341
12323: POP
// vysledek := [ 105 , 133 ] ; 7 :
12324: LD_ADDR_VAR 0 3
12328: PUSH
12329: LD_INT 105
12331: PUSH
12332: LD_INT 133
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: ST_TO_ADDR
12339: GO 12420
12341: LD_INT 7
12343: DOUBLE
12344: EQUAL
12345: IFTRUE 12349
12347: GO 12367
12349: POP
// vysledek := [ 85 , 133 ] ; 8 :
12350: LD_ADDR_VAR 0 3
12354: PUSH
12355: LD_INT 85
12357: PUSH
12358: LD_INT 133
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: ST_TO_ADDR
12365: GO 12420
12367: LD_INT 8
12369: DOUBLE
12370: EQUAL
12371: IFTRUE 12375
12373: GO 12393
12375: POP
// vysledek := [ 62 , 105 ] ; 9 :
12376: LD_ADDR_VAR 0 3
12380: PUSH
12381: LD_INT 62
12383: PUSH
12384: LD_INT 105
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: ST_TO_ADDR
12391: GO 12420
12393: LD_INT 9
12395: DOUBLE
12396: EQUAL
12397: IFTRUE 12401
12399: GO 12419
12401: POP
// vysledek := [ 103 , 97 ] ; end ;
12402: LD_ADDR_VAR 0 3
12406: PUSH
12407: LD_INT 103
12409: PUSH
12410: LD_INT 97
12412: PUSH
12413: EMPTY
12414: LIST
12415: LIST
12416: ST_TO_ADDR
12417: GO 12420
12419: POP
// result := vysledek ;
12420: LD_ADDR_VAR 0 2
12424: PUSH
12425: LD_VAR 0 3
12429: ST_TO_ADDR
// end ;
12430: LD_VAR 0 2
12434: RET
// function a_jmeno ( cislo ) ; var vysledek ; begin
12435: LD_INT 0
12437: PPUSH
12438: PPUSH
// case cislo of 1 :
12439: LD_VAR 0 1
12443: PUSH
12444: LD_INT 1
12446: DOUBLE
12447: EQUAL
12448: IFTRUE 12452
12450: GO 12463
12452: POP
// vysledek := u_north ; 2 :
12453: LD_ADDR_VAR 0 3
12457: PUSH
12458: LD_INT 16
12460: ST_TO_ADDR
12461: GO 12673
12463: LD_INT 2
12465: DOUBLE
12466: EQUAL
12467: IFTRUE 12471
12469: GO 12482
12471: POP
// vysledek := u_central_n ; 3 :
12472: LD_ADDR_VAR 0 3
12476: PUSH
12477: LD_INT 17
12479: ST_TO_ADDR
12480: GO 12673
12482: LD_INT 3
12484: DOUBLE
12485: EQUAL
12486: IFTRUE 12490
12488: GO 12501
12490: POP
// vysledek := u_central ; 4 :
12491: LD_ADDR_VAR 0 3
12495: PUSH
12496: LD_INT 19
12498: ST_TO_ADDR
12499: GO 12673
12501: LD_INT 4
12503: DOUBLE
12504: EQUAL
12505: IFTRUE 12509
12507: GO 12520
12509: POP
// vysledek := u_hill ; 5 :
12510: LD_ADDR_VAR 0 3
12514: PUSH
12515: LD_INT 18
12517: ST_TO_ADDR
12518: GO 12673
12520: LD_INT 5
12522: DOUBLE
12523: EQUAL
12524: IFTRUE 12528
12526: GO 12539
12528: POP
// vysledek := u_walley ; 6 :
12529: LD_ADDR_VAR 0 3
12533: PUSH
12534: LD_INT 21
12536: ST_TO_ADDR
12537: GO 12673
12539: LD_INT 6
12541: DOUBLE
12542: EQUAL
12543: IFTRUE 12547
12545: GO 12558
12547: POP
// vysledek := u_forgotten ; 7 :
12548: LD_ADDR_VAR 0 3
12552: PUSH
12553: LD_INT 23
12555: ST_TO_ADDR
12556: GO 12673
12558: LD_INT 7
12560: DOUBLE
12561: EQUAL
12562: IFTRUE 12566
12564: GO 12577
12566: POP
// vysledek := u_south ; 8 :
12567: LD_ADDR_VAR 0 3
12571: PUSH
12572: LD_INT 20
12574: ST_TO_ADDR
12575: GO 12673
12577: LD_INT 8
12579: DOUBLE
12580: EQUAL
12581: IFTRUE 12585
12583: GO 12596
12585: POP
// vysledek := u_heart ; 9 :
12586: LD_ADDR_VAR 0 3
12590: PUSH
12591: LD_INT 22
12593: ST_TO_ADDR
12594: GO 12673
12596: LD_INT 9
12598: DOUBLE
12599: EQUAL
12600: IFTRUE 12604
12602: GO 12615
12604: POP
// vysledek := u_east ; 11 :
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_INT 24
12612: ST_TO_ADDR
12613: GO 12673
12615: LD_INT 11
12617: DOUBLE
12618: EQUAL
12619: IFTRUE 12623
12621: GO 12634
12623: POP
// vysledek := n_gather ; 12 :
12624: LD_ADDR_VAR 0 3
12628: PUSH
12629: LD_INT 13
12631: ST_TO_ADDR
12632: GO 12673
12634: LD_INT 12
12636: DOUBLE
12637: EQUAL
12638: IFTRUE 12642
12640: GO 12653
12642: POP
// vysledek := e_gather ; 13 :
12643: LD_ADDR_VAR 0 3
12647: PUSH
12648: LD_INT 14
12650: ST_TO_ADDR
12651: GO 12673
12653: LD_INT 13
12655: DOUBLE
12656: EQUAL
12657: IFTRUE 12661
12659: GO 12672
12661: POP
// vysledek := s_gather ; end ;
12662: LD_ADDR_VAR 0 3
12666: PUSH
12667: LD_INT 15
12669: ST_TO_ADDR
12670: GO 12673
12672: POP
// result := vysledek ;
12673: LD_ADDR_VAR 0 2
12677: PUSH
12678: LD_VAR 0 3
12682: ST_TO_ADDR
// end ;
12683: LD_VAR 0 2
12687: RET
// function goto_north_sector ; var i , utocniku ; begin
12688: LD_INT 0
12690: PPUSH
12691: PPUSH
12692: PPUSH
// ComAgressiveMove ( attack_forces , 100 , 67 ) ;
12693: LD_EXP 55
12697: PPUSH
12698: LD_INT 100
12700: PPUSH
12701: LD_INT 67
12703: PPUSH
12704: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 87 , 65 ) ;
12708: LD_EXP 55
12712: PPUSH
12713: LD_INT 87
12715: PPUSH
12716: LD_INT 65
12718: PPUSH
12719: CALL_OW 174
// AddComAgressiveMove ( attack_forces , 74 , 64 ) ;
12723: LD_EXP 55
12727: PPUSH
12728: LD_INT 74
12730: PPUSH
12731: LD_INT 64
12733: PPUSH
12734: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12738: LD_INT 70
12740: PPUSH
12741: CALL_OW 67
// until vsichni_v_arei ( n_gather ) or ( not attack_forces ) ;
12745: LD_INT 13
12747: PPUSH
12748: CALL 13558 0 1
12752: PUSH
12753: LD_EXP 55
12757: NOT
12758: OR
12759: IFFALSE 12738
// attack_begin := true ;
12761: LD_ADDR_LOC 32
12765: PUSH
12766: LD_INT 1
12768: ST_TO_ADDR
// end ;
12769: LD_VAR 0 1
12773: RET
// function goto_east_sector ; var i , utocniku ; begin
12774: LD_INT 0
12776: PPUSH
12777: PPUSH
12778: PPUSH
// utocniku := 0 + attack_forces ;
12779: LD_ADDR_VAR 0 3
12783: PUSH
12784: LD_INT 0
12786: PUSH
12787: LD_EXP 55
12791: PLUS
12792: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
12793: LD_EXP 55
12797: PPUSH
12798: LD_INT 111
12800: PPUSH
12801: LD_INT 73
12803: PPUSH
12804: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 116 , 95 ) ;
12808: LD_EXP 55
12812: PPUSH
12813: LD_INT 116
12815: PPUSH
12816: LD_INT 95
12818: PPUSH
12819: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12823: LD_INT 70
12825: PPUSH
12826: CALL_OW 67
// until vsichni_v_arei ( e_gather ) or ( not attack_forces ) ;
12830: LD_INT 14
12832: PPUSH
12833: CALL 13558 0 1
12837: PUSH
12838: LD_EXP 55
12842: NOT
12843: OR
12844: IFFALSE 12823
// attack_begin := true ;
12846: LD_ADDR_LOC 32
12850: PUSH
12851: LD_INT 1
12853: ST_TO_ADDR
// end ;
12854: LD_VAR 0 1
12858: RET
// function goto_south_sector ; var i , utocniku ; begin
12859: LD_INT 0
12861: PPUSH
12862: PPUSH
12863: PPUSH
// utocniku := 0 + attack_forces ;
12864: LD_ADDR_VAR 0 3
12868: PUSH
12869: LD_INT 0
12871: PUSH
12872: LD_EXP 55
12876: PLUS
12877: ST_TO_ADDR
// ComAgressiveMove ( attack_forces , 111 , 73 ) ;
12878: LD_EXP 55
12882: PPUSH
12883: LD_INT 111
12885: PPUSH
12886: LD_INT 73
12888: PPUSH
12889: CALL_OW 114
// AddComAgressiveMove ( attack_forces , 127 , 118 ) ;
12893: LD_EXP 55
12897: PPUSH
12898: LD_INT 127
12900: PPUSH
12901: LD_INT 118
12903: PPUSH
12904: CALL_OW 174
// repeat wait ( 0 0$2 ) ;
12908: LD_INT 70
12910: PPUSH
12911: CALL_OW 67
// until vsichni_v_arei ( s_gather ) or ( not attack_forces ) ;
12915: LD_INT 15
12917: PPUSH
12918: CALL 13558 0 1
12922: PUSH
12923: LD_EXP 55
12927: NOT
12928: OR
12929: IFFALSE 12908
// attack_begin := true ;
12931: LD_ADDR_LOC 32
12935: PUSH
12936: LD_INT 1
12938: ST_TO_ADDR
// end ;
12939: LD_VAR 0 1
12943: RET
// function zjisti_schudne_okoli ( area ) ; var a1 , a2 , vysledek ; var v1 , v2 ; begin
12944: LD_INT 0
12946: PPUSH
12947: PPUSH
12948: PPUSH
12949: PPUSH
12950: PPUSH
12951: PPUSH
// case area of 1 :
12952: LD_VAR 0 1
12956: PUSH
12957: LD_INT 1
12959: DOUBLE
12960: EQUAL
12961: IFTRUE 12965
12963: GO 12984
12965: POP
// begin a1 := 2 ;
12966: LD_ADDR_VAR 0 3
12970: PUSH
12971: LD_INT 2
12973: ST_TO_ADDR
// a2 := 0 ;
12974: LD_ADDR_VAR 0 4
12978: PUSH
12979: LD_INT 0
12981: ST_TO_ADDR
// end ; 2 :
12982: GO 13282
12984: LD_INT 2
12986: DOUBLE
12987: EQUAL
12988: IFTRUE 12992
12990: GO 13011
12992: POP
// begin a1 := 3 ;
12993: LD_ADDR_VAR 0 3
12997: PUSH
12998: LD_INT 3
13000: ST_TO_ADDR
// a2 := 8 ;
13001: LD_ADDR_VAR 0 4
13005: PUSH
13006: LD_INT 8
13008: ST_TO_ADDR
// end ; 3 :
13009: GO 13282
13011: LD_INT 3
13013: DOUBLE
13014: EQUAL
13015: IFTRUE 13019
13017: GO 13038
13019: POP
// begin a1 := 7 ;
13020: LD_ADDR_VAR 0 3
13024: PUSH
13025: LD_INT 7
13027: ST_TO_ADDR
// a2 := 2 ;
13028: LD_ADDR_VAR 0 4
13032: PUSH
13033: LD_INT 2
13035: ST_TO_ADDR
// end ; 4 :
13036: GO 13282
13038: LD_INT 4
13040: DOUBLE
13041: EQUAL
13042: IFTRUE 13046
13044: GO 13065
13046: POP
// begin a1 := 2 ;
13047: LD_ADDR_VAR 0 3
13051: PUSH
13052: LD_INT 2
13054: ST_TO_ADDR
// a2 := 3 ;
13055: LD_ADDR_VAR 0 4
13059: PUSH
13060: LD_INT 3
13062: ST_TO_ADDR
// end ; 5 :
13063: GO 13282
13065: LD_INT 5
13067: DOUBLE
13068: EQUAL
13069: IFTRUE 13073
13071: GO 13092
13073: POP
// begin a1 := 3 ;
13074: LD_ADDR_VAR 0 3
13078: PUSH
13079: LD_INT 3
13081: ST_TO_ADDR
// a2 := 6 ;
13082: LD_ADDR_VAR 0 4
13086: PUSH
13087: LD_INT 6
13089: ST_TO_ADDR
// end ; 6 :
13090: GO 13282
13092: LD_INT 6
13094: DOUBLE
13095: EQUAL
13096: IFTRUE 13100
13098: GO 13119
13100: POP
// begin a1 := 7 ;
13101: LD_ADDR_VAR 0 3
13105: PUSH
13106: LD_INT 7
13108: ST_TO_ADDR
// a2 := 3 ;
13109: LD_ADDR_VAR 0 4
13113: PUSH
13114: LD_INT 3
13116: ST_TO_ADDR
// end ; 7 :
13117: GO 13282
13119: LD_INT 7
13121: DOUBLE
13122: EQUAL
13123: IFTRUE 13127
13125: GO 13146
13127: POP
// begin a1 := 8 ;
13128: LD_ADDR_VAR 0 3
13132: PUSH
13133: LD_INT 8
13135: ST_TO_ADDR
// a2 := 3 ;
13136: LD_ADDR_VAR 0 4
13140: PUSH
13141: LD_INT 3
13143: ST_TO_ADDR
// end ; 8 :
13144: GO 13282
13146: LD_INT 8
13148: DOUBLE
13149: EQUAL
13150: IFTRUE 13154
13152: GO 13173
13154: POP
// begin a1 := 2 ;
13155: LD_ADDR_VAR 0 3
13159: PUSH
13160: LD_INT 2
13162: ST_TO_ADDR
// a2 := 7 ;
13163: LD_ADDR_VAR 0 4
13167: PUSH
13168: LD_INT 7
13170: ST_TO_ADDR
// end ; 9 :
13171: GO 13282
13173: LD_INT 9
13175: DOUBLE
13176: EQUAL
13177: IFTRUE 13181
13179: GO 13200
13181: POP
// begin a1 := 2 ;
13182: LD_ADDR_VAR 0 3
13186: PUSH
13187: LD_INT 2
13189: ST_TO_ADDR
// a2 := 5 ;
13190: LD_ADDR_VAR 0 4
13194: PUSH
13195: LD_INT 5
13197: ST_TO_ADDR
// end ; 11 :
13198: GO 13282
13200: LD_INT 11
13202: DOUBLE
13203: EQUAL
13204: IFTRUE 13208
13206: GO 13227
13208: POP
// begin a1 := 1 ;
13209: LD_ADDR_VAR 0 3
13213: PUSH
13214: LD_INT 1
13216: ST_TO_ADDR
// a2 := 0 ;
13217: LD_ADDR_VAR 0 4
13221: PUSH
13222: LD_INT 0
13224: ST_TO_ADDR
// end ; 12 :
13225: GO 13282
13227: LD_INT 12
13229: DOUBLE
13230: EQUAL
13231: IFTRUE 13235
13233: GO 13254
13235: POP
// begin a1 := 5 ;
13236: LD_ADDR_VAR 0 3
13240: PUSH
13241: LD_INT 5
13243: ST_TO_ADDR
// a2 := 0 ;
13244: LD_ADDR_VAR 0 4
13248: PUSH
13249: LD_INT 0
13251: ST_TO_ADDR
// end ; 13 :
13252: GO 13282
13254: LD_INT 13
13256: DOUBLE
13257: EQUAL
13258: IFTRUE 13262
13260: GO 13281
13262: POP
// begin a1 := 9 ;
13263: LD_ADDR_VAR 0 3
13267: PUSH
13268: LD_INT 9
13270: ST_TO_ADDR
// a2 := 0 ;
13271: LD_ADDR_VAR 0 4
13275: PUSH
13276: LD_INT 0
13278: ST_TO_ADDR
// end ; end ;
13279: GO 13282
13281: POP
// v1 := [ a1 ] ;
13282: LD_ADDR_VAR 0 6
13286: PUSH
13287: LD_VAR 0 3
13291: PUSH
13292: EMPTY
13293: LIST
13294: ST_TO_ADDR
// if a2 then
13295: LD_VAR 0 4
13299: IFFALSE 13317
// v1 := v1 ^ a1 ;
13301: LD_ADDR_VAR 0 6
13305: PUSH
13306: LD_VAR 0 6
13310: PUSH
13311: LD_VAR 0 3
13315: ADD
13316: ST_TO_ADDR
// vysledek := v1 [ Rand ( 1 , v1 ) ] ;
13317: LD_ADDR_VAR 0 5
13321: PUSH
13322: LD_VAR 0 6
13326: PUSH
13327: LD_INT 1
13329: PPUSH
13330: LD_VAR 0 6
13334: PPUSH
13335: CALL_OW 12
13339: ARRAY
13340: ST_TO_ADDR
// result := vysledek ;
13341: LD_ADDR_VAR 0 2
13345: PUSH
13346: LD_VAR 0 5
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 2
13355: RET
// function navrhni_startovni_pozici ; var s1 , s2 , s3 , vysledek ; var un , truck ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
13364: PPUSH
// s1 := klic_area_1 ;
13365: LD_ADDR_VAR 0 2
13369: PUSH
13370: LD_LOC 18
13374: ST_TO_ADDR
// s2 := klic_area_9 ;
13375: LD_ADDR_VAR 0 3
13379: PUSH
13380: LD_LOC 26
13384: ST_TO_ADDR
// s3 := klic_area_5 ;
13385: LD_ADDR_VAR 0 4
13389: PUSH
13390: LD_LOC 22
13394: ST_TO_ADDR
// truck := true ;
13395: LD_ADDR_VAR 0 7
13399: PUSH
13400: LD_INT 1
13402: ST_TO_ADDR
// for un in attack_forces do
13403: LD_ADDR_VAR 0 6
13407: PUSH
13408: LD_EXP 55
13412: PUSH
13413: FOR_IN
13414: IFFALSE 13441
// if GetChassis ( un ) <> ru_heavy_tracked then
13416: LD_VAR 0 6
13420: PPUSH
13421: CALL_OW 265
13425: PUSH
13426: LD_INT 24
13428: NONEQUAL
13429: IFFALSE 13439
// truck := false ;
13431: LD_ADDR_VAR 0 7
13435: PUSH
13436: LD_INT 0
13438: ST_TO_ADDR
13439: GO 13413
13441: POP
13442: POP
// if ( a_jmeno ( s1 ) < a_jmeno ( s2 ) ) and ( a_jmeno ( s1 ) < a_jmeno ( s3 ) ) and truck then
13443: LD_VAR 0 2
13447: PPUSH
13448: CALL 12435 0 1
13452: PUSH
13453: LD_VAR 0 3
13457: PPUSH
13458: CALL 12435 0 1
13462: LESS
13463: PUSH
13464: LD_VAR 0 2
13468: PPUSH
13469: CALL 12435 0 1
13473: PUSH
13474: LD_VAR 0 4
13478: PPUSH
13479: CALL 12435 0 1
13483: LESS
13484: AND
13485: PUSH
13486: LD_VAR 0 7
13490: AND
13491: IFFALSE 13503
// vysledek := 1 else
13493: LD_ADDR_VAR 0 5
13497: PUSH
13498: LD_INT 1
13500: ST_TO_ADDR
13501: GO 13543
// if ( a_jmeno ( s2 ) < a_jmeno ( s3 ) ) then
13503: LD_VAR 0 3
13507: PPUSH
13508: CALL 12435 0 1
13512: PUSH
13513: LD_VAR 0 4
13517: PPUSH
13518: CALL 12435 0 1
13522: LESS
13523: IFFALSE 13535
// vysledek := 9 else
13525: LD_ADDR_VAR 0 5
13529: PUSH
13530: LD_INT 9
13532: ST_TO_ADDR
13533: GO 13543
// vysledek := 5 ;
13535: LD_ADDR_VAR 0 5
13539: PUSH
13540: LD_INT 5
13542: ST_TO_ADDR
// result := vysledek ;
13543: LD_ADDR_VAR 0 1
13547: PUSH
13548: LD_VAR 0 5
13552: ST_TO_ADDR
// end ;
13553: LD_VAR 0 1
13557: RET
// function vsichni_v_arei ( ktera_area ) ; var un , vysledek ; begin
13558: LD_INT 0
13560: PPUSH
13561: PPUSH
13562: PPUSH
// un := FilterUnitsInArea ( ktera_area , [ [ f_side , russians ] ] ) ;
13563: LD_ADDR_VAR 0 3
13567: PUSH
13568: LD_VAR 0 1
13572: PPUSH
13573: LD_INT 22
13575: PUSH
13576: LD_EXP 15
13580: PUSH
13581: EMPTY
13582: LIST
13583: LIST
13584: PUSH
13585: EMPTY
13586: LIST
13587: PPUSH
13588: CALL_OW 70
13592: ST_TO_ADDR
// if un >= ( ( attack_forces + 1 ) div 2 ) then
13593: LD_VAR 0 3
13597: PUSH
13598: LD_EXP 55
13602: PUSH
13603: LD_INT 1
13605: PLUS
13606: PUSH
13607: LD_INT 2
13609: DIV
13610: GREATEREQUAL
13611: IFFALSE 13623
// vysledek := true else
13613: LD_ADDR_VAR 0 4
13617: PUSH
13618: LD_INT 1
13620: ST_TO_ADDR
13621: GO 13631
// vysledek := false ;
13623: LD_ADDR_VAR 0 4
13627: PUSH
13628: LD_INT 0
13630: ST_TO_ADDR
// result := vysledek ;
13631: LD_ADDR_VAR 0 2
13635: PUSH
13636: LD_VAR 0 4
13640: ST_TO_ADDR
// end ;
13641: LD_VAR 0 2
13645: RET
// function see_important ( now_area ) ; var un , area , vysledek ; begin
13646: LD_INT 0
13648: PPUSH
13649: PPUSH
13650: PPUSH
13651: PPUSH
// vysledek := false ;
13652: LD_ADDR_VAR 0 5
13656: PUSH
13657: LD_INT 0
13659: ST_TO_ADDR
// area := [ ] ;
13660: LD_ADDR_VAR 0 4
13664: PUSH
13665: EMPTY
13666: ST_TO_ADDR
// for un in us_important do
13667: LD_ADDR_VAR 0 3
13671: PUSH
13672: LD_EXP 65
13676: PUSH
13677: FOR_IN
13678: IFFALSE 13987
// if See ( russians , un ) then
13680: LD_EXP 15
13684: PPUSH
13685: LD_VAR 0 3
13689: PPUSH
13690: CALL_OW 292
13694: IFFALSE 13985
// begin area := area ^ un ;
13696: LD_ADDR_VAR 0 4
13700: PUSH
13701: LD_VAR 0 4
13705: PUSH
13706: LD_VAR 0 3
13710: ADD
13711: ST_TO_ADDR
// case now_area of 1 :
13712: LD_VAR 0 1
13716: PUSH
13717: LD_INT 1
13719: DOUBLE
13720: EQUAL
13721: IFTRUE 13725
13723: GO 13744
13725: POP
// klic_area_1 := klic_area_1 union area ; 2 :
13726: LD_ADDR_LOC 18
13730: PUSH
13731: LD_LOC 18
13735: PUSH
13736: LD_VAR 0 4
13740: UNION
13741: ST_TO_ADDR
13742: GO 13961
13744: LD_INT 2
13746: DOUBLE
13747: EQUAL
13748: IFTRUE 13752
13750: GO 13771
13752: POP
// klic_area_2 := klic_area_2 union area ; 3 :
13753: LD_ADDR_LOC 19
13757: PUSH
13758: LD_LOC 19
13762: PUSH
13763: LD_VAR 0 4
13767: UNION
13768: ST_TO_ADDR
13769: GO 13961
13771: LD_INT 3
13773: DOUBLE
13774: EQUAL
13775: IFTRUE 13779
13777: GO 13798
13779: POP
// klic_area_3 := klic_area_3 union area ; 4 :
13780: LD_ADDR_LOC 20
13784: PUSH
13785: LD_LOC 20
13789: PUSH
13790: LD_VAR 0 4
13794: UNION
13795: ST_TO_ADDR
13796: GO 13961
13798: LD_INT 4
13800: DOUBLE
13801: EQUAL
13802: IFTRUE 13806
13804: GO 13825
13806: POP
// klic_area_4 := klic_area_4 union area ; 5 :
13807: LD_ADDR_LOC 21
13811: PUSH
13812: LD_LOC 21
13816: PUSH
13817: LD_VAR 0 4
13821: UNION
13822: ST_TO_ADDR
13823: GO 13961
13825: LD_INT 5
13827: DOUBLE
13828: EQUAL
13829: IFTRUE 13833
13831: GO 13852
13833: POP
// klic_area_5 := klic_area_5 union area ; 6 :
13834: LD_ADDR_LOC 22
13838: PUSH
13839: LD_LOC 22
13843: PUSH
13844: LD_VAR 0 4
13848: UNION
13849: ST_TO_ADDR
13850: GO 13961
13852: LD_INT 6
13854: DOUBLE
13855: EQUAL
13856: IFTRUE 13860
13858: GO 13879
13860: POP
// klic_area_6 := klic_area_6 union area ; 7 :
13861: LD_ADDR_LOC 23
13865: PUSH
13866: LD_LOC 23
13870: PUSH
13871: LD_VAR 0 4
13875: UNION
13876: ST_TO_ADDR
13877: GO 13961
13879: LD_INT 7
13881: DOUBLE
13882: EQUAL
13883: IFTRUE 13887
13885: GO 13906
13887: POP
// klic_area_7 := klic_area_7 union area ; 8 :
13888: LD_ADDR_LOC 24
13892: PUSH
13893: LD_LOC 24
13897: PUSH
13898: LD_VAR 0 4
13902: UNION
13903: ST_TO_ADDR
13904: GO 13961
13906: LD_INT 8
13908: DOUBLE
13909: EQUAL
13910: IFTRUE 13914
13912: GO 13933
13914: POP
// klic_area_8 := klic_area_8 union area ; 9 :
13915: LD_ADDR_LOC 25
13919: PUSH
13920: LD_LOC 25
13924: PUSH
13925: LD_VAR 0 4
13929: UNION
13930: ST_TO_ADDR
13931: GO 13961
13933: LD_INT 9
13935: DOUBLE
13936: EQUAL
13937: IFTRUE 13941
13939: GO 13960
13941: POP
// klic_area_9 := klic_area_9 union area ; end ;
13942: LD_ADDR_LOC 26
13946: PUSH
13947: LD_LOC 26
13951: PUSH
13952: LD_VAR 0 4
13956: UNION
13957: ST_TO_ADDR
13958: GO 13961
13960: POP
// destroy_now := destroy_now union un ;
13961: LD_ADDR_LOC 27
13965: PUSH
13966: LD_LOC 27
13970: PUSH
13971: LD_VAR 0 3
13975: UNION
13976: ST_TO_ADDR
// vysledek := true ;
13977: LD_ADDR_VAR 0 5
13981: PUSH
13982: LD_INT 1
13984: ST_TO_ADDR
// end ;
13985: GO 13677
13987: POP
13988: POP
// result := vysledek ;
13989: LD_ADDR_VAR 0 2
13993: PUSH
13994: LD_VAR 0 5
13998: ST_TO_ADDR
// end ;
13999: LD_VAR 0 2
14003: RET
// function destroy_important ( area ) ; var i , j , max , max_search ; var cil , prior_1 , prior_max ; begin
14004: LD_INT 0
14006: PPUSH
14007: PPUSH
14008: PPUSH
14009: PPUSH
14010: PPUSH
14011: PPUSH
14012: PPUSH
14013: PPUSH
// max_search := 3 ;
14014: LD_ADDR_VAR 0 6
14018: PUSH
14019: LD_INT 3
14021: ST_TO_ADDR
// max := 0 + destroy_now ;
14022: LD_ADDR_VAR 0 5
14026: PUSH
14027: LD_INT 0
14029: PUSH
14030: LD_LOC 27
14034: PLUS
14035: ST_TO_ADDR
// if max > 3 then
14036: LD_VAR 0 5
14040: PUSH
14041: LD_INT 3
14043: GREATER
14044: IFFALSE 14056
// j := 3 else
14046: LD_ADDR_VAR 0 4
14050: PUSH
14051: LD_INT 3
14053: ST_TO_ADDR
14054: GO 14066
// j := max ;
14056: LD_ADDR_VAR 0 4
14060: PUSH
14061: LD_VAR 0 5
14065: ST_TO_ADDR
// prior_max := [ 0 , 0 ] ;
14066: LD_ADDR_VAR 0 9
14070: PUSH
14071: LD_INT 0
14073: PUSH
14074: LD_INT 0
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: ST_TO_ADDR
// for i = 1 to j do
14081: LD_ADDR_VAR 0 3
14085: PUSH
14086: DOUBLE
14087: LD_INT 1
14089: DEC
14090: ST_TO_ADDR
14091: LD_VAR 0 4
14095: PUSH
14096: FOR_TO
14097: IFFALSE 14375
// begin prior_1 := 0 ;
14099: LD_ADDR_VAR 0 8
14103: PUSH
14104: LD_INT 0
14106: ST_TO_ADDR
// case GetBType ( destroy_now [ i ] ) of 33 :
14107: LD_LOC 27
14111: PUSH
14112: LD_VAR 0 3
14116: ARRAY
14117: PPUSH
14118: CALL_OW 266
14122: PUSH
14123: LD_INT 33
14125: DOUBLE
14126: EQUAL
14127: IFTRUE 14131
14129: GO 14142
14131: POP
// prior_1 := 4 ; 30 :
14132: LD_ADDR_VAR 0 8
14136: PUSH
14137: LD_INT 4
14139: ST_TO_ADDR
14140: GO 14227
14142: LD_INT 30
14144: DOUBLE
14145: EQUAL
14146: IFTRUE 14150
14148: GO 14161
14150: POP
// prior_1 := 4 ; 29 :
14151: LD_ADDR_VAR 0 8
14155: PUSH
14156: LD_INT 4
14158: ST_TO_ADDR
14159: GO 14227
14161: LD_INT 29
14163: DOUBLE
14164: EQUAL
14165: IFTRUE 14169
14167: GO 14180
14169: POP
// prior_1 := 3 ; 28 :
14170: LD_ADDR_VAR 0 8
14174: PUSH
14175: LD_INT 3
14177: ST_TO_ADDR
14178: GO 14227
14180: LD_INT 28
14182: DOUBLE
14183: EQUAL
14184: IFTRUE 14188
14186: GO 14199
14188: POP
// prior_1 := 3 ; 26 :
14189: LD_ADDR_VAR 0 8
14193: PUSH
14194: LD_INT 3
14196: ST_TO_ADDR
14197: GO 14227
14199: LD_INT 26
14201: DOUBLE
14202: EQUAL
14203: IFTRUE 14207
14205: GO 14218
14207: POP
// prior_1 := 2 ; else
14208: LD_ADDR_VAR 0 8
14212: PUSH
14213: LD_INT 2
14215: ST_TO_ADDR
14216: GO 14227
14218: POP
// prior_1 := 1 ; end ;
14219: LD_ADDR_VAR 0 8
14223: PUSH
14224: LD_INT 1
14226: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 750 then
14227: LD_LOC 27
14231: PUSH
14232: LD_VAR 0 3
14236: ARRAY
14237: PPUSH
14238: CALL_OW 256
14242: PUSH
14243: LD_INT 750
14245: LESS
14246: IFFALSE 14262
// prior_1 := prior_1 + 1 ;
14248: LD_ADDR_VAR 0 8
14252: PUSH
14253: LD_VAR 0 8
14257: PUSH
14258: LD_INT 1
14260: PLUS
14261: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 500 then
14262: LD_LOC 27
14266: PUSH
14267: LD_VAR 0 3
14271: ARRAY
14272: PPUSH
14273: CALL_OW 256
14277: PUSH
14278: LD_INT 500
14280: LESS
14281: IFFALSE 14297
// prior_1 := prior_1 + 2 ;
14283: LD_ADDR_VAR 0 8
14287: PUSH
14288: LD_VAR 0 8
14292: PUSH
14293: LD_INT 2
14295: PLUS
14296: ST_TO_ADDR
// if GetLives ( destroy_now [ i ] ) < 250 then
14297: LD_LOC 27
14301: PUSH
14302: LD_VAR 0 3
14306: ARRAY
14307: PPUSH
14308: CALL_OW 256
14312: PUSH
14313: LD_INT 250
14315: LESS
14316: IFFALSE 14332
// prior_1 := prior_1 + 2 ;
14318: LD_ADDR_VAR 0 8
14322: PUSH
14323: LD_VAR 0 8
14327: PUSH
14328: LD_INT 2
14330: PLUS
14331: ST_TO_ADDR
// if prior_1 > prior_max [ 1 ] then
14332: LD_VAR 0 8
14336: PUSH
14337: LD_VAR 0 9
14341: PUSH
14342: LD_INT 1
14344: ARRAY
14345: GREATER
14346: IFFALSE 14373
// prior_max := [ prior_1 , destroy_now [ i ] ] ;
14348: LD_ADDR_VAR 0 9
14352: PUSH
14353: LD_VAR 0 8
14357: PUSH
14358: LD_LOC 27
14362: PUSH
14363: LD_VAR 0 3
14367: ARRAY
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: ST_TO_ADDR
// end ;
14373: GO 14096
14375: POP
14376: POP
// if prior_max [ 2 ] then
14377: LD_VAR 0 9
14381: PUSH
14382: LD_INT 2
14384: ARRAY
14385: IFFALSE 14428
// DestroyTarget ( prior_max [ 2 ] , GetX ( prior_max [ 2 ] ) , GetY ( prior_max [ 2 ] ) ) ;
14387: LD_VAR 0 9
14391: PUSH
14392: LD_INT 2
14394: ARRAY
14395: PPUSH
14396: LD_VAR 0 9
14400: PUSH
14401: LD_INT 2
14403: ARRAY
14404: PPUSH
14405: CALL_OW 250
14409: PPUSH
14410: LD_VAR 0 9
14414: PUSH
14415: LD_INT 2
14417: ARRAY
14418: PPUSH
14419: CALL_OW 251
14423: PPUSH
14424: CALL 14433 0 3
// end ;
14428: LD_VAR 0 2
14432: RET
// function DestroyTarget ( target , x , y ) ; var un ; begin
14433: LD_INT 0
14435: PPUSH
14436: PPUSH
// for un in attack_forces do
14437: LD_ADDR_VAR 0 5
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: FOR_IN
14448: IFFALSE 14509
// if GetWeapon ( un ) in [ ru_rocket , ru_rocket_launcher ] then
14450: LD_VAR 0 5
14454: PPUSH
14455: CALL_OW 264
14459: PUSH
14460: LD_INT 47
14462: PUSH
14463: LD_INT 45
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: IN
14470: IFFALSE 14493
// ComAttackPlace ( un , x , y ) else
14472: LD_VAR 0 5
14476: PPUSH
14477: LD_VAR 0 2
14481: PPUSH
14482: LD_VAR 0 3
14486: PPUSH
14487: CALL_OW 116
14491: GO 14507
// ComAttackUnit ( un , target ) ;
14493: LD_VAR 0 5
14497: PPUSH
14498: LD_VAR 0 1
14502: PPUSH
14503: CALL_OW 115
14507: GO 14447
14509: POP
14510: POP
// end ;
14511: LD_VAR 0 4
14515: RET
// function konec_jednoho_utoku ; begin
14516: LD_INT 0
14518: PPUSH
// war_forces := war_forces ^ attack_forces ;
14519: LD_ADDR_EXP 52
14523: PUSH
14524: LD_EXP 52
14528: PUSH
14529: LD_EXP 55
14533: ADD
14534: ST_TO_ADDR
// attack_forces := [ ] ;
14535: LD_ADDR_EXP 55
14539: PUSH
14540: EMPTY
14541: ST_TO_ADDR
// attack_begin := false ;
14542: LD_ADDR_LOC 32
14546: PUSH
14547: LD_INT 0
14549: ST_TO_ADDR
// war_count := Rand ( cislo_utoku + 1 , cislo_utoku + 3 ) ;
14550: LD_ADDR_EXP 54
14554: PUSH
14555: LD_LOC 33
14559: PUSH
14560: LD_INT 1
14562: PLUS
14563: PPUSH
14564: LD_LOC 33
14568: PUSH
14569: LD_INT 3
14571: PLUS
14572: PPUSH
14573: CALL_OW 12
14577: ST_TO_ADDR
// if war_count > 4 then
14578: LD_EXP 54
14582: PUSH
14583: LD_INT 4
14585: GREATER
14586: IFFALSE 14604
// war_count := Rand ( 4 , 5 ) ;
14588: LD_ADDR_EXP 54
14592: PUSH
14593: LD_INT 4
14595: PPUSH
14596: LD_INT 5
14598: PPUSH
14599: CALL_OW 12
14603: ST_TO_ADDR
// end ;
14604: LD_VAR 0 1
14608: RET
// function low_cesta ; var i , max , areas , mc_id , new_destination ; begin
14609: LD_INT 0
14611: PPUSH
14612: PPUSH
14613: PPUSH
14614: PPUSH
14615: PPUSH
14616: PPUSH
// multi := false ;
14617: LD_ADDR_LOC 29
14621: PUSH
14622: LD_INT 0
14624: ST_TO_ADDR
// attack_begin := false ;
14625: LD_ADDR_LOC 32
14629: PUSH
14630: LD_INT 0
14632: ST_TO_ADDR
// max := 0 + attack_forces ;
14633: LD_ADDR_VAR 0 3
14637: PUSH
14638: LD_INT 0
14640: PUSH
14641: LD_EXP 55
14645: PLUS
14646: ST_TO_ADDR
// destroy_now := [ ] ;
14647: LD_ADDR_LOC 27
14651: PUSH
14652: EMPTY
14653: ST_TO_ADDR
// if cislo_utoku > 1 then
14654: LD_LOC 33
14658: PUSH
14659: LD_INT 1
14661: GREATER
14662: IFFALSE 14676
// now_area := navrhni_startovni_pozici else
14664: LD_ADDR_LOC 34
14668: PUSH
14669: CALL 13356 0 0
14673: ST_TO_ADDR
14674: GO 14684
// now_area := 1 ;
14676: LD_ADDR_LOC 34
14680: PUSH
14681: LD_INT 1
14683: ST_TO_ADDR
// case now_area of 1 :
14684: LD_LOC 34
14688: PUSH
14689: LD_INT 1
14691: DOUBLE
14692: EQUAL
14693: IFTRUE 14697
14695: GO 14704
14697: POP
// goto_north_sector ; 9 :
14698: CALL 12688 0 0
14702: GO 14735
14704: LD_INT 9
14706: DOUBLE
14707: EQUAL
14708: IFTRUE 14712
14710: GO 14719
14712: POP
// goto_east_sector ; 5 :
14713: CALL 12774 0 0
14717: GO 14735
14719: LD_INT 5
14721: DOUBLE
14722: EQUAL
14723: IFTRUE 14727
14725: GO 14734
14727: POP
// goto_south_sector ; end ;
14728: CALL 12859 0 0
14732: GO 14735
14734: POP
// repeat wait ( 0 0$1 ) ;
14735: LD_INT 35
14737: PPUSH
14738: CALL_OW 67
// until attack_begin ;
14742: LD_LOC 32
14746: IFFALSE 14735
// mc_id := 0 ;
14748: LD_ADDR_VAR 0 5
14752: PUSH
14753: LD_INT 0
14755: ST_TO_ADDR
// repeat next_area := zjisti_schudne_okoli ( now_area ) ;
14756: LD_ADDR_LOC 35
14760: PUSH
14761: LD_LOC 34
14765: PPUSH
14766: CALL 12944 0 1
14770: ST_TO_ADDR
// new_destination := zjisti_cilove_misto ( next_area ) ;
14771: LD_ADDR_VAR 0 6
14775: PUSH
14776: LD_LOC 35
14780: PPUSH
14781: CALL 12176 0 1
14785: ST_TO_ADDR
// repeat if see_important ( now_area ) then
14786: LD_LOC 34
14790: PPUSH
14791: CALL 13646 0 1
14795: IFFALSE 14836
// begin if ExistMc ( mc_id ) then
14797: LD_VAR 0 5
14801: PPUSH
14802: CALL_OW 386
14806: IFFALSE 14825
// begin KillMc ( mc_id ) ;
14808: LD_VAR 0 5
14812: PPUSH
14813: CALL_OW 387
// mc_id := 0 ;
14817: LD_ADDR_VAR 0 5
14821: PUSH
14822: LD_INT 0
14824: ST_TO_ADDR
// end ; destroy_important ( now_area ) ;
14825: LD_LOC 34
14829: PPUSH
14830: CALL 14004 0 1
// end else
14834: GO 14893
// if not ExistMc ( mc_id ) then
14836: LD_VAR 0 5
14840: PPUSH
14841: CALL_OW 386
14845: NOT
14846: IFFALSE 14893
// mc_id := McMove ( 2 , attack_forces , [ [ new_destination [ 1 ] , new_destination [ 2 ] ] ] , [ ] ) ;
14848: LD_ADDR_VAR 0 5
14852: PUSH
14853: LD_INT 2
14855: PPUSH
14856: LD_EXP 55
14860: PPUSH
14861: LD_VAR 0 6
14865: PUSH
14866: LD_INT 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 6
14874: PUSH
14875: LD_INT 2
14877: ARRAY
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: PUSH
14883: EMPTY
14884: LIST
14885: PPUSH
14886: EMPTY
14887: PPUSH
14888: CALL_OW 398
14892: ST_TO_ADDR
// wait ( 0 0$3 ) ;
14893: LD_INT 105
14895: PPUSH
14896: CALL_OW 67
// until vsichni_v_arei ( a_jmeno ( next_area ) ) or ( not attack_forces ) ;
14900: LD_LOC 35
14904: PPUSH
14905: CALL 12435 0 1
14909: PPUSH
14910: CALL 13558 0 1
14914: PUSH
14915: LD_EXP 55
14919: NOT
14920: OR
14921: IFFALSE 14786
// now_area := next_area ;
14923: LD_ADDR_LOC 34
14927: PUSH
14928: LD_LOC 35
14932: ST_TO_ADDR
// until not attack_forces ;
14933: LD_EXP 55
14937: NOT
14938: IFFALSE 14756
// konec_jednoho_utoku ;
14940: CALL 14516 0 0
// cislo_utoku := cislo_utoku + 1 ;
14944: LD_ADDR_LOC 33
14948: PUSH
14949: LD_LOC 33
14953: PUSH
14954: LD_INT 1
14956: PLUS
14957: ST_TO_ADDR
// end ;
14958: LD_VAR 0 1
14962: RET
// function nacti_important_budovy ; var list_important , un ; begin
14963: LD_INT 0
14965: PPUSH
14966: PPUSH
14967: PPUSH
// us_important := [ ] ;
14968: LD_ADDR_EXP 65
14972: PUSH
14973: EMPTY
14974: ST_TO_ADDR
// list_important := FilterAllUnits ( [ [ f_or , [ f_side , you ] , [ f_side , neutral ] ] , [ f_type , unit_building ] ] ) ;
14975: LD_ADDR_VAR 0 2
14979: PUSH
14980: LD_INT 2
14982: PUSH
14983: LD_INT 22
14985: PUSH
14986: LD_EXP 14
14990: PUSH
14991: EMPTY
14992: LIST
14993: LIST
14994: PUSH
14995: LD_INT 22
14997: PUSH
14998: LD_EXP 16
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: LIST
15011: PUSH
15012: LD_INT 21
15014: PUSH
15015: LD_INT 3
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PPUSH
15026: CALL_OW 69
15030: ST_TO_ADDR
// important := [ b_depot , b_warehouse , b_factory , b_armoury , b_barracks , b_lab_full , b_oil_power , b_solar_power , b_siberite_power , b_oil_mine , b_siberite_mine , b_breastwork , b_bunker , b_turret ] ;
15031: LD_ADDR_LOC 28
15035: PUSH
15036: LD_INT 0
15038: PUSH
15039: LD_INT 1
15041: PUSH
15042: LD_INT 3
15044: PUSH
15045: LD_INT 4
15047: PUSH
15048: LD_INT 5
15050: PUSH
15051: LD_INT 8
15053: PUSH
15054: LD_INT 26
15056: PUSH
15057: LD_INT 27
15059: PUSH
15060: LD_INT 28
15062: PUSH
15063: LD_INT 29
15065: PUSH
15066: LD_INT 30
15068: PUSH
15069: LD_INT 31
15071: PUSH
15072: LD_INT 32
15074: PUSH
15075: LD_INT 33
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: LIST
15091: LIST
15092: LIST
15093: ST_TO_ADDR
// for un in list_important do
15094: LD_ADDR_VAR 0 3
15098: PUSH
15099: LD_VAR 0 2
15103: PUSH
15104: FOR_IN
15105: IFFALSE 15142
// begin if GetBType ( un ) in important then
15107: LD_VAR 0 3
15111: PPUSH
15112: CALL_OW 266
15116: PUSH
15117: LD_LOC 28
15121: IN
15122: IFFALSE 15140
// us_important := us_important ^ un ;
15124: LD_ADDR_EXP 65
15128: PUSH
15129: LD_EXP 65
15133: PUSH
15134: LD_VAR 0 3
15138: ADD
15139: ST_TO_ADDR
// end ;
15140: GO 15104
15142: POP
15143: POP
// end ;
15144: LD_VAR 0 1
15148: RET
// on UnitGoesToRed ( jednotka ) do begin event_unit := jednotka ;
15149: LD_ADDR_LOC 36
15153: PUSH
15154: LD_VAR 0 1
15158: ST_TO_ADDR
// if jednotka in attack_forces then
15159: LD_VAR 0 1
15163: PUSH
15164: LD_EXP 55
15168: IN
15169: IFFALSE 15207
// begin attack_forces := attack_forces diff [ jednotka ] ;
15171: LD_ADDR_EXP 55
15175: PUSH
15176: LD_EXP 55
15180: PUSH
15181: LD_VAR 0 1
15185: PUSH
15186: EMPTY
15187: LIST
15188: DIFF
15189: ST_TO_ADDR
// if ( not attack_forces ) and ( attack_begin ) then
15190: LD_EXP 55
15194: NOT
15195: PUSH
15196: LD_LOC 32
15200: AND
15201: IFFALSE 15207
// konec_jednoho_utoku ;
15203: CALL 14516 0 0
// end ; if ( ( jednotka = MacMillan ) and ( not IsOK ( survivor ) ) ) or ( ( jednotka = MacMillan ) and ( not visit_base ) ) then
15207: LD_VAR 0 1
15211: PUSH
15212: LD_EXP 1
15216: EQUAL
15217: PUSH
15218: LD_EXP 6
15222: PPUSH
15223: CALL_OW 302
15227: NOT
15228: AND
15229: PUSH
15230: LD_VAR 0 1
15234: PUSH
15235: LD_EXP 1
15239: EQUAL
15240: PUSH
15241: LD_EXP 34
15245: NOT
15246: AND
15247: OR
15248: IFFALSE 15254
// konec_mise ;
15250: CALL 755 0 0
// end ;
15254: PPOPN 1
15256: END
// on UnitDestroyed ( jednotka ) do var pomocna_mnozina ;
15257: LD_INT 0
15259: PPUSH
// begin event_unit := jednotka ;
15260: LD_ADDR_LOC 36
15264: PUSH
15265: LD_VAR 0 1
15269: ST_TO_ADDR
// attack_forces := attack_forces diff [ jednotka ] ;
15270: LD_ADDR_EXP 55
15274: PUSH
15275: LD_EXP 55
15279: PUSH
15280: LD_VAR 0 1
15284: PUSH
15285: EMPTY
15286: LIST
15287: DIFF
15288: ST_TO_ADDR
// us_important := us_important diff [ jednotka ] ;
15289: LD_ADDR_EXP 65
15293: PUSH
15294: LD_EXP 65
15298: PUSH
15299: LD_VAR 0 1
15303: PUSH
15304: EMPTY
15305: LIST
15306: DIFF
15307: ST_TO_ADDR
// destroy_now := destroy_now diff [ jednotka ] ;
15308: LD_ADDR_LOC 27
15312: PUSH
15313: LD_LOC 27
15317: PUSH
15318: LD_VAR 0 1
15322: PUSH
15323: EMPTY
15324: LIST
15325: DIFF
15326: ST_TO_ADDR
// case now_area of 1 :
15327: LD_LOC 34
15331: PUSH
15332: LD_INT 1
15334: DOUBLE
15335: EQUAL
15336: IFTRUE 15340
15338: GO 15362
15340: POP
// klic_area_1 := klic_area_1 diff [ jednotka ] ; 2 :
15341: LD_ADDR_LOC 18
15345: PUSH
15346: LD_LOC 18
15350: PUSH
15351: LD_VAR 0 1
15355: PUSH
15356: EMPTY
15357: LIST
15358: DIFF
15359: ST_TO_ADDR
15360: GO 15603
15362: LD_INT 2
15364: DOUBLE
15365: EQUAL
15366: IFTRUE 15370
15368: GO 15392
15370: POP
// klic_area_2 := klic_area_2 diff [ jednotka ] ; 3 :
15371: LD_ADDR_LOC 19
15375: PUSH
15376: LD_LOC 19
15380: PUSH
15381: LD_VAR 0 1
15385: PUSH
15386: EMPTY
15387: LIST
15388: DIFF
15389: ST_TO_ADDR
15390: GO 15603
15392: LD_INT 3
15394: DOUBLE
15395: EQUAL
15396: IFTRUE 15400
15398: GO 15422
15400: POP
// klic_area_3 := klic_area_3 diff [ jednotka ] ; 4 :
15401: LD_ADDR_LOC 20
15405: PUSH
15406: LD_LOC 20
15410: PUSH
15411: LD_VAR 0 1
15415: PUSH
15416: EMPTY
15417: LIST
15418: DIFF
15419: ST_TO_ADDR
15420: GO 15603
15422: LD_INT 4
15424: DOUBLE
15425: EQUAL
15426: IFTRUE 15430
15428: GO 15452
15430: POP
// klic_area_4 := klic_area_4 diff [ jednotka ] ; 5 :
15431: LD_ADDR_LOC 21
15435: PUSH
15436: LD_LOC 21
15440: PUSH
15441: LD_VAR 0 1
15445: PUSH
15446: EMPTY
15447: LIST
15448: DIFF
15449: ST_TO_ADDR
15450: GO 15603
15452: LD_INT 5
15454: DOUBLE
15455: EQUAL
15456: IFTRUE 15460
15458: GO 15482
15460: POP
// klic_area_5 := klic_area_5 diff [ jednotka ] ; 6 :
15461: LD_ADDR_LOC 22
15465: PUSH
15466: LD_LOC 22
15470: PUSH
15471: LD_VAR 0 1
15475: PUSH
15476: EMPTY
15477: LIST
15478: DIFF
15479: ST_TO_ADDR
15480: GO 15603
15482: LD_INT 6
15484: DOUBLE
15485: EQUAL
15486: IFTRUE 15490
15488: GO 15512
15490: POP
// klic_area_6 := klic_area_6 diff [ jednotka ] ; 7 :
15491: LD_ADDR_LOC 23
15495: PUSH
15496: LD_LOC 23
15500: PUSH
15501: LD_VAR 0 1
15505: PUSH
15506: EMPTY
15507: LIST
15508: DIFF
15509: ST_TO_ADDR
15510: GO 15603
15512: LD_INT 7
15514: DOUBLE
15515: EQUAL
15516: IFTRUE 15520
15518: GO 15542
15520: POP
// klic_area_7 := klic_area_7 diff [ jednotka ] ; 8 :
15521: LD_ADDR_LOC 24
15525: PUSH
15526: LD_LOC 24
15530: PUSH
15531: LD_VAR 0 1
15535: PUSH
15536: EMPTY
15537: LIST
15538: DIFF
15539: ST_TO_ADDR
15540: GO 15603
15542: LD_INT 8
15544: DOUBLE
15545: EQUAL
15546: IFTRUE 15550
15548: GO 15572
15550: POP
// klic_area_8 := klic_area_8 diff [ jednotka ] ; 9 :
15551: LD_ADDR_LOC 25
15555: PUSH
15556: LD_LOC 25
15560: PUSH
15561: LD_VAR 0 1
15565: PUSH
15566: EMPTY
15567: LIST
15568: DIFF
15569: ST_TO_ADDR
15570: GO 15603
15572: LD_INT 9
15574: DOUBLE
15575: EQUAL
15576: IFTRUE 15580
15578: GO 15602
15580: POP
// klic_area_9 := klic_area_9 diff [ jednotka ] ; end ;
15581: LD_ADDR_LOC 26
15585: PUSH
15586: LD_LOC 26
15590: PUSH
15591: LD_VAR 0 1
15595: PUSH
15596: EMPTY
15597: LIST
15598: DIFF
15599: ST_TO_ADDR
15600: GO 15603
15602: POP
// if jednotka = macmillan then
15603: LD_VAR 0 1
15607: PUSH
15608: LD_EXP 1
15612: EQUAL
15613: IFFALSE 15619
// konec_mise ;
15615: CALL 755 0 0
// if ( not attack_forces ) and ( attack_begin ) then
15619: LD_EXP 55
15623: NOT
15624: PUSH
15625: LD_LOC 32
15629: AND
15630: IFFALSE 15636
// konec_jednoho_utoku ;
15632: CALL 14516 0 0
// if GetSide ( jednotka ) = russians then
15636: LD_VAR 0 1
15640: PPUSH
15641: CALL_OW 255
15645: PUSH
15646: LD_EXP 15
15650: EQUAL
15651: IFFALSE 15740
// begin russians_forces := russians_forces diff jednotka ;
15653: LD_ADDR_EXP 28
15657: PUSH
15658: LD_EXP 28
15662: PUSH
15663: LD_VAR 0 1
15667: DIFF
15668: ST_TO_ADDR
// ru_ing := ru_ing diff jednotka ;
15669: LD_ADDR_EXP 24
15673: PUSH
15674: LD_EXP 24
15678: PUSH
15679: LD_VAR 0 1
15683: DIFF
15684: ST_TO_ADDR
// ru_sol := ru_sol diff jednotka ;
15685: LD_ADDR_EXP 25
15689: PUSH
15690: LD_EXP 25
15694: PUSH
15695: LD_VAR 0 1
15699: DIFF
15700: ST_TO_ADDR
// ru_sci := ru_sci diff jednotka ;
15701: LD_ADDR_EXP 26
15705: PUSH
15706: LD_EXP 26
15710: PUSH
15711: LD_VAR 0 1
15715: DIFF
15716: ST_TO_ADDR
// ru_mec := ru_mec diff jednotka ;
15717: LD_ADDR_EXP 27
15721: PUSH
15722: LD_EXP 27
15726: PUSH
15727: LD_VAR 0 1
15731: DIFF
15732: ST_TO_ADDR
// reserved_people := [ ] ;
15733: LD_ADDR_EXP 31
15737: PUSH
15738: EMPTY
15739: ST_TO_ADDR
// end ; end ;
15740: PPOPN 2
15742: END
// on VehicleCaptured ( veh_new , veh_old , veh_orig , veh_hum ) do begin if GetSide ( veh_old ) = russians then
15743: LD_VAR 0 2
15747: PPUSH
15748: CALL_OW 255
15752: PUSH
15753: LD_EXP 15
15757: EQUAL
15758: IFFALSE 15798
// begin war_forces := war_forces diff [ veh_old ] ;
15760: LD_ADDR_EXP 52
15764: PUSH
15765: LD_EXP 52
15769: PUSH
15770: LD_VAR 0 2
15774: PUSH
15775: EMPTY
15776: LIST
15777: DIFF
15778: ST_TO_ADDR
// attack_forces := attack_forces diff [ veh_old ] ;
15779: LD_ADDR_EXP 55
15783: PUSH
15784: LD_EXP 55
15788: PUSH
15789: LD_VAR 0 2
15793: PUSH
15794: EMPTY
15795: LIST
15796: DIFF
15797: ST_TO_ADDR
// end ; if ( not attack_forces ) and ( attack_begin ) then
15798: LD_EXP 55
15802: NOT
15803: PUSH
15804: LD_LOC 32
15808: AND
15809: IFFALSE 15815
// konec_jednoho_utoku ;
15811: CALL 14516 0 0
// end ;
15815: PPOPN 4
15817: END
// on BuildingComplete ( jednotka ) do begin if GetBType ( jednotka ) in important then
15818: LD_VAR 0 1
15822: PPUSH
15823: CALL_OW 266
15827: PUSH
15828: LD_LOC 28
15832: IN
15833: IFFALSE 15851
// us_important := us_important ^ jednotka ;
15835: LD_ADDR_EXP 65
15839: PUSH
15840: LD_EXP 65
15844: PUSH
15845: LD_VAR 0 1
15849: ADD
15850: ST_TO_ADDR
// end ;
15851: PPOPN 1
15853: END
// function multi_cesta ; begin
15854: LD_INT 0
15856: PPUSH
// multi := true ;
15857: LD_ADDR_LOC 29
15861: PUSH
15862: LD_INT 1
15864: ST_TO_ADDR
// end ;
15865: LD_VAR 0 1
15869: RET
// every 0 0$45 trigger ( war_forces >= war_count ) and ( not attack_begin ) do var list , un ;
15870: LD_EXP 52
15874: PUSH
15875: LD_EXP 54
15879: GREATEREQUAL
15880: PUSH
15881: LD_LOC 32
15885: NOT
15886: AND
15887: IFFALSE 15995
15889: GO 15891
15891: DISABLE
15892: LD_INT 0
15894: PPUSH
15895: PPUSH
// begin list := [ ] ;
15896: LD_ADDR_VAR 0 1
15900: PUSH
15901: EMPTY
15902: ST_TO_ADDR
// for un in war_forces do
15903: LD_ADDR_VAR 0 2
15907: PUSH
15908: LD_EXP 52
15912: PUSH
15913: FOR_IN
15914: IFFALSE 15946
// if un in defend_forces then
15916: LD_VAR 0 2
15920: PUSH
15921: LD_EXP 64
15925: IN
15926: IFFALSE 15944
// list := list ^ un ;
15928: LD_ADDR_VAR 0 1
15932: PUSH
15933: LD_VAR 0 1
15937: PUSH
15938: LD_VAR 0 2
15942: ADD
15943: ST_TO_ADDR
15944: GO 15913
15946: POP
15947: POP
// if ( war_forces diff list ) < war_count then
15948: LD_EXP 52
15952: PUSH
15953: LD_VAR 0 1
15957: DIFF
15958: PUSH
15959: LD_EXP 54
15963: LESS
15964: IFFALSE 15969
// begin enable ;
15966: ENABLE
// exit ;
15967: GO 15995
// end ; attack_forces := war_forces ;
15969: LD_ADDR_EXP 55
15973: PUSH
15974: LD_EXP 52
15978: ST_TO_ADDR
// war_forces := [ ] ;
15979: LD_ADDR_EXP 52
15983: PUSH
15984: EMPTY
15985: ST_TO_ADDR
// nacti_important_budovy ;
15986: CALL 14963 0 0
// low_cesta ;
15990: CALL 14609 0 0
// enable ;
15994: ENABLE
// end ;
15995: PPOPN 2
15997: END
// every 0 0$5 trigger attack_forces > 0 do var un , puvodni_velikost ;
15998: LD_EXP 55
16002: PUSH
16003: LD_INT 0
16005: GREATER
16006: IFFALSE 16097
16008: GO 16010
16010: DISABLE
16011: LD_INT 0
16013: PPUSH
16014: PPUSH
// begin puvodni_velikost := 0 + attack_forces ;
16015: LD_ADDR_VAR 0 2
16019: PUSH
16020: LD_INT 0
16022: PUSH
16023: LD_EXP 55
16027: PLUS
16028: ST_TO_ADDR
// for un in attack_forces do
16029: LD_ADDR_VAR 0 1
16033: PUSH
16034: LD_EXP 55
16038: PUSH
16039: FOR_IN
16040: IFFALSE 16072
// if not IsOK ( un ) then
16042: LD_VAR 0 1
16046: PPUSH
16047: CALL_OW 302
16051: NOT
16052: IFFALSE 16070
// attack_forces := attack_forces diff un ;
16054: LD_ADDR_EXP 55
16058: PUSH
16059: LD_EXP 55
16063: PUSH
16064: LD_VAR 0 1
16068: DIFF
16069: ST_TO_ADDR
16070: GO 16039
16072: POP
16073: POP
// if ( attack_forces = [ ] ) and ( puvodni_velikost > 0 ) then
16074: LD_EXP 55
16078: PUSH
16079: EMPTY
16080: EQUAL
16081: PUSH
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 0
16089: GREATER
16090: AND
16091: IFFALSE 16097
// konec_jednoho_utoku ;
16093: CALL 14516 0 0
// end ; end_of_file
16097: PPOPN 2
16099: END
// var id_reg , id_def ; function prepare_defend ( side ) ; var def_u ; begin
16100: LD_INT 0
16102: PPUSH
16103: PPUSH
// def_u := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_building ] , [ f_btype , b_turret ] , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_type , unit_vehicle ] ] ] ) ;
16104: LD_ADDR_VAR 0 3
16108: PUSH
16109: LD_INT 22
16111: PUSH
16112: LD_VAR 0 1
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: PUSH
16121: LD_INT 2
16123: PUSH
16124: LD_INT 21
16126: PUSH
16127: LD_INT 3
16129: PUSH
16130: EMPTY
16131: LIST
16132: LIST
16133: PUSH
16134: LD_INT 30
16136: PUSH
16137: LD_INT 33
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: PUSH
16144: LD_INT 30
16146: PUSH
16147: LD_INT 32
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PUSH
16154: LD_INT 30
16156: PUSH
16157: LD_INT 31
16159: PUSH
16160: EMPTY
16161: LIST
16162: LIST
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: LIST
16168: LIST
16169: PUSH
16170: LD_INT 21
16172: PUSH
16173: LD_INT 2
16175: PUSH
16176: EMPTY
16177: LIST
16178: LIST
16179: PUSH
16180: EMPTY
16181: LIST
16182: LIST
16183: LIST
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PPUSH
16189: CALL_OW 69
16193: ST_TO_ADDR
// def_u := def_u union ru_sol ;
16194: LD_ADDR_VAR 0 3
16198: PUSH
16199: LD_VAR 0 3
16203: PUSH
16204: LD_EXP 25
16208: UNION
16209: ST_TO_ADDR
// def_u := def_u diff reserved_people ;
16210: LD_ADDR_VAR 0 3
16214: PUSH
16215: LD_VAR 0 3
16219: PUSH
16220: LD_EXP 31
16224: DIFF
16225: ST_TO_ADDR
// def_u := def_u diff ru_collector ;
16226: LD_ADDR_VAR 0 3
16230: PUSH
16231: LD_VAR 0 3
16235: PUSH
16236: LD_EXP 29
16240: DIFF
16241: ST_TO_ADDR
// def_u := ( def_u union war_forces ) union backup_forces ;
16242: LD_ADDR_VAR 0 3
16246: PUSH
16247: LD_VAR 0 3
16251: PUSH
16252: LD_EXP 52
16256: UNION
16257: PUSH
16258: LD_EXP 56
16262: UNION
16263: ST_TO_ADDR
// def_u := def_u union manual_forces ;
16264: LD_ADDR_VAR 0 3
16268: PUSH
16269: LD_VAR 0 3
16273: PUSH
16274: LD_EXP 59
16278: UNION
16279: ST_TO_ADDR
// result := def_u ;
16280: LD_ADDR_VAR 0 2
16284: PUSH
16285: LD_VAR 0 3
16289: ST_TO_ADDR
// end ;
16290: LD_VAR 0 2
16294: RET
// export function start_defend ; var side ; begin
16295: LD_INT 0
16297: PPUSH
16298: PPUSH
// id_reg := McRegistry ( 3 , [ [ mc_reg_refresh_time , 0 0$1 ] , [ mc_reg_expire_stops_to_attack , 0 0$4 ] , [ mc_reg_area_to_guard , ru_defend ] , [ mc_reg_area_to_protect , ru_defend ] , [ mc_reg_units_to_protect , prepare_defend ( russians ) ] , mc_reg_only_important , - mc_reg_ignore_fog ] ) ;
16299: LD_ADDR_LOC 37
16303: PUSH
16304: LD_INT 3
16306: PPUSH
16307: LD_INT 1
16309: PUSH
16310: LD_INT 35
16312: PUSH
16313: EMPTY
16314: LIST
16315: LIST
16316: PUSH
16317: LD_INT 5
16319: PUSH
16320: LD_INT 140
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: LD_INT 2
16329: PUSH
16330: LD_INT 27
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: PUSH
16337: LD_INT 3
16339: PUSH
16340: LD_INT 27
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PUSH
16347: LD_INT 4
16349: PUSH
16350: LD_EXP 15
16354: PPUSH
16355: CALL 16100 0 1
16359: PUSH
16360: EMPTY
16361: LIST
16362: LIST
16363: PUSH
16364: LD_INT 8
16366: PUSH
16367: LD_INT 7
16369: NEG
16370: PUSH
16371: EMPTY
16372: LIST
16373: LIST
16374: LIST
16375: LIST
16376: LIST
16377: LIST
16378: LIST
16379: PPUSH
16380: CALL_OW 399
16384: ST_TO_ADDR
// id_def := McDefend ( 100 , id_reg , prepare_defend ( russians ) , [ [ mc_def_advantage , 500 ] , [ mc_area_dont_leave , ru_base ] , [ mc_retreat_area_people , ru_heal ] , [ mc_retreat_lives_people , 600 ] , ] ) ;
16385: LD_ADDR_LOC 38
16389: PUSH
16390: LD_INT 100
16392: PPUSH
16393: LD_LOC 37
16397: PPUSH
16398: LD_EXP 15
16402: PPUSH
16403: CALL 16100 0 1
16407: PPUSH
16408: LD_INT 1
16410: PUSH
16411: LD_INT 500
16413: PUSH
16414: EMPTY
16415: LIST
16416: LIST
16417: PUSH
16418: LD_INT 2
16420: PUSH
16421: LD_INT 2
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: PUSH
16428: LD_INT 7
16430: PUSH
16431: LD_INT 28
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: PUSH
16438: LD_INT 5
16440: PUSH
16441: LD_INT 600
16443: PUSH
16444: EMPTY
16445: LIST
16446: LIST
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: LIST
16452: LIST
16453: PPUSH
16454: CALL_OW 401
16458: ST_TO_ADDR
// end ;
16459: LD_VAR 0 1
16463: RET
// on McRegistryResultChanges ( mcid , n , s ) do begin if n then
16464: LD_VAR 0 2
16468: IFFALSE 16493
// begin AddMcUnits ( mcid , prepare_defend ( russians ) ) ;
16470: LD_VAR 0 1
16474: PPUSH
16475: LD_EXP 15
16479: PPUSH
16480: CALL 16100 0 1
16484: PPUSH
16485: CALL_OW 390
// SendForces ;
16489: CALL 16739 0 0
// end ; end ;
16493: PPOPN 3
16495: END
// every 0 0$5 do var side , sci , list ;
16496: GO 16498
16498: DISABLE
16499: LD_INT 0
16501: PPUSH
16502: PPUSH
16503: PPUSH
// begin list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 950 ] ] ] ) ;
16504: LD_ADDR_VAR 0 3
16508: PUSH
16509: LD_INT 28
16511: PPUSH
16512: LD_INT 22
16514: PUSH
16515: LD_EXP 15
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: LD_INT 21
16526: PUSH
16527: LD_INT 1
16529: PUSH
16530: EMPTY
16531: LIST
16532: LIST
16533: PUSH
16534: LD_INT 3
16536: PUSH
16537: LD_INT 24
16539: PUSH
16540: LD_INT 950
16542: PUSH
16543: EMPTY
16544: LIST
16545: LIST
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: PUSH
16551: EMPTY
16552: LIST
16553: LIST
16554: LIST
16555: PPUSH
16556: CALL_OW 70
16560: ST_TO_ADDR
// if list then
16561: LD_VAR 0 3
16565: IFFALSE 16735
// begin sci := FilterAllUnits ( [ [ f_side , russians ] , [ f_class , class_scientistic ] ] ) ;
16567: LD_ADDR_VAR 0 2
16571: PUSH
16572: LD_INT 22
16574: PUSH
16575: LD_EXP 15
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 25
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: PPUSH
16598: CALL_OW 69
16602: ST_TO_ADDR
// ComRemember ( sci ) ;
16603: LD_VAR 0 2
16607: PPUSH
16608: CALL_OW 143
// wait ( 5 ) ;
16612: LD_INT 5
16614: PPUSH
16615: CALL_OW 67
// ComMoveToArea ( sci , ru_heal ) ;
16619: LD_VAR 0 2
16623: PPUSH
16624: LD_INT 28
16626: PPUSH
16627: CALL_OW 113
// repeat list := FilterUnitsInArea ( ru_heal , [ [ f_side , russians ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
16631: LD_ADDR_VAR 0 3
16635: PUSH
16636: LD_INT 28
16638: PPUSH
16639: LD_INT 22
16641: PUSH
16642: LD_EXP 15
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: PUSH
16651: LD_INT 21
16653: PUSH
16654: LD_INT 1
16656: PUSH
16657: EMPTY
16658: LIST
16659: LIST
16660: PUSH
16661: LD_INT 3
16663: PUSH
16664: LD_INT 24
16666: PUSH
16667: LD_INT 1000
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: EMPTY
16679: LIST
16680: LIST
16681: LIST
16682: PPUSH
16683: CALL_OW 70
16687: ST_TO_ADDR
// if list then
16688: LD_VAR 0 3
16692: IFFALSE 16712
// AddComHeal ( sci , list [ 1 ] ) ;
16694: LD_VAR 0 2
16698: PPUSH
16699: LD_VAR 0 3
16703: PUSH
16704: LD_INT 1
16706: ARRAY
16707: PPUSH
16708: CALL_OW 188
// wait ( 0 0$2 ) ;
16712: LD_INT 70
16714: PPUSH
16715: CALL_OW 67
// until not list ;
16719: LD_VAR 0 3
16723: NOT
16724: IFFALSE 16631
// ComReturn ( sci ) ;
16726: LD_VAR 0 2
16730: PPUSH
16731: CALL_OW 144
// end ; enable ;
16735: ENABLE
// end ;
16736: PPOPN 3
16738: END
// function SendForces ; var list , target ; begin
16739: LD_INT 0
16741: PPUSH
16742: PPUSH
16743: PPUSH
// ComRemember ( war_forces ) ;
16744: LD_EXP 52
16748: PPUSH
16749: CALL_OW 143
// ComRemember ( backup_forces ) ;
16753: LD_EXP 56
16757: PPUSH
16758: CALL_OW 143
// repeat list := FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) ;
16762: LD_ADDR_VAR 0 2
16766: PUSH
16767: LD_INT 33
16769: PPUSH
16770: LD_INT 22
16772: PUSH
16773: LD_EXP 14
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: LD_INT 50
16784: PUSH
16785: EMPTY
16786: LIST
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PPUSH
16792: CALL_OW 70
16796: ST_TO_ADDR
// defend_forces := war_forces union backup_forces ;
16797: LD_ADDR_EXP 64
16801: PUSH
16802: LD_EXP 52
16806: PUSH
16807: LD_EXP 56
16811: UNION
16812: ST_TO_ADDR
// target := NearestUnitToUnit ( list , ru_depot ) ;
16813: LD_ADDR_VAR 0 3
16817: PUSH
16818: LD_VAR 0 2
16822: PPUSH
16823: LD_INT 22
16825: PPUSH
16826: CALL_OW 74
16830: ST_TO_ADDR
// ComAttackPlace ( defend_forces , GetX ( target ) , GetY ( target ) ) ;
16831: LD_EXP 64
16835: PPUSH
16836: LD_VAR 0 3
16840: PPUSH
16841: CALL_OW 250
16845: PPUSH
16846: LD_VAR 0 3
16850: PPUSH
16851: CALL_OW 251
16855: PPUSH
16856: CALL_OW 116
// wait ( 50 ) ;
16860: LD_INT 50
16862: PPUSH
16863: CALL_OW 67
// until not list ;
16867: LD_VAR 0 2
16871: NOT
16872: IFFALSE 16762
// ComReturn ( war_forces ) ;
16874: LD_EXP 52
16878: PPUSH
16879: CALL_OW 144
// ComReturn ( backup_forces ) ;
16883: LD_EXP 56
16887: PPUSH
16888: CALL_OW 144
// end ; end_of_file
16892: LD_VAR 0 1
16896: RET
// var b_list ; export function init_keep_base ; var un , list ; begin
16897: LD_INT 0
16899: PPUSH
16900: PPUSH
16901: PPUSH
// b_list := [ ] ;
16902: LD_ADDR_LOC 39
16906: PUSH
16907: EMPTY
16908: ST_TO_ADDR
// un := FilterAllUnits ( [ [ f_side , russians ] , [ f_type , unit_building ] ] ) ;
16909: LD_ADDR_VAR 0 2
16913: PUSH
16914: LD_INT 22
16916: PUSH
16917: LD_EXP 15
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PUSH
16926: LD_INT 21
16928: PUSH
16929: LD_INT 3
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: PUSH
16936: EMPTY
16937: LIST
16938: LIST
16939: PPUSH
16940: CALL_OW 69
16944: ST_TO_ADDR
// if un then
16945: LD_VAR 0 2
16949: IFFALSE 16975
// b_list := GetBuildList ( GetBase ( un [ 1 ] ) ) ;
16951: LD_ADDR_LOC 39
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 274
16969: PPUSH
16970: CALL_OW 417
16974: ST_TO_ADDR
// enable ( 2 ) ;
16975: LD_INT 2
16977: ENABLE_MARKED
// end ;
16978: LD_VAR 0 1
16982: RET
// every 0 0$3 trigger FilterUnitsInArea ( manual_defend , [ [ f_side , you ] , [ f_ok ] ] ) marked 2 do var engineers ;
16983: LD_INT 33
16985: PPUSH
16986: LD_INT 22
16988: PUSH
16989: LD_EXP 14
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: LD_INT 50
17000: PUSH
17001: EMPTY
17002: LIST
17003: PUSH
17004: EMPTY
17005: LIST
17006: LIST
17007: PPUSH
17008: CALL_OW 70
17012: IFFALSE 17097
17014: GO 17016
17016: DISABLE
17017: LD_INT 0
17019: PPUSH
// begin engineers := ru_ing ;
17020: LD_ADDR_VAR 0 1
17024: PUSH
17025: LD_EXP 24
17029: ST_TO_ADDR
// if not engineers then
17030: LD_VAR 0 1
17034: NOT
17035: IFFALSE 17047
// engineers := ru_sol ;
17037: LD_ADDR_VAR 0 1
17041: PUSH
17042: LD_EXP 25
17046: ST_TO_ADDR
// ComRemember ( engineers ) ;
17047: LD_VAR 0 1
17051: PPUSH
17052: CALL_OW 143
// WaitForMc ( McBase ( 3 , engineers , b_list , 0 , 0 , 0 ) ) ;
17056: LD_INT 3
17058: PPUSH
17059: LD_VAR 0 1
17063: PPUSH
17064: LD_LOC 39
17068: PPUSH
17069: LD_INT 0
17071: PPUSH
17072: LD_INT 0
17074: PPUSH
17075: LD_INT 0
17077: PPUSH
17078: CALL_OW 397
17082: PPUSH
17083: CALL_OW 385
// ComReturn ( engineers ) ;
17087: LD_VAR 0 1
17091: PPUSH
17092: CALL_OW 144
// enable ;
17096: ENABLE
// end ; end_of_file
17097: PPOPN 1
17099: END
// every 0 0$2 + 0 0$0.1 do
17100: GO 17102
17102: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
17103: LD_INT 22
17105: PUSH
17106: LD_INT 1
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: PUSH
17113: LD_INT 2
17115: PUSH
17116: LD_INT 25
17118: PUSH
17119: LD_INT 12
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: PUSH
17126: LD_INT 25
17128: PUSH
17129: LD_INT 16
17131: PUSH
17132: EMPTY
17133: LIST
17134: LIST
17135: PUSH
17136: LD_INT 25
17138: PUSH
17139: LD_INT 15
17141: PUSH
17142: EMPTY
17143: LIST
17144: LIST
17145: PUSH
17146: LD_INT 25
17148: PUSH
17149: LD_INT 17
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: PPUSH
17167: CALL_OW 69
17171: PUSH
17172: LD_INT 22
17174: PUSH
17175: LD_INT 1
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PUSH
17182: LD_INT 21
17184: PUSH
17185: LD_INT 1
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 3
17194: PUSH
17195: LD_INT 2
17197: PUSH
17198: LD_INT 25
17200: PUSH
17201: LD_INT 12
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: PUSH
17208: LD_INT 25
17210: PUSH
17211: LD_INT 16
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PUSH
17218: LD_INT 25
17220: PUSH
17221: LD_INT 15
17223: PUSH
17224: EMPTY
17225: LIST
17226: LIST
17227: PUSH
17228: LD_INT 25
17230: PUSH
17231: LD_INT 17
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: PUSH
17238: EMPTY
17239: LIST
17240: LIST
17241: LIST
17242: LIST
17243: LIST
17244: PUSH
17245: EMPTY
17246: LIST
17247: LIST
17248: PUSH
17249: EMPTY
17250: LIST
17251: LIST
17252: LIST
17253: PPUSH
17254: CALL_OW 69
17258: GREATER
17259: IFFALSE 17270
// begin SetAchievement ( ACH_POTA ) ;
17261: LD_STRING ACH_POTA
17263: PPUSH
17264: CALL_OW 543
// exit ;
17268: GO 17271
// end ; enable ;
17270: ENABLE
// end ;
17271: END
// export function SA_HelpJoan ; begin
17272: LD_INT 0
17274: PPUSH
// SetAchievement ( ACH_TLO ) ;
17275: LD_STRING ACH_TLO
17277: PPUSH
17278: CALL_OW 543
// end ; end_of_file
17282: LD_VAR 0 1
17286: RET
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
17287: LD_INT 0
17289: PPUSH
17290: PPUSH
// if not missionNumber then
17291: LD_VAR 0 2
17295: NOT
17296: IFFALSE 17300
// exit ;
17298: GO 17430
// achiv := false ;
17300: LD_ADDR_VAR 0 7
17304: PUSH
17305: LD_INT 0
17307: ST_TO_ADDR
// case campaignNumber of 1 :
17308: LD_VAR 0 1
17312: PUSH
17313: LD_INT 1
17315: DOUBLE
17316: EQUAL
17317: IFTRUE 17321
17319: GO 17332
17321: POP
// achiv := ACH_GOTA ; 2 :
17322: LD_ADDR_VAR 0 7
17326: PUSH
17327: LD_STRING ACH_GOTA
17329: ST_TO_ADDR
17330: GO 17382
17332: LD_INT 2
17334: DOUBLE
17335: EQUAL
17336: IFTRUE 17340
17338: GO 17343
17340: POP
// ; 3 :
17341: GO 17382
17343: LD_INT 3
17345: DOUBLE
17346: EQUAL
17347: IFTRUE 17351
17349: GO 17362
17351: POP
// achiv := ACH_MOTSU ; 4 :
17352: LD_ADDR_VAR 0 7
17356: PUSH
17357: LD_STRING ACH_MOTSU
17359: ST_TO_ADDR
17360: GO 17382
17362: LD_INT 4
17364: DOUBLE
17365: EQUAL
17366: IFTRUE 17370
17368: GO 17381
17370: POP
// achiv := ACH_LOP ; end ;
17371: LD_ADDR_VAR 0 7
17375: PUSH
17376: LD_STRING ACH_LOP
17378: ST_TO_ADDR
17379: GO 17382
17381: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
17382: LD_OWVAR 67
17386: PUSH
17387: LD_INT 3
17389: EQUAL
17390: PUSH
17391: LD_VAR 0 7
17395: AND
17396: PUSH
17397: LD_VAR 0 3
17401: AND
17402: PUSH
17403: LD_VAR 0 4
17407: AND
17408: PUSH
17409: LD_VAR 0 5
17413: AND
17414: IFFALSE 17430
// SetAchievementEX ( achiv , missionNumber ) ;
17416: LD_VAR 0 7
17420: PPUSH
17421: LD_VAR 0 2
17425: PPUSH
17426: CALL_OW 564
// end ;
17430: LD_VAR 0 6
17434: RET
// export function SA_BehemothConstructed ; begin
17435: LD_INT 0
17437: PPUSH
// SetAchievement ( ACH_SMC ) ;
17438: LD_STRING ACH_SMC
17440: PPUSH
17441: CALL_OW 543
// end ;
17445: LD_VAR 0 1
17449: RET
